<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/copy.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * copy.c
 *		Implements the COPY utility command
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/copy.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/execute_pipe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/external.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/url.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extprotocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbaocsam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbconn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbcopy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autostats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/metrics_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resscheduler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/string_utils.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISOCTAL</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((c) &gt;= '0') &amp;&amp; ((c) &lt;= '7'))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OCTVALUE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) - '0')</cpp:value></cpp:define>

<comment type="block">/*
 * Represents the heap insert method to be used during COPY FROM.
 */</comment>
<typedef>typedef <type><enum>enum <name>CopyInsertMethod</name>
<block>{
	<decl><name>CIM_SINGLE</name></decl>,					<comment type="block">/* use table_tuple_insert or fdw routine */</comment>
	<decl><name>CIM_MULTI</name></decl>,					<comment type="block">/* always use table_multi_insert */</comment>
	<decl><name>CIM_MULTI_CONDITIONAL</name></decl>		<comment type="block">/* use table_multi_insert only if valid */</comment>
}</block></enum></type> <name>CopyInsertMethod</name>;</typedef>

<comment type="block">/*
 * No more than this many tuples per CopyMultiInsertBuffer
 *
 * Caution: Don't make this too big, as we could end up with this many
 * CopyMultiInsertBuffer items stored in CopyMultiInsertInfo's
 * multiInsertBuffers list.  Increasing this can cause quadratic growth in
 * memory requirements during copies into partitioned tables with a large
 * number of partitions.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BUFFERED_TUPLES</name></cpp:macro>		<cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/*
 * Flush buffers if there are &gt;= this many bytes, as counted by the input
 * size, of tuples stored.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BUFFERED_BYTES</name></cpp:macro>		<cpp:value>65535</cpp:value></cpp:define>

<comment type="block">/* Trim the list of buffers back down to this number after flushing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PARTITION_BUFFERS</name></cpp:macro>	<cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* Stores multi-insert data related to a single relation in CopyFrom. */</comment>
<typedef>typedef <type><struct>struct <name>CopyMultiInsertBuffer</name>
<block>{
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name><name>slots</name><index>[<expr><name>MAX_BUFFERED_TUPLES</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Array to store tuples */</comment>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>	<comment type="block">/* ResultRelInfo for 'relid' */</comment>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>	<comment type="block">/* BulkInsertState for this rel */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nused</name></decl>;</decl_stmt>			<comment type="block">/* number of 'slots' containing tuples */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name><name>linenos</name><index>[<expr><name>MAX_BUFFERED_TUPLES</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Line # of tuple in copy
												 * stream */</comment>
}</block></struct></type> <name>CopyMultiInsertBuffer</name>;</typedef>

<comment type="block">/*
 * Stores one or many CopyMultiInsertBuffers and details about the size and
 * number of tuples which are stored in them.  This allows multiple buffers to
 * exist at once when COPYing into a partitioned table.
 */</comment>
<typedef>typedef <type><struct>struct <name>CopyMultiInsertInfo</name>
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>multiInsertBuffers</name></decl>;</decl_stmt> <comment type="block">/* List of tracked CopyMultiInsertBuffers */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bufferedTuples</name></decl>;</decl_stmt> <comment type="block">/* number of tuples buffered over all buffers */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bufferedBytes</name></decl>;</decl_stmt>	<comment type="block">/* number of bytes from all buffered tuples */</comment>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>			<comment type="block">/* Copy state for this CopyMultiInsertInfo */</comment>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>			<comment type="block">/* Executor state used for COPY */</comment>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>mycid</name></decl>;</decl_stmt>			<comment type="block">/* Command Id used for COPY */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ti_options</name></decl>;</decl_stmt>		<comment type="block">/* table insert options */</comment>
}</block></struct></type> <name>CopyMultiInsertInfo</name>;</typedef>


<comment type="block">/*
 * These macros centralize code used to process line_buf and raw_buf buffers.
 * They are macros because they often do continue/break control and to avoid
 * function call overhead in tight COPY loops.
 *
 * We must use "if (1)" because the usual "do {...} while(0)" wrapper would
 * prevent the continue/break processing from working.  We end the "if (1)"
 * with "else ((void) 0)" to ensure the "if" does not unintentionally match
 * any "else" in the calling code, and to avoid any compiler warnings about
 * empty statements.  See http://www.cit.gu.edu.au/~anthony/info/C/C.macros.
 */</comment>

<comment type="block">/*
 * This keeps the character read at the top of the loop in the buffer
 * even if there is more than one read-ahead.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><parameter_list>(<parameter><type><name>extralen</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>if (1) \
{ \
	if (raw_buf_ptr + (extralen) &gt;= copy_buf_len &amp;&amp; !hit_eof) \
	{ \
		raw_buf_ptr = prev_raw_ptr; <comment type="block">/* undo fetch */</comment> \
		need_data = true; \
		continue; \
	} \
} else ((void) 0)</cpp:value></cpp:define>

<comment type="block">/* This consumes the remainder of the buffer and breaks */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_NEED_REFILL_AND_EOF_BREAK</name><parameter_list>(<parameter><type><name>extralen</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>if (1) \
{ \
	if (raw_buf_ptr + (extralen) &gt;= copy_buf_len &amp;&amp; hit_eof) \
	{ \
		if (extralen) \
			raw_buf_ptr = copy_buf_len; <comment type="block">/* consume the partial character */</comment> \
		<comment type="block">/* backslash just before EOF, treat as data char */</comment> \
		result = true; \
		break; \
	} \
} else ((void) 0)</cpp:value></cpp:define>

<comment type="block">/*
 * Transfer any approved data to line_buf; must do this to be sure
 * there is some room in raw_buf.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REFILL_LINEBUF</name></cpp:macro> \
<cpp:value>if (1) \
{ \
	if (raw_buf_ptr &gt; cstate-&gt;raw_buf_index) \
	{ \
		appendBinaryStringInfo(&amp;cstate-&gt;line_buf, \
							 cstate-&gt;raw_buf + cstate-&gt;raw_buf_index, \
							   raw_buf_ptr - cstate-&gt;raw_buf_index); \
		cstate-&gt;raw_buf_index = raw_buf_ptr; \
	} \
} else ((void) 0)</cpp:value></cpp:define>

<comment type="block">/* Undo any read-ahead and jump out of the block. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_END_OF_COPY_GOTO</name></cpp:macro> \
<cpp:value>if (1) \
{ \
	raw_buf_ptr = prev_raw_ptr + 1; \
	goto not_end_of_copy; \
} else ((void) 0)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>BinarySignature</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <init>= <expr><literal type="string">"PGCOPY\n\377\r\n\0"</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EndCopy</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CopyState</name></type> <name>BeginCopyTo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>queryRelId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_program</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EndCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>processed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>DoCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>CopyToDispatch</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>CopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>CopyDispatchOnSegment</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>CopyToQueryOnSegment</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CopyReadLine</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CopyReadLineText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CopyReadAttributesText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stop_processing_at_field</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CopyReadAttributesCSV</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stop_processing_at_field</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>CopyReadBinaryAttribute</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>column_no</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyAttributeOutText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyAttributeOutCSV</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>use_quote</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>single_attr</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Low-level communications functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReceiveCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyEnd</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendString</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendChar</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CopyGetData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendInt32</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CopyGetInt32</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendInt16</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CopyGetInt16</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyFromForwardedTuple</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>,
						   <parameter><decl><type><name>CdbCopy</name> <modifier>*</modifier></type><name>cdbCopy</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>toAll</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>target_seg</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>int64</name></type> <name>lineno</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>line_len</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyFromForwardedHeader</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>CdbCopy</name> <modifier>*</modifier></type><name>cdbCopy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyFromForwardedError</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>CdbCopy</name> <modifier>*</modifier></type><name>cdbCopy</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NextCopyFromDispatch</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
								 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NextCopyFromExecute</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NextCopyFromRawFieldsX</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nfields</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>stop_processing_at_field</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NextCopyFromX</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HandleCopyError</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HandleQDErrorFrame</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyInitDataParser</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setEncodingConversionProc</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GpDistributionData</name> <modifier>*</modifier></type><name>InitDistributionData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreeDistributionData</name><parameter_list>(<parameter><decl><type><name>GpDistributionData</name> <modifier>*</modifier></type><name>distData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitCopyFromDispatchSplit</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>GpDistributionData</name> <modifier>*</modifier></type><name>distData</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>GetTargetSeg</name><parameter_list>(<parameter><decl><type><name>GpDistributionData</name> <modifier>*</modifier></type><name>distData</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ProgramPipes</name> <modifier>*</modifier></type><name>open_program_pipes</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forwrite</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>close_program_pipes</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ifThrow</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CopyIntoClause</name><modifier>*</modifier></type>
<name>MakeCopyIntoClause</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>parse_joined_option_list</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>delimiter</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ==========================================================================
 * The following macros aid in major refactoring of data processing code (in
 * CopyFrom(+Dispatch)). We use macros because in some cases the code must be in
 * line in order to work (for example elog_dismiss() in PG_CATCH) while in
 * other cases we'd like to inline the code for performance reasons.
 *
 * NOTE that an almost identical set of macros exists in fileam.c. If you make
 * changes here you may want to consider taking a look there as well.
 * ==========================================================================
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESET_LINEBUF</name></cpp:macro> \
<cpp:value>cstate-&gt;line_buf.len = 0; \
cstate-&gt;line_buf.data[0] = '\0'; \
cstate-&gt;line_buf.cursor = 0;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESET_ATTRBUF</name></cpp:macro> \
<cpp:value>cstate-&gt;attribute_buf.len = 0; \
cstate-&gt;attribute_buf.data[0] = '\0'; \
cstate-&gt;attribute_buf.cursor = 0;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESET_LINEBUF_WITH_LINENO</name></cpp:macro> \
<cpp:value>line_buf_with_lineno.len = 0; \
line_buf_with_lineno.data[0] = '\0'; \
line_buf_with_lineno.cursor = 0;</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>CopyState</name></type> <name>glob_cstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* GPDB_91_MERGE_FIXME: passing through a global variable like this is ugly */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>glob_copystmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Testing GUC: When enabled, COPY FROM prints an INFO line to indicate which
 * fields are processed in the QD, and which in the QE.
 */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>Test_copy_qd_qe_split</name></decl>;</decl_stmt>

<comment type="block">/*
 * When doing a COPY FROM through the dispatcher, the QD reads the input from
 * the input file (or stdin or program), and forwards the data to the QE nodes,
 * where they will actually be inserted.
 *
 * Ideally, the QD would just pass through each line to the QE as is, and let
 * the QEs to do all the processing. Because the more processing the QD has
 * to do, the more likely it is to become a bottleneck.
 *
 * However, the QD needs to figure out which QE to send each row to. For that,
 * it needs to at least parse the distribution key. The distribution key might
 * also be a DEFAULTed column, in which case the DEFAULT value needs to be
 * evaluated in the QD. In that case, the QD must send the computed value
 * to the QE - we cannot assume that the QE can re-evaluate the expression and
 * arrive at the same value, at least not if the DEFAULT expression is volatile.
 *
 * Therefore, we need a flexible format between the QD and QE, where the QD
 * processes just enough of each input line to figure out where to send it.
 * It must send the values it had to parse and evaluate to the QE, as well
 * as the rest of the original input line, so that the QE can parse the rest
 * of it.
 *
 * The 'copy_from_dispatch_*' structs are used in the QD-&gt;QE stream. For each
 * input line, the QD constructs a 'copy_from_dispatch_row' struct, and sends
 * it to the QE. Before any rows, a QDtoQESignature is sent first, followed by
 * a 'copy_from_dispatch_header'. When QD encounters a recoverable error that
 * needs to be logged in the error log (LOG ERRORS SEGMENT REJECT LIMIT), it
 * sends the erroneous raw to a QE, in a 'copy_from_dispatch_error' struct.
 *
 *
 * COPY TO is simpler: The QEs form the output rows in the final form, and the QD
 * just collects and forwards them to the client. The QD doesn't need to parse
 * the rows at all.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>QDtoQESignature</name><index>[]</index></name> <init>= <expr><literal type="string">"PGCOPY-QD-TO-QE\n\377\r\n"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Header contains information that applies to all the rows that follow. */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/*
	 * First field that should be processed in the QE. Any fields before
	 * this will be included as Datums in the rows that follow.
	 */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>first_qe_processed_field</name></decl>;</decl_stmt>
}</block></struct></type> <name>copy_from_dispatch_header</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/*
	 * Information about this input line.
	 *
	 * 'relid' is the target relation's OID. Normally, the same as
	 * cstate-&gt;relid, but for a partitioned relation, it indicates the target
	 * partition. Note: this must be the first field, because InvalidOid means
	 * that this is actually a 'copy_from_dispatch_error' struct.
	 *
	 * 'lineno' is the input line number, for error reporting.
	 */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type>		<name>line_len</name></decl>;</decl_stmt>			<comment type="block">/* size of the included input line */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>residual_off</name></decl>;</decl_stmt>		<comment type="block">/* offset in the line, where QE should
									 * process remaining fields */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>delim_seen_at_end</name></decl>;</decl_stmt>  <comment type="block">/* conveys to QE if QD saw a delim at end
									 * of its processing */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>fld_count</name></decl>;</decl_stmt>			<comment type="block">/* # of fields that were processed in the
									 * QD. */</comment>

	<comment type="block">/* The input line follows. */</comment>

	<comment type="block">/*
	 * For each field that was parsed in the QD already, the following data follows:
	 *
	 * int16	fieldnum;
	 * &lt;data&gt;
	 *
	 * NULL values are not included, any attributes that are not included in
	 * the message are implicitly NULL.
	 *
	 * For pass-by-value datatypes, the &lt;data&gt; is the raw Datum. For
	 * simplicity, it is always sent as a full-width 8-byte Datum, regardless
	 * of the datatype's length.
	 *
	 * For other fixed width datatypes, &lt;data&gt; is the datatype's value.
	 *
	 * For variable-length datatypes, &lt;data&gt; begins with a 4-byte length field,
	 * followed by the data. Cstrings (typlen = -2) are also sent in this
	 * format.
	 */</comment>
}</block></struct></type> <name>copy_from_dispatch_row</name>;</typedef>

<comment type="block">/* Size of the struct, without padding at the end. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeOfCopyFromDispatchRow</name></cpp:macro> <cpp:value>(offsetof(copy_from_dispatch_row, fld_count) + sizeof(uint16))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int64</name></type>		<name>error_marker</name></decl>;</decl_stmt>	<comment type="block">/* constant -1, to mark that this is an error
								 * frame rather than 'copy_from_dispatch_row' */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>errmsg_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>line_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>line_buf_converted</name></decl>;</decl_stmt>

	<comment type="block">/* 'errmsg' follows */</comment>
	<comment type="block">/* 'line' follows */</comment>
}</block></struct></type> <name>copy_from_dispatch_error</name>;</typedef>

<comment type="block">/* Size of the struct, without padding at the end. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeOfCopyFromDispatchError</name></cpp:macro> <cpp:value>(offsetof(copy_from_dispatch_error, line_buf_converted) + sizeof(bool))</cpp:value></cpp:define>


<comment type="block">/*
 * Send copy start/stop messages for frontend copies.  These have changed
 * in past protocol redesigns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* new way */</comment>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>format</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* overall format */</comment>
		<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> <comment type="block">/* per-column formats */</comment>
		<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_NEW_FE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* old way */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY BINARY is not supported to stdout or from stdin"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* grottiness needed for old COPY OUT protocol */</comment>
		<expr_stmt><expr><call><name>pq_startcopyout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_OLD_FE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReceiveCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* new way */</comment>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>format</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'G'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* overall format */</comment>
		<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> <comment type="block">/* per-column formats */</comment>
		<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_NEW_FE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* old way */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY BINARY is not supported to stdout or from stdin"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'G'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* any error in old protocol will make us lose sync */</comment>
		<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_OLD_FE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* We *must* flush here to ensure FE knows it can send. */</comment>
	<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyEnd</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>==</operator> <name>COPY_NEW_FE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Shouldn't have any unsent data */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Send Copy Done message */</comment>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"\\."</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Need to flush out the trailer (this also appends a newline) */</comment>
		<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_endcopyout</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 * CopySendData sends output data to the destination (file or frontend)
 * CopySendString does the same for null-terminated strings
 * CopySendChar does the same for single characters
 * CopySendEndOfRow does the appropriate thing at end of each data row
 *	(data is not actually flushed except by CopySendEndOfRow)
 *
 * NB: no data conversion is applied by these functions
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>databuf</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendString</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendChar</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* AXG: Note that this will both add a newline AND flush the data.
 * For the dispatcher COPY TO we don't want to use this method since
 * our newlines already exist. We use another new method similar to
 * this one to flush the data
 */</comment>
<function><type><name>void</name></type>
<name>CopySendEndOfRow</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>fe_msgbuf</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>COPY_FILE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Default line termination depends on platform */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
				<call><name>ferror</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EPIPE</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The pipe will be closed automatically on error at
						 * the end of transaction, but we might get a better
						 * error message from the subprocess' exit code than
						 * just "Broken Pipe"
						 */</comment>
						<expr_stmt><expr><call><name>close_program_pipes</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * If close_program_pipes() didn't throw an error,
						 * the program terminated normally, but closed the
						 * pipe first. Restore errno, and throw an error.
						 */</comment>
						<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EPIPE</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to COPY program: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to COPY file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>COPY_OLD_FE</name></expr>:</case>
			<comment type="block">/* The FE/BE protocol uses \n as newline for all platforms */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pq_putbytes</name><argument_list>(<argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no hope of recovering connection sync, so FATAL */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection lost during COPY to stdout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>COPY_NEW_FE</name></expr>:</case>
			<comment type="block">/* The FE/BE protocol uses \n as newline for all platforms */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Dump the accumulated row as one CopyData message */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COPY_CALLBACK</name></expr>:</case>
			<comment type="block">/* we don't actually do the write here, we let the caller do it */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
			<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<return>return;</return> <comment type="block">/* don't want to reset msgbuf quite yet */</comment>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>fe_msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AXG: This one is equivalent to CopySendEndOfRow() besides that
 * it doesn't send end of row - it just flushed the data. We need
 * this method for the dispatcher COPY TO since it already has data
 * with newlines (from the executors).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyToDispatchFlush</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>fe_msgbuf</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>COPY_FILE</name></expr>:</case>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
						  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EPIPE</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The pipe will be closed automatically on error at
						 * the end of transaction, but we might get a better
						 * error message from the subprocess' exit code than
						 * just "Broken Pipe"
						 */</comment>
						<expr_stmt><expr><call><name>close_program_pipes</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * If close_program_pipes() didn't throw an error,
						 * the program terminated normally, but closed the
						 * pipe first. Restore errno, and throw an error.
						 */</comment>
						<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EPIPE</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to COPY program: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to COPY file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>COPY_OLD_FE</name></expr>:</case>

			<if_stmt><if>if <condition>(<expr><call><name>pq_putbytes</name><argument_list>(<argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no hope of recovering connection sync, so FATAL */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection lost during COPY to stdout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>COPY_NEW_FE</name></expr>:</case>

			<comment type="block">/* Dump the accumulated row as one CopyData message */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COPY_CALLBACK</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected destination COPY_CALLBACK to flush data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>fe_msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyGetData reads data from the source (file or frontend)
 *
 * Note: when copying from the frontend, we expect a proper EOF mark per
 * protocol; if the frontend simply drops the connection, we raise error.
 * It seems unwise to allow the COPY IN to complete normally in that case.
 *
 * NB: no data conversion is applied here.
 *
 * Returns: the number of bytes that were successfully read
 * into the data buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CopyGetData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytesread</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>COPY_FILE</name></expr>:</case>
			<expr_stmt><expr><name>bytesread</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>databuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>datasize</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>feof</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>reached_eof</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> <name>olderrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>close_program_pipes</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If close_program_pipes() didn't throw an error,
					 * the program terminated normally, but closed the
					 * pipe first. Restore errno, and throw an error.
					 */</comment>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>olderrno</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from COPY program: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from COPY file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>COPY_OLD_FE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>pq_getbytes</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>databuf</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Only a \. terminator is legal EOF in old protocol */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>bytesread</name> <operator>+=</operator> <name>datasize</name></expr>;</expr_stmt>		<comment type="block">/* update the count of bytes that were
										 * read so far */</comment>
			<break>break;</break>
		<case>case <expr><name>COPY_NEW_FE</name></expr>:</case>
			<while>while <condition>(<expr><name>datasize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>reached_eof</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>

				<while>while <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>cursor</name></name> <operator>&gt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Try to receive another message */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>mtype</name></decl>;</decl_stmt>

			<label><name>readmessage</name>:</label>
					<expr_stmt><expr><call><name>HOLD_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>mtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>RESUME_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><literal type="char">'d'</literal></expr>:</case>	<comment type="block">/* CopyData */</comment>
							<break>break;</break>
						<case>case <expr><literal type="char">'c'</literal></expr>:</case>	<comment type="block">/* CopyDone */</comment>
							<comment type="block">/* COPY IN correctly terminated by frontend */</comment>
							<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>reached_eof</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<return>return <expr><name>bytesread</name></expr>;</return>
						<case>case <expr><literal type="char">'f'</literal></expr>:</case>	<comment type="block">/* CopyFail */</comment>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY from stdin failed: %s"</literal></expr></argument>,
											<argument><expr><call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'H'</literal></expr>:</case>	<comment type="block">/* Flush */</comment>
						<case>case <expr><literal type="char">'S'</literal></expr>:</case>	<comment type="block">/* Sync */</comment>

							<comment type="block">/*
							 * Ignore Flush/Sync for the convenience of client
							 * libraries (such as libpq) that may send those
							 * without noticing that the command they just
							 * sent was COPY.
							 */</comment>
							<goto>goto <name>readmessage</name>;</goto>
						<default>default:</default>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected message type 0x%02X during COPY from stdin"</literal></expr></argument>,
											<argument><expr><name>mtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block></while>
				<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>cursor</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&gt;</operator> <name>datasize</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>avail</name> <operator>=</operator> <name>datasize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>pq_copymsgbytes</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>databuf</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>databuf</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>databuf</name> <operator>+</operator> <name>avail</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>bytesread</name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>		<comment type="block">/* update the count of bytes that were
										 * read so far */</comment>
				<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <name>avail</name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<break>break;</break>
		<case>case <expr><name>COPY_CALLBACK</name></expr>:</case>
			<expr_stmt><expr><name>bytesread</name> <operator>=</operator> <call><name><name>cstate</name><operator>-&gt;</operator><name>data_source_cb</name></name><argument_list>(<argument><expr><name>databuf</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>,
											   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_source_cb_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>bytesread</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * These functions do apply some data conversion
 */</comment>

<comment type="block">/*
 * CopySendInt32 sends an int32 in network byte order
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendInt32</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyGetInt32 reads an int32 that appears in network byte order
 *
 * Returns true if OK, false if EOF
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyGetInt32</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* suppress compiler warning */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <call><name>pg_ntoh32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CopySendInt16 sends an int16 in network byte order
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendInt16</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>pg_hton16</name><argument_list>(<argument><expr><operator>(</operator><name>uint16</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyGetInt16 reads an int16 that appears in network byte order
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyGetInt16</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* suppress compiler warning */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <call><name>pg_ntoh16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyLoadRawBuf loads some more data into raw_buf
 *
 * Returns true if able to obtain at least one more byte, else false.
 *
 * If raw_buf_index &lt; raw_buf_len, the unprocessed bytes are transferred
 * down to the start of the buffer and then we load more data after that.
 * This case is used only when a frontend multibyte character crosses a
 * bufferload boundary.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyLoadRawBuf</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inbytes</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>&lt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Copy down the unprocessed data */</comment>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr></argument>,
				<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>				<comment type="block">/* no data need be saved */</comment>

	<expr_stmt><expr><name>inbytes</name> <operator>=</operator> <call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name> <operator>+</operator> <name>nbytes</name></expr></argument>,
						  <argument><expr><name>RAW_BUF_SIZE</name> <operator>-</operator> <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name>inbytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name><index>[<expr><name>nbytes</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>inbytes</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	 DoCopy executes the SQL COPY statement
 *
 * Either unload or reload contents of table &lt;relation&gt;, depending on &lt;from&gt;.
 * (&lt;from&gt; = true means we are inserting into the table.)  In the "TO" case
 * we also support copying the output of an arbitrary SELECT, INSERT, UPDATE
 * or DELETE query.
 *
 * If &lt;pipe&gt; is false, transfer is between the table and the file named
 * &lt;filename&gt;.  Otherwise, transfer is between the table and our regular
 * input/output stream. The latter could be either stdin/stdout or a
 * socket, depending on whether we're running under Postmaster control.
 *
 * Do not allow a Postgres user without the 'pg_read_server_files' or
 * 'pg_write_server_files' role to read from or write to a file.
 *
 * Do not allow the copy if user doesn't have proper permission to access
 * the table or the specifically requested columns.
 */</comment>
<function><type><name>void</name></type>
<name>DoCopy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
	   <parameter><decl><type><name>int</name></type> <name>stmt_location</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stmt_len</name></decl></parameter>,
	   <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>processed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_from</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>is_from</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pipe</name> <init>= <expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>query</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>whereClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnamelist</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>glob_cstate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>glob_copystmt</name> <operator>=</operator> <operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>options</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>sreh</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY single row error handling only available using COPY FROM"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* GPDB_91_MERGE_FIXME: this should probably be done earlier, e.g. in parser */</comment>
	<comment type="block">/* Transfer any SREH options to the options list, so that BeginCopy can see them. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>sreh</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SingleRowErrorDesc</name> <modifier>*</modifier></type><name>sreh</name> <init>= <expr><operator>(</operator><name>SingleRowErrorDesc</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>sreh</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"sreh"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sreh</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Disallow COPY to/from file or program except to users with the
	 * appropriate role.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pipe</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_EXECUTE_SERVER_PROGRAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or a member of the pg_execute_server_program role to COPY to or from an external program"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Anyone can COPY to stdout or from stdin. "</literal>
								 <literal type="string">"psql's \\copy command also works for anyone."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>is_from</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_SERVER_FILES</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or a member of the pg_read_server_files role to COPY from a file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Anyone can COPY to stdout or from stdin. "</literal>
								 <literal type="string">"psql's \\copy command also works for anyone."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_from</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_WRITE_SERVER_FILES</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or a member of the pg_write_server_files role to COPY to a file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Anyone can COPY to stdout or from stdin. "</literal>
								 <literal type="string">"psql's \\copy command also works for anyone."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><ternary><condition><expr><name>is_from</name></expr> ?</condition><then> <expr><name>RowExclusiveLock</name></expr> </then><else>: <expr><name>AccessShareLock</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Open and lock the relation, using the appropriate lock type. */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_from</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure the configuration parameter allow_system_table_mods is set."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>is_from</name></expr> ?</condition><then> <expr><name>ACL_INSERT</name></expr> </then><else>: <expr><name>ACL_SELECT</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* add rte to column namespace  */</comment>
			<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Transform the raw expression tree */</comment>
			<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_COPY_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Make sure it yields a boolean result. */</comment>
			<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* we have to fix its collations too */</comment>
			<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>whereClause</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnamelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call> <operator>-</operator>
			<name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>ExecCheckRTPerms</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Permission check for row security policies.
		 *
		 * check_enable_rls will ereport(ERROR) if the user has requested
		 * something invalid and will otherwise indicate if we should enable
		 * RLS (returns RLS_ENABLED) or not for this COPY statement.
		 *
		 * If the relation has a row security policy and we are to apply it
		 * then perform a "query" copy and allow the normal query processing
		 * to handle the policies.
		 *
		 * If RLS is not enabled for this, then just fall through to the
		 * normal non-filtering relation handling.
		 *
		 * GPDB: Also do this for partitioned tables. In PostgreSQL, you get
		 * an error:
		 *
		 * ERROR:  cannot copy from partitioned table "foo"
		 * HINT:  Try the COPY (SELECT ...) TO variant.
		 *
		 * In GPDB 6 and before, support for COPYing partitioned table was
		 * implemented deenop in the COPY processing code. In GPDB 7,
		 * partitiong was replaced with upstream impementation, but for
		 * backwards-compatibility, we do the translation to "COPY (SELECT
		 * ...)" variant automatically, just like PostgreSQL does for RLS.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name> <operator>||</operator>
			<operator>(</operator><operator>!</operator><name>is_from</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>select</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY FROM not supported with row-level security"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use INSERT statements instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Build target list
			 *
			 * If no columns are specified in the attribute list of the COPY
			 * command, then the target list is 'all' columns. Therefore, '*'
			 * should be used as the target list for the resulting SELECT
			 * statement.
			 *
			 * In the case that columns are specified in the attribute list,
			 * create a ColumnRef and ResTarget for each column and add them
			 * to the target list for the resulting SELECT statement.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>indirection</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;attlist</argument>)</argument_list></macro>
				<block>{<block_content>
					<comment type="block">/*
					 * Build the ColumnRef for each column.  The ColumnRef
					 * 'fields' property is a String 'Value' node (see
					 * nodes/value.h) that corresponds to the column name
					 * respectively.
					 */</comment>
					<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<comment type="block">/* Build the ResTarget and add the ColumnRef to it. */</comment>
					<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>indirection</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<comment type="block">/* Add each column to the SELECT statement's target list */</comment>
					<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Build RangeVar for from clause, fully qualified based on the
			 * relation which we have opened and locked.
			 */</comment>
			<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Build query */</comment>
			<expr_stmt><expr><name>select</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>targetList</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>select</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name>stmt_location</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name>stmt_len</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Close the relation for now, but keep the lock on it to prevent
			 * changes between now and when we start the query-based COPY.
			 *
			 * We'll reopen it later as part of the query-based COPY.
			 */</comment>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name>stmt_location</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name>stmt_len</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_from</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>sreh</name></name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY single row error handling only available for distributed user tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * GPDB_91_MERGE_FIXME: is it possible to get to this point in the code
		 * with a temporary relation that belongs to another session? If so, the
		 * following code doesn't function as expected.
		 */</comment>
		<comment type="block">/* check read-only transaction and parallel mode */</comment>
		<if_stmt><if>if <condition>(<expr><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><literal type="string">"COPY FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><literal type="string">"COPY FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopyFrom</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <name>whereClause</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Error handling setup
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>sreh</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Single row error handling requested */</comment>
			<decl_stmt><decl><type><name>SingleRowErrorDesc</name> <modifier>*</modifier></type><name>sreh</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>sreh</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name>log_to_file</name> <init>= <expr><name>LOG_ERRORS_DISABLE</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IS_LOG_TO_FILE</name><argument_list>(<argument><expr><name><name>sreh</name><operator>-&gt;</operator><name>log_error_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>errMode</name></name> <operator>=</operator> <name>SREH_LOG</name></expr>;</expr_stmt>
				<comment type="block">/* LOG ERRORS PERSISTENTLY for COPY is not allowed for now. */</comment>
				<expr_stmt><expr><name>log_to_file</name> <operator>=</operator> <name>LOG_ERRORS_ENABLE</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>errMode</name></name> <operator>=</operator> <name>SREH_IGNORE</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name> <operator>=</operator> <call><name>makeCdbSreh</name><argument_list>(<argument><expr><name><name>sreh</name><operator>-&gt;</operator><name>rejectlimit</name></name></expr></argument>,
										  <argument><expr><name><name>sreh</name><operator>-&gt;</operator><name>is_limit_in_rows</name></name></expr></argument>,
										  <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
										  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
										  <argument><expr><name>log_to_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No single row error handling requested. Use "all or nothing" */</comment>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* default - no SREH */</comment>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>errMode</name></name> <operator>=</operator> <name>ALL_OR_NOTHING</name></expr>;</expr_stmt> <comment type="block">/* default */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator> <call><name>CopyDispatchOnSegment</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator> <call><name>CopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* copy from file to database */</comment>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbCopy</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>cdbCopyAbort</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbCopy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbCopy</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EndCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * GPDB_91_MERGE_FIXME: ExecutorStart() is called in BeginCopyTo,
		 * but the TRY-CATCH block only starts here. If an error is
		 * thrown in-between, we would fail to call mppExecutorCleanup. We
		 * really should be using a ResourceOwner or something else for
		 * cleanup, instead of TRY-CATCH blocks...
		 *
		 * Update: I tried to fix this using the glob_cstate hack. It's ugly,
		 * but fixes at least some cases that came up in regression tests.
		 */</comment>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopyTo</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>,
								 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>,
								 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * "copy t to file on segment"					CopyDispatchOnSegment
			 * "copy (select * from t) to file on segment"	CopyToQueryOnSegment
			 * "copy t/(select * from t) to file"			DoCopyTo
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator> <call><name>CopyDispatchOnSegment</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator> <call><name>CopyToQueryOnSegment</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator> <call><name>DoCopyTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* copy from database to file */</comment>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>glob_cstate</name> <operator>&amp;&amp;</operator> <name><name>glob_cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* should shutdown the mpp stuff such as interconnect and dispatch thread */</comment>
				<expr_stmt><expr><call><name>mppExecutorCleanup</name><argument_list>(<argument><expr><name><name>glob_cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>EndCopyTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/*
	 * Close the relation.  If reading, we can release the AccessShareLock we
	 * got; if writing, we should hold the lock until end of transaction to
	 * ensure that updates will be committed before lock is released.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>is_from</name></expr> ?</condition><then> <expr><name>NoLock</name></expr> </then><else>: <expr><name>AccessShareLock</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Issue automatic ANALYZE if conditions are satisfied (MPP-4082). */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>auto_stats</name><argument_list>(<argument><expr><name>AUTOSTATS_CMDTYPE_COPY</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>*</operator><name>processed</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* inFunction */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process the statement option list for COPY.
 *
 * Scan the options list (a list of DefElem) and transpose the information
 * into cstate, applying appropriate error checking.
 *
 * cstate is assumed to be filled with zeroes initially.
 *
 * This is exported so that external users of the COPY API can sanity-check
 * a list of options.  In that usage, cstate should be passed as NULL
 * (since external users don't know sizeof(CopyStateData)) and the collected
 * data is just leaked until CurrentMemoryContext is reset.
 *
 * Note that additional checking, such as whether column names listed in FORCE
 * QUOTE actually exist, has to be applied later.  This just checks for
 * self-consistency of the options list.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessCopyOptions</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
				   <parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>is_from</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>format_specified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>

	<comment type="block">/* Support external use for option sanity checking */</comment>
	<if_stmt><if>if <condition>(<expr><name>cstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cstate</name> <operator>=</operator> <operator>(</operator><name>CopyStateData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape_off</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>skip_foreign_partitions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_copy_from</name></name> <operator>=</operator> <name>is_from</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Extract options from the statement node tree */</comment>
	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>format_specified</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>format_specified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* default format */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"csv"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY format \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"freeze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>freeze</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>freeze</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"delimiter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * MPP-2010: unfortunately serialization function doesn't
			 * distinguish between 0x0 and empty string. Therefore we
			 * must assume that if NULL AS was indicated and has no value
			 * the actual value is an empty string.
			 */</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"header"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"quote"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"escape"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_quote"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* OPTIONS (force_quote 'c1,c2') */</comment>
					<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name> <operator>=</operator> <call><name>parse_joined_option_list</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a list of column names"</literal></expr></argument>,
								<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_not_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* OPTIONS (force_not_null 'c1,c2') */</comment>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name> <operator>=</operator> <call><name>parse_joined_option_list</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a list of column names"</literal></expr></argument>,
								<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a list of column names"</literal></expr></argument>,
								<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"convert_selectively"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Undocumented, not-accessible-from-SQL option: convert only the
			 * named columns to binary form, storing the rest as NULLs. It's
			 * allowed for the column list to be NIL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_selectively</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_selectively</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a list of column names"</literal></expr></argument>,
								<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>=</operator> <call><name>pg_char_to_encoding</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a valid encoding name"</literal></expr></argument>,
								<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fill_missing_fields"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>fill_missing</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fill_missing</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"newline"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_str</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_str</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sreh"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>SingleRowErrorDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a list of column names"</literal></expr></argument>,
								<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>sreh</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>sreh</name></name> <operator>=</operator> <operator>(</operator><name>SingleRowErrorDesc</name> <operator>*</operator><operator>)</operator> <name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"on_segment"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"skip_foreign_partitions"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>skip_foreign_partitions</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>skip_foreign_partitions</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rel_is_external_table</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Check for incompatible options (must do these two before inserting
	 * defaults)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY cannot specify DELIMITER in BINARY mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY cannot specify NULL in BINARY mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_UNKNOWN</name></expr>;</expr_stmt>

	<comment type="block">/* Set defaults for omitted options */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name> <operator>=</operator> <ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">"\t"</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name> <operator>=</operator> <ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"\\N"</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name> <operator>=</operator> <literal type="string">"\""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>=</operator> <literal type="string">"\\"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* default escape for text mode */</comment>

	<comment type="block">/* Only single-byte delimiter strings are supported. */</comment>
	<comment type="block">/* GPDB: This is checked later */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	if (strlen(cstate-&gt;delim) != 1)
		ereport(ERROR,
				(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
				 errmsg("COPY delimiter must be a single one-byte character")));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Disallow end-of-line characters */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
		<call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter cannot be newline or carriage return"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
		<call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY null representation cannot use newline or carriage return"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Disallow unsafe delimiter characters in non-CSV mode.  We can't allow
	 * backslash because it would be ambiguous.  We can't allow the other
	 * cases because data characters matching the delimiter must be
	 * backslashed, and certain backslash combinations are interpreted
	 * non-literally by COPY IN.  Disallowing all lower case ASCII letters is
	 * more than strictly necessary, but seems best for consistency and
	 * future-proofing.  Likewise we disallow all digits though only octal
	 * digits are actually dangerous.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name> <operator>&amp;&amp;</operator>
		<call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"\\.abcdefghijklmnopqrstuvwxyz0123456789"</literal></expr></argument>,
			   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter cannot be \"%s\""</literal></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check header */</comment>
	<comment type="block">/*
	 * In PostgreSQL, HEADER is not allowed in text mode either, but in GPDB,
	 * only forbid it with BINARY.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY cannot specify HEADER in BINARY mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check quote */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY quote available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY quote must be a single one-byte character"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter and quote must be different"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check escape */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY escape in CSV format must be a single character"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
		<call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY escape representation in text format cannot use newline or carriage return"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY escape must be a single character, or [OFF/off] to disable escapes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check force_quote */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force quote available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force quote only available using COPY TO"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check force_notnull */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force not null available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force not null only available using COPY FROM"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check force_null */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force null available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force null only available using COPY FROM"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't allow the delimiter to appear in the null string. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter must not appear in the NULL specification"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't allow the CSV quote char to appear in the null string. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator>
		<call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CSV quote character must not appear in the NULL specification"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * DELIMITER
	 *
	 * Only single-byte delimiter strings are supported. In addition, if the
	 * server encoding is a multibyte character encoding we only allow the
	 * delimiter to be an ASCII character (like postgresql. For more info
	 * on this see discussion and comments in MPP-3756).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* single byte encoding such as ascii, latinx and other */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter must be a single one-byte character, or \'off\'"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* multi byte encoding such as utf8 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name></expr> )</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter must be a single one-byte character, or \'off\'"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter cannot be backslash"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>fill_missing</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fill missing fields only available for data loading, not unloading"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * NEWLINE
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_str</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_from</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_FEATURE_NOT_YET</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"newline currently available for data loading only, not unloading"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_str</name></name></expr></argument>, <argument><expr><literal type="string">"lf"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_NL</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_str</name></name></expr></argument>, <argument><expr><literal type="string">"cr"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_CR</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_str</name></name></expr></argument>, <argument><expr><literal type="string">"crlf"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_CRNL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for NEWLINE \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_str</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Valid options are: 'LF', 'CRLF' and 'CR'."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape_off</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common setup routines used by BeginCopyFrom and BeginCopyTo.
 *
 * Iff &lt;binary&gt;, unload or reload in the binary format, as opposed to the
 * more wasteful but more robust and portable text format.
 *
 * Iff &lt;oids&gt;, unload or reload the format that includes OID information.
 * On input, we accept OIDs whether or not the table has an OID column,
 * but silently drop them if it does not.  On output, we report an error
 * if the user asks for OIDs in a table that has none (not providing an
 * OID column might seem friendlier, but could seriously confuse programs).
 *
 * If in the text format, delimit columns with delimiter &lt;delim&gt; and print
 * NULL values as &lt;null_print&gt;.
 */</comment>
<function><type><name>CopyState</name></type>
<name>BeginCopy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>is_from</name></decl></parameter>,
		  <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
		  <parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>raw_query</name></decl></parameter>,
		  <parameter><decl><type><name>Oid</name></type> <name>queryRelId</name></decl></parameter>,
		  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
		  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
		  <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_phys_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate workspace and zero all fields */</comment>
	<expr_stmt><expr><name>cstate</name> <operator>=</operator> <operator>(</operator><name>CopyStateData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>glob_cstate</name> <operator>=</operator> <name>cstate</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We allocate everything used by a cstate in a new memory context. This
	 * avoids memory leaks during repeated use of COPY in a query.
	 */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												<argument><expr><literal type="string">"COPY"</literal></expr></argument>,
												<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Greenplum needs this to detect custom protocol */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Extract options from the statement node tree */</comment>
	<expr_stmt><expr><call><name>ProcessCopyOptions</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>is_from</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rel_is_external_table</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't support delimiter 'off' for COPY because the QD COPY
		 * sometimes internally adds columns to the data that it sends to
		 * the QE COPY modules, and it uses the delimiter for it. There
		 * are ways to work around this but for now it's not important and
		 * we simply don't support it.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"using no delimiter is only supported for external tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process the source/target relation or query */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>raw_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>raw_query</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rewritten</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Run parse analysis and rewrite.  Note this also acquires sufficient
		 * locks on the source table(s).
		 *
		 * Because the parser and planner tend to scribble on their input, we
		 * make a preliminary copy of the source querytree.  This prevents
		 * problems in the case that the COPY is in a portal or plpgsql
		 * function and is executed repeatedly.  (See also the same hack in
		 * DECLARE CURSOR and PREPARE.)  XXX FIXME someday.
		 */</comment>
		<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>raw_query</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check that we got back something we can work with */</comment>
		<if_stmt><if>if <condition>(<expr><name>rewritten</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DO INSTEAD NOTHING rules are not supported for COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* examine queries to determine which error message to issue */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rewritten</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_QUAL_INSTEAD_RULE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional DO INSTEAD rules are not supported for COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_NON_INSTEAD_RULE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DO ALSO rules are not supported for the COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multi-statement DO INSTEAD rules are not supported for COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>rewritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>parentStmtType</name></name> <operator>=</operator> <name>PARENTSTMTTYPE_COPY</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Query mustn't use INTO, either */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY (SELECT INTO) is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Similarly the grammar doesn't enforce the presence of a RETURNING
		 * clause, but this is required here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<name><name>query</name><operator>-&gt;</operator><name>returningList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
				   <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
				   <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY query must have a RETURNING clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* plan the query */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>cursorOptions</name> <init>= <expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* GPDB: Pass the IGNORE EXTERNAL PARTITION option to the planner. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>skip_foreign_partitions</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cursorOptions</name> <operator>|=</operator> <name>CURSOR_OPT_SKIP_FOREIGN_PARTITIONS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * With row level security and a user using "COPY relation TO", we
		 * have to convert the "COPY relation TO" to a query-based COPY (eg:
		 * "COPY (SELECT * FROM relation) TO"), to allow the rewriter to add
		 * in any RLS clauses.
		 *
		 * When this happens, we are passed in the relid of the originally
		 * found relation (which we have locked).  As the planner will look up
		 * the relation again, we double-check here to make sure it found the
		 * same one that we have locked.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>queryRelId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note that with RLS involved there may be multiple relations,
			 * and while the one we need is almost certainly first, we don't
			 * make any guarantees of that in the planner, so check the whole
			 * list and make sure we find the original relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>, <argument><expr><name>queryRelId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation referenced by COPY statement has changed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Use a snapshot with an updated command ID to ensure this query sees
		 * results of any previously executed queries.
		 */</comment>
		<expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create dest receiver for COPY OUT */</comment>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestCopyOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <name>dest</name><operator>)</operator><operator>-&gt;</operator><name>cstate</name> <operator>=</operator> <name>cstate</name></expr>;</expr_stmt>

		<comment type="block">/* Create a QueryDesc requesting no output */</comment>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>,
											<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
											<argument><expr><name>InvalidSnapshot</name></expr></argument>,
											<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>GP_INSTRUMENT_OPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>copyIntoClause</name></name> <operator>=</operator>
					<call><name>MakeCopyIntoClause</name><argument_list>(<argument><expr><name>glob_copystmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* GPDB hook for collecting query info */</comment>
		<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_QUERY_SUBMIT</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Call ExecutorStart to prepare the plan for execution.
		 *
		 * ExecutorStart computes a result tupdesc for us
		 */</comment>
		<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnamelist</name></name> <operator>=</operator> <name>attnamelist</name></expr>;</expr_stmt>
	<comment type="block">/* Generate or convert list of attributes to process */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>attnamelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Convert FORCE_QUOTE name list to per-column flags, check validity */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_phys_attrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FORCE_QUOTE column \"%s\" not referenced by COPY"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Convert FORCE_NOT_NULL name list to per-column flags, check validity */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull_flags</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FORCE_NOT_NULL column \"%s\" not referenced by COPY"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Convert FORCE_NULL name list to per-column flags, check validity */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null_flags</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FORCE_NULL column \"%s\" not referenced by COPY"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Convert convert_selectively name list to per-column flags */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_selectively</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select_flags</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"selected column \"%s\" not referenced by COPY"</literal></expr></argument>,
										 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Use client encoding when ENCODING option is not specified. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>=</operator> <call><name>pg_get_client_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up encoding conversion info.  Even if the file and server encodings
	 * are the same, we must apply pg_any_to_server() to validate data in
	 * multibyte encodings.
	 *
	 * In COPY_EXECUTE mode, the dispatcher has already done the conversion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>!=</operator> <name>COPY_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name> <operator>=</operator>
			<operator>(</operator><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>!=</operator> <call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>||</operator>
			  <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* See Multibyte encoding comment above */</comment>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name> <operator>=</operator> <call><name>PG_ENCODING_IS_CLIENT_ONLY</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setEncodingConversionProc</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>, <argument><expr><operator>!</operator><name>is_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name> <operator>=</operator> <call><name>PG_ENCODING_IS_CLIENT_ONLY</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_FILE</name></expr>;</expr_stmt>	<comment type="block">/* default */</comment>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Dispatch a COPY ON SEGMENT statement to QEs.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>CopyDispatchOnSegment</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyStmt</name>   <modifier>*</modifier></type><name>dispatchStmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPgResults</name></type> <name>pgresults</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rejected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>dispatchStmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>dispatchStmt</name></expr></argument>,
								<argument><expr><name>DF_NEED_TWO_PHASE</name> <operator>|</operator>
								<name>DF_WITH_SNAPSHOT</name> <operator>|</operator>
								<name>DF_CANCEL_ON_ERROR</name></expr></argument>,
								<argument><expr><name>NIL</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB_91_MERGE_FIXME: SREH handling seems to be handled in a different
	 * place for every type of copy. This should be consolidated with the
	 * others.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pgresults</name><operator>.</operator><name>numResults</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name><name>pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>processed</name> <operator>+=</operator> <name><name>result</name><operator>-&gt;</operator><name>numCompleted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejected</name> <operator>+=</operator> <name><name>result</name><operator>-&gt;</operator><name>numRejected</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>rejected</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReportSrehResults</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rejected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Modify the filename in cstate-&gt;filename, and cstate-&gt;cdbsreh if any,
 * for COPY ON SEGMENT.
 *
 * Replaces the "&lt;SEGID&gt;" token in the filename with this segment's ID.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MangleCopyFileName</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>filepath</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filepath</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>replaceStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filepath</name></expr></argument>, <argument><expr><literal type="string">"&lt;SEG_DATA_DIR&gt;"</literal></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"&lt;SEGID&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"&lt;SEGID&gt; is required for file name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>segid_buf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>segid_buf</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>replaceStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filepath</name></expr></argument>, <argument><expr><literal type="string">"&lt;SEGID&gt;"</literal></expr></argument>, <argument><expr><name>segid_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name><name>filepath</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<comment type="block">/* Rename filename if error log needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
				 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
				 <argument><expr><name><name>filepath</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release resources allocated in a cstate for COPY TO/FROM.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EndCopy</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>close_program_pipes</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>FreeFile</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Clean up single row error handling related memory */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>destroyCdbSreh</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>CopyIntoClause</name><modifier>*</modifier></type>
<name>MakeCopyIntoClause</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyIntoClause</name> <modifier>*</modifier></type><name>copyIntoClause</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>copyIntoClause</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CopyIntoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>copyIntoClause</name><operator>-&gt;</operator><name>is_program</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>is_program</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyIntoClause</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyIntoClause</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyIntoClause</name><operator>-&gt;</operator><name>attlist</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr>;</expr_stmt>

	<return>return <expr><name>copyIntoClause</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CopyState</name></type>
<name>BeginCopyToOnSegment</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_phys_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyIntoClause</name> <modifier>*</modifier></type><name>copyIntoClause</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>copyIntoClause</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>copyIntoClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopy</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name><name>copyIntoClause</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>,
					   <argument><expr><name><name>copyIntoClause</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>;</expr_stmt>		<comment type="block">/* default */</comment>

	<comment type="block">/* We use fe_msgbuf as a per-row buffer regardless of copy_dest */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>copyIntoClause</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name> <operator>=</operator> <name><name>copyIntoClause</name><operator>-&gt;</operator><name>is_program</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MangleCopyFileName</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>filename</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>program_pipes</name></name> <operator>=</operator> <call><name>open_program_pipes</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>program_pipes</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not execute command \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>mode_t</name></type> <name>oumask</name></decl>;</decl_stmt> <comment type="block">/* Pre-existing umask value */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Prevent write to relative path ... too easy to shoot oneself in
		 * the foot by overwriting a database file ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relative path not allowed for COPY to file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><name>S_IWGRP</name> <operator>|</operator> <name>S_IWOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for writing: %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="line">// Increase buffer size to improve performance  (cmcdevitt)</comment>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IOFBF</name></expr></argument>, <argument><expr><literal type="number">393216</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// 384 Kbytes</comment>

		<expr_stmt><expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a directory"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<comment type="block">/* Get info about the columns we need to process. */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>out_func_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isvarlena</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeBinaryOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>atttypid</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>atttypid</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create a temporary memory context that we can reset once per row to
	 * recover palloc'd memory.  This avoids any problems with leaks inside
	 * datatype output routines, and should be faster than retail pfree's
	 * anyway.  (We don't need a whole econtext as CopyFrom does.)
	 */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											   <argument><expr><literal type="string">"COPY TO"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate header for a binary copy */</comment>
		<decl_stmt><decl><type><name>int32</name></type>		<name>tmp</name></decl>;</decl_stmt>

		<comment type="block">/* Signature */</comment>
		<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BinarySignature</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flags field */</comment>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* No header extension */</comment>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* if a header has been requested send the line */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>hdr_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>hdr_delim</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>hdr_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CopyAttributeOutCSV</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Setup CopyState to read tuples from a table or a query for COPY TO.
 */</comment>
<function><type><specifier>static</specifier> <name>CopyState</name></type>
<name>BeginCopyTo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
			<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
			<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>queryRelId</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>is_program</name></decl></parameter>,
			<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
			<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from view \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try the COPY (SELECT ...) TO variant."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from materialized view \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try the COPY (SELECT ...) TO variant."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from foreign table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try the COPY (SELECT ...) TO variant."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from sequence \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/*
		 * GPDB: This is not reached in GPDB, because we transform the command
		 * to the COPY (SELECT ...) TO variant automatically earlier already.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from partitioned table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try the COPY (SELECT ...) TO variant."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from non-table relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>queryRelId</name></expr></argument>, <argument><expr><name>attnamelist</name></expr></argument>,
					   <argument><expr><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine the mode */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name> <operator>&amp;&amp;</operator>
		<name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>=</operator> <name>COPY_DISPATCH</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>=</operator> <name>COPY_DIRECT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>pipe</name> <init>= <expr><operator>(</operator><name>filename</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* in ON SEGMENT mode, we don't open anything on the dispatcher. */</comment>

		<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"STDOUT is not supported by 'COPY ON SEGMENT'"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>pipe</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_program</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* the grammar does not allow this */</comment>
		<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name> <operator>=</operator> <name>is_program</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MangleCopyFileName</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_program</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>program_pipes</name></name> <operator>=</operator> <call><name>open_program_pipes</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>program_pipes</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not execute command \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>mode_t</name></type> <name>oumask</name></decl>;</decl_stmt> <comment type="block">/* Pre-existing umask value */</comment>
			<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Prevent write to relative path ... too easy to shoot oneself in
			 * the foot by overwriting a database file ...
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relative path not allowed for COPY to file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><name>S_IWGRP</name> <operator>|</operator> <name>S_IWOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* copy errno because ereport subfunctions might change it */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for writing: %m"</literal></expr></argument>,
								<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><operator>(</operator><name>save_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>save_errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator></expr> ?</condition><then>
						 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"COPY TO instructs the PostgreSQL server process to write a file. "</literal>
								 <literal type="string">"You may want a client-side facility such as psql's \\copy."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// Increase buffer size to improve performance  (cmcdevitt)</comment>
			<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IOFBF</name></expr></argument>, <argument><expr><literal type="number">393216</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// 384 Kbytes</comment>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a directory"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set up CopyState for writing to a foreign or external table.
 */</comment>
<function><type><name>CopyState</name></type>
<name>BeginCopyToForeignTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>forrel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>forrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopy</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>forrel</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* raw_query */</comment>
					   <argument><expr><name>InvalidOid</name></expr></argument>,
					   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
					   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>forrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>=</operator> <name>COPY_DIRECT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use COPY_CALLBACK to mean that the each line should be
	 * left in fe_msgbuf. There is no actual callback!
	 */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_CALLBACK</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Some more initialization, that in the normal COPY TO codepath, is done
	 * in CopyTo() itself.
	 */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>;</expr_stmt>		<comment type="block">/* default */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <call><name>pg_server_to_custom</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>,
														<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name></expr></argument>,
														<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>,
														<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>enc_conversion_proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>cstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This intermediate routine exists mainly to localize the effects of setjmp
 * so we don't need to plaster a lot of variables with "volatile".
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>DoCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pipe</name> <init>= <expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fe_copy</name> <init>= <expr><operator>(</operator><name>pipe</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>processed</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(<argument><expr><literal type="string">"DoCopyToFail"</literal></expr></argument>, <argument><expr><name>DDLNotSpecified</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fe_copy</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SendCopyBegin</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We want to dispatch COPY TO commands only in the case that
		 * we are the dispatcher and we are copying from a user relation
		 * (a relation where data is distributed in the segment databases).
		 * Otherwize, if we are not the dispatcher *or* if we are
		 * doing COPY (SELECT) we just go straight to work, without
		 * dispatching COPY commands to executors.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>processed</name> <operator>=</operator> <call><name>CopyToDispatch</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>processed</name> <operator>=</operator> <call><name>CopyTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fe_copy</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SendCopyEnd</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For COPY ON SEGMENT command, switch back to front end
			 * before sending copy end which is "\."
			 */</comment>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_NEW_FE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SendCopyEnd</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure we turn off old-style COPY OUT mode upon error. It is
		 * okay to do this in all cases, since it does nothing if the mode is
		 * not on.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_NEW_FE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pq_endcopyout</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>EndCopyToOnSegment</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate trailer for a binary copy */</comment>
		<expr_stmt><expr><call><name>CopySendInt16</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Need to flush out the trailer */</comment>
		<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EndCopy</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up storage and release resources for COPY TO.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EndCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>processed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Close down the query and free resources. */</comment>
		<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean up storage */</comment>
	<expr_stmt><expr><call><name>EndCopy</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy FROM relation TO file, in the dispatcher. Starts a COPY TO command on
 * each of the executors and gathers all the results and writes it out.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>CopyToDispatch</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name>glob_copystmt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_phys_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attr_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbCopy</name>    <modifier>*</modifier></type><name>cdbCopy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We use fe_msgbuf as a per-row buffer regardless of copy_dest */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cdbCopy</name> <operator>=</operator> <call><name>makeCdbCopy</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX: lock all partitions */</comment>

	<comment type="block">/*
	 * Start a COPY command in every db of every segment in Greenplum Database.
	 *
	 * From this point in the code we need to be extra careful
	 * about error handling. ereport() must not be called until
	 * the COPY command sessions are closed on the executors.
	 * Calling ereport() will leave the executors hanging in
	 * COPY state.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"COPY command sent to segdbs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cdbCopyStart</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Generate header for a binary copy */</comment>
			<decl_stmt><decl><type><name>int32</name></type>		<name>tmp</name></decl>;</decl_stmt>

			<comment type="block">/* Signature */</comment>
			<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>BinarySignature</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Flags field */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No header extension */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* if a header has been requested send the line */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>hdr_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * For non-binary copy, we need to convert null_print to client
			 * encoding, because it will be sent directly with CopySendString.
			 *
			 * MPP: in here we only care about this if we need to print the
			 * header. We rely on the segdb server copy out to do the conversion
			 * before sending the data rows out. We don't need to repeat it here
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
					<call><name>pg_server_to_custom</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>,
										<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>,
										<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>enc_conversion_proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>hdr_delim</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>hdr_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CopyAttributeOutCSV</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* add a newline and flush the data */</comment>
			<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * This is the main work-loop. In here we keep collecting data from the
		 * COPY commands on the segdbs, until no more data is available. We
		 * keep writing data out a chunk at a time.
		 */</comment>
		<do>do
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>copy_cancel</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>QueryCancelPending</name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/* get a chunk of data rows from the QE's */</comment>
			<expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>cdbCopyGetData</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><name>copy_cancel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* send the chunk of data rows to destination (file or stdout) */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cdbCopy</name><operator>-&gt;</operator><name>copy_out_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <comment type="block">/* conditional is important! */</comment>
			<block>{<block_content>
				<comment type="block">/*
				 * in the dispatcher we receive chunks of whole rows with row endings.
				 * We don't want to use CopySendEndOfRow() b/c it adds row endings and
				 * also b/c it's intended for a single row at a time. Therefore we need
				 * to fill in the out buffer and just flush it instead.
				 */</comment>
				<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>cdbCopy</name><operator>-&gt;</operator><name>copy_out_buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>cdbCopy</name><operator>-&gt;</operator><name>copy_out_buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopyToDispatchFlush</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block> while<condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

		<expr_stmt><expr><call><name>cdbCopyEnd</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now it's safe to destroy the whole dispatcher state */</comment>
		<expr_stmt><expr><call><name>CdbDispatchCopyEnd</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
    <comment type="block">/* catch error from CopyStart, CopySendEndOfRow or CopyToDispatchFlush */</comment>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cdbCopyAbort</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate trailer for a binary copy */</comment>
		<expr_stmt><expr><call><name>CopySendInt16</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Need to flush out the trailer */</comment>
		<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we can throw the error now if QueryCancelPending was set previously */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>CopyToQueryOnSegment</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* run the plan --- the dest receiver will send tuples */</comment>
	<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy from relation or query TO file.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>CopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_phys_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>;</expr_stmt> <comment type="block">/* default */</comment>

	<comment type="block">/* We use fe_msgbuf as a per-row buffer regardless of copy_dest */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get info about the columns we need to process. */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>out_func_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isvarlena</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeBinaryOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create a temporary memory context that we can reset once per row to
	 * recover palloc'd memory.  This avoids any problems with leaks inside
	 * datatype output routines, and should be faster than retail pfree's
	 * anyway.  (We don't need a whole econtext as CopyFrom does.)
	 */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											   <argument><expr><literal type="string">"COPY TO"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For non-binary copy, we need to convert null_print to file
		 * encoding, because it will be sent directly with CopySendString.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <call><name>pg_server_to_custom</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>,
															<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name></expr></argument>,
															<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>,
															<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>enc_conversion_proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* header should not be printed in execute mode. */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate header for a binary copy */</comment>
		<decl_stmt><decl><type><name>int32</name></type>		<name>tmp</name></decl>;</decl_stmt>

		<comment type="block">/* Signature */</comment>
		<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BinarySignature</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flags field */</comment>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* No header extension */</comment>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* if a header has been requested send the line */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>hdr_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>hdr_delim</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>hdr_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CopyAttributeOutCSV</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>processed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Deconstruct the tuple ... */</comment>
			<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Format and send the data */</comment>
			<expr_stmt><expr><call><name>CopyOneRowTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* run the plan --- the dest receiver will send tuples */</comment>
		<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>processed</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name><operator>)</operator><operator>-&gt;</operator><name>processed</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Trailer should not be printed in execute mode. The dispatcher will
		 * write it once.
		 */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate trailer for a binary copy */</comment>
		<expr_stmt><expr><call><name>CopySendInt16</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Need to flush out the trailer */</comment>
		<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SendNumRows</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>CopyOneCustomRowTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>,
						   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Emit one row during CopyTo().
 */</comment>
<function><type><name>void</name></type>
<name>CopyOneRowTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>out_functions</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Binary per-tuple header */</comment>
		<expr_stmt><expr><call><name>CopySendInt16</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make sure the tuple is fully deconstructed */</comment>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>need_delim</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>need_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>quotec</name> <init>= <expr><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr> ?</condition><then> <expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

				<comment type="block">/* int2out or int4out ? */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>==</operator> <literal type="number">39</literal> <operator>||</operator>  <comment type="block">/* int2out or int4out */</comment>
					<name><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>==</operator> <literal type="number">43</literal></expr> )</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">33</literal></expr>]</index></name></decl>;</decl_stmt>
					<comment type="block">/*
					 * The standard postgres way is to call the output function, but that involves one or more pallocs,
					 * and a call to sprintf, followed by a conversion to client charset.
					 * Do a fast conversion to string instead.
					 */</comment>

					<if_stmt><if>if <condition>(<expr><name><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>==</operator>  <literal type="number">39</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pg_itoa</name><argument_list>(<argument><expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pg_ltoa</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<comment type="block">/*
					 * Integers don't need quoting, or transcoding to client char
					 * set. We still quote them if FORCE QUOTE was used, though.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>quotec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>quotec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>==</operator> <literal type="number">1702</literal></expr>)</condition>   <comment type="block">/* numeric_out */</comment>
				<block>{<block_content>
					<expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
												<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/*
					 * Numerics don't need quoting, or transcoding to client char
					 * set. We still quote them if FORCE QUOTE was used, though.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>quotec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>quotec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
												<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CopyAttributeOutCSV</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>string</name></expr></argument>,
											<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
											<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CopyAttributeOutText</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>outputbytes</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>outputbytes</name> <operator>=</operator> <call><name>SendFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
											   <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Finish off the row: write it to the destination, and update the count.
	 * However, if we're in the context of a writable external table, we let
	 * the caller do it - send the data to its local external source (see
	 * external_insert() ).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>!=</operator> <name>COPY_CALLBACK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * error context callback for COPY FROM
 *
 * The argument for the error context must be CopyState.
 */</comment>
<function><type><name>void</name></type>
<name>CopyFromErrorCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name> <init>= <expr><operator>(</operator><name>CopyState</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>curlineno_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>curlineno_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>curlineno_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
			 <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* can't usefully display the data */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %s, column %s"</literal></expr></argument>,
					   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name>curlineno_str</name></expr></argument>,
					   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %s"</literal></expr></argument>,
					   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name>curlineno_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* error is relevant to a particular column */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attval</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attval</name> <operator>=</operator> <call><name>limit_printout_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %s, column %s: \"%s\""</literal></expr></argument>,
					   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name>curlineno_str</name></expr></argument>,
					   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr></argument>, <argument><expr><name>attval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* error is relevant to a particular column, value is NULL */</comment>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %s, column %s: null input"</literal></expr></argument>,
					   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name>curlineno_str</name></expr></argument>,
					   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Error is relevant to a particular line.
			 *
			 * If line_buf still contains the correct line, and it's already
			 * transcoded, print it. If it's still in a foreign encoding, it's
			 * quite likely that the error is precisely a failure to do
			 * encoding conversion (ie, bad data). We dare not try to convert
			 * it, and at present there's no way to regurgitate it without
			 * conversion. So we have to punt and just report the line number.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>||</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lineval</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>lineval</name> <operator>=</operator> <call><name>limit_printout_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %s: \"%s\""</literal></expr></argument>,
						   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name>curlineno_str</name></expr></argument>, <argument><expr><name>lineval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lineval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Here, the line buffer is still in a foreign encoding,
				 * and indeed it's quite likely that the error is precisely
				 * a failure to do encoding conversion (ie, bad data).	We
				 * dare not try to convert it, and at present there's no way
				 * to regurgitate it without conversion.  So we have to punt
				 * and just report the line number.
				 */</comment>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %s"</literal></expr></argument>,
						   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name>curlineno_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure we don't print an unreasonable amount of COPY data in a message.
 *
 * It would seem a lot easier to just use the sprintf "precision" limit to
 * truncate the string.  However, some versions of glibc have a bug/misfeature
 * that vsnprintf will always fail (return -1) if it is asked to truncate
 * a string that contains invalid byte sequences for the current encoding.
 * So, do our own truncation.  We return a pstrdup'd copy of the input.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>limit_printout_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_COPY_DATA_DISPLAY</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>int</name></type>			<name>slen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/* Fast path if definitely okay */</comment>
	<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&lt;=</operator> <name>MAX_COPY_DATA_DISPLAY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Apply encoding-dependent truncation */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>MAX_COPY_DATA_DISPLAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Truncate, and add "..." to show we truncated the input.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>res</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate memory and initialize a new CopyMultiInsertBuffer for this
 * ResultRelInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>CopyMultiInsertBuffer</name> <modifier>*</modifier></type>
<name>CopyMultiInsertBufferInit</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>CopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyMultiInsertBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleTableSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_BUFFERED_TUPLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name>rri</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>bistate</name></name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make a new buffer for this ResultRelInfo.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CopyMultiInsertInfoSetupBuffer</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>,
							   <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>CopyMultiInsertBufferInit</name><argument_list>(<argument><expr><name>rri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setup back-link so we can easily find this buffer again */</comment>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_CopyMultiInsertBuffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
	<comment type="block">/* Record that we're tracking this buffer */</comment>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize an already allocated CopyMultiInsertInfo.
 *
 * If rri is a non-partitioned table then a CopyMultiInsertBuffer is set up
 * for that table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyMultiInsertInfoInit</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>,
						<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>mycid</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>ti_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedBytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>cstate</name></name> <operator>=</operator> <name>cstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>mycid</name></name> <operator>=</operator> <name>mycid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>ti_options</name></name> <operator>=</operator> <name>ti_options</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only setup the buffer when not dealing with a partitioned table.
	 * Buffers for partitioned tables will just be setup when we need to send
	 * tuples their way for the first time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CopyMultiInsertInfoSetupBuffer</name><argument_list>(<argument><expr><name>miinfo</name></expr></argument>, <argument><expr><name>rri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if the buffers are full
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>CopyMultiInsertInfoIsFull</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedTuples</name></name> <operator>&gt;=</operator> <name>MAX_BUFFERED_TUPLES</name> <operator>||</operator>
		<name><name>miinfo</name><operator>-&gt;</operator><name>bufferedBytes</name></name> <operator>&gt;=</operator> <name>MAX_BUFFERED_BYTES</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if we have no buffered tuples
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>CopyMultiInsertInfoIsEmpty</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedTuples</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write the tuples stored in 'buffer' out to the table.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CopyMultiInsertBufferFlush</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>,
						   <parameter><decl><type><name>CopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>save_cur_lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name> <init>= <expr><name><name>miinfo</name><operator>-&gt;</operator><name>cstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>miinfo</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>mycid</name> <init>= <expr><name><name>miinfo</name><operator>-&gt;</operator><name>mycid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ti_options</name> <init>= <expr><name><name>miinfo</name><operator>-&gt;</operator><name>ti_options</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>line_buf_valid</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nused</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set es_result_relation_info to the ResultRelInfo we're flushing. */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Print error context information correctly, if one of the operations
	 * below fail.
	 */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_cur_lineno</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * table_multi_insert may leak memory, so switch to short-lived memory
	 * context before calling it.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_multi_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
					   <argument><expr><name>slots</name></expr></argument>,
					   <argument><expr><name>nused</name></expr></argument>,
					   <argument><expr><name>mycid</name></expr></argument>,
					   <argument><expr><name>ti_options</name></expr></argument>,
					   <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nused</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * If there are any indexes, update them for all the inserted tuples,
		 * and run AFTER ROW INSERT triggers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>recheckIndexes</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>linenos</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator>
				<call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>recheckIndexes</name></expr></argument>,
								 <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * There's no indexes, but see if we need to run AFTER ROW INSERT
		 * triggers anyway.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name> <operator>||</operator>
				  <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_new_table</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>linenos</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Mark that all slots are free */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* reset cur_lineno and line_buf_valid to what they were */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>=</operator> <name>line_buf_valid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name>save_cur_lineno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop used slots and free member for this buffer.
 *
 * The buffer must be flushed before cleanup.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CopyMultiInsertBufferCleanup</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure buffer was flushed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove back-link to ourself */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_CopyMultiInsertBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since we only create slots on demand, just drop the non-null ones. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_BUFFERED_TUPLES</name> <operator>&amp;&amp;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write out all stored tuples in all buffers out to the tables.
 *
 * Once flushed we also trim the tracked buffers list down to size by removing
 * the buffers created earliest first.
 *
 * Callers should pass 'curr_rri' is the ResultRelInfo that's currently being
 * used.  When cleaning up old buffers we'll never remove the one for
 * 'curr_rri'.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CopyMultiInsertInfoFlush</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>curr_rri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>miinfo-&gt;multiInsertBuffers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><operator>(</operator><name>CopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CopyMultiInsertBufferFlush</name><argument_list>(<argument><expr><name>miinfo</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedBytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Trim the list of tracked buffers down if it exceeds the limit.  Here we
	 * remove buffers starting with the ones we created first.  It seems more
	 * likely that these older ones are less likely to be needed than ones
	 * that were just created.
	 */</comment>
	<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_PARTITION_BUFFERS</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>CopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We never want to remove the buffer that's currently being used, so
		 * if we happen to find that then move it to the end of the list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>==</operator> <name>curr_rri</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>CopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CopyMultiInsertBufferCleanup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup allocated buffers and free memory
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CopyMultiInsertInfoCleanup</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>miinfo-&gt;multiInsertBuffers</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>CopyMultiInsertBufferCleanup</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the next TupleTableSlot that the next tuple should be stored in.
 *
 * Callers must ensure that the buffer is not full.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>CopyMultiInsertInfoNextFreeSlot</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>,
								<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name><name>rri</name><operator>-&gt;</operator><name>ri_CopyMultiInsertBuffer</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nused</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nused</name> <operator>&lt;</operator> <name>MAX_BUFFERED_TUPLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>nused</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>nused</name></expr>]</index></name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>nused</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Record the previously reserved TupleTableSlot that was reserved by
 * CopyMultiInsertInfoNextFreeSlot as being consumed.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CopyMultiInsertInfoStore</name><parameter_list>(<parameter><decl><type><name>CopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>,
						 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tuplen</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>lineno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name><name>rri</name><operator>-&gt;</operator><name>ri_CopyMultiInsertBuffer</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>==</operator> <name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the line number so we can properly report any errors later */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>linenos</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name></expr>]</index></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>

	<comment type="block">/* Record this slot as being used */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Update how many tuples are stored and their size */</comment>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedTuples</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedBytes</name></name> <operator>+=</operator> <name>tuplen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy FROM file to relation.
 */</comment>
<function><type><name>uint64</name></type>
<name>CopyFrom</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>target_resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>prevResultRelInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* for ExecConstraints() */</comment>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>singleslot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>mycid</name> <init>= <expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ti_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* start with default options for insert */</comment>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyInsertMethod</name></type> <name>insertMethod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyMultiInsertInfo</name></type> <name>multiInsertInfo</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>	<comment type="block">/* pacify compiler */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_before_insert_row_trig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_instead_insert_row_trig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>leafpart_use_multi_insert</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CdbCopy</name>	   <modifier>*</modifier></type><name>cdbCopy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_check_distkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpDistributionData</name> <modifier>*</modifier></type><name>distData</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* distribution data used to compute target seg */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The target must be a plain, foreign, or partitioned relation, or have
	 * an INSTEAD OF INSERT row trigger.  (Currently, such triggers are only
	 * allowed on views, so we only hint about them in the view case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator>
		  <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to view \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable copying to a view, provide an INSTEAD OF INSERT trigger."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to materialized view \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to sequence \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to non-table relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * Check to see if we can avoid writing WAL
	 *
	 * If archive logging/streaming is not enabled *and* either
	 *	- table was created in same transaction as this COPY
	 *	- data is being written to relfilenode created in this transaction
	 * then we can skip writing WAL.  It's safe because if the transaction
	 * doesn't commit, we'll discard the table (or the new relfilenode file).
	 * If it does commit, we'll have done the table_finish_bulk_insert() at
	 * the bottom of this routine first.
	 *
	 * As mentioned in comments in utils/rel.h, the in-same-transaction test
	 * is not always set correctly, since in rare cases rd_newRelfilenodeSubid
	 * can be cleared before the end of the transaction. The exact case is
	 * when a relation sets a new relfilenode twice in same transaction, yet
	 * the second one fails in an aborted subtransaction, e.g.
	 *
	 * BEGIN;
	 * TRUNCATE t;
	 * SAVEPOINT save;
	 * TRUNCATE t;
	 * ROLLBACK TO save;
	 * COPY ...
	 *
	 * Also, if the target file is new-in-transaction, we assume that checking
	 * FSM for free space is a waste of time, even if we must use WAL because
	 * of archiving.  This could possibly be wrong, but it's unlikely.
	 *
	 * The comments for table_tuple_insert and RelationGetBufferForTuple
	 * specify that skipping WAL logging is only safe if we ensure that our
	 * tuples do not go into pages containing tuples from any other
	 * transactions --- but this must be the case if we have a new table or
	 * new relfilenode, so we need no additional work to enforce that.
	 *
	 * We currently don't support this optimization if the COPY target is a
	 * partitioned table as we currently only lazily initialize partition
	 * information when routing the first tuple to the partition.  We cannot
	 * know at this stage if we can perform this optimization.  It should be
	 * possible to improve on this, but it does mean maintaining heap insert
	 * option flags per partition and setting them when we first open the
	 * partition.
	 *
	 * This optimization is not supported for relation types which do not
	 * have any physical storage, with foreign tables and views using
	 * INSTEAD OF triggers entering in this category.  Partitioned tables
	 * are not supported as per the description above.
	 *----------
	 */</comment>
	<comment type="block">/* createSubid is creation check, newRelfilenodeSubid is truncation check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELKIND_HAS_STORAGE</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name> <operator>||</operator>
		 <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ti_options</name> <operator>|=</operator> <name>TABLE_INSERT_SKIP_FSM</name></expr>;</expr_stmt>
		<comment type="block">/*
		 * The optimization to skip WAL has been disabled in GPDB. wal_level
		 * is hardcoded to 'archive' in GPDB, so it wouldn't have any effect
		 * anyway.
		 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
		if (!XLogIsNeeded())
			ti_options |= TABLE_INSERT_SKIP_WAL;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Optimize if new relfilenode was created in this subxact or one of its
	 * committed children and we won't see those rows later as part of an
	 * earlier scan or command. The subxact test ensures that if this subxact
	 * aborts then the frozen rows won't be visible after xact cleanup.  Note
	 * that the stronger test of exactly which subtransaction created it is
	 * crucial for correctness of this optimization. The test for an earlier
	 * scan or command tolerates false negatives. FREEZE causes other sessions
	 * to see rows they would not see under MVCC, and a false negative merely
	 * spreads that anomaly to the current session.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>freeze</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We currently disallow COPY FREEZE on partitioned tables.  The
		 * reason for this is that we've simply not yet opened the partitions
		 * to determine if the optimization can be applied to them.  We could
		 * go and open them all here, but doing so may be quite a costly
		 * overhead for small copies.  In any case, we may just end up routing
		 * tuples to a small number of partitions.  It seems better just to
		 * raise an ERROR for partitioned tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform COPY FREEZE on a partitioned table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Tolerate one registration for the benefit of FirstXactSnapshot.
		 * Scan-bearing queries generally create at least two registrations,
		 * though relying on that is fragile, as is ignoring ActiveSnapshot.
		 * Clear CatalogSnapshot to avoid counting its registration.  We'll
		 * still detect ongoing catalog scans, each of which separately
		 * registers the snapshot it uses.
		 */</comment>
		<expr_stmt><expr><call><name>InvalidateCatalogSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ThereAreNoPriorRegisteredSnapshots</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ThereAreNoReadyPortals</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform COPY FREEZE because of prior transaction activity"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>!=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>!=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform COPY FREEZE because the table was not created or truncated in the current subtransaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ti_options</name> <operator>|=</operator> <name>TABLE_INSERT_FROZEN</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We need a ResultRelInfo so we can use the regular executor's
	 * index-entry-making machinery.  (There used to be a huge amount of code
	 * here that basically duplicated execUtils.c ...)
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
					  <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
					  <argument><expr><literal type="number">1</literal></expr></argument>,		<comment type="block">/* must match rel's position in range_table */</comment>
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>target_resultRelInfo</name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/* Verify the named relation is a valid target for INSERT */</comment>
	<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecInitRangeTable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up a ModifyTableState so we can let FDW(s) init themselves for
	 * foreign-table result relation(s).
	 */</comment>
	<expr_stmt><expr><name>mtstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>CMD_INSERT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignInsert</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignInsert</name></name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
														 <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare to catch AFTER triggers. */</comment>
	<expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are any triggers with transition tables on the named relation,
	 * we need to be prepared to capture transition tuples.
	 *
	 * Because partition tuple routing would like to know about whether
	 * transition capture is active, we also set it in mtstate, which is
	 * passed to ExecFindPartition() below.
	 */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>=</operator>
		<call><name>MakeTransitionCaptureState</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the named relation is a partitioned table, initialize state for
	 * CopyFrom tuple routing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>proute</name> <operator>=</operator> <call><name>ExecSetupPartitionTupleRouting</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>qualexpr</name></name> <operator>=</operator> <call><name>ExecInitQual</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It's generally more efficient to prepare a bunch of tuples for
	 * insertion, and insert them in one table_multi_insert() call, than call
	 * table_tuple_insert() separately for every tuple. However, there are a
	 * number of reasons why we might not be able to do this.  These are
	 * explained below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name> <operator>||</operator>
		 <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Can't support multi-inserts when there are any BEFORE/INSTEAD OF
		 * triggers on the table. Such triggers might query the table we're
		 * inserting into and act differently if the tuples that have already
		 * been processed and prepared for insertion are not there.
		 */</comment>
		<expr_stmt><expr><name>insertMethod</name> <operator>=</operator> <name>CIM_SINGLE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>proute</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			 <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_new_table</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For partitioned tables we can't support multi-inserts when there
		 * are any statement level insert triggers. It might be possible to
		 * allow partitioned tables with such triggers in the future, but for
		 * now, CopyMultiInsertInfoFlush expects that any before row insert
		 * and statement level insert triggers are on the same relation.
		 */</comment>
		<expr_stmt><expr><name>insertMethod</name> <operator>=</operator> <name>CIM_SINGLE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
			 <name><name>cstate</name><operator>-&gt;</operator><name>volatile_defexprs</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Can't support multi-inserts to foreign tables or if there are any
		 * volatile default expressions in the table.  Similarly to the
		 * trigger case above, such expressions may query the table we're
		 * inserting into.
		 *
		 * Note: It does not matter if any partitions have any volatile
		 * default expressions as we use the defaults from the target of the
		 * COPY command.
		 */</comment>
		<expr_stmt><expr><name>insertMethod</name> <operator>=</operator> <name>CIM_SINGLE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Can't support multi-inserts if there are any volatile function
		 * expressions in WHERE clause.  Similarly to the trigger case above,
		 * such expressions may query the table we're inserting into.
		 */</comment>
		<expr_stmt><expr><name>insertMethod</name> <operator>=</operator> <name>CIM_SINGLE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For partitioned tables, we may still be able to perform bulk
		 * inserts.  However, the possibility of this depends on which types
		 * of triggers exist on the partition.  We must disable bulk inserts
		 * if the partition is a foreign table or it has any before row insert
		 * or insert instead triggers (same as we checked above for the parent
		 * table).  Since the partition's resultRelInfos are initialized only
		 * when we actually need to insert the first tuple into them, we must
		 * have the intermediate insert method of CIM_MULTI_CONDITIONAL to
		 * flag that we must later determine if we can use bulk-inserts for
		 * the partition being inserted into.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>proute</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>insertMethod</name> <operator>=</operator> <name>CIM_MULTI_CONDITIONAL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>insertMethod</name> <operator>=</operator> <name>CIM_MULTI</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>CopyMultiInsertInfoInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>cstate</name></expr></argument>,
								<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>ti_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If not using batch mode (which allocates slots as needed) set up a
	 * tuple slot too. When inserting into a partitioned table, we also need
	 * one, even if we might batch insert, to read the tuple in the root
	 * partition's form.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>insertMethod</name> <operator>==</operator> <name>CIM_SINGLE</name> <operator>||</operator> <name>insertMethod</name> <operator>==</operator> <name>CIM_MULTI_CONDITIONAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>singleslot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bistate</name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>has_before_insert_row_trig</name> <operator>=</operator> <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
								  <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>has_instead_insert_row_trig</name> <operator>=</operator> <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
								   <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check BEFORE STATEMENT insertion triggers. It's debatable whether we
	 * should do this for COPY, since it's not really an "INSERT" statement as
	 * such. However, executing these triggers maintains consistency with the
	 * EACH ROW triggers that we already fire on COPY.
	 */</comment>
	<expr_stmt><expr><call><name>ExecBSInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up callback to identify error line number */</comment>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>CopyFromErrorCallback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>cstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do we need to check the distribution keys? Normally, the QD computes the
	 * target segment and sends the data to the correct segment. We don't need to
	 * verify that in the QE anymore. But in ON SEGMENT, we're reading data
	 * directly from a file, and there's no guarantee on what it contains, so we
	 * need to do the checking in the QE.
	 */</comment>
	<expr_stmt><expr><name>is_check_distkey</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name>gp_enable_segment_copy_checking</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize information about distribution keys, needed to compute target
	 * segment for each row.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_DISPATCH</name> <operator>||</operator> <name>is_check_distkey</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>distData</name> <operator>=</operator> <call><name>InitDistributionData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this table is distributed randomly, there is nothing to check,
		 * after all.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>distData</name><operator>-&gt;</operator><name>policy</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>distData</name><operator>-&gt;</operator><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_check_distkey</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Determine which fields we need to parse in the QD. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitCopyFromDispatchSplit</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>distData</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_DISPATCH</name> <operator>||</operator>
		<name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_EXECUTOR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Now split the attnumlist into the parts that are parsed in the QD, and
		 * in QE.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qd_attnumlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qe_attnumlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>first_qe_processed_field</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>first_qe_processed_field</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>first_qe_processed_field</name></name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>first_qe_processed_field</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>qd_attnumlist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>qd_attnumlist</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>qe_attnumlist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>qe_attnumlist</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>qd_attnumlist</name></name> <operator>=</operator> <name>qd_attnumlist</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>qe_attnumlist</name></name> <operator>=</operator> <name>qe_attnumlist</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We are the QD node, and we are receiving rows from client, or
		 * reading them from a file. We are not writing any data locally,
		 * instead, we determine the correct target segment for row,
		 * and forward each to the correct segment.
		 */</comment>

		<comment type="block">/*
		 * pre-allocate buffer for constructing a message.
		 */</comment>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_msgbuf</name></name></expr></argument>, <argument><expr><name>SizeOfCopyFromDispatchRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * prepare to COPY data into segDBs:
		 * - set table partitioning information
		 * - set append only table relevant info for dispatch.
		 * - get the distribution policy for this table.
		 * - build a COPY command to dispatch to segdbs.
		 * - dispatch the modified COPY command to all segment databases.
		 * - prepare cdbhash for hashing on row values.
		 */</comment>
		<expr_stmt><expr><name>cdbCopy</name> <operator>=</operator> <call><name>makeCdbCopy</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Dispatch the COPY command.
		 *
		 * From this point in the code we need to be extra careful about error
		 * handling. ereport() must not be called until the COPY command sessions
		 * are closed on the executors. Calling ereport() will leave the executors
		 * hanging in COPY state.
		 *
		 * For errors detected by the dispatcher, we save the error message in
		 * cdbcopy_err StringInfo, move on to closing all COPY sessions on the
		 * executors and only then raise an error. We need to make sure to TRY/CATCH
		 * all other errors that may be raised from elsewhere in the backend. All
		 * error during COPY on the executors will be detected only when we end the
		 * COPY session there, so we are fine there.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"COPY command sent to segdbs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>cdbCopyStart</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><name>glob_copystmt</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Skip header processing if dummy file get from master for COPY FROM ON
		 * SEGMENT
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SendCopyFromForwardedHeader</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>cdbCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CopyInitDataParser</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_tableam</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_dml_init</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>myslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>skip_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>target_seg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* result segment of cdbhash */</comment>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset the per-tuple exprcontext. We do this after every tuple, to
		 * clean-up after expression evaluations etc.
		 */</comment>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* select slot to (initially) load row into */</comment>
		<if_stmt><if>if <condition>(<expr><name>insertMethod</name> <operator>==</operator> <name>CIM_SINGLE</name> <operator>||</operator> <name>proute</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>myslot</name> <operator>=</operator> <name>singleslot</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>myslot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultRelInfo</name> <operator>==</operator> <name>target_resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>insertMethod</name> <operator>==</operator> <name>CIM_MULTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>myslot</name> <operator>=</operator> <call><name>CopyMultiInsertInfoNextFreeSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>,
													 <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Switch to per-tuple context before calling NextCopyFrom, which does
		 * evaluate default expressions etc. and requires per-tuple context.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_EXECUTOR</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NextCopyFromExecute</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * NextCopyFromExecute set up estate-&gt;es_result_relation_info,
			 * and stored the tuple in the correct slot.
			 */</comment>
			<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Directly store the values/nulls array in the slot */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_DISPATCH</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NextCopyFromDispatch</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NextCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Constraints and where clause might reference the tableoid column,
		 * so (re-)initialize tts_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>target_resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Triggers and stuff need to be invoked in query context. */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>myslot</name></expr>;</expr_stmt>
			<comment type="block">/* Skip items that don't match COPY's WHERE clause */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>qualexpr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>!=</operator> <name>COPY_DISPATCH</name> <operator>&amp;&amp;</operator> <name>is_check_distkey</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In COPY FROM ON SEGMENT, check the distribution key in the
			 * QE.
			 * Note: For partitioned tables, the order of the root table's columns can be
			 * inconsistent with the order of the partition's columns and Greenplum/PostgreSQL
			 * allows such behavior. When they have different orders, we need to re-order the
			 * TupleTableSlot (myslot) to make it match the partition's columns (see execute_attr_map_slot()
			 * for details). We must perform this check before the re-ordering of TupleTableslot,
			 * or the value of target_seg will be incorrect.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>distData</name><operator>-&gt;</operator><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>target_seg</name> <operator>=</operator> <call><name>GetTargetSeg</name><argument_list>(<argument><expr><name>distData</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name> <operator>!=</operator> <name>target_seg</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTEGRITY_CONSTRAINT_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value of distribution key doesn't belong to segment with ID %d, it belongs to segment with ID %d"</literal></expr></argument>,
										<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>, <argument><expr><name>target_seg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<expr_stmt><expr><call><name>HandleCopyError</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Determine the partition to insert the tuple into */</comment>
		<if_stmt><if>if <condition>(<expr><name>proute</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>!=</operator> <name>COPY_DISPATCH</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>got_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Attempt to find a partition suitable for this tuple.
			 * ExecFindPartition() will raise an error if none can be found or
			 * if the found partition is not suitable for INSERTs.
			 */</comment>
			<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>ExecFindPartition</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>target_resultRelInfo</name></expr></argument>,
												  <argument><expr><name>proute</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<comment type="block">/* after all the prep work let cdbsreh do the real work */</comment>
				<expr_stmt><expr><call><name>HandleCopyError</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>got_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>got_error</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>prevResultRelInfo</name> <operator>!=</operator> <name>resultRelInfo</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Determine which triggers exist on this partition */</comment>
				<expr_stmt><expr><name>has_before_insert_row_trig</name> <operator>=</operator> <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
											  <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name>has_instead_insert_row_trig</name> <operator>=</operator> <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
											   <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * Disable multi-inserts when the partition has BEFORE/INSTEAD
				 * OF triggers, or if the partition is a foreign partition.
				 */</comment>
				<expr_stmt><expr><name>leafpart_use_multi_insert</name> <operator>=</operator> <name>insertMethod</name> <operator>==</operator> <name>CIM_MULTI_CONDITIONAL</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>has_before_insert_row_trig</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>has_instead_insert_row_trig</name> <operator>&amp;&amp;</operator>
					<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* Set the multi-insert buffer to use for this partition. */</comment>
				<if_stmt><if>if <condition>(<expr><name>leafpart_use_multi_insert</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_CopyMultiInsertBuffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CopyMultiInsertInfoSetupBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>,
													   <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>insertMethod</name> <operator>==</operator> <name>CIM_MULTI_CONDITIONAL</name> <operator>&amp;&amp;</operator>
						 <operator>!</operator><call><name>CopyMultiInsertInfoIsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Flush pending inserts if this partition can't use
					 * batching, so rows are visible to triggers etc.
					 */</comment>
					<expr_stmt><expr><call><name>CopyMultiInsertInfoFlush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>bistate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ReleaseBulkInsertStatePin</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>prevResultRelInfo</name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * For ExecInsertIndexTuples() to work on the partition's indexes
			 */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we're capturing transition tuples, we might need to convert
			 * from the partition rowtype to root rowtype.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>has_before_insert_row_trig</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If there are any BEFORE triggers on the partition,
					 * we'll have to be ready to convert their result back to
					 * tuplestore format.
					 */</comment>
					<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
						<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionInfo</name><operator>-&gt;</operator><name>pi_PartitionToRootMap</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Otherwise, just remember the original unconverted
					 * tuple, to avoid a needless round trip conversion.
					 */</comment>
					<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>myslot</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We might need to convert from the root rowtype to the partition
			 * rowtype.
			 */</comment>
			<expr_stmt><expr><name>map</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionInfo</name><operator>-&gt;</operator><name>pi_RootToPartitionMap</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>insertMethod</name> <operator>==</operator> <name>CIM_SINGLE</name> <operator>||</operator> <operator>!</operator><name>leafpart_use_multi_insert</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* non batch insert */</comment>
				<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>new_slot</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>new_slot</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionInfo</name><operator>-&gt;</operator><name>pi_PartitionTupleSlot</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>myslot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>new_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Prepare to queue up tuple for later batch insert into
				 * current partition.
				 */</comment>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>batchslot</name></decl>;</decl_stmt>

				<comment type="block">/* no other path available for partitioned table */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>insertMethod</name> <operator>==</operator> <name>CIM_MULTI_CONDITIONAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>batchslot</name> <operator>=</operator> <call><name>CopyMultiInsertInfoNextFreeSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>,
															<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>myslot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>,
												   <argument><expr><name>batchslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * This looks more expensive than it is (Believe me, I
					 * optimized it away. Twice.). The input is in virtual
					 * form, and we'll materialize the slot below - for most
					 * slot types the copy performs the work materialization
					 * would later require anyway.
					 */</comment>
					<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name>batchslot</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>myslot</name> <operator>=</operator> <name>batchslot</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* ensure that triggers etc see the right relation  */</comment>
			<expr_stmt><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>skip_tuple</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute which segment this row belongs to.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_DISPATCH</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* In QD, compute the target segment to send this row to. */</comment>
			<expr_stmt><expr><name>target_seg</name> <operator>=</operator> <call><name>GetTargetSeg</name><argument_list>(<argument><expr><name>distData</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>send_to_all</name> <init>= <expr><name>distData</name> <operator>&amp;&amp;</operator>
							   <call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>distData</name><operator>-&gt;</operator><name>policy</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* in the QD, forward the row to the correct segment(s). */</comment>
			<expr_stmt><expr><call><name>SendCopyFromForwardedTuple</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><name>send_to_all</name></expr></argument>,
									   <argument><expr><ternary><condition><expr><name>send_to_all</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>target_seg</name></expr></else></ternary></expr></argument>,
									   <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
									   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>,
									   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>,
									   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>,
									   <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
									   <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>skip_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* BEFORE ROW INSERT Triggers */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_before_insert_row_trig</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the tuple was dispatched to segments, do not execute trigger
			 * on master.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_tuple</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecBRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>skip_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* "do nothing" */</comment>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_tuple</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there is an INSTEAD OF INSERT ROW trigger, let it handle the
			 * tuple.  Otherwise, proceed with inserting the tuple into the
			 * table or foreign table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>has_instead_insert_row_trig</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecIRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Compute stored generated columns */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
					<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecComputeStoredGenerated</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If the target is a plain table, check the constraints of
				 * the tuple.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Also check the tuple against the partition constraint, if
				 * there is one; except that if we got here via tuple-routing,
				 * we don't need to if there's no BR trigger defined on the
				 * partition.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>proute</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>has_before_insert_row_trig</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Store the slot in the multi-insert buffer, when enabled. */</comment>
				<if_stmt><if>if <condition>(<expr><name>insertMethod</name> <operator>==</operator> <name>CIM_MULTI</name> <operator>||</operator> <name>leafpart_use_multi_insert</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The slot previously might point into the per-tuple
					 * context. For batching it needs to be longer lived.
					 */</comment>
					<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Add this tuple to the tuple buffer */</comment>
					<expr_stmt><expr><call><name>CopyMultiInsertInfoStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>,
											 <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>,
											 <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>,
											 <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If enough inserts have queued up, then flush all
					 * buffers out to their tables.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>CopyMultiInsertInfoIsFull</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CopyMultiInsertInfoFlush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>recheckIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* OK, store the tuple */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>myslot</name> <operator>=</operator> <call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignInsert</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
																				 <argument><expr><name>resultRelInfo</name></expr></argument>,
																				 <argument><expr><name>myslot</name></expr></argument>,
																				 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>myslot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* "do nothing" */</comment>
							<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* next tuple please */</comment>

						<comment type="block">/*
						 * AFTER ROW Triggers might reference the tableoid
						 * column, so (re-)initialize tts_tableOid before
						 * evaluating them.
						 */</comment>
						<expr_stmt><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* OK, store the tuple and create index entries for it */</comment>
						<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
										   <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>ti_options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>,
																   <argument><expr><name>estate</name></expr></argument>,
																   <argument><expr><name>false</name></expr></argument>,
																   <argument><expr><name>NULL</name></expr></argument>,
																   <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/* AFTER ROW INSERT Triggers */</comment>
					<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>,
										 <argument><expr><name>recheckIndexes</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * We count only tuples not suppressed by a BEFORE INSERT trigger
			 * or FDW; this is the same definition used by nodeModifyTable.c
			 * for counting tuples inserted by an INSERT command.
			 *
			 * MPP: incrementing this counter here only matters for utility
			 * mode. in dispatch mode only the dispatcher COPY collects row
			 * count, so this counter is meaningless.
			 */</comment>
			<expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>processed</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * After processed data from QD, which is empty and just for workflow, now
	 * to process the data on segment, only one shot if cstate-&gt;on_segment &amp;&amp;
	 * Gp_role == GP_ROLE_DISPATCH
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopyInitDataParser</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Segment %u, Copied %lu rows."</literal></expr></argument>, <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Flush any remaining buffered tuples */</comment>
	<if_stmt><if>if <condition>(<expr><name>insertMethod</name> <operator>!=</operator> <name>CIM_SINGLE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyMultiInsertInfoIsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CopyMultiInsertInfoFlush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Tear down the multi-insert buffer data */</comment>
		<expr_stmt><expr><call><name>CopyMultiInsertInfoCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Done, clean up */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>bistate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Done reading input data and sending it off to the segment
	 * databases Now we would like to end the copy command on
	 * all segment databases across the cluster.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>total_completed_from_qes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>total_rejected_from_qes</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cdbCopyEnd</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>total_completed_from_qes</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>total_rejected_from_qes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset returned processed to total_completed_from_qes.
		 *
		 * processed above excludes only rejected rows on QD, it
		 * should also exclude rejected rows on QEs.
		 *
		 * NOTE:
		 *  total_completed_from_qes + total_rejected_from_qes &lt;= # of
		 *  input file rows
		 *
		 * total_rejected_from_qes includes only rows rejected by
		 * SREH; however, total_completed_from_qes excludes both
		 * SREH-rejected rows and TRIGGER-rejected rows.
		 */</comment>
		<expr_stmt><expr><name>processed</name> <operator>=</operator> <name>total_completed_from_qes</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* emit a NOTICE with number of rejected rows */</comment>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>total_rejected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>total_rejected_from_qd</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>rejectcount</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If error log has been requested, then we send the row to the segment
			 * so that it can be written in the error log file. The segment process
			 * counts it again as a rejected row. So we ignore the reject count
			 * from the master and only consider the reject count from segments.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IS_LOG_TO_FILE</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>logerrors</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>total_rejected_from_qd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>total_rejected</name> <operator>=</operator> <name>total_rejected_from_qd</name> <operator>+</operator> <name>total_rejected_from_qes</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReportSrehResults</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr></argument>, <argument><expr><name>total_rejected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In the old protocol, tell pqcomm that we can process normal protocol
	 * messages again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>==</operator> <name>COPY_OLD_FE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_endmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Execute AFTER STATEMENT insertion triggers */</comment>
	<expr_stmt><expr><call><name>ExecASInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target_resultRelInfo</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle queued AFTER triggers */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In QE, send the number of rejected rows to the client (QD COPY) if
	 * SREH is on, always send the number of completed rows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendNumRows</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>errMode</name></name> <operator>!=</operator> <name>ALL_OR_NOTHING</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>rejectcount</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allow the FDW to shut down */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>target_resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>target_resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignInsert</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>target_resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignInsert</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
															  <argument><expr><name>target_resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>target_resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close all the partitioned tables, leaf partitions, and their indices */</comment>
	<if_stmt><if>if <condition>(<expr><name>proute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecCleanupTupleRouting</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Close any trigger target relations */</comment>
	<expr_stmt><expr><call><name>ExecCleanUpTriggerState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeDistributionData</name><argument_list>(<argument><expr><name>distData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_finish_bulk_insert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>ti_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Setup to read tuples from a file for COPY FROM.
 *
 * 'rel': Used as a template for the tuples
 * 'filename': Name of server-local file to read
 * 'attnamelist': List of char *, columns to include. NIL selects all cols.
 * 'options': List of DefElem. See copy_opt_item in gram.y for selections.
 *
 * Returns a CopyState, to be passed to NextCopyFrom and related functions.
 */</comment>
<function><type><name>CopyState</name></type>
<name>BeginCopyFrom</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
			  <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>is_program</name></decl></parameter>,
			  <parameter><decl><type><name>copy_data_source_cb</name></type> <name>data_source_cb</name></decl></parameter>,
			  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data_source_cb_extra</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>num_phys_attrs</name></decl>,
				<decl><type ref="prev"/><name>num_defaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>in_functions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>typioparams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>in_func_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>defmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier><modifier>*</modifier></type><name>defexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>volatile_defexprs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>attnamelist</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the mode
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name> <operator>||</operator> <name>data_source_cb</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>=</operator> <name>COPY_DIRECT</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
			 <name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>&amp;&amp;</operator>
			 <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>=</operator> <name>COPY_DISPATCH</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>=</operator> <name>COPY_EXECUTOR</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>=</operator> <name>COPY_DIRECT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Initialize state variables */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>reached_eof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="line">// cstate-&gt;eol_type = EOL_UNKNOWN; /* GPDB: don't overwrite value set in ProcessCopyOptions */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Set up variables to avoid per-attribute overhead. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>RAW_BUF_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Assign range table, we'll need it in CopyFrom. */</comment>
	<if_stmt><if>if <condition>(<expr><name>pstate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>range_table</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_defaults</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>volatile_defexprs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pick up the required catalog information for each attribute in the
	 * relation, including the input function, the element type (to pass to
	 * the input function), and info about defaults and constraints. (Which
	 * input function we use depends on text/binary format choice.)
	 */</comment>
	<expr_stmt><expr><name>in_functions</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typioparams</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>defmap</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>defexprs</name> <operator>=</operator> <operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>num_phys_attrs</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* We don't need info for dropped attributes */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Fetch the input function and typioparam info */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeBinaryInputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typioparams</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typioparams</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>in_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* TODO: is force quote array necessary for default conversion */</comment>

		<comment type="block">/* Get default info if needed */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* attribute is NOT to be copied from input */</comment>
			<comment type="block">/* use default value if one exists */</comment>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>defexpr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
																<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>defexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Run the expression through planner */</comment>
				<expr_stmt><expr><name>defexpr</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Initialize executable expression in copycontext */</comment>
				<expr_stmt><expr><name><name>defexprs</name><index>[<expr><name>num_defaults</name></expr>]</index></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>defmap</name><index>[<expr><name>num_defaults</name></expr>]</index></name> <operator>=</operator> <name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>num_defaults</name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * If a default expression looks at the table being loaded,
				 * then it could give the wrong answer when using
				 * multi-insert. Since database access can be dynamic this is
				 * hard to test for exactly, so we use the much wider test of
				 * whether the default expression is volatile. We allow for
				 * the special case of when the default expression is the
				 * nextval() of a sequence which in this specific case is
				 * known to be safe for use with the multi-insert
				 * optimization. Hence we use this special case function
				 * checker rather than the standard check for
				 * contain_volatile_functions().
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>volatile_defexprs</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>volatile_defexprs</name> <operator>=</operator> <call><name>contain_volatile_functions_not_nextval</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>defexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We keep those variables in cstate. */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>in_functions</name></name> <operator>=</operator> <name>in_functions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>typioparams</name></name> <operator>=</operator> <name>typioparams</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>defmap</name></name> <operator>=</operator> <name>defmap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>defexprs</name></name> <operator>=</operator> <name>defexprs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>volatile_defexprs</name></name> <operator>=</operator> <name>volatile_defexprs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>num_defaults</name></name> <operator>=</operator> <name>num_defaults</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name> <operator>=</operator> <name>is_program</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>pipe</name> <init>= <expr><operator>(</operator><name>filename</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_EXECUTOR</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* open nothing */</comment>

		<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"STDIN is not supported by 'COPY ON SEGMENT'"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>data_source_cb</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_CALLBACK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_source_cb</name></name> <operator>=</operator> <name>data_source_cb</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_source_cb_extra</name></name> <operator>=</operator> <name>data_source_cb_extra</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>pipe</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_program</name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_EXECUTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* the grammar does not allow this */</comment>
		<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReceiveCopyBegin</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MangleCopyFileName</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>program_pipes</name></name> <operator>=</operator> <call><name>open_program_pipes</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>program_pipes</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not execute command \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* copy errno because ereport subfunctions might change it */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for reading: %m"</literal></expr></argument>,
								<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><operator>(</operator><name>save_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>save_errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator></expr> ?</condition><then>
						 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"COPY FROM instructs the PostgreSQL server process to read a file. "</literal>
								 <literal type="string">"You may want a client-side facility such as psql's \\copy."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="line">// Increase buffer size to improve performance  (cmcdevitt)</comment>
			<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IOFBF</name></expr></argument>, <argument><expr><literal type="number">393216</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// 384 Kbytes</comment>

			<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a directory"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>==</operator> <name>COPY_EXECUTOR</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>!=</operator> <name>COPY_CALLBACK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Read special header from QD */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>sigsize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>QDtoQESignature</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>readSig</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>QDtoQESignature</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>copy_from_dispatch_header</name></type> <name>header_frame</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>readSig</name></expr></argument>, <argument><expr><name>sigsize</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>sigsize</name> <operator>||</operator>
			<call><name>memcmp</name><argument_list>(<argument><expr><name>readSig</name></expr></argument>, <argument><expr><name>QDtoQESignature</name></expr></argument>, <argument><expr><name>sigsize</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"QD-&gt;QE COPY communication signature not recognized"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_frame</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header_frame</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>header_frame</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid QD-&gt;QD COPY communication header"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>first_qe_processed_field</name></name> <operator>=</operator> <name><name>header_frame</name><operator>.</operator><name>first_qe_processed_field</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Read and verify binary header */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>readSig</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>tmp</name></decl>;</decl_stmt>

		<comment type="block">/* Signature */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>readSig</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">11</literal> <operator>||</operator>
			<call><name>memcmp</name><argument_list>(<argument><expr><name>readSig</name></expr></argument>, <argument><expr><name>BinarySignature</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY file signature not recognized"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Flags field */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyGetInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid COPY file header (missing flags)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid COPY file header (WITH OIDS)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized critical flags in COPY file header"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Header extension length */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyGetInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>tmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid COPY file header (missing length)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Skip extension header, if present */</comment>
		<while>while <condition>(<expr><name>tmp</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>readSig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid COPY file header (wrong length)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* create workspace for CopyReadAttributes results */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attr_count</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>=</operator> <name>attr_count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>attr_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read raw fields in the next line for COPY FROM in text or csv mode.
 * Return false if no more lines.
 *
 * An internal temporary buffer is returned via 'fields'. It is valid until
 * the next call of the function. Since the function returns all raw fields
 * in the input file, 'nfields' could be different from the number of columns
 * in the relation.
 *
 * NOTE: force_not_null option are not applied to the returned fields.
 */</comment>
<function><type><name>bool</name></type>
<name>NextCopyFromRawFields</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>NextCopyFromRawFieldsX</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NextCopyFromRawFieldsX</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nfields</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>stop_processing_at_field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fldct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>

	<comment type="block">/* only available for text or csv input */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* on input just throw the header line away */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>CopyReadLine</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* done */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Actually read the line into memory here */</comment>
	<expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>CopyReadLine</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * EOF at start of line means we're done.  If we see EOF after some
	 * characters, we act as though it was newline followed by EOF, ie,
	 * process the line and then exit loop on next iteration.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>done</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Parse the line into de-escaped field values */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fldct</name> <operator>=</operator> <call><name>CopyReadAttributesCSV</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>stop_processing_at_field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fldct</name> <operator>=</operator> <call><name>CopyReadAttributesText</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>stop_processing_at_field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>fields</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nfields</name> <operator>=</operator> <name>fldct</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>NextCopyFrom</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>NextCopyFromX</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>got_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>NextCopyFromX</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><call><name>HandleCopyError</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cdbsreh-&gt;processed is updated inside here */</comment>
				<expr_stmt><expr><name>got_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>processed</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>got_error</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A data error happened. This code block will always be inside a PG_CATCH()
 * block right when a higher stack level produced an error. We handle the error
 * by checking which error mode is set (SREH or all-or-nothing) and do the right
 * thing accordingly. Note that we MUST have this code in a macro (as opposed
 * to a function) as elog_dismiss() has to be inlined with PG_CATCH in order to
 * access local error state variables.
 *
 * changing me? take a look at FILEAM_HANDLE_ERROR in fileam.c as well.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleCopyError</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>errMode</name></name> <operator>==</operator> <name>ALL_OR_NOTHING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* re-throw error and abort */</comment>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* SREH must only handle data errors. all other errors must not be caught */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ERRCODE_TO_CATEGORY</name><argument_list>(<argument><expr><call><name>elog_geterrcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ERRCODE_DATA_EXCEPTION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* re-throw error and abort */</comment>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* SREH - release error state and handle error */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ErrorData</name>	<modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbSreh</name>	   <modifier>*</modifier></type><name>cdbsreh</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>processed</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>badrowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* save a copy of the error info */</comment>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * set the error message. Use original msg and add column name if available.
		 * We do this even if we're not logging the errors, because
		 * ErrorIfRejectLimit() below will use this information in the error message,
		 * if the error count is reached.
		 */</comment>
		<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>rawdata</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>rawdata</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>rawdata</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>is_server_enc</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator>  <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s, column %s"</literal></expr></argument>,
								 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>=</operator> <name>errormsg</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_LOG_TO_FILE</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>logerrors</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>on_segment</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>rejectcount</name></name><operator>++</operator></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SendCopyFromForwardedError</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbCopy</name></name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* after all the prep work let cdbsreh do the real work */</comment>
				<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>rejectcount</name></name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>HandleSingleRowError</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>rejectcount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ErrorIfRejectLimitReached</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>badrowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Read next tuple from file for COPY FROM. Return false if no more tuples.
 *
 * 'econtext' is used to evaluate default expression for each columns not
 * read from the file. It can be NULL when no default values are used, i.e.
 * when all columns are read from the file.
 *
 * 'values' and 'nulls' arrays must be the same length as columns of the
 * relation passed to BeginCopyFrom. This function fills the arrays.
 */</comment>
<function><type><name>bool</name></type>
<name>NextCopyFromX</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
			 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>num_phys_attrs</name></decl>,
				<decl><type ref="prev"/><name>attr_count</name></decl>,
				<decl><type ref="prev"/><name>num_defaults</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>num_defaults</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>in_functions</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>in_functions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>typioparams</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>typioparams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>defmap</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>defmap</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier><modifier>*</modifier></type><name>defexprs</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>defexprs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnumlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>stop_processing_at_field</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Figure out what fields we're going to process in this process.
	 *
	 * In the QD, set 'stop_processing_at_field' so that we only those
	 * fields that are needed in the QD.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>COPY_DIRECT</name></expr>:</case>
			<expr_stmt><expr><name>stop_processing_at_field</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>attnumlist</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>COPY_DISPATCH</name></expr>:</case>
			<expr_stmt><expr><name>stop_processing_at_field</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>first_qe_processed_field</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attnumlist</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>qd_attnumlist</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>COPY_EXECUTOR</name></expr>:</case>
			<expr_stmt><expr><name>stop_processing_at_field</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>attnumlist</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>qe_attnumlist</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected COPY dispatch mode %d"</literal></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attnumlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize all values for row to NULL */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>field_strings</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>fldct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>fieldno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>

		<comment type="block">/* read raw fields in the next line */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>!=</operator> <name>COPY_EXECUTOR</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NextCopyFromRawFieldsX</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>field_strings</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fldct</name></expr></argument>,
										<argument><expr><name>stop_processing_at_field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We have received the raw line from the QD, and we just
			 * need to split it into raw fields.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>stopped_processing_at_delim</name></name> <operator>&amp;&amp;</operator>
				<name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>cursor</name></name> <operator>&lt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>fldct</name> <operator>=</operator> <call><name>CopyReadAttributesCSV</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>fldct</name> <operator>=</operator> <call><name>CopyReadAttributesText</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>fldct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>field_strings</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* check for overflowing fields */</comment>
		<if_stmt><if>if <condition>(<expr><name>attr_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fldct</name> <operator>&gt;</operator> <name>attr_count</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extra data after last expected column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * A completely empty line is not allowed with FILL MISSING FIELDS. Without
		 * FILL MISSING FIELDS, it's almost surely an error, but not always:
		 * a table with a single text column, for example, needs to accept empty
		 * lines.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>cstate</name><operator>-&gt;</operator><name>fill_missing</name></name> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing data for column \"%s\", found empty data line"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Loop to read the user attributes on the line. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnumlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>m</name> <init>= <expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;=</operator> <name>fldct</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Some attributes are missing. In FILL MISSING FIELDS mode,
				 * treat them as NULLs.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>fill_missing</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing data for column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>fieldno</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>string</name> <operator>=</operator> <name><name>field_strings</name><index>[<expr><name>fieldno</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select_flags</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>convert_select_flags</name><index>[<expr><name>m</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ignore input field, leaving column as NULL */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>string</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<name><name>cstate</name><operator>-&gt;</operator><name>force_notnull_flags</name><index>[<expr><name>m</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * FORCE_NOT_NULL option is set and column is NULL -
					 * convert it to the NULL string.
					 */</comment>
					<expr_stmt><expr><name>string</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>string</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_null_flags</name><index>[<expr><name>m</name></expr>]</index></name>
						 <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * FORCE_NULL option is set and column matches the NULL
					 * string. It must have been quoted, or otherwise the
					 * string would already have been set to NULL. Convert it
					 * to NULL as specified.
					 */</comment>
					<expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>in_functions</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name>string</name></expr></argument>,
										  <argument><expr><name><name>typioparams</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>string</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fieldno</name> <operator>==</operator> <name>attr_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>attr_count</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* binary */</comment>
		<decl_stmt><decl><type><name>int16</name></type>		<name>fld_count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyGetInt16</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fld_count</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* EOF detected (end of file, or protocol-level EOF) */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fld_count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Received EOF marker.  In a V3-protocol copy, wait for the
			 * protocol-level EOF, and complain if it doesn't come
			 * immediately.  This ensures that we correctly handle CopyFail,
			 * if client chooses to send that now.
			 *
			 * Note that we MUST NOT try to read more data in an old-protocol
			 * copy, since there is no protocol-level EOF marker then.  We
			 * could go either way for copy from file, but choose to throw
			 * error if there's data after the EOF marker, for consistency
			 * with the new-protocol case.
			 */</comment>
			<decl_stmt><decl><type><name>char</name></type>		<name>dummy</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>!=</operator> <name>COPY_OLD_FE</name> <operator>&amp;&amp;</operator>
				<call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received copy data after EOF marker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fld_count</name> <operator>!=</operator> <name>attr_count</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row field count is %d, expected %d"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>fld_count</name></expr></argument>, <argument><expr><name>attr_count</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnumlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>m</name> <init>= <expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <call><name>CopyReadBinaryAttribute</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
												<argument><expr><name>i</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>in_functions</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>,
												<argument><expr><name><name>typioparams</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>,
												<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now compute and insert any defaults available for the columns not
	 * provided by the input data.  Anything not processed here or above will
	 * remain NULL.
	 *
	 * GPDB: The defaults are always computed in the QD, and are included
	 * in the QD-&gt;QE stream as pre-computed Datums. Funny indentation, to
	 * keep the indentation of the code inside the same as in upstream.
	 * (We could improve this, and compute immutable defaults that don't
	 * affect which segment the row belongs to, in the QE.)
	 */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>dispatch_mode</name></name> <operator>!=</operator> <name>COPY_EXECUTOR</name></expr>)</condition>
  <block>{<block_content>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_defaults</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * The caller must supply econtext and have switched into the
		 * per-tuple memory context in it.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>econtext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name><name>defmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>defexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name><name>defmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Like NextCopyFrom(), but used in the QD, when we want to parse the
 * input line only partially. We only want to parse enough fields needed
 * to determine which target segment to forward the row to.
 *
 * (The logic is actually within NextCopyFrom(). This is a separate
 * function just for symmetry with NextCopyFromExecute()).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NextCopyFromDispatch</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>NextCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like NextCopyFrom(), but used in the QE, when we're reading pre-processed
 * rows from the QD.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NextCopyFromExecute</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>num_phys_attrs</name></decl>,
				<decl><type ref="prev"/><name>attr_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>copy_from_dispatch_row</name></type> <name>frame</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>got_error</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The code below reads the 'copy_from_dispatch_row' struct, and only
	 * then checks if it was actually a 'copy_from_dispatch_error' struct.
	 * That only works when 'copy_from_dispatch_error' is larger than
	 *'copy_from_dispatch_row'.
	 */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>SizeOfCopyFromDispatchError</name> <operator>&gt;=</operator> <name>SizeOfCopyFromDispatchRow</name></expr></argument>,
					 <argument><expr><literal type="string">"copy_from_dispatch_error must be larger than copy_from_dispatch_row"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we encounter an error while parsing the row (or we receive a row from
	 * the QD that was already marked as an erroneous row), we loop back here
	 * until we get a good row.
	 */</comment>
<label><name>retry</name>:</label>
	<expr_stmt><expr><name>got_error</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>frame</name></expr></argument>, <argument><expr><name>SizeOfCopyFromDispatchRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SizeOfCopyFromDispatchRow</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>frame</name><operator>.</operator><name>lineno</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleQDErrorFrame</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>frame</name></expr></argument>, <argument><expr><name>SizeOfCopyFromDispatchRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>retry</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Prepare for parsing the input line */</comment>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Initialize all values for row to NULL */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check for overflowing fields */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>frame</name><operator>.</operator><name>fld_count</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>frame</name><operator>.</operator><name>fld_count</name></name> <operator>&gt;</operator> <name>num_phys_attrs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extra data after last expected column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Read the input line into 'line_buf'.
	 */</comment>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><name><name>frame</name><operator>.</operator><name>line_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>frame</name><operator>.</operator><name>line_len</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>frame</name><operator>.</operator><name>line_len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>frame</name><operator>.</operator><name>line_len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>frame</name><operator>.</operator><name>line_len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <name><name>frame</name><operator>.</operator><name>residual_off</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name><name>frame</name><operator>.</operator><name>lineno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stopped_processing_at_delim</name></name> <operator>=</operator> <name><name>frame</name><operator>.</operator><name>delim_seen_at_end</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse any fields from the input line that were not processed in the
	 * QD already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NextCopyFromX</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>NextCopyFromX</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HandleCopyError</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>got_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Read any attributes that were processed in the QD already. The attribute
	 * numbers in the message are already in terms of the target partition, so
	 * we do this after remapping and switching to the partition slot.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>frame</name><operator>.</operator><name>fld_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int16</name></type>		<name>attnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>m</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attnum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attnum</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>attnum</name></expr></argument> &gt;</argument_list></name> <name>num_phys_attrs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum received from QD: %d (num physical attributes: %d)"</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>num_phys_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>m</name> <operator>=</operator> <name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>attbyval</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>attlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>attlen</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* For simplicity, varlen's are always transmitted in "long" format */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>VARHDRSZ</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid varlen length received from QD: %d"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name> <operator>-</operator> <name>VARHDRSZ</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Like the varlen case above, cstrings are sent with a length
				 * prefix and no terminator, so we have to NULL-terminate in
				 * memory after reading them in.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d has invalid length %d"</literal></expr></argument>,
					 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>attlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>got_error</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Here we should compute defaults for any columns for which we didn't
	 * get a default from the QD. But at the moment, all defaults are evaluated
	 * in the QD.
	 */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse and handle an "error frame" from QD.
 *
 * The caller has already read part of the frame; 'p' points to that part,
 * of length 'len'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleQDErrorFrame</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbSreh</name> <modifier>*</modifier></type><name>cdbsreh</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>copy_from_dispatch_error</name></type> <name>errframe</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name>SizeOfCopyFromDispatchError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>badrowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the part of the struct that the caller had already read, and
	 * read the rest.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errframe</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>errframe</name><operator>)</operator> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>SizeOfCopyFromDispatchError</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SizeOfCopyFromDispatchError</name> <operator>-</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>errframe</name><operator>.</operator><name>errmsg_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>errframe</name><operator>.</operator><name>line_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>, <argument><expr><name><name>errframe</name><operator>.</operator><name>errmsg_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name><name>errframe</name><operator>.</operator><name>errmsg_len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>errormsg</name><index>[<expr><name><name>errframe</name><operator>.</operator><name>errmsg_len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name><name>errframe</name><operator>.</operator><name>line_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name><name>errframe</name><operator>.</operator><name>line_len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>line</name><index>[<expr><name><name>errframe</name><operator>.</operator><name>line_len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>=</operator> <name><name>errframe</name><operator>.</operator><name>lineno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>rawdata</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>rawdata</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>rawdata</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>=</operator> <name>errormsg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cdbsreh</name><operator>-&gt;</operator><name>is_server_enc</name></name> <operator>=</operator> <name><name>errframe</name><operator>.</operator><name>line_buf_converted</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HandleSingleRowError</name><argument_list>(<argument><expr><name>cdbsreh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Inlined versions of appendBinaryStringInfo and enlargeStringInfo, for
 * speed.
 *
 * NOTE: These versions don't NULL-terminate the string. We don't need
 * it here.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_MSGBUF_NOCHECK</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>datalen</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		memcpy((buf)-&gt;data + (buf)-&gt;len, ptr, (datalen)); \
		(buf)-&gt;len += (datalen); \
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_MSGBUF</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>datalen</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if ((buf)-&gt;len + (datalen) &gt;= (buf)-&gt;maxlen) \
			enlargeStringInfo((buf), (datalen)); \
		memcpy((buf)-&gt;data + (buf)-&gt;len, ptr, (datalen)); \
		(buf)-&gt;len += (datalen); \
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENLARGE_MSGBUF</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>needed</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if ((buf)-&gt;len + (needed) &gt;= (buf)-&gt;maxlen) \
			enlargeStringInfo((buf), (needed)); \
	} while(0)</cpp:value></cpp:define>

<comment type="block">/*
 * This is the sending counterpart of NextCopyFromExecute. Used in the QD,
 * to send a row to a QE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyFromForwardedTuple</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>,
						   <parameter><decl><type><name>CdbCopy</name> <modifier>*</modifier></type><name>cdbCopy</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>toAll</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>target_seg</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>int64</name></type> <name>lineno</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>line_len</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>copy_from_dispatch_row</name> <modifier>*</modifier></type><name>frame</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>msgbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_sent_fields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>num_phys_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid target table OID in COPY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset the message buffer, and reserve enough space for the header,
	 * the OID if any, and the residual line.
	 */</comment>
	<expr_stmt><expr><name>msgbuf</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>dispatch_msgbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ENLARGE_MSGBUF</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>SizeOfCopyFromDispatchRow</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the header goes to the beginning of the struct, but it will be filled in later. */</comment>
	<expr_stmt><expr><name><name>msgbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>SizeOfCopyFromDispatchRow</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Next, any residual text that we didn't process in the QD.
	 */</comment>
	<expr_stmt><expr><call><name>APPEND_MSGBUF_NOCHECK</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Append attributes to the buffer.
	 */</comment>
	<expr_stmt><expr><name>num_sent_fields</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_phys_attrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int16</name></type>		<name>attnum</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* NULLs are simply left out of the message. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Make sure we have room for the attribute number. While we're at it,
		 * also reserve room for the Datum, if it's a by-value datatype, or for
		 * the length field, if it's a varlena. Allocating both in one call
		 * saves one size-check.
		 */</comment>
		<expr_stmt><expr><call><name>ENLARGE_MSGBUF</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* attribute number comes first */</comment>
		<expr_stmt><expr><call><name>APPEND_MSGBUF_NOCHECK</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attnum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attbyval</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we already reserved space for this above, so we can just memcpy */</comment>
			<expr_stmt><expr><call><name>APPEND_MSGBUF_NOCHECK</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>APPEND_MSGBUF</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32</name></type>		<name>len</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

				<comment type="block">/* For simplicity, varlen's are always transmitted in "long" format */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* we already reserved space for this int */</comment>
				<expr_stmt><expr><call><name>APPEND_MSGBUF_NOCHECK</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_MSGBUF</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * These attrs are NULL-terminated in memory, but we send
				 * them length-prefixed (like the varlen case above) so that
				 * the receiver can preallocate a data buffer.
				 */</comment>
				<decl_stmt><decl><type><name>int32</name></type>		<name>len</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>slen</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <name>PG_INT32_MAX</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d is too long (%lld bytes)"</literal></expr></argument>,
						 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator> <name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>slen</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>APPEND_MSGBUF_NOCHECK</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_MSGBUF</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d has invalid length %d"</literal></expr></argument>,
					 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>num_sent_fields</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Fill in the header. We reserved room for this at the beginning of the
	 * buffer.
	 */</comment>
	<expr_stmt><expr><name>frame</name> <operator>=</operator> <operator>(</operator><name>copy_from_dispatch_row</name> <operator>*</operator><operator>)</operator> <name><name>msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>line_len</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>residual_off</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>cursor</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>fld_count</name></name> <operator>=</operator> <name>num_sent_fields</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>delim_seen_at_end</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>stopped_processing_at_delim</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>toAll</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cdbCopySendDataToAll</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><name><name>msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cdbCopySendData</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><name>target_seg</name></expr></argument>, <argument><expr><name><name>msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyFromForwardedHeader</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>CdbCopy</name> <modifier>*</modifier></type><name>cdbCopy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>copy_from_dispatch_header</name></type> <name>header_frame</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cdbCopySendDataToAll</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><name>QDtoQESignature</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QDtoQESignature</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header_frame</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header_frame</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header_frame</name><operator>.</operator><name>first_qe_processed_field</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>first_qe_processed_field</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbCopySendDataToAll</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>header_frame</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header_frame</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyFromForwardedError</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>CdbCopy</name> <modifier>*</modifier></type><name>cdbCopy</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>copy_from_dispatch_error</name> <modifier>*</modifier></type><name>errframe</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>msgbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>target_seg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>errormsg_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>msgbuf</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>dispatch_msgbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>SizeOfCopyFromDispatchError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* allocate space for the header (we'll fill it in last). */</comment>
	<expr_stmt><expr><name><name>msgbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>SizeOfCopyFromDispatchError</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>, <argument><expr><name>errormsg_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errframe</name> <operator>=</operator> <operator>(</operator><name>copy_from_dispatch_error</name> <operator>*</operator><operator>)</operator> <name><name>msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>errframe</name><operator>-&gt;</operator><name>error_marker</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errframe</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errframe</name><operator>-&gt;</operator><name>line_len</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errframe</name><operator>-&gt;</operator><name>errmsg_len</name></name> <operator>=</operator> <name>errormsg_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errframe</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name></expr>;</expr_stmt>

	<comment type="block">/* send the bad data row to a random QE (via roundrobin) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>lastsegid</name></name> <operator>==</operator> <name><name>cdbCopy</name><operator>-&gt;</operator><name>total_segs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>lastsegid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* start over from first segid */</comment>

	<expr_stmt><expr><name>target_seg</name> <operator>=</operator> <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>lastsegid</name></name><operator>++</operator> <operator>%</operator> <name><name>cdbCopy</name><operator>-&gt;</operator><name>total_segs</name></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbCopySendData</name><argument_list>(<argument><expr><name>cdbCopy</name></expr></argument>, <argument><expr><name>target_seg</name></expr></argument>, <argument><expr><name><name>msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up storage and release resources for COPY FROM.
 */</comment>
<function><type><name>void</name></type>
<name>EndCopyFrom</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No COPY FROM related resources except memory. */</comment>

	<expr_stmt><expr><call><name>EndCopy</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the next input line and stash it in line_buf, with conversion to
 * server encoding.
 *
 * Result is true if read was terminated by EOF, false if terminated
 * by newline.  The terminating newline or EOF marker is not included
 * in the final value of line_buf.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyReadLine</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Mark that encoding conversion hasn't occurred yet */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Parse data and transfer into line_buf */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CopyReadLineText</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Reached EOF.  In protocol version 3, we should ignore anything
		 * after \. up to the protocol end of copy data.  (XXX maybe better
		 * not to treat \. as special?)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>==</operator> <name>COPY_NEW_FE</name></expr>)</condition>
		<block>{<block_content>
			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><call><name>CopyLoadRawBuf</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we didn't hit EOF, then we must have transferred the EOL marker
		 * to line_buf along with the data.  Get rid of it.
		 */</comment>
		<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>EOL_NL</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>EOL_CR</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>EOL_CRNL</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>EOL_UNKNOWN</name></expr>:</case>
				<comment type="block">/* shouldn't get here */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Done reading the line.  Convert it to server encoding. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cvt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cvt</name> <operator>=</operator> <call><name>pg_any_to_server</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>,
							   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>,
							   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cvt</name> <operator>!=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* transfer converted data back to line_buf */</comment>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><name>cvt</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cvt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cvt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now it's safe to use the buffer in error messages */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CopyReadLineText - inner loop of CopyReadLine for text mode
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyReadLineText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copy_raw_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>raw_buf_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>copy_buf_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hit_eof</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>mblen_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* CSV variables */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_char_in_line</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_quote</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>last_was_esc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>quotec</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>escapec</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>quotec</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>escapec</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>escape</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* ignore special escape processing if it's the same as quotec */</comment>
		<if_stmt><if>if <condition>(<expr><name>quotec</name> <operator>==</operator> <name>escapec</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>escapec</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>mblen_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * The objective of this loop is to transfer the entire next input line
	 * into line_buf.  Hence, we only care for detecting newlines (\r and/or
	 * \n) and the end-of-copy marker (\.).
	 *
	 * In CSV mode, \r and \n inside a quoted field are just part of the data
	 * value and are put in line_buf.  We keep just enough state to know if we
	 * are currently in a quoted field or not.
	 *
	 * These four characters, and the CSV escape and quote characters, are
	 * assumed the same in frontend and backend encodings.
	 *
	 * For speed, we try to move data from raw_buf to line_buf in chunks
	 * rather than one character at a time.  raw_buf_ptr points to the next
	 * character to examine; any characters from raw_buf_index to raw_buf_ptr
	 * have been determined to be part of the line, but not yet transferred to
	 * line_buf.
	 *
	 * For a little extra speed within the loop, we copy raw_buf and
	 * raw_buf_len into local variables.
	 */</comment>
	<expr_stmt><expr><name>copy_raw_buf</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>raw_buf_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>copy_buf_len</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>prev_raw_ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Load more data if needed.  Ideally we would just force four bytes
		 * of read-ahead and avoid the many calls to
		 * IF_NEED_REFILL_AND_NOT_EOF_CONTINUE(), but the COPY_OLD_FE protocol
		 * does not allow us to read too far ahead or we might read into the
		 * next data, so we read-ahead only as far we know we can.  One
		 * optimization would be to read-ahead four byte here if
		 * cstate-&gt;copy_dest != COPY_OLD_FE, but it hardly seems worth it,
		 * considering the size of the buffer.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>raw_buf_ptr</name> <operator>&gt;=</operator> <name>copy_buf_len</name> <operator>||</operator> <name>need_data</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>REFILL_LINEBUF</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Try to read some more data.  This will certainly reset
			 * raw_buf_index to zero, and raw_buf_ptr must go with it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyLoadRawBuf</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hit_eof</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>raw_buf_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>copy_buf_len</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we are completely out of data, break out of the loop,
			 * reporting EOF.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>copy_buf_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>need_data</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK to fetch a character */</comment>
		<expr_stmt><expr><name>prev_raw_ptr</name> <operator>=</operator> <name>raw_buf_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If character is '\\' or '\r', we may need to look ahead below.
			 * Force fetch of the next character if we don't already have it.
			 * We need to do this before changing CSV state, in case one of
			 * these characters is also the quote or escape character.
			 *
			 * Note: old-protocol does not like forced prefetch, but it's OK
			 * here since we cannot validly be at EOF.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Dealing with quotes and escapes here is mildly tricky. If the
			 * quote char is also the escape char, there's no problem - we
			 * just use the char as a toggle. If they are different, we need
			 * to ensure that we only take account of an escape inside a
			 * quoted field and immediately preceding a quote char, and not
			 * the second in an escape-escape sequence.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>in_quote</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>escapec</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>last_was_esc</name> <operator>=</operator> <operator>!</operator><name>last_was_esc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>quotec</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>last_was_esc</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <operator>!</operator><name>in_quote</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>escapec</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>last_was_esc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Updating the line count for embedded CR and/or LF chars is
			 * necessarily a little fragile - this test is probably about the
			 * best we can do.  (XXX it's arguable whether we should do this
			 * at all --- is cur_lineno a physical or logical count?)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>in_quote</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_NL</name></expr> ?</condition><then> <expr><literal type="char">'\n'</literal></expr> </then><else>: <expr><literal type="char">'\r'</literal></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Process \r */</comment>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>||</operator> <operator>!</operator><name>in_quote</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check for \r\n on first line, _and_ handle \r\n. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_UNKNOWN</name> <operator>||</operator>
				<name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CRNL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If need more data, go back to loop top to load it.
				 *
				 * Note that if we are at EOF, c will wind up as '\0' because
				 * of the guaranteed pad of raw_buf.
				 */</comment>
				<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* get next char */</comment>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name></expr>]</index></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* eat newline */</comment>
					<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_CRNL</name></expr>;</expr_stmt>	<comment type="block">/* in case not set yet */</comment>

					<comment type="block">/*
					 * GPDB: end of line. Since we don't error out if we find a
					 * bare CR or LF in CRLF mode, break here instead.
					 */</comment>
					<break>break;</break>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * GPDB_91_MERGE_FIXME: these commented-out blocks (as well
					 * as the restructured newline checks) are here because we
					 * allow the user to manually set the newline mode, and
					 * therefore don't error out on bare CR/LF in the middle of
					 * a column. Instead, they will be included verbatim.
					 *
					 * This probably has other fallout -- but so does changing
					 * the behavior. Discuss.
					 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
					<comment type="block">/* found \r, but no \n */</comment>
					if (cstate-&gt;eol_type == EOL_CRNL)
						ereport(ERROR,
								(errcode(ERRCODE_BAD_COPY_FILE_FORMAT),
								 !cstate-&gt;csv_mode ?
								 errmsg("literal carriage return found in data") :
								 errmsg("unquoted carriage return found in data"),
								 !cstate-&gt;csv_mode ?
								 errhint("Use \"\\r\" to represent carriage return.") :
								 errhint("Use quoted CSV field to represent carriage return.")));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

					<comment type="block">/* GPDB: only reset eol_type if it's currently unknown. */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_UNKNOWN</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * if we got here, it is the first line and we didn't find
						 * \n, so don't consume the peeked character
						 */</comment>
						<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_CR</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* GPDB_91_MERGE_FIXME: see above. */</comment>
			else if (cstate-&gt;eol_type == EOL_NL)
				ereport(ERROR,
						(errcode(ERRCODE_BAD_COPY_FILE_FORMAT),
						 !cstate-&gt;csv_mode ?
						 errmsg("literal carriage return found in data") :
						 errmsg("unquoted carriage return found in data"),
						 !cstate-&gt;csv_mode ?
						 errhint("Use \"\\r\" to represent carriage return.") :
						 errhint("Use quoted CSV field to represent carriage return.")));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* GPDB: a CR only ends the line in CR mode. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CR</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If reach here, we have found the line terminator */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Process \n */</comment>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>||</operator> <operator>!</operator><name>in_quote</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* GPDB_91_MERGE_FIXME: see above. */</comment>
			if (cstate-&gt;eol_type == EOL_CR || cstate-&gt;eol_type == EOL_CRNL)
				ereport(ERROR,
						(errcode(ERRCODE_BAD_COPY_FILE_FORMAT),
						 !cstate-&gt;csv_mode ?
						 errmsg("literal newline found in data") :
						 errmsg("unquoted newline found in data"),
						 !cstate-&gt;csv_mode ?
						 errhint("Use \"\\n\" to represent newline.") :
						 errhint("Use quoted CSV field to represent newline.")));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* GPDB: only reset eol_type if it's currently unknown. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_NL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* in case not set yet */</comment>

			<comment type="block">/* GPDB: a LF only ends the line in LF mode. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_NL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If reach here, we have found the line terminator */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In CSV mode, we only recognize \. alone on a line.  This is because
		 * \. is a valid CSV data value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>||</operator> <name>first_char_in_line</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>c2</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_EOF_BREAK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* -----
			 * get next character
			 * Note: we do not change c so if it isn't \., we can fall
			 * through and continue processing for file encoding.
			 * -----
			 */</comment>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/*
			* We need to recognize the EOL.
			* Github issue: https://github.com/greenplum-db/gpdb/issues/12454
			*/</comment>
			<if_stmt><if>if<condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_UNKNOWN</name></expr>)</condition>
				<block>{<block_content>
				<comment type="block">/* We still do not found the first EOL.
				* The current '\n' will be recongnized as EOL
				* in next loop of c1.
				*/</comment>
					<goto>goto <name>not_end_of_copy</name>;</goto>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_NL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// found a new line with '\n'</comment>
					<expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_UNKNOWN</name></expr>)</condition>
				<block>{<block_content>
					<goto>goto <name>not_end_of_copy</name>;</goto>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CR</name></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// found a new line wirh '\r'</comment>
					<expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CRNL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					* Because the eol is '\r\n', we need another character c3
					* which comes after c2 if exists.
					*/</comment>
					<decl_stmt><decl><type><name>char</name></type> <name>c3</name></decl>;</decl_stmt>
					<expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_EOF_BREAK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>c3</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name></expr>]</index></name></expr>;</expr_stmt>
					<if_stmt><if>if<condition>(<expr><name>c3</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="line">// found a new line with '\r\n'</comment>
						<expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if> <else>else <block>{<block_content>
						<expr_stmt><expr><name>NO_END_OF_COPY_GOTO</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* consume the '.' */</comment>

				<comment type="block">/*
				 * Note: if we loop back for more data here, it does not
				 * matter that the CSV state change checks are re-executed; we
				 * will come back here with no important state changed.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CRNL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Get the next character */</comment>
					<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* if hit_eof, c2 will become '\0' */</comment>
					<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name>raw_buf_ptr</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-copy marker does not match previous newline style"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>NO_END_OF_COPY_GOTO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>c2</name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name>raw_buf_ptr</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-copy marker corrupt"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>NO_END_OF_COPY_GOTO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Get the next character */</comment>
				<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* if hit_eof, c2 will become '\0' */</comment>
				<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name>c2</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name>raw_buf_ptr</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-copy marker corrupt"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>NO_END_OF_COPY_GOTO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_NL</name> <operator>&amp;&amp;</operator> <name>c2</name> <operator>!=</operator> <literal type="char">'\n'</literal><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CRNL</name> <operator>&amp;&amp;</operator> <name>c2</name> <operator>!=</operator> <literal type="char">'\n'</literal><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CR</name> <operator>&amp;&amp;</operator> <name>c2</name> <operator>!=</operator> <literal type="char">'\r'</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name>raw_buf_ptr</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-copy marker does not match previous newline style"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Transfer only the data before the \. into line_buf, then
				 * discard the data and the \. sequence.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>prev_raw_ptr</name> <operator>&gt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>,
										   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr></argument>,
										   <argument><expr><name>prev_raw_ptr</name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name>raw_buf_ptr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* report EOF */</comment>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we are here, it means we found a backslash followed by
				 * something other than a period.  In non-CSV mode, anything
				 * after a backslash is special, so we skip over that second
				 * character too.  If we didn't do that \\. would be
				 * considered an eof-of copy, while in non-CSV mode it is a
				 * literal backslash followed by a period.  In CSV mode,
				 * backslashes are not special, so we want to process the
				 * character after the backslash just like a normal character,
				 * so we don't increment in those cases.
				 */</comment>
				<expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * This label is for CSV cases where \. appears at the start of a
		 * line, but there is more text after it, meaning it was a data value.
		 * We are more strict for \. in CSV mode because \. could be a data
		 * value, while in non-CSV mode, \. cannot be a data value.
		 */</comment>
<label><name>not_end_of_copy</name>:</label>

		<comment type="block">/*
		 * Process all bytes of a multi-byte character as a group.
		 *
		 * We only support multi-byte sequences where the first byte has the
		 * high-bit set, so as an optimization we can avoid this block
		 * entirely if it is not set.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name> <operator>&amp;&amp;</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>mblen</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * It is enough to look at the first byte in all our encodings, to
			 * get the length.  (GB18030 is a bit special, but still works for
			 * our purposes; see comment in pg_gb18030_mblen())
			 */</comment>
			<expr_stmt><expr><name><name>mblen_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>mblen</name> <operator>=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>, <argument><expr><name>mblen_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><name>mblen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>IF_NEED_REFILL_AND_EOF_BREAK</name><argument_list>(<argument><expr><name>mblen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>raw_buf_ptr</name> <operator>+=</operator> <name>mblen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>first_char_in_line</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>							<comment type="block">/* end of outer loop */</comment>

	<comment type="block">/*
	 * Transfer any still-uncopied data to line_buf.
	 */</comment>
	<expr_stmt><expr><name>REFILL_LINEBUF</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Return decimal value for a hexadecimal digit
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetDecimalFromHex</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>hex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>hex</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hex</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the current line into separate attributes (fields),
 * performing de-escaping as needed.
 *
 * The input is in line_buf.  We use attribute_buf to hold the result
 * strings.  cstate-&gt;raw_fields[k] is set to point to the k'th attribute
 * string, or NULL when the input matches the null marker string.
 * This array is expanded as necessary.
 *
 * (Note that the caller cannot check for nulls since the returned
 * string would be the post-de-escaping equivalent, which may look
 * the same as some valid data string.)
 *
 * delim is the column delimiter string (must be just one byte for now).
 * null_print is the null marker string.  Note that this is compared to
 * the pre-de-escaped input string.
 *
 * The return value is the number of fields actually read.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CopyReadAttributesText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stop_processing_at_field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>delimc</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>escapec</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>delim_off</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fieldno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>output_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cur_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>line_end_ptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need a special case for zero-column tables: check that the input
	 * line is empty, and return.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extra data after last expected column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The de-escaped attributes will certainly not be longer than the input
	 * data line, so we can just force attribute_buf to be large enough and
	 * then transfer data without any checks for enough space.  We need to do
	 * it this way because enlarging attribute_buf mid-stream would invalidate
	 * pointers already stored into cstate-&gt;raw_fields[].
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>maxlen</name></name> <operator>&lt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>output_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<comment type="block">/* set pointer variables for loop */</comment>
	<expr_stmt><expr><name>cur_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>cursor</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>line_end_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/* Outer loop iterates over fields */</comment>
	<expr_stmt><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>end_ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>input_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>saw_non_ascii</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In QD, stop once we have processed the last field we need in the QD.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>==</operator> <name>stop_processing_at_field</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stopped_processing_at_delim</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Make sure there is enough space for the next value */</comment>
		<if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name> <operator>=</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember start of field on both input and output sides */</comment>
		<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>output_ptr</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan data for field.
		 *
		 * Note that in this loop, we are scanning to locate the end of field
		 * and also speculatively performing de-escaping.  Once we find the
		 * end-of-field, we can match the raw field contents against the null
		 * marker string.  Only after that comparison fails do we know that
		 * de-escaping is actually the right thing to do; therefore we *must
		 * not* throw any syntax errors before we've done the null-marker
		 * check.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>delim_off</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>escapec</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>escape_off</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'0'</literal></expr>:</case>
					<case>case <expr><literal type="char">'1'</literal></expr>:</case>
					<case>case <expr><literal type="char">'2'</literal></expr>:</case>
					<case>case <expr><literal type="char">'3'</literal></expr>:</case>
					<case>case <expr><literal type="char">'4'</literal></expr>:</case>
					<case>case <expr><literal type="char">'5'</literal></expr>:</case>
					<case>case <expr><literal type="char">'6'</literal></expr>:</case>
					<case>case <expr><literal type="char">'7'</literal></expr>:</case>
						<block>{<block_content>
							<comment type="block">/* handle \013 */</comment>
							<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OCTVALUE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><call><name>ISOCTAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
									<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <call><name>OCTVALUE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name></expr>;</expr_stmt>
										<if_stmt><if>if <condition>(<expr><call><name>ISOCTAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
										<block>{<block_content>
											<expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
											<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <call><name>OCTVALUE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										</block_content>}</block></if></if_stmt>
									</block_content>}</block></if></if_stmt>
								</block_content>}</block></if></if_stmt>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><name>c</name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0377</literal></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>saw_non_ascii</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block>
						<break>break;</break>
					<case>case <expr><literal type="char">'x'</literal></expr>:</case>
						<comment type="block">/* Handle \x3F */</comment>
						<if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name></type>		<name>hexchar</name> <init>= <expr><operator>*</operator><name>cur_ptr</name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hexchar</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>int</name></type>			<name>val</name> <init>= <expr><call><name>GetDecimalFromHex</name><argument_list>(<argument><expr><name>hexchar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

								<expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><name>hexchar</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name></expr>;</expr_stmt>
									<if_stmt><if>if <condition>(<expr><call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hexchar</name></expr></argument>)</argument_list></call></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
										<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <call><name>GetDecimalFromHex</name><argument_list>(<argument><expr><name>hexchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									</block_content>}</block></if></if_stmt>
								</block_content>}</block></if></if_stmt>
								<expr_stmt><expr><name>c</name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>saw_non_ascii</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'b'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'f'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'n'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'r'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'t'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'v'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\v'</literal></expr>;</expr_stmt>
						<break>break;</break>

						<comment type="block">/*
						 * in all other cases, take the char after '\'
						 * literally
						 */</comment>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Add c to output string */</comment>
			<expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Check whether raw input matched null marker */</comment>
		<expr_stmt><expr><name>input_len</name> <operator>=</operator> <name>end_ptr</name> <operator>-</operator> <name>start_ptr</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>input_len</name> <operator>==</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * At this point we know the field is supposed to contain data.
			 *
			 * If we de-escaped any non-7-bit-ASCII chars, make sure the
			 * resulting string is valid data for the db encoding.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>saw_non_ascii</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fld</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pg_verifymbstr</name><argument_list>(<argument><expr><name>fld</name></expr></argument>, <argument><expr><name>output_ptr</name> <operator>-</operator> <name>fld</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Terminate attribute value in output area */</comment>
		<expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>fieldno</name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Done if we hit EOL instead of a delim */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_delim</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stopped_processing_at_delim</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Make note of the stopping point in 'line_buf.cursor', so that we
	 * can send the rest to the QE later.
	 */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <name>cur_ptr</name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<comment type="block">/* Clean up state of attribute_buf */</comment>
	<expr_stmt><expr><name>output_ptr</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>output_ptr</name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>fieldno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the current line into separate attributes (fields),
 * performing de-escaping as needed.  This has exactly the same API as
 * CopyReadAttributesText, except we parse the fields according to
 * "standard" (i.e. common) CSV usage.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CopyReadAttributesCSV</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stop_processing_at_field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>delimc</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>delim_off</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>quotec</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>escapec</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fieldno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>output_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cur_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>line_end_ptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need a special case for zero-column tables: check that the input
	 * line is empty, and return.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extra data after last expected column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The de-escaped attributes will certainly not be longer than the input
	 * data line, so we can just force attribute_buf to be large enough and
	 * then transfer data without any checks for enough space.  We need to do
	 * it this way because enlarging attribute_buf mid-stream would invalidate
	 * pointers already stored into cstate-&gt;raw_fields[].
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>maxlen</name></name> <operator>&lt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>output_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<comment type="block">/* set pointer variables for loop */</comment>
	<expr_stmt><expr><name>cur_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>cursor</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>line_end_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/* Outer loop iterates over fields */</comment>
	<expr_stmt><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>saw_quote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>end_ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>input_len</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * In QD, stop once we have processed the last field we need in the QD.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>==</operator> <name>stop_processing_at_field</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stopped_processing_at_delim</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Make sure there is enough space for the next value */</comment>
		<if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name> <operator>=</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember start of field on both input and output sides */</comment>
		<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>output_ptr</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan data for field,
		 *
		 * The loop starts in "not quote" mode and then toggles between that
		 * and "in quote" mode. The loop exits normally if it is in "not
		 * quote" mode and a delimiter or line end is seen.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>

			<comment type="block">/* Not in quote */</comment>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>endfield</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* unquoted field delimiter */</comment>
				<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>delim_off</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<goto>goto <name>endfield</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* start of quoted field (or part of field) */</comment>
				<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>quotec</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>saw_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Add c to output string */</comment>
				<expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/* In quote */</comment>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unterminated CSV quoted field"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/* escape within a quoted field */</comment>
				<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>escapec</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * peek at the next char if available, and escape it if it
					 * is an escape char or a quote char
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name></type>		<name>nextc</name> <init>= <expr><operator>*</operator><name>cur_ptr</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>nextc</name> <operator>==</operator> <name>escapec</name> <operator>||</operator> <name>nextc</name> <operator>==</operator> <name>quotec</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <name>nextc</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * end of quoted field. Must do this test after testing for
				 * escape in case quote char and escape char are the same
				 * (which is the common case).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>quotec</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<comment type="block">/* Add c to output string */</comment>
				<expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
<label><name>endfield</name>:</label>

		<comment type="block">/* Terminate attribute value in output area */</comment>
		<expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* Check whether raw input matched null marker */</comment>
		<expr_stmt><expr><name>input_len</name> <operator>=</operator> <name>end_ptr</name> <operator>-</operator> <name>start_ptr</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>saw_quote</name> <operator>&amp;&amp;</operator> <name>input_len</name> <operator>==</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>fieldno</name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Done if we hit EOL instead of a delim */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_delim</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stopped_processing_at_delim</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Make note of the stopping point in 'line_buf.cursor', so that we
	 * can send the rest to the QE later.
	 */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <name>cur_ptr</name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<comment type="block">/* Clean up state of attribute_buf */</comment>
	<expr_stmt><expr><name>output_ptr</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>output_ptr</name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>fieldno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a binary attribute
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>CopyReadBinaryAttribute</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>column_no</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
						<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fld_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyGetInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fld_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld_size</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><name>flinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid field size"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* reset attribute_buf to empty, and load raw data in it */</comment>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>, <argument><expr><name>fld_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name></expr></argument>,
					<argument><expr><name>fld_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>fld_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>fld_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name><index>[<expr><name>fld_size</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* Call the column type's binary input converter */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><name>flinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>,
								 <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Trouble if it didn't eat the whole buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>cursor</name></name> <operator>!=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect binary data format"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send text representation of one attribute, with conversion and escaping
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPSOFAR</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (ptr &gt; start) \
			CopySendData(cstate, start, ptr - start); \
	} while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyAttributeOutText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>delimc</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>escapec</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>pg_server_to_custom</name><argument_list>(<argument><expr><name>string</name></expr></argument>,
								  <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>,
								  <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>enc_conversion_proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>escape_off</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have to grovel through the string searching for control characters
	 * and instances of the delimiter character.  In most cases, though, these
	 * are infrequent.  To avoid overhead from calling CopySendData once per
	 * character, we dump out all characters between escaped characters in a
	 * single call.  The loop invariant is that the data from "start" to "ptr"
	 * can be sent literally, but hasn't yet been.
	 *
	 * We can skip pg_encoding_mblen() overhead when encoding is safe, because
	 * in valid backend encodings, extra bytes of a multibyte character never
	 * look like ASCII.  This loop is sufficiently performance-critical that
	 * it's worth making two copies of it to get the IS_HIGHBIT_SET() test out
	 * of the normal safe-encoding path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <literal type="number">0x20</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * \r and \n must be escaped, the others are traditional. We
				 * prefer to dump these using the C-like notation, rather than
				 * a backslash and the literal character, because it makes the
				 * dump file a bit more proof against Microsoftish data
				 * mangling.
				 */</comment>
				<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'\b'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\f'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\r'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\t'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\v'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<comment type="block">/* If it's the delimiter, must backslash it */</comment>
						<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<comment type="block">/* All ASCII control chars are length 1 */</comment>
						<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
						<continue>continue;</continue>	<comment type="block">/* fall to end of loop */</comment>
				</block_content>}</block></switch>
				<comment type="block">/* if we get here, we need to convert the control char */</comment>
				<expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>escapec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>	<comment type="block">/* do not include char in next run */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>escapec</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>escapec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* we include char in next run */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <literal type="number">0x20</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * \r and \n must be escaped, the others are traditional. We
				 * prefer to dump these using the C-like notation, rather than
				 * a backslash and the literal character, because it makes the
				 * dump file a bit more proof against Microsoftish data
				 * mangling.
				 */</comment>
				<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'\b'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\f'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\r'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\t'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'\v'</literal></expr>:</case>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<comment type="block">/* If it's the delimiter, must backslash it */</comment>
						<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<comment type="block">/* All ASCII control chars are length 1 */</comment>
						<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
						<continue>continue;</continue>	<comment type="block">/* fall to end of loop */</comment>
				</block_content>}</block></switch>
				<comment type="block">/* if we get here, we need to convert the control char */</comment>
				<expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>escapec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>	<comment type="block">/* do not include char in next run */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>escapec</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>escapec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* we include char in next run */</comment>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send text representation of one attribute, with conversion and
 * CSV-style escaping
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyAttributeOutCSV</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>use_quote</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>single_attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>delimc</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>quotec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>escapec</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * MPP-8075. We may get called with cstate-&gt;quote == NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>quotec</name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>quotec</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* force quoting if it matches null_print (before conversion!) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_quote</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>pg_server_to_custom</name><argument_list>(<argument><expr><name>string</name></expr></argument>,
								  <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>,
								  <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>enc_conversion_proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Make a preliminary pass to discover if it needs quoting
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_quote</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Because '\.' can be a data value, quote it if it appears alone on a
		 * line so it is not interpreted as the end-of-data marker.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>single_attr</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"\\."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>use_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tptr</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>tptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>quotec</name> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>use_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tptr</name> <operator>+=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>, <argument><expr><name>tptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_quote</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>quotec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We adopt the same optimization strategy as in CopyAttributeOutText
		 */</comment>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>quotec</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>escapec</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>escapec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>	<comment type="block">/* we include char in next run */</comment>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>quotec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If it doesn't need quoting, we can just dump it as-is */</comment>
		<expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyGetAttnums - build an integer list of attnums to be copied
 *
 * The input attnamelist is either the user-specified column list,
 * or NIL if there was none (in which case we want all the non-dropped
 * columns).
 *
 * We don't include generated columns in the generated full list and we don't
 * allow them to be specified explicitly.  They don't make sense for COPY
 * FROM, but we could possibly allow them for COPY TO.  But this way it's at
 * least ensured that whatever we copy out can be copied back in.
 *
 * rel can be NULL ... it's only used for error reports.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CopyGetAttnums</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnamelist</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate default column list */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>attr_count</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Validate the user-supplied list and extract attnums */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>attnamelist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/* Lookup column name */</comment>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is a generated column"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Generated columns cannot be used in COPY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Check for duplicates */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>attnums</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* remove end of line chars from end of a buffer */</comment>
<function><type><name>void</name></type> <name>truncateEol</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>EolType</name></type> <name>eol_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>one_back</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>two_back</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>eol_type</name> <operator>==</operator> <name>EOL_CRNL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>two_back</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator>
		   <name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>one_back</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>two_back</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>one_back</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>one_back</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator>
		   <name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>one_back</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>one_back</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* wrapper for truncateEol */</comment>
<function><type><name>void</name></type>
<name>truncateEolStr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>EolType</name></type> <name>eol_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>maxlen</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>truncateEol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>eol_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * copy_dest_startup --- executor startup
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>copy_dest_startup</name><argument_list>(<argument><expr><name>DestReceiver</name> <operator>*</operator><name>self</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>int</name> <name>operation</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TupleDesc</name> <name>typeinfo</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>DR_copy</name>    <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>cstate</name></name> <operator>=</operator> <call><name>BeginCopyToOnSegment</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * copy_dest_receive --- receive one tuple
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>copy_dest_receive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DR_copy</name>    <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name> <init>= <expr><name><name>myState</name><operator>-&gt;</operator><name>cstate</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Send the data */</comment>
	<expr_stmt><expr><call><name>CopyOneRowTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>processed</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copy_dest_shutdown --- executor end
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>copy_dest_shutdown</name><argument_list>(<argument><expr><name>DestReceiver</name> <operator>*</operator><name>self</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>DR_copy</name>    <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>EndCopyToOnSegment</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>cstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * copy_dest_destroy --- release DestReceiver object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_dest_destroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CreateCopyDestReceiver -- create a suitable DestReceiver object
 */</comment>
<function><type><name>DestReceiver</name> <modifier>*</modifier></type>
<name>CreateCopyDestReceiver</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DR_copy</name>    <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DR_copy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>receiveSlot</name></name> <operator>=</operator> <name>copy_dest_receive</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rStartup</name></name> <operator>=</operator> <name>copy_dest_startup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rShutdown</name></name> <operator>=</operator> <name>copy_dest_shutdown</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rDestroy</name></name> <operator>=</operator> <name>copy_dest_destroy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>=</operator> <name>DestCopyOut</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>cstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* need to be set later */</comment>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* need to be set later */</comment>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize data loader parsing state
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>CopyInitDataParser</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>reached_eof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up data buffer to hold a chunk of data */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>RAW_BUF_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name><index>[<expr><name>RAW_BUF_SIZE</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setEncodingConversionProc
 *
 * COPY and External tables use a custom path to the encoding conversion
 * API because external tables have their own encoding (which is not
 * necessarily client_encoding). We therefore have to set the correct
 * encoding conversion function pointer ourselves, to be later used in
 * the conversion engine.
 *
 * The code here mimics a part of SetClientEncoding() in mbutils.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setEncodingConversionProc</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>		<name>conversion_proc</name></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * COPY FROM and RET: convert from file to server
	 * COPY TO   and WET: convert from server to file
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>iswritable</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>conversion_proc</name> <operator>=</operator> <call><name>FindDefaultConversionProc</name><argument_list>(<argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>		
		<expr_stmt><expr><name>conversion_proc</name> <operator>=</operator> <call><name>FindDefaultConversionProc</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>conversion_proc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* conversion proc found */</comment>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>enc_conversion_proc</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>conversion_proc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>enc_conversion_proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no conversion function (both encodings are probably the same) */</comment>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>enc_conversion_proc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GpDistributionData</name> <modifier>*</modifier></type>
<name>InitDistributionData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpDistributionData</name> <modifier>*</modifier></type><name>distData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbHash</name>	   <modifier>*</modifier></type><name>cdbHash</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * A non-partitioned table, or all the partitions have identical
	 * distribution policies.
	 */</comment>
	<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>GpPolicyCopy</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cdbHash</name> <operator>=</operator> <call><name>makeCdbHashForRelation</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>distData</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpDistributionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distData</name><operator>-&gt;</operator><name>policy</name></name> <operator>=</operator> <name>policy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distData</name><operator>-&gt;</operator><name>cdbHash</name></name> <operator>=</operator> <name>cdbHash</name></expr>;</expr_stmt>

	<return>return <expr><name>distData</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreeDistributionData</name><parameter_list>(<parameter><decl><type><name>GpDistributionData</name> <modifier>*</modifier></type><name>distData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>distData</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>distData</name><operator>-&gt;</operator><name>policy</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>distData</name><operator>-&gt;</operator><name>policy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>distData</name><operator>-&gt;</operator><name>cdbHash</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>distData</name><operator>-&gt;</operator><name>cdbHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>distData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute which fields need to be processed in the QD, and which ones can
 * be delayed to the QE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitCopyFromDispatchSplit</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>GpDistributionData</name> <modifier>*</modifier></type><name>distData</name></decl></parameter>,
						  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>first_qe_processed_field</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>needed_cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>needed_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>needed_cols</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first_qe_processed_field</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>fieldno</name></decl>;</decl_stmt>
		<comment type="block">/*
		 * We need all the columns that form the distribution key.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>distData</name><operator>-&gt;</operator><name>policy</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>distData</name><operator>-&gt;</operator><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name>needed_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>needed_cols</name></expr></argument>, <argument><expr><name><name>distData</name><operator>-&gt;</operator><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the max fieldno that contains one of the needed attributes. */</comment>
		<expr_stmt><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>needed_cols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>first_qe_processed_field</name> <operator>=</operator> <name>fieldno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>fieldno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>first_qe_processed_field</name></name> <operator>=</operator> <name>first_qe_processed_field</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Test_copy_qd_qe_split</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>first_qe_processed_field</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"all fields will be processed in the QD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"first field processed in the QE: %d"</literal></expr></argument>, <argument><expr><name>first_qe_processed_field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>GetTargetSeg</name><parameter_list>(<parameter><decl><type><name>GpDistributionData</name> <modifier>*</modifier></type><name>distData</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>target_seg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbHash</name>	   <modifier>*</modifier></type><name>cdbHash</name> <init>= <expr><name><name>distData</name><operator>-&gt;</operator><name>cdbHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name> <init>= <expr><name><name>distData</name><operator>-&gt;</operator><name>policy</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* the partitioning policy for this table */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>p_nattrs</name></decl>;</decl_stmt>	<comment type="block">/* num of attributes in the distribution policy */</comment>

	<comment type="block">/*
	 * These might be NULL, if we're called with a "main" GpDistributionData,
	 * for a partitioned table with heterogenous partitions. The caller
	 * should've used GetDistributionPolicyForPartition() to get the right
	 * distdata object for the partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>policy</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing distribution policy."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cdbHash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing cdbhash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * At this point in the code, baseValues[x] is final for this
	 * data row -- either the input data, a null or a default
	 * value is in there, and constraints applied.
	 *
	 * Perform a cdbhash on this data row. Perform a hash operation
	 * on each attribute.
	 */</comment>
	<expr_stmt><expr><name>p_nattrs</name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>p_nattrs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cdbhashinit</name><argument_list>(<argument><expr><name>cdbHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>p_nattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* current attno from the policy */</comment>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>h_attnum</name> <init>= <expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>h_attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>cdbhash</name><argument_list>(<argument><expr><name>cdbHash</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>target_seg</name> <operator>=</operator> <call><name>cdbhashreduce</name><argument_list>(<argument><expr><name>cdbHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* hash result segment */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Randomly distributed. Pick a segment at random.
		 */</comment>
		<expr_stmt><expr><name>target_seg</name> <operator>=</operator> <call><name>cdbhashrandomseg</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>target_seg</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ProgramPipes</name><modifier>*</modifier></type>
<name>open_program_pipes</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forwrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pqsigfunc</name></type> <name>save_SIGPIPE</name></decl>;</decl_stmt>
	<comment type="block">/* set up extvar */</comment>
	<decl_stmt><decl><type><name>extvar_t</name></type> <name>extvar</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extvar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>extvar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>external_set_env_vars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extvar</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ProgramPipes</name> <modifier>*</modifier></type><name>program_pipes</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProgramPipes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>program_pipes</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>program_pipes</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>program_pipes</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>program_pipes</name><operator>-&gt;</operator><name>shexec</name></name> <operator>=</operator> <call><name>make_command</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Preserve the SIGPIPE handler and set to default handling.  This
	 * allows "normal" SIGPIPE handling in the command pipeline.  Normal
	 * for PG is to *ignore* SIGPIPE.
	 */</comment>
	<expr_stmt><expr><name>save_SIGPIPE</name> <operator>=</operator> <call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>program_pipes</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <call><name>popen_with_stderr</name><argument_list>(<argument><expr><name><name>program_pipes</name><operator>-&gt;</operator><name>pipes</name></name></expr></argument>, <argument><expr><name><name>program_pipes</name><operator>-&gt;</operator><name>shexec</name></name></expr></argument>, <argument><expr><name>forwrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

	<comment type="block">/* Restore the SIGPIPE handler */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>save_SIGPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"COPY ... PROGRAM command: %s"</literal></expr></argument>, <argument><expr><name><name>program_pipes</name><operator>-&gt;</operator><name>shexec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>program_pipes</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can not start command: %s"</literal></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>program_pipes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>close_program_pipes</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ifThrow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sinfo</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* just return if pipes not created, like when relation does not exist */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>program_pipes</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pclose_with_stderr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>program_pipes</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>program_pipes</name><operator>-&gt;</operator><name>pipes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>ifThrow</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pclose()/wait4() ended with an error; errno should be valid */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can not close pipe: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * pclose() returned the process termination state.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SQL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"command error message: %s"</literal></expr></argument>, <argument><expr><name><name>sinfo</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>parse_joined_option_list</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>delimiter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>comma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>whitespace</name> <init>= <expr><literal type="string">" \t\n\r"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cols</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name> <init>= <expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
					 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>token</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* consume the comma if any */</comment>
		<expr_stmt><expr><name>comma</name> <operator>=</operator> <call><name>strtokx2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>comma</name> <operator>||</operator> <name><name>comma</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>cols</name></expr>;</return>
</block_content>}</block></function>
</unit>
