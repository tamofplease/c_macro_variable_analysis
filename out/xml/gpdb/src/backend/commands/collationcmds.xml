<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/collationcmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * collationcmds.c
 *	  collation-related commands support code
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/collationcmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/collationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>localename</name></decl>;</decl_stmt>		<comment type="block">/* name of locale, as per "locale -a" */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>			<comment type="block">/* shortened alias for same */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>enc</name></decl>;</decl_stmt>			<comment type="block">/* encoding */</comment>
}</block></struct></type> <name>CollAliasData</name>;</typedef>


<comment type="block">/*
 * CREATE COLLATION
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineCollation</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parameters</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collNamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>fromEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>localeEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>lccollateEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>lcctypeEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>providerEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>deterministicEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>versionEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collcollate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collctype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collproviderstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>collisdeterministic</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>collencoding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>collprovider</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collversion</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>collNamespace</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>collNamespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>collNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>pl</argument>, <argument>parameters</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DefElem</name>   <modifier>*</modifier><modifier>*</modifier></type><name>defelp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"from"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>fromEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"locale"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>localeEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"lc_collate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>lccollateEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"lc_ctype"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>lcctypeEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"provider"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>providerEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"deterministic"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>deterministicEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>versionEl</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation attribute \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>defelp</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>localeEl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>lccollateEl</name> <operator>||</operator> <name>lcctypeEl</name><operator>)</operator><operator>)</operator>
		<operator>||</operator> <operator>(</operator><name>fromEl</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fromEl</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>get_collation_oid</name><argument_list>(<argument><expr><call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>fromEl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>collcollate</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>collcollate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collctype</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>collctype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collprovider</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>collprovider</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>collisdeterministic</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>collisdeterministic</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>collencoding</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>collencoding</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Copying the "default" collation is not allowed because most code
		 * checks for DEFAULT_COLLATION_OID instead of COLLPROVIDER_DEFAULT,
		 * and so having a second collation with COLLPROVIDER_DEFAULT would
		 * not work and potentially confuse or crash some code.  This could be
		 * fixed with some legwork.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>collprovider</name> <operator>==</operator> <name>COLLPROVIDER_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation \"default\" cannot be copied"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>localeEl</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>collcollate</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>localeEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collctype</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>localeEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>lccollateEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collcollate</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>lccollateEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>lcctypeEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collctype</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>lcctypeEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>providerEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collproviderstr</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>providerEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>deterministicEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collisdeterministic</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>deterministicEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>versionEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collversion</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>versionEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>collproviderstr</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>collproviderstr</name></expr></argument>, <argument><expr><literal type="string">"icu"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>collprovider</name> <operator>=</operator> <name>COLLPROVIDER_ICU</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>collproviderstr</name></expr></argument>, <argument><expr><literal type="string">"libc"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>collprovider</name> <operator>=</operator> <name>COLLPROVIDER_LIBC</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized collation provider: %s"</literal></expr></argument>,
							<argument><expr><name>collproviderstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>fromEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collprovider</name> <operator>=</operator> <name>COLLPROVIDER_LIBC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>collcollate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"lc_collate\" must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>collctype</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"lc_ctype\" must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Nondeterministic collations are currently only supported with ICU
	 * because that's the only case where it can actually make a difference.
	 * So we can save writing the code for the other providers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>collisdeterministic</name> <operator>&amp;&amp;</operator> <name>collprovider</name> <operator>!=</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"nondeterministic collations not supported with this provider"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fromEl</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>collprovider</name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>collencoding</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>collencoding</name> <operator>=</operator> <call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>check_encoding_locale_matches</name><argument_list>(<argument><expr><name>collencoding</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>collctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>collversion</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collversion</name> <operator>=</operator> <call><name>get_collation_actual_version</name><argument_list>(<argument><expr><name>collprovider</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newoid</name> <operator>=</operator> <call><name>CollationCreate</name><argument_list>(<argument><expr><name>collName</name></expr></argument>,
							 <argument><expr><name>collNamespace</name></expr></argument>,
							 <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
							 <argument><expr><name>collprovider</name></expr></argument>,
							 <argument><expr><name>collisdeterministic</name></expr></argument>,
							 <argument><expr><name>collencoding</name></expr></argument>,
							 <argument><expr><name>collcollate</name></expr></argument>,
							 <argument><expr><name>collctype</name></expr></argument>,
							 <argument><expr><name>collversion</name></expr></argument>,
							 <argument><expr><name>if_not_exists</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* not quiet */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the locales can be loaded.  NB: pg_newlocale_from_collation
	 * is only supposed to be called on non-C-equivalent locales.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lc_collate_is_c</name><argument_list>(<argument><expr><name>newoid</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>lc_ctype_is_c</name><argument_list>(<argument><expr><name>newoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pg_newlocale_from_collation</name><argument_list>(<argument><expr><name>newoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>CollationRelationId</name></expr></argument>, <argument><expr><name>newoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefineStmt</name> <modifier>*</modifier></type> <name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DefineStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>OBJECT_COLLATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldstyle</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name> <operator>=</operator> <name>names</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name> <operator>=</operator> <name>parameters</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>trusted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
		                            <argument><expr><name>DF_CANCEL_ON_ERROR</name><operator>|</operator>
			                        <name>DF_WITH_SNAPSHOT</name><operator>|</operator>
			                        <name>DF_NEED_TWO_PHASE</name></expr></argument>,
		                            <argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
		                            <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ALTER COLLATION SET SCHEMA and RENAME
 *
 * Is there a collation with the same name of the given collation already in
 * the given namespace?  If so, raise an appropriate error message.
 */</comment>
<function><type><name>void</name></type>
<name>IsThereCollationInNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* make sure the name doesn't already exist in new schema */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists3</name><argument_list>(<argument><expr><name>COLLNAMEENCNSP</name></expr></argument>,
							  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation \"%s\" for encoding \"%s\" already exists in schema \"%s\""</literal></expr></argument>,
						<argument><expr><name>collname</name></expr></argument>, <argument><expr><call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* mustn't match an any-encoding entry, either */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists3</name><argument_list>(<argument><expr><name>COLLNAMEENCNSP</name></expr></argument>,
							  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation \"%s\" already exists in schema \"%s\""</literal></expr></argument>,
						<argument><expr><name>collname</name></expr></argument>, <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER COLLATION
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterCollation</name><parameter_list>(<parameter><decl><type><name>AlterCollationStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>collForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>collversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>CollationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collOid</name> <operator>=</operator> <call><name>get_collation_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_collation_ownercheck</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_COLLATION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>collForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collversion</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>Anum_pg_collation_collversion</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldversion</name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>collversion</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>newversion</name> <operator>=</operator> <call><name>get_collation_actual_version</name><argument_list>(<argument><expr><name><name>collForm</name><operator>-&gt;</operator><name>collprovider</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>collForm</name><operator>-&gt;</operator><name>collcollate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cannot change from NULL to non-NULL or vice versa */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>oldversion</name> <operator>&amp;&amp;</operator> <name>newversion</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>oldversion</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>newversion</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid collation version change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>oldversion</name> <operator>&amp;&amp;</operator> <name>newversion</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>newversion</name></expr></argument>, <argument><expr><name>oldversion</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_collation</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_collation</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_collation</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"changing version from %s to %s"</literal></expr></argument>,
						<argument><expr><name>oldversion</name></expr></argument>, <argument><expr><name>newversion</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_collation_collversion</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>newversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_collation_collversion</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version has not changed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>CollationRelationId</name></expr></argument>, <argument><expr><name>collOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>CollationRelationId</name></expr></argument>, <argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>pg_collation_actual_version</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collcollate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>collprovider</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>collcollate</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>collcollate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collprovider</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>collprovider</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>get_collation_actual_version</name><argument_list>(<argument><expr><name>collprovider</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* will we use "locale -a" in pg_import_system_collations? */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LOCALE_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCALE_A_OUTPUT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>READ_LOCALE_A_OUTPUT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>USE_ICU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Check a string to see if it is pure ASCII
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_all_ascii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* READ_LOCALE_A_OUTPUT || USE_ICU */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>READ_LOCALE_A_OUTPUT</name></cpp:ifdef>
<comment type="block">/*
 * "Normalize" a libc locale name, stripping off encoding tags such as
 * ".utf8" (e.g., "en_US.utf8" -&gt; "en_US", but "br_FR.iso885915@euro"
 * -&gt; "br_FR@euro").  Return true if a new, different name was
 * generated.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>normalize_libc_locale_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>new</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><name>new</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name>old</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>o</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>o</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip over encoding tag such as ".utf8" or ".UTF-8" */</comment>
			<expr_stmt><expr><name>o</name><operator>++</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>o</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>o</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator>
				   <operator>||</operator> <operator>(</operator><operator>*</operator><name>o</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>o</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator>
				   <operator>||</operator> <operator>(</operator><operator>*</operator><name>o</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>o</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator>
				   <operator>||</operator> <operator>(</operator><operator>*</operator><name>o</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>o</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>n</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>o</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>changed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for CollAliasData items
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmpaliases</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CollAliasData</name> <modifier>*</modifier></type><name>ca</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CollAliasData</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CollAliasData</name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CollAliasData</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* comparing localename is enough because other fields are derived */</comment>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>localename</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>localename</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* READ_LOCALE_A_OUTPUT */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DispatchCollationCreate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>schemaname</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parameters</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defstring</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>defstring</name><operator>-&gt;</operator><name>defname</name></name> <operator>=</operator> <literal type="string">"locale"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>defstring</name><operator>-&gt;</operator><name>defaction</name></name> <operator>=</operator> <name>DEFELEM_UNSPEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>defstring</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>parameters</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>, <argument><expr><name>defstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DefineStmt</name> <modifier>*</modifier></type> <name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DefineStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>OBJECT_COLLATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldstyle</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name> <operator>=</operator> <name>names</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name> <operator>=</operator> <name>parameters</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>trusted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
	                            <argument><expr><name>DF_CANCEL_ON_ERROR</name><operator>|</operator>
		                        <name>DF_WITH_SNAPSHOT</name><operator>|</operator>
		                        <name>DF_NEED_TWO_PHASE</name></expr></argument>,
	                            <argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
	                            <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
<comment type="block">/*
 * Get the ICU language tag for a locale name.
 * The result is a palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_icu_language_tag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>localename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>ULOC_FULLNAME_CAPACITY</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uloc_toLanguageTag</name><argument_list>(<argument><expr><name>localename</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert locale name \"%s\" to language tag: %s"</literal></expr></argument>,
						<argument><expr><name>localename</name></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get a comment (specifically, the display name) for an ICU locale.
 * The result is a palloc'd string, or NULL if we can't get a comment
 * or find that it's not all ASCII.  (We can *not* accept non-ASCII
 * comments, because the contents of template0 must be encoding-agnostic.)
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_icu_locale_comment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>localename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UChar</name></type>		<name><name>displayname</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>len_uchar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_uchar</name> <operator>=</operator> <call><name>uloc_getDisplayName</name><argument_list>(<argument><expr><name>localename</name></expr></argument>, <argument><expr><literal type="string">"en"</literal></expr></argument>,
									<argument><expr><name>displayname</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>displayname</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no good reason to raise an error */</comment>

	<comment type="block">/* Check for non-ASCII comment (can't use is_all_ascii for this) */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len_uchar</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>displayname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* OK, transcribe */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len_uchar</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len_uchar</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>displayname</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>len_uchar</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ICU */</comment>


<comment type="block">/*
 * pg_import_system_collations: add known system collations to pg_collation
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_import_system_collations</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncreated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* silence compiler warning if we have no locale implementation at all */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>nspid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to import system collations"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be dispatcher to import system collations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Load collations known to libc, using "locale -a" to enumerate them */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>READ_LOCALE_A_OUTPUT</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>locale_a_handle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>localebuf</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* we assume ASCII so this is fine */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>nvalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CollAliasData</name> <modifier>*</modifier></type><name>aliases</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>naliases</name></decl>,
					<decl><type ref="prev"/><name>maxaliases</name></decl>,
					<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

		<comment type="block">/* expansible array of aliases */</comment>
		<expr_stmt><expr><name>maxaliases</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>aliases</name> <operator>=</operator> <operator>(</operator><name>CollAliasData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>maxaliases</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CollAliasData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>naliases</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>locale_a_handle</name> <operator>=</operator> <call><name>OpenPipeStream</name><argument_list>(<argument><expr><literal type="string">"locale -a"</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>locale_a_handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not execute command \"%s\": %m"</literal></expr></argument>,
							<argument><expr><literal type="string">"locale -a"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>locale_a_handle</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>enc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>alias</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>localebuf</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"locale name too long, skipped: \"%s\""</literal></expr></argument>, <argument><expr><name>localebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>localebuf</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Some systems have locale names that don't consist entirely of
			 * ASCII letters (such as "bokm&amp;aring;l" or "fran&amp;ccedil;ais").
			 * This is pretty silly, since we need the locale itself to
			 * interpret the non-ASCII characters. We can't do much with
			 * those, so we filter them out.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_all_ascii</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"locale name has non-ASCII characters, skipped: \"%s\""</literal></expr></argument>, <argument><expr><name>localebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>pg_get_encoding_from_locale</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* error message printed by pg_get_encoding_from_locale() */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_VALID_BE_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore locales for client-only encodings */</comment>
			<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name>PG_SQL_ASCII</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* C/POSIX are already in the catalog */</comment>
            <comment type="block">/*
             * Greenplum specific behavior: this function in Greenplum can only be called after a full cluster is
             * built, this is different from Postgres which might call this function during initdb. When reaching
             * here, it must be in a database session, we can just ignore the collations not match current database's
             * encoding because they cannot be used in this database.
             */</comment>
			<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>       <comment type="block">/* Ignore collations incompatible with database encoding */</comment> 

			<comment type="block">/* count valid locales found in operating system */</comment>
			<expr_stmt><expr><name>nvalid</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * Create a collation named the same as the locale, but quietly
			 * doing nothing if it already exists.  This is the behavior we
			 * need even at initdb time, because some versions of "locale -a"
			 * can report the same locale name more than once.  And it's
			 * convenient for later import runs, too, since you just about
			 * always want to add on new locales without a lot of chatter
			 * about existing ones.
			 */</comment>
			<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>CollationCreate</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><name>COLLPROVIDER_LIBC</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
									 <argument><expr><name>localebuf</name></expr></argument>, <argument><expr><name>localebuf</name></expr></argument>,
									 <argument><expr><call><name>get_collation_actual_version</name><argument_list>(<argument><expr><name>COLLPROVIDER_LIBC</name></expr></argument>, <argument><expr><name>localebuf</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DispatchCollationCreate</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>, <argument><expr><name>localebuf</name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ncreated</name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/* Must do CCI between inserts to handle duplicates correctly */</comment>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Generate aliases such as "en_US" in addition to "en_US.utf8"
			 * for ease of use.  Note that collation names are unique per
			 * encoding only, so this doesn't clash with "en_US" for LATIN1,
			 * say.
			 *
			 * However, it might conflict with a name we'll see later in the
			 * "locale -a" output.  So save up the aliases and try to add them
			 * after we've read all the output.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>normalize_libc_locale_name</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><name>localebuf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>naliases</name> <operator>&gt;=</operator> <name>maxaliases</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>maxaliases</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>aliases</name> <operator>=</operator> <operator>(</operator><name>CollAliasData</name> <operator>*</operator><operator>)</operator>
						<call><name>repalloc</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>, <argument><expr><name>maxaliases</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CollAliasData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>aliases</name><index>[<expr><name>naliases</name></expr>]</index></name><operator>.</operator><name>localename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>aliases</name><index>[<expr><name>naliases</name></expr>]</index></name><operator>.</operator><name>alias</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>aliases</name><index>[<expr><name>naliases</name></expr>]</index></name><operator>.</operator><name>enc</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>naliases</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>ClosePipeStream</name><argument_list>(<argument><expr><name>locale_a_handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Before processing the aliases, sort them by locale name.  The point
		 * here is that if "locale -a" gives us multiple locale names with the
		 * same encoding and base name, say "en_US.utf8" and "en_US.utf-8", we
		 * want to pick a deterministic one of them.  First in ASCII sort
		 * order is a good enough rule.  (Before PG 10, the code corresponding
		 * to this logic in initdb.c had an additional ordering rule, to
		 * prefer the locale name exactly matching the alias, if any.  We
		 * don't need to consider that here, because we would have already
		 * created such a pg_collation entry above, and that one will win.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>naliases</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aliases</name></expr></argument>, <argument><expr><name>naliases</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollAliasData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmpaliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Now add aliases, ignoring any that match pre-existing entries */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>naliases</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>locale</name> <init>= <expr><name><name>aliases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>localename</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>alias</name> <init>= <expr><name><name>aliases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alias</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>enc</name> <init>= <expr><name><name>aliases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>enc</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>CollationCreate</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><name>COLLPROVIDER_LIBC</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
									 <argument><expr><name>locale</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>,
									 <argument><expr><call><name>get_collation_actual_version</name><argument_list>(<argument><expr><name>COLLPROVIDER_LIBC</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DispatchCollationCreate</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ncreated</name><operator>++</operator></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Give a warning if "locale -a" seems to be malfunctioning */</comment>
		<if_stmt><if>if <condition>(<expr><name>nvalid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no usable system locales were found"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* READ_LOCALE_A_OUTPUT */</comment>

	<comment type="block">/*
	 * Load collations known to ICU
	 *
	 * We use uloc_countAvailable()/uloc_getAvailable() rather than
	 * ucol_countAvailable()/ucol_getAvailable().  The former returns a full
	 * set of language+region combinations, whereas the latter only returns
	 * language+region combinations of they are distinct from the language's
	 * base collation.  So there might not be a de-DE or en-GB, which would be
	 * confusing.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Start the loop at -1 to sneak in the root locale without too much
		 * code duplication.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>uloc_countAvailable</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>langtag</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>icucomment</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collcollate</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* ICU root locale */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>uloc_getAvailable</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>langtag</name> <operator>=</operator> <call><name>get_icu_language_tag</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>collcollate</name> <operator>=</operator> <ternary><condition><expr><name>U_ICU_VERSION_MAJOR_NUM</name> <operator>&gt;=</operator> <literal type="number">54</literal></expr> ?</condition><then> <expr><name>langtag</name></expr> </then><else>: <expr><name>name</name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/*
			 * Be paranoid about not allowing any non-ASCII strings into
			 * pg_collation
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_all_ascii</name><argument_list>(<argument><expr><name>langtag</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>is_all_ascii</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>CollationCreate</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s-x-icu"</literal></expr></argument>, <argument><expr><name>langtag</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>nspid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><name>COLLPROVIDER_ICU</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									 <argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>,
									 <argument><expr><call><name>get_collation_actual_version</name><argument_list>(<argument><expr><name>COLLPROVIDER_ICU</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ncreated</name><operator>++</operator></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>icucomment</name> <operator>=</operator> <call><name>get_icu_locale_comment</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>icucomment</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CreateComments</name><argument_list>(<argument><expr><name>collid</name></expr></argument>, <argument><expr><name>CollationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								   <argument><expr><name>icucomment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ICU */</comment>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>ncreated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
