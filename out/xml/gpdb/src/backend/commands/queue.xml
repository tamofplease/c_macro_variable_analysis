<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/queue.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * queue.c
 *	  Commands for manipulating resource queues.
 *
 * Portions Copyright (c) 2006-2010, Greenplum inc.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *    src/backend/commands/queue.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resourcetype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resqueuecapability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/crypt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/formatting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resource_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resscheduler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc_tables.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_RES_LIMIT_STRING</name></cpp:macro>		<cpp:value>"-1"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**
 * Establish a lower bound on what memory limit may be set on a queue.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_RESOURCEQUEUE_MEMORY_LIMIT_KB</name></cpp:macro> <cpp:value>(10 * 1024L)</cpp:value></cpp:define>

<comment type="block">/* MPP-6923: 
 * GetResourceTypeByName: find the named resource in pg_resourcetype
 *
 * Input: name of resource
 * Output: resourcetypid (int2), oid of entry
 *
 * updates output and returns true if named resource found
 *
*/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>GetResourceTypeByName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pNameIn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pTypeOut</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>pOidOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_resourcetype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bStat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * SELECT * FROM pg_resourcetype WHERE resname = :1 FOR UPDATE
	 *
	 * XXX XXX: maybe should be share lock, ie remove FOR UPDATE ?
	 * XXX XXX: only one
	 */</comment>
	<expr_stmt><expr><name>pg_resourcetype</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ResourceTypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_resourcetype_resname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>pNameIn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_resourcetype</name></expr></argument>, <argument><expr><name>ResourceTypeResnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_resourcetype</name></type> <name>rtype</name> <init>= <expr><operator>(</operator><name>Form_pg_resourcetype</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>pOidOut</name> <operator>=</operator> <name><name>rtype</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pTypeOut</name> <operator>=</operator> <name><name>rtype</name><operator>-&gt;</operator><name>restypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bStat</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_resourcetype</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>bStat</name><operator>)</operator></expr>;</return>
</block_content>}</block></function> <comment type="block">/* end GetResourceTypeByName */</comment>

<function><type><specifier>static</specifier> 
<name>bool</name></type> <name>ValidPriority</name><parameter_list>(<parameter><decl><type><name>char</name>			<modifier>*</modifier></type><name>pResSetting</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>priority_vals</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"MAX"</literal></expr>,
							 <expr><literal type="string">"HIGH"</literal></expr>,
							 <expr><literal type="string">"MEDIUM"</literal></expr>,
							 <expr><literal type="string">"LOW"</literal></expr>,
							 <expr><literal type="string">"MIN"</literal></expr>,
							 <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ii</name>				  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pval</name> <init>= <expr><name><name>priority_vals</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt> 

	<while>while <condition>(<expr><name>pval</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>pval</name></expr></argument>, <argument><expr><name>pResSetting</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pval</name> <operator>=</operator> <name><name>priority_vals</name><index>[<expr><operator>++</operator><name>ii</name></expr>]</index></name></expr>;</expr_stmt> 
	</block_content>}</block></while>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Validate memory limit setting.
 */</comment>
<function><type><specifier>static</specifier> 
<name>bool</name></type> <name>ValidMemoryLimit</name><parameter_list>(<parameter><decl><type><name>char</name>			<modifier>*</modifier></type><name>pResSetting</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>valueKB</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>restyp</name> <init>= <expr><literal type="string">"MEMORY_LIMIT"</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name>parse_int</name><argument_list>(<argument><expr><name>pResSetting</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valueKB</name></expr></argument>, <argument><expr><name>GUC_UNIT_KB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid parameter value \"%s\" for "</literal>
						<literal type="string">"resource type \"%s\". "</literal>
						<literal type="string">"Value must be in kB, MB or GB."</literal></expr></argument>,
						<argument><expr><name>pResSetting</name></expr></argument>, <argument><expr><name>restyp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>valueKB</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>valueKB</name> <operator>&lt;</operator> <name>MIN_RESOURCEQUEUE_MEMORY_LIMIT_KB</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid parameter value \"%s\" for "</literal>
						<literal type="string">"resource type \"%s\". "</literal>
						<literal type="string">"Value must be at least %dkB"</literal></expr></argument>,
						<argument><expr><name>pResSetting</name></expr></argument>, <argument><expr><name>restyp</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MIN_RESOURCEQUEUE_MEMORY_LIMIT_KB</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
	</block_content>}</block></if></if_stmt>
	
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ValidateResqueueCapabilityEntry
 *
 * Validate the resource setting for a pg_resqueuecapability entry.
 * Insert calls to separate per-resourcetype validation functions
 * here.
 */</comment>
<function><type><specifier>static</specifier>
<name>void</name></type> <name>ValidateResqueueCapabilityEntry</name><parameter_list>(<parameter><decl><type><name>int</name></type>			 <name>resTypeInt</name></decl></parameter>,
									 <parameter><decl><type><name>char</name>			<modifier>*</modifier></type><name>pResSetting</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		 <name>bValid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>restyp</name> <init>= <expr><literal type="string">"unknown"</literal></expr></init></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><name>resTypeInt</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_RESRCTYPE_ACTIVE_STATEMENTS</name></expr>:</case><comment type="block">/* rsqcountlimit: count  */</comment>
		<case>case <expr><name>PG_RESRCTYPE_MAX_COST</name></expr>:</case>			<comment type="block">/* rsqcostlimit: max_cost */</comment>
		<case>case <expr><name>PG_RESRCTYPE_MIN_COST</name></expr>:</case>			<comment type="block">/* rsqignorecostlimit: min_cost */</comment>
		<case>case <expr><name>PG_RESRCTYPE_COST_OVERCOMMIT</name></expr>:</case>	<comment type="block">/* rsqovercommit: cost_overcommit*/</comment>
			<break>break;</break>

		<comment type="block">/* start of "pg_resourcetype" entries... */</comment>
		<case>case <expr><name>PG_RESRCTYPE_PRIORITY</name></expr>:</case>			<comment type="block">/* backoff.c: priority queue */</comment>
			<expr_stmt><expr><name>bValid</name> <operator>=</operator> <call><name>ValidPriority</name><argument_list>(<argument><expr><name>pResSetting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>restyp</name> <operator>=</operator> <literal type="string">"PRIORITY"</literal></expr>;</expr_stmt>
			<break>break;</break>				

		<case>case <expr><name>PG_RESRCTYPE_MEMORY_LIMIT</name></expr>:</case>
			<expr_stmt><expr><name>bValid</name> <operator>=</operator> <call><name>ValidMemoryLimit</name><argument_list>(<argument><expr><name>pResSetting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>restyp</name> <operator>=</operator> <literal type="string">"MEMORY_LIMIT"</literal></expr>;</expr_stmt>
						
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown resource type \"%d\""</literal></expr></argument>,
							<argument><expr><name>resTypeInt</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
	</block_content>}</block></switch>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bValid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid parameter value \"%s\" for "</literal>
						<literal type="string">"resource type \"%s\""</literal></expr></argument>,
						<argument><expr><name>pResSetting</name></expr></argument>, <argument><expr><name>restyp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<comment type="block">/* MPP-6923: */</comment>
<comment type="block">/* AddUpdResqueueCapabilityEntryInternal:
 *
 * Internal function to add a new entry to pg_resqueuecapability, or
 * update an existing one.  Key cols are queueid, restypint.  If
 * old_tuple is set (ie not InvalidOid), the update the ressetting column,
 * else insert a new row.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddUpdResqueueCapabilityEntryInternal</name><parameter_list>(
								  <parameter><decl><type><name>Relation</name></type>		 <name>resqueuecap_rel</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type>			 <name>queueid</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type>			 <name>resTypeInt</name></decl></parameter>,
								  <parameter><decl><type><name>char</name>			<modifier>*</modifier></type><name>pResSetting</name></decl></parameter>,
								  <parameter><decl><type><name>Relation</name></type>		 <name>rel</name></decl></parameter>,
								  <parameter><decl><type><name>HeapTuple</name></type>		 <name>old_tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_resqueuecapability</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>Natts_pg_resqueuecapability</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_record_repl</name><index>[<expr><name>Natts_pg_resqueuecapability</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>Natts_pg_resqueuecapability</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record_repl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>Natts_pg_resqueuecapability</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_resqueuecapability_resqueueid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>  <operator>=</operator> 
			<call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_resqueuecapability_restypid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>   <operator>=</operator> <name>resTypeInt</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pResSetting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_resqueuecapability_ressetting</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
			<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>pResSetting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set this column to update */</comment>
	<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_resqueuecapability_ressetting</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ValidateResqueueCapabilityEntry</name><argument_list>(<argument><expr><name>resTypeInt</name></expr></argument>, <argument><expr><name>pResSetting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>old_tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>old_tuple</name></expr></argument>,
									  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resqueuecap_rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>new_record_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>resqueuecap_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>old_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resqueuecap_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>resqueuecap_rel</name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>old_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function> <comment type="block">/* end AddUpdResqueueCapabilityEntryInternal */</comment>
				
<comment type="block">/* MPP-6923: */</comment>				  
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterResqueueCapabilityEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>queueid</name></decl></parameter>,
							 <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>initcell</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>bCreate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>elems</name>	   <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>dropelems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>dupcheck</name>  <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	 <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	 <name>rel</name>	   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		 <name>bWithout</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	 <name>tupdesc</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>initcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"withliststart"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>initcell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>initcell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* walk the original list and build a list of valid entries */</comment>

	<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>initcell</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name>		<init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>		 <name>resTypeOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		 <name>resTypeInt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	<modifier>*</modifier></type><name>pentry</name>		<init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Value</name>	<modifier>*</modifier></type><name>pKeyVal</name>	<init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Value</name>	<modifier>*</modifier></type><name>pStrVal</name>	<init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bWithout</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"withoutliststart"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bWithout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ResourceTypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<goto>goto <name>L_loop_cont</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* ignore the basic threshold entries -- should already be processed */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"active_statements"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>L_loop_cont</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"max_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>L_loop_cont</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cost_overcommit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>L_loop_cont</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"min_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>L_loop_cont</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetResourceTypeByName</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resTypeInt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resTypeOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option \"%s\" is not a valid resource type"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pKeyVal</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* WITHOUT clause value determined in pg_resourcetype */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bWithout</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pStrVal</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pStrVal</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* if NULL, delete entry from
							 * pg_resqueuecapability 
							 */</comment>
			<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
						<argument><expr><name>Anum_pg_resourcetype_restypid</name></expr></argument>,
						<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
						<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>resTypeInt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ResourceTypeRestypidIndexId</name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shutoff_str</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>shutoff_datum</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_resourcetype</name></type> <name>rtyp</name> <init>= 
						<expr><operator>(</operator><name>Form_pg_resourcetype</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rtyp</name><operator>-&gt;</operator><name>reshasdisable</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option \"%s\" cannot be disabled"</literal></expr></argument>,
									<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* required type must have a default value if it can
				 * be disabled 
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rtyp</name><operator>-&gt;</operator><name>reshasdefault</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rtyp</name><operator>-&gt;</operator><name>resrequired</name></name></expr>)</condition><block type="pseudo"><block_content>
						<comment type="block">/* optional resource without a default is
						 * turned off by removing entry from
						 * pg_resqueuecapability 
						 */</comment>
						<break>break;</break></block_content></block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* XXX XXX */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"required option \"%s\" cannot be disabled"</literal></expr></argument>,
										<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* get the shutoff string */</comment>
				<expr_stmt><expr><name>shutoff_datum</name> <operator>=</operator> 
						<call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
									 <argument><expr><name>Anum_pg_resourcetype_resdisabledsetting</name></expr></argument>,
									 <argument><expr><name>tupdesc</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>shutoff_str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>shutoff_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>pStrVal</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>shutoff_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></while> <comment type="block">/* end while heaptuple is valid */</comment>
			<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* check for duplicate key specifications */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>dupcheck</name></expr></argument>, <argument><expr><name>pKeyVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant option for \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>dupcheck</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dupcheck</name></expr></argument>, <argument><expr><name>pKeyVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pentry</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(
							<argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name>resTypeInt</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>pStrVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* list of lists - (resource type, resource setting) */</comment>
		<if_stmt><if>if <condition>(<expr><name>bWithout</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if the "without" entry has an "off" value, then treat
			 * it as a regular "with" item and update it in
			 * pg_resqueuecapability, else remove its entry
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pStrVal</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dropelems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropelems</name></expr></argument>, <argument><expr><name>pentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>pentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>pentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<label><name>L_loop_cont</name>:</label>
		<expr_stmt><expr><name>resTypeInt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* make compiler happy */</comment>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>bWithout</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* close pg_resourcetype */</comment>

	<if_stmt><if>if <condition>(<expr><name>bCreate</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>

		<comment type="block">/* If creating a new resource queue, check pg_resourcetype for
		 * optional types that have a default value.  Check for
		 * corresponding match in dupcheck -- if no entry then add the
		 * one to the WITH list (elems) with the default. 
		 */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ResourceTypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Note: key is empty - scan entire table */</comment>

		<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pentry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>pResnameVal</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>default_str</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>default_datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_resourcetype</name></type> <name>rtyp</name> <init>= 
					<expr><operator>(</operator><name>Form_pg_resourcetype</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* only interested in resources types with default value */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rtyp</name><operator>-&gt;</operator><name>reshasdefault</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Note: ignore the dummy entries for active_statements,
			 * max_cost, etc 
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rtyp</name><operator>-&gt;</operator><name>restypid</name></name> <operator>&lt;</operator> <name>PG_RESRCTYPE_PRIORITY</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* if resource has a default value, see if it was already
			 * specified 
			 */</comment>
			<expr_stmt><expr><name>pResnameVal</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>rtyp</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>dupcheck</name></expr></argument>, <argument><expr><name>pResnameVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* resource was not specified, so add its default value to
			 * the WITH list 
			 */</comment>

			<comment type="block">/* get the default string */</comment>
			<expr_stmt><expr><name>default_datum</name> <operator>=</operator> 
					<call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								 <argument><expr><name>Anum_pg_resourcetype_resdefaultsetting</name></expr></argument>,
								 <argument><expr><name>tupdesc</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>default_str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>default_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* add the new entry to dupcheck and WITH elems */</comment>
			<expr_stmt><expr><name>dupcheck</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dupcheck</name></expr></argument>, <argument><expr><name>pResnameVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pentry</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name><name>rtyp</name><operator>-&gt;</operator><name>restypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>default_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>pentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while> <comment type="block">/* end while heaptuple is valid */</comment>
		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* close pg_resourcetype */</comment>
	</block_content>}</block></if></if_stmt> <comment type="block">/* end if bCreate */</comment>

	<comment type="block">/* insert/update valid entries in pg_resqueuecapability */</comment>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueCapabilityRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>elems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>		<modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>			<modifier>*</modifier></type><name>pentry</name>		 <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>				 <name>resTypeInt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>			<modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>			<modifier>*</modifier></type><name>pResSetting</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>				 <name>ii</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><literal type="number">2</literal> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pentry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>pentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>resTypeInt</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pResSetting</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
					<argument><expr><name>Anum_pg_resqueuecapability_resqueueid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ResQueueCapabilityResqueueidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>resTypeInt</name> <operator>==</operator>
					<operator>(</operator><operator>(</operator><name>Form_pg_resqueuecapability</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>restypid</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* found it -- update it */</comment>
					<expr_stmt><expr><call><name>AddUpdResqueueCapabilityEntryInternal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>queueid</name></expr></argument>,
														  <argument><expr><name>resTypeInt</name></expr></argument>,
														  <argument><expr><name>pResSetting</name></expr></argument>,
														  <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ii</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ii</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* does not exist -- add it */</comment>
			<expr_stmt><expr><call><name>AddUpdResqueueCapabilityEntryInternal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
												  <argument><expr><name>queueid</name></expr></argument>,
												  <argument><expr><name>resTypeInt</name></expr></argument>,
												  <argument><expr><name>pResSetting</name></expr></argument>,
												  <argument><expr><name>rel</name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* InvalidOid */</comment>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block> <comment type="block">/* end foreach elem */</comment>


	<comment type="block">/* drop these items here */</comment>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dropelems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>		<modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>			<modifier>*</modifier></type><name>pentry</name>		 <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>				 <name>resTypeInt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>			<modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>				 <name>ii</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type>	 <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type>	 <name>scan</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><literal type="number">2</literal> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pentry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>pentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>resTypeInt</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* CaQL UNDONE: no test coverage */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_resqueuecapability_resqueueid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								  <argument><expr><name>ResQueueCapabilityResqueueidIndexId</name></expr></argument>,
								  <comment type="block">/* XXX XXX XXX XXX : snapshotnow ? */</comment>
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>resTypeInt</name> <operator>==</operator>
					<operator>(</operator><operator>(</operator><name>Form_pg_resqueuecapability</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>restypid</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* no "off" setting -- just remove entry */</comment>
					<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ii</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

	</block_content>}</block> <comment type="block">/* end foreach elem */</comment>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function> <comment type="block">/* end AlterResqueueCapabilityEntry */</comment>

<comment type="block">/* MPP-6923: */</comment>				  
<function><type><name>List</name> <modifier>*</modifier></type> 
<name>GetResqueueCapabilityEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>  <name>queueid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>elems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	 <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	 <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	 <name>tupdesc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* SELECT * FROM pg_resqueuecapability WHERE resqueueid = :1 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueCapabilityRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_resqueuecapability_resqueueid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ResQueueCapabilityResqueueidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pentry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>resTypeInt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>resSet_datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resSetting</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>resTypeInt</name> <operator>=</operator>
					<operator>(</operator><operator>(</operator><name>Form_pg_resqueuecapability</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>restypid</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>resSet_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
										<argument><expr><name>Anum_pg_resqueuecapability_ressetting</name></expr></argument>,
										<argument><expr><name>tupdesc</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resSetting</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>resSet_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pentry</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(
					<argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name>resTypeInt</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>resSetting</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* list of lists */</comment>
			<expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>pentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><operator>(</operator><name>elems</name><operator>)</operator></expr>;</return>
</block_content>}</block></function> <comment type="block">/* end GetResqueueCapabilityEntry */</comment>

<comment type="block">/*
 * CREATE RESOURCE QUEUE
 */</comment>
<function><type><name>void</name></type>
<name>CreateQueue</name><parameter_list>(<parameter><decl><type><name>CreateQueueStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_resqueue_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>pg_resqueue_dsc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>queueid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name><name>thresholds</name><index>[<expr><name>NUM_RES_LIMIT_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>new_record</name><index>[<expr><name>Natts_pg_resqueue</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_record_nulls</name><index>[<expr><name>Natts_pg_resqueue</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>pWithList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* thresholds for active and cost limiters. */</comment>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>activelimit</name> <init>= <expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></init></decl>;</decl_stmt>	
	<decl_stmt><decl><type><name>Cost</name></type>		<name>costlimit</name>	<init>= <expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* overcommit indicator */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>overcommit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* cost ignore limit for queries */</comment>
	<decl_stmt><decl><type><name>float4</name></type>		<name>ignorelimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DefElem</name>     <modifier>*</modifier></type><name>dactivelimit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>     <modifier>*</modifier></type><name>dcostlimit</name>	  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>     <modifier>*</modifier></type><name>dovercommit</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>     <modifier>*</modifier></type><name>dignorelimit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		 <name>queueok</name>	  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		 <name>bWith</name>		  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Permission check - only superuser can create queues. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to create resource queues"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Extract options from the statement node tree */</comment>
	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"active_statements"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dactivelimit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>dactivelimit</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"max_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dcostlimit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>dcostlimit</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cost_overcommit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dovercommit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>dovercommit</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"min_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dignorelimit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>dignorelimit</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"withliststart"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't allow a "with list entry" with this defname... */</comment>
			<if_stmt><if>if <condition>(<expr><name>bWith</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option \"%s\" is not a valid resource type"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* marks start of WITH options... */</comment>
			<expr_stmt><expr><name>pWithList</name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bWith</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* silently ignore options on WITH list -- will deal with
			 * them later in AlterResqueueCapabilityEntry 
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bWith</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
					 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Perform range checks on the various thresholds.*/</comment>
	<if_stmt><if>if <condition>(<expr><name>dactivelimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>activelimit</name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <call><name>defGetInt64</name><argument_list>(<argument><expr><name>dactivelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>activelimit</name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name> <operator>||</operator> <operator>(</operator><name>activelimit</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"active threshold cannot be less than %d or equal to 0"</literal></expr></argument>, 
							<argument><expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dcostlimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>costlimit</name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <call><name>defGetNumeric</name><argument_list>(<argument><expr><name>dcostlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>costlimit</name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name> <operator>||</operator> <operator>(</operator><name>costlimit</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cost threshold cannot be less than %d or equal to 0"</literal></expr></argument>, 
							<argument><expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>dovercommit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>overcommit</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>dovercommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>dignorelimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ignorelimit</name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <call><name>defGetNumeric</name><argument_list>(<argument><expr><name>dignorelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ignorelimit</name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name> <operator>||</operator> <operator>(</operator><name>ignorelimit</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"min_cost threshold cannot be negative"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * Check that at least one threshold is to be set.
	 */</comment>
	<if_stmt><if>if <condition>( <expr><operator>!</operator><name>dactivelimit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dcostlimit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"at least one threshold (\"ACTIVE_STATEMENTS\", \"MAX_COST\") must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check all thresholds are not invalid. */</comment>
	<if_stmt><if>if <condition>(<expr><name>activelimit</name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name> <operator>&amp;&amp;</operator>
		<name>costlimit</name>   <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the value for at least one threshold (\"ACTIVE_STATEMENTS\", \"MAX_COST\") must be different from no limit (%d)"</literal></expr></argument>,
						 <argument><expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for an illegal name ('none' is used to signify no queue in ALTER
	 * ROLE).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_RESERVED_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue name \"%s\" is reserved"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check the pg_resqueue relation to be certain the queue doesn't already
	 * exist. 
	 */</comment>
	<expr_stmt><expr><name>pg_resqueue_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_resqueue_dsc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/**
	 * Get database locks in anticipation that we'll need to access
	 * this catalog table later.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>resqueueCapabilityRel</name> <init>= 
			<expr><call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueCapabilityRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_resqueue_rsqname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><name>ResQueueRsqnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a tuple to insert
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record_nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record_nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_rsqname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_rsqcountlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
		<call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>activelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_rsqcostlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
		<call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>costlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_rsqovercommit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
		<call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>overcommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_rsqignorecostlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
		<call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>ignorelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>queueid</name> <operator>=</operator> <call><name>GetNewOidForResQueue</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><name>ResQueueOidIndexId</name></expr></argument>, <argument><expr><name>Anum_pg_resqueue_oid</name></expr></argument>,
								   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_oid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>queueid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>pg_resqueue_dsc</name></expr></argument>, <argument><expr><name>new_record</name></expr></argument>, <argument><expr><name>new_record_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert new record in the pg_resqueue table
	 */</comment>
	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* process the remainder of the WITH (...) list items */</comment>
	<if_stmt><if>if <condition>(<expr><name>bWith</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AlterResqueueCapabilityEntry</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>, <argument><expr><name>pWithList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* 
	 * We must bump the command counter to make the new entry 
	 * in the pg_resqueuecapability table visible 
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the in-memory resource queue, if resource scheduling is on,
	 * otherwise don't - and gripe a little about it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsResQueueEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name>	 <operator>=</operator> <name>activelimit</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name>	 <operator>=</operator> <name>costlimit</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_MEMORY_LIMIT</name></expr>]</index></name> <operator>=</operator> 
					<call><name>ResourceQueueGetMemoryLimit</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>queueok</name>	<operator>=</operator> <call><name>ResCreateQueue</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>, 
									 <argument><expr><name>thresholds</name></expr></argument>, 
									 <argument><expr><name>overcommit</name></expr></argument>, 
									 <argument><expr><name>ignorelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queueok</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient resource queues available"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase max_resource_queues"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue is disabled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable set gp_resource_manager=queue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* MPP-6929, MPP-7583: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name><operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name><operator>|</operator>
									<name>DF_NEED_TWO_PHASE</name></expr></argument>,
									<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MetaTrackAddObject</name><argument_list>(<argument><expr><name>ResQueueRelationId</name></expr></argument>,
						   <argument><expr><name>queueid</name></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <comment type="block">/* not ownerid */</comment>
						   <argument><expr><literal type="string">"CREATE"</literal></expr></argument>, <argument><expr><literal type="string">"RESOURCE QUEUE"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>resqueueCapabilityRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER RESOURCE QUEUE
 */</comment>
<function><type><name>void</name></type>
<name>AlterQueue</name><parameter_list>(<parameter><decl><type><name>AlterQueueStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_resqueue_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>pg_resqueue_dsc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>, <decl><type ref="prev"/><name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>queueid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name><name>thresholds</name><index>[<expr><name>NUM_RES_LIMIT_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>new_record</name><index>[<expr><name>Natts_pg_resqueue</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_record_nulls</name><index>[<expr><name>Natts_pg_resqueue</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_record_repl</name><index>[<expr><name>Natts_pg_resqueue</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>pWithList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* thresholds for active and cost limiters. */</comment>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>activelimit</name> <init>= <expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>costlimit</name>	<init>= <expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* overcommit indicator */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>overcommit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* cost ignore limit for queries */</comment>
	<decl_stmt><decl><type><name>float4</name></type>		<name>ignorelimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DefElem</name>     <modifier>*</modifier></type><name>dactivelimit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>     <modifier>*</modifier></type><name>dcostlimit</name>	  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>     <modifier>*</modifier></type><name>dovercommit</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>     <modifier>*</modifier></type><name>dignorelimit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResAlterQueueResult</name></type>		<name>queueok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		 <name>bWith</name>		   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		 <name>bWithOut</name>	   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			 <name>numopts</name>	   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>alter_subtype</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* metadata tracking: kind of
										   redundant to say "role" */</comment>

	<comment type="block">/* Permission check - only superuser can alter queues. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to alter resource queues"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Extract options from the statement node tree */</comment>
	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"active_statements"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dactivelimit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bWithOut</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dactivelimit</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dactivelimit</name> <operator>=</operator> 
						<call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"active_statements"</literal></expr></argument>, 
									<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
									<call><name>makeFloat</name><argument_list>(<argument><expr><name>INVALID_RES_LIMIT_STRING</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>numopts</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>alter_subtype</name> <operator>=</operator> <name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"max_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dcostlimit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bWithOut</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dcostlimit</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dcostlimit</name> <operator>=</operator> 
						<call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"max_cost"</literal></expr></argument>, 
									<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
									<call><name>makeInteger</name><argument_list>(<argument><expr><name>costlimit</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>numopts</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>alter_subtype</name> <operator>=</operator> <name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cost_overcommit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dovercommit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bWithOut</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dovercommit</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dovercommit</name> <operator>=</operator> 
						<call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"cost_overcommit"</literal></expr></argument>, 
									<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
									<call><name>makeInteger</name><argument_list>(<argument><expr><name>overcommit</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>numopts</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>alter_subtype</name> <operator>=</operator> <name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"min_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dignorelimit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bWithOut</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dignorelimit</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dignorelimit</name> <operator>=</operator> 
						<call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"min_cost"</literal></expr></argument>, 
									<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
									<call><name>makeFloat</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* MPP-7817 */</comment>
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>numopts</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>alter_subtype</name> <operator>=</operator> <name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr>;</expr_stmt>

		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"withliststart"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't allow a "with list entry" with this defname... */</comment>
			<if_stmt><if>if <condition>(<expr><name>bWith</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option \"%s\" is not a valid resource type"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* marks start of WITH options... */</comment>
			<expr_stmt><expr><name>pWithList</name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bWith</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"withoutliststart"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't allow a "with out list entry" with this defname... */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bWith</name> <operator>||</operator> <name>bWithOut</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option \"%s\" is not a valid resource type"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* marks start of WITHOUT options... */</comment>
			<expr_stmt><expr><name>bWithOut</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* silently ignore options on WITH list -- will deal with
			 * them later in AlterResqueueCapabilityEntry 
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bWith</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
					 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>numopts</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>alter_subtype</name> <operator>=</operator> <name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>numopts</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>allopts</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>allopts</name></expr></argument>, <argument><expr><literal type="string">"%d OPTIONS"</literal></expr></argument>, <argument><expr><name>numopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>alter_subtype</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>allopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>numopts</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>alter_subtype</name> <operator>=</operator> <literal type="string">"0 OPTIONS"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tempo</name> <init>= <expr><call><name>asc_toupper</name><argument_list>(<argument><expr><name>alter_subtype</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alter_subtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>alter_subtype</name> <operator>=</operator> <name>tempo</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Perform range checks on the various thresholds. */</comment>
	<if_stmt><if>if <condition>(<expr><name>dactivelimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>activelimit</name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <call><name>defGetInt64</name><argument_list>(<argument><expr><name>dactivelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>activelimit</name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name> <operator>||</operator> <operator>(</operator><name>activelimit</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"active threshold cannot be less than %d or equal to 0"</literal></expr></argument>, 
							<argument><expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dcostlimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>costlimit</name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <call><name>defGetNumeric</name><argument_list>(<argument><expr><name>dcostlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>costlimit</name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name> <operator>||</operator> <operator>(</operator><name>costlimit</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cost threshold must be equal to %d or greater than 0"</literal></expr></argument>, 
							<argument><expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dovercommit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>overcommit</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>dovercommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>dignorelimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ignorelimit</name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <call><name>defGetNumeric</name><argument_list>(<argument><expr><name>dignorelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ignorelimit</name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name> <operator>||</operator> 
			  <operator>(</operator><name>ignorelimit</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"min_cost threshold cannot be negative"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that at least one threshold is to be set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dactivelimit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dcostlimit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dovercommit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dignorelimit</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>		<modifier>*</modifier></type><name>initcell</name> <init>= <expr><name>pWithList</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>bWith</name> <operator>&amp;&amp;</operator> <name>initcell</name> <operator>&amp;&amp;</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>initcell</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if have an item on the "with list", don't need to set a
			 * threshold 
			 */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"at least one threshold, overcommit or ignore limit must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check the pg_resqueue relation to be certain the queue already
	 * exists. 
	 */</comment>
	<expr_stmt><expr><name>pg_resqueue_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/**
	 * Get database locks in anticipation that we'll need to access this catalog table later.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>resqueueCapabilityRel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueCapabilityRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>pg_resqueue_dsc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_resqueue_rsqname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><name>ResQueueRsqnameIndexId</name></expr></argument>,
							   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remember the Oid and current thresholds, for updating the in-memory
	 * queue later.
	 */</comment>
	<expr_stmt><expr><name>queueid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_resqueue</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name> <operator>=</operator> 
		<operator>(</operator><operator>(</operator><name>Form_pg_resqueue</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rsqcountlimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name> <operator>=</operator> 
		<operator>(</operator><operator>(</operator><name>Form_pg_resqueue</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rsqcostlimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_MEMORY_LIMIT</name></expr>]</index></name> <operator>=</operator> <call><name>ResourceQueueGetMemoryLimit</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also set overcommit if it was *not* specified. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dovercommit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>overcommit</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_resqueue</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rsqovercommit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also set ignore cost limit if it was *not* specified. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dignorelimit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ignorelimit</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_resqueue</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rsqignorecostlimit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/*
	 * Build a tuple to update.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record_nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record_nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dactivelimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_rsqcountlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
			<call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>activelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_resqueue_rsqcountlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name> <operator>=</operator> <name>activelimit</name></expr>;</expr_stmt>
		
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dcostlimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_rsqcostlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
			<call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>costlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_resqueue_rsqcostlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name> <operator>=</operator> <name>costlimit</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dovercommit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_rsqovercommit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
			<call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>overcommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_resqueue_rsqovercommit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dignorelimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_resqueue_rsqignorecostlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
			<call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>ignorelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_resqueue_rsqignorecostlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * Check we are not going to set all the thresholds to be invalid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>thresholds</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name> <operator>&amp;&amp;</operator>
		<name><name>thresholds</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the value for at least one threshold (\"ACTIVE_STATEMENTS\", \"MAX_COST\") must be different from no limit (%d)"</literal></expr></argument>,
						<argument><expr><name>INVALID_RES_LIMIT_THRESHOLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * update the tuple in the pg_resqueue table
	 */</comment>
	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>pg_resqueue_dsc</name></expr></argument>, <argument><expr><name>new_record</name></expr></argument>,
									<argument><expr><name>new_record_nulls</name></expr></argument>, <argument><expr><name>new_record_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* process the remainder of the WITH (...) list items */</comment>
	<if_stmt><if>if <condition>(<expr><name>bWith</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AlterResqueueCapabilityEntry</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>, <argument><expr><name>pWithList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* 
	 * We must bump the command counter to make the altered memory limit 
	 * in the pg_resqueuecapability table visible 
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/** Get new memory limit if changed */</comment>
	<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_MEMORY_LIMIT</name></expr>]</index></name> <operator>=</operator> <call><name>ResourceQueueGetMemoryLimit</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If resource scheduling is on, see if we can change the threshold(s)
	 * for the in-memory queue.
	 * otherwise don't - and gripe a little about it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsResQueueEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>queueok</name> <operator>=</operator> <call><name>ResAlterQueue</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>, 
									<argument><expr><name>thresholds</name></expr></argument>, 
									<argument><expr><name>overcommit</name></expr></argument>, 
									<argument><expr><name>ignorelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<if_stmt><if>if <condition>(<expr><name>queueok</name> <operator>!=</operator> <name>ALTERQUEUE_OK</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>queueok</name> <operator>==</operator> <name>ALTERQUEUE_SMALL_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_LIMIT_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"thresholds cannot be less than current values"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>queueok</name> <operator>==</operator> <name>ALTERQUEUE_OVERCOMMITTED</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_LIMIT_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling overcommit cannot leave queue in possibly overcommitted state"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"queue hash table corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			</block_content>}</block></if></if_stmt>

		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue is disabled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable set gp_resource_manager=queue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>resqueueCapabilityRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929, MPP-7583: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name><operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name><operator>|</operator>
									<name>DF_NEED_TWO_PHASE</name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>ResQueueRelationId</name></expr></argument>,
						   <argument><expr><name>queueid</name></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <comment type="block">/* not ownerid */</comment>
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><name>alter_subtype</name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DROP RESOURCE QUEUE
 */</comment>
<function><type><name>void</name></type>
<name>DropQueue</name><parameter_list>(<parameter><decl><type><name>DropQueueStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	 <name>pg_resqueue_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	 <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>authid_scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>authid_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			 <name>queueid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		 <name>queueok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


	<comment type="block">/* Permission check - only superuser can drop queues. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to drop resource queues"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/*
	 * Check the pg_resqueue relation to be certain the queue already
	 * exists. 
	 */</comment>
	<expr_stmt><expr><name>pg_resqueue_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block" format="doxygen">/**
	 * Get database locks in anticipation that we'll need to access this catalog table later.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>resqueueCapabilityRel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueCapabilityRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_resqueue_rsqname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><name>ResQueueRsqnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remember the Oid, for destroying the in-memory
	 * queue later.
	 */</comment>
	<expr_stmt><expr><name>queueid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_resqueue</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to see if any roles are in this queue.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>authIdRel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>authid_scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_authid_rolresqueue</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>authid_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>authIdRel</name></expr></argument>, <argument><expr><name>AuthIdRolResQueueIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>authid_scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>authid_scan</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue \"%s\" is used by at least one role"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* MPP-6926: cannot DROP default queue  */</comment>
	<if_stmt><if>if <condition>(<expr><name>queueid</name> <operator>==</operator> <name>DEFAULTRESQUEUE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop default resource queue \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>authid_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>authIdRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete the queue from the catalog.
	 */</comment>
	<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If resource scheduling is on, see if we can destroy the in-memory queue.
	 * otherwise don't - and gripe a little about it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsResQueueEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>queueok</name> <operator>=</operator> <call><name>ResDestroyQueue</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queueok</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue cannot be dropped as is in use"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue is disabled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable set gp_resource_manager=queue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remove any comments on this resource queue
	 */</comment>
	<expr_stmt><expr><call><name>DeleteSharedComments</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>, <argument><expr><name>ResQueueRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name><operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name><operator>|</operator>
									<name>DF_NEED_TWO_PHASE</name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* MPP-6929, MPP-7583: metadata tracking */</comment>
	<expr_stmt><expr><call><name>MetaTrackDropObject</name><argument_list>(<argument><expr><name>ResQueueRelationId</name></expr></argument>,
						<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6923: drop the extended attributes for this queue */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_resqueuecapability_resqueueid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>resqueueCapabilityRel</name></expr></argument>, <argument><expr><name>ResQueueCapabilityResqueueidIndexId</name></expr></argument>,
							   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>resqueueCapabilityRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>resqueueCapabilityRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_resqueue_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>get_resqueue_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queuename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type>	<name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>, <argument><expr><name>Anum_pg_resqueue_rsqname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>queuename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ResQueueRsqnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_resqueue</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource queue \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>queuename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>oid</name></expr>;</return>
</block_content>}</block></function>
</unit>
