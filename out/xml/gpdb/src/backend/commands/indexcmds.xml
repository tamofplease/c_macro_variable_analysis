<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/indexcmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * indexcmds.c
 *	  POSTGRES define and remove index code.
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/indexcmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/aoblkdir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbcat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdboidsync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbrelsize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckPredicate</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ComputeIndexAttrs</name><parameter_list>(<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeOidP</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collationOidP</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>classOidP</name></decl></parameter>,
				  <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>colOptionP</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attList</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exclusionOpNames</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>accessMethodName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>amcanorder</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>isconstraint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ChooseIndexNameAddition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForReindexIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
											<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReindexRelationConcurrently</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReindexPartitions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>concurrent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReindexMultipleInternal</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>concurrent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reindex_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_relispartition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newval</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * callback argument type for RangeVarCallbackForReindexIndex()
 */</comment>
<struct>struct <name>ReindexIndexCallbackState</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>concurrent</name></decl>;</decl_stmt>		<comment type="block">/* flag from statement */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>locked_table_oid</name></decl>;</decl_stmt>	<comment type="block">/* tracks previously locked table */</comment>
}</block>;</struct>


<comment type="block">/*
 * Helper function, to check indcheckxmin for an index on all segments, and
 * set it on the master if it was set on any segment.
 *
 * If CREATE INDEX creates a "broken" HOT chain, the new index must not be
 * used by new queries, with an old snapshot, that would need to see the old
 * values. See src/backend/access/heap/README.HOT. This is enforced by
 * setting indcheckxmin in the pg_index row. In GPDB, we use the pg_index
 * row in the master for planning, but all the data is stored in the
 * segments, so indcheckxmin must be set in the master, if it's set in any
 * of the segments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdb_sync_indcheckxmin_with_segments</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPgResults</name></type> <name>cdb_pgresults</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>indcheckxmin_set_in_any_segment</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Query all the segments, for their indcheckxmin value for this index.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"select indcheckxmin from pg_catalog.pg_index where indexrelid = '%u'"</literal></expr></argument>,
			 <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CdbDispatchCommand</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>DF_WITH_SNAPSHOT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indcheckxmin_set_in_any_segment</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdb_pgresults</name><operator>.</operator><name>numResults</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not fetch indcheckxmin from segment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>PQnfields</name><argument_list>(<argument><expr><name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected shape of result set for indcheckxmin query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>indcheckxmin_set_in_any_segment</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid boolean value received from segment: %s"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If indcheckxmin was set on any segment, also set it in the master.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>indcheckxmin_set_in_any_segment</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indcheckxmin</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indcheckxmin</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * callback arguments for reindex_error_callback()
 */</comment>
<typedef>typedef <type><struct>struct <name>ReindexErrorInfo</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReindexErrorInfo</name>;</typedef>

<comment type="block">/*
 * CheckIndexCompatible
 *		Determine whether an existing index definition is compatible with a
 *		prospective index definition, such that the existing index storage
 *		could become the storage of the new index, avoiding a rebuild.
 *
 * 'heapRelation': the relation the index would apply to.
 * 'accessMethodName': name of the AM to use.
 * 'attributeList': a list of IndexElem specifying columns and expressions
 *		to index on.
 * 'exclusionOpNames': list of names of exclusion-constraint operators,
 *		or NIL if not an exclusion constraint.
 *
 * This is tailored to the needs of ALTER TABLE ALTER TYPE, which recreates
 * any indexes that depended on a changing column from their pg_get_indexdef
 * or pg_get_constraintdef definitions.  We omit some of the sanity checks of
 * DefineIndex.  We assume that the old and new indexes have the same number
 * of columns and that if one has an expression column or predicate, both do.
 * Errors arising from the attribute list still apply.
 *
 * Most column type changes that can skip a table rewrite do not invalidate
 * indexes.  We acknowledge this when all operator classes, collations and
 * exclusion operators match.  Though we could further permit intra-opfamily
 * changes for btree and hash indexes, that adds subtle complexity with no
 * concrete benefit for core types. Note, that INCLUDE columns aren't
 * checked by this function, for them it's enough that table rewrite is
 * skipped.
 *
 * When a comparison or exclusion operator has a polymorphic input type, the
 * actual input types must also match.  This defends against the possibility
 * that operators could vary behavior in response to get_fn_expr_argtype().
 * At present, this hazard is theoretical: check_exclusion_constraint() and
 * all core index access methods decline to set fn_expr for such calls.
 *
 * We do not yet implement a test to verify compatibility of expression
 * columns or predicates, so assume any such index is incompatible.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckIndexCompatible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>accessMethodName</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeList</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exclusionOpNames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isconstraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>typeObjectId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>collationObjectId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>classObjectId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>accessMethodId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_am</name></type>	<name>accessMethodForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amRoutine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>amcanorder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>coloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>old_indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>old_indcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>irel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

	<comment type="block">/* Caller should already have the relation locked in some way. */</comment>
	<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can pretend isconstraint = false unconditionally.  It only serves to
	 * decide the text of an error message that should never happen for us.
	 */</comment>
	<expr_stmt><expr><name>isconstraint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>numberOfAttributes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attributeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>&lt;=</operator> <name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* look up the access method */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>accessMethodForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>accessMethodId</name> <operator>=</operator> <name><name>accessMethodForm</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>amRoutine</name> <operator>=</operator> <call><name>GetIndexAmRoutine</name><argument_list>(<argument><expr><name><name>accessMethodForm</name><operator>-&gt;</operator><name>amhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>amcanorder</name> <operator>=</operator> <name><name>amRoutine</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the operator classes, collations, and exclusion operators for
	 * the new index, so we can test whether it's compatible with the existing
	 * one.  Note that ComputeIndexAttrs might fail here, but that's OK:
	 * DefineIndex would have called this function with the same arguments
	 * later on, and it would have failed then anyway.  Our attributeList
	 * contains only key attributes, thus we're filling ii_NumIndexAttrs and
	 * ii_NumIndexKeyAttrs with same value.
	 */</comment>
	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>=</operator> <name>numberOfAttributes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>=</operator> <name>numberOfAttributes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Am</name></name> <operator>=</operator> <name>accessMethodId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeObjectId</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collationObjectId</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>classObjectId</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>coloptions</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ComputeIndexAttrs</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
					  <argument><expr><name>typeObjectId</name></expr></argument>, <argument><expr><name>collationObjectId</name></expr></argument>, <argument><expr><name>classObjectId</name></expr></argument>,
					  <argument><expr><name>coloptions</name></expr></argument>, <argument><expr><name>attributeList</name></expr></argument>,
					  <argument><expr><name>exclusionOpNames</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
					  <argument><expr><name>accessMethodName</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>,
					  <argument><expr><name>amcanorder</name></expr></argument>, <argument><expr><name>isconstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* Get the soon-obsolete pg_index tuple. */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't assess expressions or predicates; assume incompatibility.
	 * Also, if the index is invalid for any reason, treat it as incompatible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Any change in operator class or collation breaks compatibility. */</comment>
	<expr_stmt><expr><name>old_natts</name> <operator>=</operator> <name><name>indexForm</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>old_natts</name> <operator>==</operator> <name>numberOfAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indcollation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_indcollation</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>old_indclass</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name>classObjectId</name></expr></argument>,
				  <argument><expr><name>old_natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <call><name>memcmp</name><argument_list>(<argument><expr><name><name>old_indcollation</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name>collationObjectId</name></expr></argument>,
				  <argument><expr><name>old_natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* For polymorphic opcintype, column type changes break compatibility. */</comment>
	<expr_stmt><expr><name>irel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* caller probably has a lock */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>old_natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name><name>classObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>irel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name><name>typeObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Any change in exclusion operator selections breaks compatibility. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&amp;&amp;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>old_operators</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>old_procs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name>	   <modifier>*</modifier></type><name>old_strats</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RelationGetExclusionInfo</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_operators</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_procs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_strats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>old_operators</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name></expr></argument>,
					 <argument><expr><name>old_natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Require an exact input type match for polymorphic operators. */</comment>
		<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>old_natts</name> <operator>&amp;&amp;</operator> <name>ret</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>left</name></decl>,
							<decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>op_input_types</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
					<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>irel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name><name>typeObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WaitForOlderSnapshots
 *
 * Wait for transactions that might have an older snapshot than the given xmin
 * limit, because it might not contain tuples deleted just before it has
 * been taken. Obtain a list of VXIDs of such transactions, and wait for them
 * individually. This is used when building an index concurrently.
 *
 * We can exclude any running transactions that have xmin &gt; the xmin given;
 * their oldest snapshot must be newer than our xmin limit.
 * We can also exclude any transactions that have xmin = zero, since they
 * evidently have no live snapshot at all (and any one they might be in
 * process of taking is certainly newer than ours).  Transactions in other
 * DBs can be ignored too, since they'll never even be able to see the
 * index being worked on.
 *
 * We can also exclude autovacuum processes and processes running manual
 * lazy VACUUMs, because they won't be fazed by missing index entries
 * either.  (Manual ANALYZEs, however, can't be excluded because they
 * might be within transactions that are going to do arbitrary operations
 * later.)
 *
 * Also, GetCurrentVirtualXIDs never reports our own vxid, so we need not
 * check for that.
 *
 * If a process goes idle-in-transaction with xmin zero, we do not need to
 * wait for it anymore, per the above argument.  We do not have the
 * infrastructure right now to stop waiting if that happens, but we can at
 * least avoid the folly of waiting when it is idle at the time we would
 * begin to wait.  We do this by repeatedly rechecking the output of
 * GetCurrentVirtualXIDs.  If, during any iteration, a particular vxid
 * doesn't show up in the output, we know we can forget about it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitForOlderSnapshots</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>limitXmin</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_old_snapshots</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>old_snapshots</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>old_snapshots</name> <operator>=</operator> <call><name>GetCurrentVirtualXIDs</name><argument_list>(<argument><expr><name>limitXmin</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>PROC_IS_AUTOVACUUM</name> <operator>|</operator> <name>PROC_IN_VACUUM</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>n_old_snapshots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_WAITFOR_TOTAL</name></expr></argument>, <argument><expr><name>n_old_snapshots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_old_snapshots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name><name>old_snapshots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* found uninteresting in previous cycle */</comment>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* see if anything's changed ... */</comment>
			<decl_stmt><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>newer_snapshots</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>n_newer_snapshots</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newer_snapshots</name> <operator>=</operator> <call><name>GetCurrentVirtualXIDs</name><argument_list>(<argument><expr><name>limitXmin</name></expr></argument>,
													<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>PROC_IS_AUTOVACUUM</name> <operator>|</operator> <name>PROC_IN_VACUUM</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>n_newer_snapshots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n_old_snapshots</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name><name>old_snapshots</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* found uninteresting in previous cycle */</comment>
				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>n_newer_snapshots</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdEquals</name><argument_list>(<argument><expr><name><name>old_snapshots</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
												   <argument><expr><name><name>newer_snapshots</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;=</operator> <name>n_newer_snapshots</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* not there anymore */</comment>
					<expr_stmt><expr><call><name>SetInvalidVirtualTransactionId</name><argument_list>(<argument><expr><name><name>old_snapshots</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newer_snapshots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name><name>old_snapshots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>holder</name> <init>= <expr><call><name>BackendIdGetProc</name><argument_list>(<argument><expr><name><name>old_snapshots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>backendId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_WAITFOR_CURRENT_PID</name></expr></argument>,
											 <argument><expr><name><name>holder</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>VirtualXactLock</name><argument_list>(<argument><expr><name><name>old_snapshots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_WAITFOR_DONE</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * DefineIndex
 *		Creates a new index.
 *
 * 'relationId': the OID of the heap relation on which the index is to be
 *		created
 * 'stmt': IndexStmt describing the properties of the new index.
 * 'indexRelationId': normally InvalidOid, but during bootstrap can be
 *		nonzero to specify a preselected OID for the index.
 * 'parentIndexId': the OID of the parent index; InvalidOid if not the child
 *		of a partitioned index.
 * 'parentConstraintId': the OID of the parent constraint; InvalidOid if not
 *		the child of a constraint (only used when recursing)
 * 'is_alter_table': this is due to an ALTER rather than a CREATE operation.
 * 'check_rights': check for CREATE rights in namespace and tablespace.  (This
 *		should be true except when ALTER is deleting/recreating an index.)
 * 'check_not_in_use': check for table not already in use in current session.
 *		This should be true unless caller is holding the table open, in which
 *		case the caller had better have checked it earlier.
 * 'skip_build': make the catalog entries but don't create the index files
 * 'quiet': suppress the NOTICE chatter ordinarily provided for constraints.
 *
 * GPDB:
 * 'is_new_table': is the parent relation new, guaranteed to still be empty?
 *
 * Returns the object address of the created index.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
			<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>indexRelationId</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>parentIndexId</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>parentConstraintId</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>is_alter_table</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>check_rights</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>check_not_in_use</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>skip_build</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>quiet</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>is_new_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indexRelationName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>accessMethodName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>typeObjectId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>collationObjectId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>classObjectId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>accessMethodId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tablespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>createdConstraintId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexColNames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>allIndexParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_am</name></type>	<name>accessMethodForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amRoutine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>amcanorder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>amoptions_function</name></type> <name>amoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partitioned</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>reloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>coloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits16</name></type>		<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits16</name></type>		<name>constr_flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfKeyAttributes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>limitXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockRelId</name></type>	<name>heaprelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>heaplocktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldDispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>blkdirrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>parentIndexId</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we're recursing for partitions, don't dispatch this command
		 * separately. We will dispatch the parent command.
		 */</comment>
		<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Also don't dispatch this if it's part of an ALTER TABLE. We will dispatch
	 * the whole ALTER TABLE command later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_alter_table</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Some callers need us to run with an empty default_tablespace; this is a
	 * necessary hack to be able to reproduce catalog state accurately when
	 * recreating indexes after table-rewriting ALTER TABLE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"default_tablespace"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
								 <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
								 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start progress report.  If we're building a partition, this was already
	 * done.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_progress_start_command</name><argument_list>(<argument><expr><name>PROGRESS_COMMAND_CREATE_INDEX</name></expr></argument>,
									  <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_COMMAND</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then>
									 <expr><name>PROGRESS_CREATEIDX_COMMAND_CREATE_CONCURRENTLY</name></expr> </then><else>:
									 <expr><name>PROGRESS_CREATEIDX_COMMAND_CREATE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * No index OID to report yet
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_INDEX_OID</name></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * count key attributes in index
	 */</comment>
	<expr_stmt><expr><name>numberOfKeyAttributes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate the new list of index columns including both key columns and
	 * INCLUDE columns.  Later we can determine which of these are key
	 * columns, and which are just part of the INCLUDE list by checking the
	 * list position.  A list item in a position less than ii_NumIndexKeyAttrs
	 * is part of the key columns, and anything equal to and over is part of
	 * the INCLUDE columns.
	 */</comment>
	<expr_stmt><expr><name>allIndexParams</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numberOfAttributes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>allIndexParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>numberOfAttributes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must specify at least one column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>numberOfAttributes</name> <operator>&gt;</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use more than %d columns in an index"</literal></expr></argument>,
						<argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Only SELECT ... FOR UPDATE/SHARE are allowed while doing a standard
	 * index build; but for concurrent builds we allow INSERT/UPDATE/DELETE
	 * (but not VACUUM).
	 *
	 * NB: Caller is responsible for making sure that relationId refers to the
	 * relation on which the index should be built; except in bootstrap mode,
	 * this will typically require the caller to have already locked the
	 * relation.  To avoid lock upgrade hazards, that lock should be at least
	 * as strong as the one we take here.
	 *
	 * NB: If the lock strength here ever changes, code that is run by
	 * parallel workers under the control of certain particular ambuild
	 * functions will need to be updated, too.
	 */</comment>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>ShareLock</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Appendoptimized tables need block directory relation for index
	 * access. Creating and maintaining block directory is expensive,
	 * because it needs to be kept up to date whenever new data is inserted
	 * in the table. We delay the block directory creation until it is
	 * really needed - the first index creation. Once created, all indexes
	 * share the same block directory. We need stronger lock
	 * (ShareRowExclusiveLock) that blocks index creation from another
	 * transaction (not to be confused with create index concurrently) as
	 * well as concurrent insert for appendoptimized tables, if the block
	 * directory needs to be created. If the block directory already exists,
	 * we can use the same lock as heap tables.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdirrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>ShareRowExclusiveLock</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Relation is AO, and has no block directory */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure that it makes sense to index this kind of relation */</comment>
	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<comment type="block">/* OK */</comment>
			<break>break;</break>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>

			<comment type="block">/*
			 * Custom error message for FOREIGN TABLE since the term is close
			 * to a regular table and can confuse the user.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create index on foreign table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or materialized view"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Establish behavior for partitioned tables, and verify sanity of
	 * parameters.
	 *
	 * We do not build an actual index in this case; we only create a few
	 * catalog entries.  The actual indexes are built by recursing for each
	 * partition.
	 */</comment>
	<expr_stmt><expr><name>partitioned</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>partitioned</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create index on partitioned table \"%s\" concurrently"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create exclusion constraints on partitioned table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Don't try to CREATE INDEX on temp tables of other backends.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create indexes on temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unless our caller vouches for having checked this already, insist that
	 * the table not be in use by our own session, either.  Otherwise we might
	 * fail to make entries in the new index (for instance, if an INSERT or
	 * UPDATE is in progress and has already made its list of target indexes).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>check_not_in_use</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"CREATE INDEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Verify we (still) have CREATE rights in the rel's namespace.
	 * (Presumably we did when the rel was created, but maybe not anymore.)
	 * Skip check if caller doesn't want it.  Also skip check if
	 * bootstrapping, since permissions machinery may not be working yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>check_rights</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										  <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
						   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Select tablespace to use.  If not specified, use default tablespace
	 * (which may in turn default to database's default).
	 *
	 * Note: This code duplicates code in tablecmds.c
	 *
	 * MPP-8238 : inconsistent tablespaces between segments and master. In the
	 * QD, store the resolved tablespace name in the command, so that it's
	 * dispatched. In QE, skip the check for 'partitioned': because we got
	 * the value from the QD, it should be ok.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>tableSpace</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableSpace</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>partitioned</name> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>==</operator> <name>MyDatabaseTableSpace</name> <operator>&amp;&amp;</operator>
			<name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify default tablespace for partitioned relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>GetDefaultTablespace</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
											<argument><expr><name>partitioned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* note InvalidOid is OK in this case */</comment>

		<comment type="block">/* Need the real tablespace id for dispatch */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 
			<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <name>MyDatabaseTableSpace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Check tablespace permissions */</comment>
	<if_stmt><if>if <condition>(<expr><name>check_rights</name> <operator>&amp;&amp;</operator>
		<call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>,
						   <argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Force shared indexes into the pg_global tablespace.  This is a bit of a
	 * hack but seems simpler than marking them in the BKI commands.  On the
	 * other hand, if it's not shared, don't allow it to be placed there.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <name>GLOBALTABLESPACE_OID</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>tablespaceId</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Choose the index column names.
	 */</comment>
	<expr_stmt><expr><name>indexColNames</name> <operator>=</operator> <call><name>ChooseIndexColumnNames</name><argument_list>(<argument><expr><name>allIndexParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Select name for index if caller didn't specify
	 *
	 * In GPDB, we need to coordinate the index name between the QD and the
	 * QEs. In the QD, after creating the child index, we stash the chosen
	 * index name in the "oid assignments" list that's normally used to sync
	 * OIDs between QD and QEs. Here, in the QE, we fetch the stashed name
	 * from the list.
	 */</comment>
	<expr_stmt><expr><name>indexRelationName</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>indexRelationName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>indexRelationName</name> <operator>=</operator> <call><name>GetPreassignedIndexNameForChildIndex</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>,
																	 <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>indexRelationName</name> <operator>=</operator> <call><name>ChooseIndexName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>namespaceId</name></expr></argument>,
											<argument><expr><name>indexColNames</name></expr></argument>,
											<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>,
											<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr></argument>,
											<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * look up the access method, verify it can handle the requested features
	 */</comment>
	<expr_stmt><expr><name>accessMethodName</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>accessMethod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Hack to provide more-or-less-transparent updating of old RTREE
		 * indexes to GiST: if RTREE is requested and not found, use GIST.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>accessMethodName</name></expr></argument>, <argument><expr><literal type="string">"rtree"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substituting access method \"gist\" for obsolete method \"rtree\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>accessMethodName</name> <operator>=</operator> <literal type="string">"gist"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>accessMethodForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>accessMethodId</name> <operator>=</operator> <name><name>accessMethodForm</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>amRoutine</name> <operator>=</operator> <call><name>GetIndexAmRoutine</name><argument_list>(<argument><expr><name><name>accessMethodForm</name><operator>-&gt;</operator><name>amhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_ACCESS_METHOD_OID</name></expr></argument>,
								 <argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>amRoutine</name><operator>-&gt;</operator><name>amcanunique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not support unique indexes"</literal></expr></argument>,
						<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>amRoutine</name><operator>-&gt;</operator><name>amcaninclude</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not support included columns"</literal></expr></argument>,
						<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>numberOfAttributes</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>amRoutine</name><operator>-&gt;</operator><name>amcanmulticol</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not support multicolumn indexes"</literal></expr></argument>,
						<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>&amp;&amp;</operator> <name><name>amRoutine</name><operator>-&gt;</operator><name>amgettuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not support exclusion constraints"</literal></expr></argument>,
						<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>&amp;&amp;</operator> <call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"append-only tables do not support unique indexes built concurrently"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Additional version checks needed if block directory already exists */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ValidateRelationVersionForUniqueIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>amcanorder</name> <operator>=</operator> <name><name>amRoutine</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>amoptions</name> <operator>=</operator> <name><name>amRoutine</name><operator>-&gt;</operator><name>amoptions</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>amRoutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Validate predicate, if given
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CheckPredicate</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Parse AM-specific options, convert to text array form, validate.
	 */</comment>
	<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>index_reloptions</name><argument_list>(<argument><expr><name>amoptions</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare arguments for index_create, primarily an IndexInfo structure.
	 * Note that ii_Predicate must be in implicit-AND format.
	 */</comment>
	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>=</operator> <name>numberOfAttributes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>=</operator> <name>numberOfKeyAttributes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* for now */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name></expr>;</expr_stmt>
	<comment type="block">/* In a concurrent build, mark it not-ready-for-inserts */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ReadyForInserts</name></name> <operator>=</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Am</name></name> <operator>=</operator> <name>accessMethodId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>typeObjectId</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collationObjectId</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>classObjectId</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>coloptions</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ComputeIndexAttrs</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
					  <argument><expr><name>typeObjectId</name></expr></argument>, <argument><expr><name>collationObjectId</name></expr></argument>, <argument><expr><name>classObjectId</name></expr></argument>,
					  <argument><expr><name>coloptions</name></expr></argument>, <argument><expr><name>allIndexParams</name></expr></argument>,
					  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
					  <argument><expr><name>accessMethodName</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>,
					  <argument><expr><name>amcanorder</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extra checks when creating a PRIMARY KEY index.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_check_primary_key</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>is_alter_table</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the index is compatible with the distribution policy.
	 *
	 * If the index is unique, the index columns must include all the
	 * distribution key columns. Otherwise we cannot enforce the uniqueness,
	 * because rows with duplicate keys might be stored in differenet segments,
	 * and we would miss it. Similarly, an exlusion constraint must include
	 * all all the distribution key columns.
	 *
	 * As a convenience, if it's a newly created table, we try to change the
	 * policy to allow the index to exist, instead of throwing an error. This
	 * allows the typical case of CREATE TABLE, without a DISTRIBUTED BY
	 * clause, followed by CREATE UNIQUE INDEX, to work. This is a bit weird
	 * if the user specified the distribution policy explicitly in the
	 * CREATE TABLE clause, but we have no way of knowing whether it was
	 * specified explicitly or not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>index_check_policy_compatible_context</name></type> <name>ctx</name></decl>;</decl_stmt>

		<comment type="block">/* Don't allow indexes on system attributes. */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create constraint or unique index on system column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>for_alter_dist_policy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>is_constraint</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>is_unique</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>is_primarykey</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>constraint_name</name></name> <operator>=</operator> <name>indexRelationName</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>index_check_policy_compatible</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>,
											 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name></name></expr></argument>,
											 <argument><expr><name>classObjectId</name></expr></argument>,
											 <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name></expr></argument>,
											 <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>, <comment type="block">/* report_error */</comment>
											 <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this table is partitioned and we're creating a unique index or a
	 * primary key, make sure that the indexed columns are part of the
	 * partition key.  Otherwise it would be possible to violate uniqueness by
	 * putting values that ought to be unique in different partitions.
	 *
	 * We could lift this limitation if we had global indexes, but those have
	 * their own problems, so this is a useful feature combination.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitioned</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partkey</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * A partitioned table can have unique indexes, as long as all the
		 * columns in the partition key appear in the unique key.  A
		 * partition-local index can enforce global uniqueness iff the PK
		 * value completely determines the partition that a row is in.
		 *
		 * Thus, verify that all the columns in the partition key appear in
		 * the unique key definition.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constraint_type</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>constraint_type</name> <operator>=</operator> <literal type="string">"PRIMARY KEY"</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>constraint_type</name> <operator>=</operator> <literal type="string">"UNIQUE"</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>constraint_type</name> <operator>=</operator> <literal type="string">"EXCLUDE"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown constraint type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>constraint_type</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * It may be possible to support UNIQUE constraints when partition
			 * keys are expressions, but is it worth it?  Give up for now.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported %s constraint with partition key definition"</literal></expr></argument>,
								<argument><expr><name>constraint_type</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s constraints cannot be used when partition keys include expressions."</literal></expr></argument>,
								   <argument><expr><name>constraint_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient columns in %s constraint definition"</literal></expr></argument>,
								<argument><expr><name>constraint_type</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s constraint on table \"%s\" lacks column \"%s\" which is part of the partition key."</literal></expr></argument>,
								   <argument><expr><name>constraint_type</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name>stmt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>quiet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We disallow indexes on system columns.  They would not necessarily get
	 * updated correctly, and they don't seem useful anyway.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index creation on system columns is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Also check for system columns used in expressions or predicates.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>||</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>indexattrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
							  <argument><expr><name>indexattrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index creation on system columns is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Report index creation if appropriate (delay this till after most of the
	 * error checks)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>quiet</name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constraint_type</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>constraint_type</name> <operator>=</operator> <literal type="string">"PRIMARY KEY"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>constraint_type</name> <operator>=</operator> <literal type="string">"UNIQUE"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>constraint_type</name> <operator>=</operator> <literal type="string">"EXCLUDE"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown constraint type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>constraint_type</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s %s will create implicit index \"%s\" for table \"%s\""</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><name>is_alter_table</name></expr> ?</condition><then> <expr><literal type="string">"ALTER TABLE / ADD"</literal></expr> </then><else>: <expr><literal type="string">"CREATE TABLE /"</literal></expr></else></ternary></expr></argument>,
						<argument><expr><name>constraint_type</name></expr></argument>,
						<argument><expr><name>indexRelationName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldDispatch</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cdb_sync_oid_to_segments</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We defer the dispatch of the utility command until after
		 * index_create(), because that call will *wait*
		 * for any other transactions touching this new relation,
		 * which can cause a non-local deadlock if we've already
		 * dispatched
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * A valid stmt-&gt;oldNode implies that we already have a built form of the
	 * index.  The caller should also decline any index build.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>skip_build</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create block directory if this is an appendoptimized
	 * relation
	 */</comment>
	<expr_stmt><expr><call><name>AlterTableCreateAoBlkdirTable</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the catalog entries for the index, including constraints. This
	 * step also actually builds the index, except if caller requested not to
	 * or in concurrent mode, in which case it'll be done later, or doing a
	 * partitioned index (because those don't have storage).
	 */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>constr_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INDEX_CREATE_ADD_CONSTRAINT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>skip_build</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>||</operator> <name>partitioned</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INDEX_CREATE_SKIP_BUILD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INDEX_CREATE_IF_NOT_EXISTS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INDEX_CREATE_CONCURRENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>partitioned</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INDEX_CREATE_PARTITIONED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INDEX_CREATE_IS_PRIMARY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the table is partitioned, and recursion was declined but partitions
	 * exist, mark the index as invalid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitioned</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>pd</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pd</name><operator>-&gt;</operator><name>nparts</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INDEX_CREATE_INVALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>deferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>constr_flags</name> <operator>|=</operator> <name>INDEX_CONSTR_CREATE_DEFERRABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>constr_flags</name> <operator>|=</operator> <name>INDEX_CONSTR_CREATE_INIT_DEFERRED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>indexRelationId</name> <operator>=</operator>
		<call><name>index_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexRelationName</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>parentIndexId</name></expr></argument>,
					 <argument><expr><name>parentConstraintId</name></expr></argument>,
					 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>indexColNames</name></expr></argument>,
					 <argument><expr><name>accessMethodId</name></expr></argument>, <argument><expr><name>tablespaceId</name></expr></argument>,
					 <argument><expr><name>collationObjectId</name></expr></argument>, <argument><expr><name>classObjectId</name></expr></argument>,
					 <argument><expr><name>coloptions</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>,
					 <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>constr_flags</name></expr></argument>,
					 <argument><expr><name>allowSystemTableMods</name></expr></argument>, <argument><expr><operator>!</operator><name>check_rights</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>createdConstraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Revert to original default_tablespace.  Must do this before any return
	 * from this function, but after index_create, so this is a good time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>save_nestlevel</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If this is the top-level index, we're done */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>address</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In the QD, remember the chosen index name and stash it with the
	 * chosen OIDs, so that it's dispatched to the QE later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RememberPreassignedIndexNameForChildIndex</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>,
												  <argument><expr><name>relationId</name></expr></argument>,
												  <argument><expr><name>indexRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add any requested comment */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateComments</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>idxcomment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>partitioned</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Unless caller specified to skip this step (via ONLY), process each
		 * partition to make sure they all contain a corresponding index.
		 *
		 * If we're called internally (no stmt-&gt;relation), recurse always.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>part_oids</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>invalidate_parent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>parentDesc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>opfamOids</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PARTITIONS_TOTAL</name></expr></argument>,
										 <argument><expr><name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>part_oids</name></expr></argument>, <argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>parentDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opfamOids</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numberOfKeyAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfKeyAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>opfamOids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name><name>classObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

			<comment type="block">/*
			 * For each partition, scan all existing indexes; if one matches
			 * our index definition and is not already attached to some other
			 * parent index, attach it to the one we just created.
			 *
			 * If none matches, build a new index by calling ourselves
			 * recursively with the same options (except for the index name).
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>childRelid</name> <init>= <expr><name><name>part_oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>childidxs</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>maplen</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childRelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Don't try to create indexes on foreign tables, though. Skip
				 * those if a regular index, or fail if trying to create a
				 * constraint index.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create unique index on partitioned table \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" contains partitions that are foreign tables."</literal></expr></argument>,
										   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>childidxs</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attmap</name> <operator>=</operator>
					<call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>parentDesc</name></expr></argument>,
											   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>maplen</name> <operator>=</operator> <name><name>parentDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

				<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>childidxs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>cldidxid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type>	<name>cldidx</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>cldIdxInfo</name></decl>;</decl_stmt>

					<comment type="block">/* this index is already partition of another one */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>has_superclass</name><argument_list>(<argument><expr><name>cldidxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>cldidx</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>cldidxid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cldIdxInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>cldidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>CompareIndexInfo</name><argument_list>(<argument><expr><name>cldIdxInfo</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
										 <argument><expr><name><name>cldidx</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
										 <argument><expr><name>collationObjectId</name></expr></argument>,
										 <argument><expr><name><name>cldidx</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
										 <argument><expr><name>opfamOids</name></expr></argument>,
										 <argument><expr><name>attmap</name></expr></argument>, <argument><expr><name>maplen</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>cldConstrOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * Found a match.
						 *
						 * If this index is being created in the parent
						 * because of a constraint, then the child needs to
						 * have a constraint also, so look for one.  If there
						 * is no such constraint, this index is no good, so
						 * keep looking.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>createdConstraintId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>cldConstrOid</name> <operator>=</operator>
								<call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><name>childRelid</name></expr></argument>,
																<argument><expr><name>cldidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>cldConstrOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>cldidx</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<continue>continue;</continue>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/* Attach index to parent and we're done. */</comment>
						<expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name>cldidx</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>createdConstraintId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>cldConstrOid</name></expr></argument>,
														  <argument><expr><name>createdConstraintId</name></expr></argument>,
														  <argument><expr><name>childRelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cldidx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>invalidate_parent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<comment type="block">/* keep lock till commit */</comment>
						<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>cldidx</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>cldidx</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>childidxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If no matching index was found, create our own.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>childStmt</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * We can't use the same index name for the child index,
					 * so clear idxname to let the recursive invocation choose
					 * a new name.  Likewise, the existing target relation
					 * field is wrong, and if indexOid or oldNode are set,
					 * they mustn't be applied to the child either.
					 */</comment>
					<expr_stmt><expr><name><name>childStmt</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>childStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>childStmt</name><operator>-&gt;</operator><name>indexOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>childStmt</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Adjust any Vars (both in expressions and in the index's
					 * WHERE clause) to match the partition's column numbering
					 * in case it's different from the parent's.
					 */</comment>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>childStmt-&gt;indexParams</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>ielem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * If the index parameter is an expression, we must
						 * translate it to contain child Vars.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator>
								<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
													<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>attmap</name></expr></argument>, <argument><expr><name>maplen</name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><name><name>childStmt</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator>
						<call><name>map_variable_attnos</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											<argument><expr><name>attmap</name></expr></argument>, <argument><expr><name>maplen</name></expr></argument>,
											<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>DefineIndex</name><argument_list>(<argument><expr><name>childRelid</name></expr></argument>, <argument><expr><name>childStmt</name></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no predefined OID */</comment>
								<argument><expr><name>indexRelationId</name></expr></argument>,	<comment type="block">/* this is our child */</comment>
								<argument><expr><name>createdConstraintId</name></expr></argument>,
								<argument><expr><name>is_alter_table</name></expr></argument>, <argument><expr><name>check_rights</name></expr></argument>, <argument><expr><name>check_not_in_use</name></expr></argument>,
								<argument><expr><name>skip_build</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>, <argument><expr><name>is_new_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PARTITIONS_DONE</name></expr></argument>,
											 <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * The pg_index row we inserted for this index was marked
			 * indisvalid=true.  But if we attached an existing index that is
			 * invalid, this is incorrect, so update our row to invalid too.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>invalidate_parent</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>,
							<decl><type ref="prev"/><name>newtup</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>,
						 <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>indisvalid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <name>indexRelationName</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>shouldDispatch</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* make sure the QE uses the same index name that we chose */</comment>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableSpace</name></name> <operator>=</operator> <call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
										<argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
										<name>DF_WITH_SNAPSHOT</name> <operator>|</operator>
										<name>DF_NEED_TWO_PHASE</name></expr></argument>,
										<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Indexes on partitioned tables are not themselves built, so we're
		 * done here.
		 */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>address</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <name>indexRelationName</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>shouldDispatch</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* make sure the QE uses the same index name that we chose */</comment>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name> <operator>|</operator>
									<name>DF_NEED_TWO_PHASE</name></expr></argument>,
									<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set indcheckxmin in the master, if it was set on any segment */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cdb_sync_indcheckxmin_with_segments</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Close the heap and we're done, in the non-concurrent case */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If this is the top-level index, we're done. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>address</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * FIXME: concurrent index build needs additional work in Greenplum.  The
	 * feature is disabled in Greenplum until this work is done.  In upstream,
	 * concurrent index build is accomplished in three steps.  Each step is
	 * performed in its own transaction.  In GPDB, each step must be performed
	 * in its own distributed transaction.  Today, we only support dispatching
	 * one IndexStmt.  QEs cannot distinguish the steps within a concurrent
	 * index build.  May be, augment IndexStmt with a variable indicating which
	 * step of concurrent index build a QE should perform?
	 */</comment>

	<comment type="block">/* save lockrelid and locktag for below, then close rel */</comment>
	<expr_stmt><expr><name>heaprelid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>heaplocktag</name></expr></argument>, <argument><expr><name><name>heaprelid</name><operator>.</operator><name>dbId</name></name></expr></argument>, <argument><expr><name><name>heaprelid</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For a concurrent build, it's important to make the catalog entries
	 * visible to other transactions before we start to build the index. That
	 * will prevent them from making incompatible HOT updates.  The new index
	 * will be marked not indisready and not indisvalid, so that no one else
	 * tries to either insert into it or use it for queries.
	 *
	 * We must commit our current transaction so that the index becomes
	 * visible; then start another.  Note that all the data structures we just
	 * built are lost in the commit.  The only data we keep past here are the
	 * relation IDs.
	 *
	 * Before committing, get a session-level lock on the table, to ensure
	 * that neither it nor the index can be dropped before we finish. This
	 * cannot block, even if someone else is waiting for access, because we
	 * already have the same lock within our transaction.
	 *
	 * Note: we don't currently bother with a session lock on the index,
	 * because there are no operations that could change its state while we
	 * hold lock on the parent table.  This might need to change later.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heaprelid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The index is now visible, so we can report the OID.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_INDEX_OID</name></expr></argument>,
								 <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Phase 2 of concurrent index build (see comments for validate_index()
	 * for an overview of how this works)
	 *
	 * Now we must wait until no running transaction could have the table open
	 * with the old list of indexes.  Use ShareLock to consider running
	 * transactions that hold locks that permit writing to the table.  Note we
	 * do not need to worry about xacts that open the table for writing after
	 * this point; they will see the new index when they open it.
	 *
	 * Note: the reason we use actual lock acquisition here, rather than just
	 * checking the ProcArray and sleeping, is that deadlock is possible if
	 * one of the transactions in question is blocked trying to acquire an
	 * exclusive lock on our table.  The lock code will detect deadlock and
	 * error out properly.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CREATEIDX_PHASE_WAIT_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WaitForLockers</name><argument_list>(<argument><expr><name>heaplocktag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * At this moment we are sure that there are no transactions with the
	 * table open for write that don't have this new index in their list of
	 * indexes.  We have waited out all the existing transactions and any new
	 * transaction will have the new index in its list, but the index is still
	 * marked as "not-ready-for-inserts".  The index is consulted while
	 * deciding HOT-safety though.  This arrangement ensures that no new HOT
	 * chains can be created where the new tuple and the old tuple in the
	 * chain have different index keys.
	 *
	 * We now take a new snapshot, and build the index using all tuples that
	 * are visible in this snapshot.  We can be sure that any HOT updates to
	 * these tuples will be compatible with the index, since any updates made
	 * by transactions that didn't know about the index are now committed or
	 * rolled back.  Thus, each visible tuple is either the end of its
	 * HOT-chain or the extension of the chain is HOT-safe for this index.
	 */</comment>

	<comment type="block">/* Set ActiveSnapshot since functions in the indexes may need it */</comment>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform concurrent build of index */</comment>
	<expr_stmt><expr><call><name>index_concurrently_build</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we can do away with our snapshot */</comment>
	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Commit this transaction to make the indisready update visible.
	 */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Phase 3 of concurrent index build
	 *
	 * We once again wait until no transaction can have the table open with
	 * the index marked as read-only for updates.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CREATEIDX_PHASE_WAIT_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WaitForLockers</name><argument_list>(<argument><expr><name>heaplocktag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now take the "reference snapshot" that will be used by validate_index()
	 * to filter candidate tuples.  Beware!  There might still be snapshots in
	 * use that treat some transaction as in-progress that our reference
	 * snapshot treats as committed.  If such a recently-committed transaction
	 * deleted tuples in the table, we will not include them in the index; yet
	 * those transactions which see the deleting one as still-in-progress will
	 * expect such tuples to be there once we mark the index as valid.
	 *
	 * We solve this by waiting for all endangered transactions to exit before
	 * we mark the index as valid.
	 *
	 * We also set ActiveSnapshot to this snap, since functions in indexes may
	 * need a snapshot.
	 */</comment>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the index and the heap, insert any missing index entries.
	 */</comment>
	<expr_stmt><expr><call><name>validate_index</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Drop the reference snapshot.  We must do this before waiting out other
	 * snapshot holders, else we will deadlock against other processes also
	 * doing CREATE INDEX CONCURRENTLY, which would see our snapshot as one
	 * they must wait for.  But first, save the snapshot's xmin to use as
	 * limitXmin for GetCurrentVirtualXIDs().
	 */</comment>
	<expr_stmt><expr><name>limitXmin</name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The snapshot subsystem could still contain registered snapshots that
	 * are holding back our process's advertised xmin; in particular, if
	 * default_transaction_isolation = serializable, there is a transaction
	 * snapshot that is still active.  The CatalogSnapshot is likewise a
	 * hazard.  To ensure no deadlocks, we must commit and start yet another
	 * transaction, and do our wait before any snapshot has been taken in it.
	 */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We should now definitely not be advertising any xmin. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>==</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The index is now valid in the sense that it contains all currently
	 * interesting tuples.  But since it might not contain tuples deleted just
	 * before the reference snap was taken, we have to wait out any
	 * transactions that might have older snapshots.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CREATEIDX_PHASE_WAIT_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WaitForOlderSnapshots</name><argument_list>(<argument><expr><name>limitXmin</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Index can now be marked valid -- update its pg_index entry
	 */</comment>
	<expr_stmt><expr><call><name>index_set_state_flags</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>INDEX_CREATE_SET_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The pg_index update will cause backends (including this one) to update
	 * relcache entries for the index itself, but we should also send a
	 * relcache inval on the parent table to force replanning of cached plans.
	 * Otherwise existing sessions might fail to use the new index where it
	 * would be useful.  (Note that our earlier commits did not create reasons
	 * to replan; so relcache flush on the index itself was sufficient.)
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name><name>heaprelid</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Last thing to do is release the session-level lock on the parent table.
	 */</comment>
	<expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heaprelid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckMutability
 *		Test whether given expression is mutable
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckMutability</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * First run the expression through the planner.  This has a couple of
	 * important consequences.  First, function default arguments will get
	 * inserted, which may affect volatility (consider "default now()").
	 * Second, inline-able functions will get inlined, which may allow us to
	 * conclude that the function is really less volatile than it's marked. As
	 * an example, polymorphic functions must be marked with the most volatile
	 * behavior that they have for any input type, but once we inline the
	 * function we may be able to conclude that it's not so volatile for the
	 * particular input type we're dealing with.
	 *
	 * We assume here that expression_planner() won't scribble on its input.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we can search for non-immutable functions */</comment>
	<return>return <expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckPredicate
 *		Checks that the given partial-index predicate is valid.
 *
 * This used to also constrain the form of the predicate to forms that
 * indxpath.c could do something with.  However, that seems overly
 * restrictive.  One useful application of partial indexes is to apply
 * a UNIQUE constraint across a subset of a table, and in that scenario
 * any evaluable predicate will work.  So accept any predicate here
 * (except ones requiring a plan), and let indxpath.c fend for itself.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckPredicate</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * transformExpr() should have already rejected subqueries, aggregates,
	 * and window functions, based on the EXPR_KIND_ for a predicate.
	 */</comment>

	<comment type="block">/*
	 * A predicate using mutable functions is probably wrong, for the same
	 * reasons that we don't allow an index expression to use one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CheckMutability</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"functions in index predicate must be marked IMMUTABLE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute per-index-column information, including indexed column numbers
 * or index expressions, opclasses, and indoptions. Note, all output vectors
 * should be allocated for all columns, including "including" ones.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ComputeIndexAttrs</name><parameter_list>(<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeOidP</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collationOidP</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>classOidP</name></decl></parameter>,
				  <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>colOptionP</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attList</name></decl></parameter>,	<comment type="block">/* list of IndexElem's */</comment>
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exclusionOpNames</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>accessMethodName</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>amcanorder</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>isconstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nextExclOp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeycols</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Allocate space for exclusion operator info, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>exclusionOpNames</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exclusionOpNames</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nkeycols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name> <operator>=</operator> <operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextExclOp</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>exclusionOpNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextExclOp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * process attributeList
	 */</comment>
	<expr_stmt><expr><name>attn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>attList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>attribute</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Process the column-or-expression to be indexed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple index attribute */</comment>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>expr</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* difference in error message spellings is historical */</comment>
				<if_stmt><if>if <condition>(<expr><name>isconstraint</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" named in key does not exist"</literal></expr></argument>,
									<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
									<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>atttype</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Index expression */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>attribute</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>&gt;=</operator> <name>nkeycols</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expressions are not supported in included columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>atttype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * transformExpr() should have already rejected subqueries,
			 * aggregates, and window functions, based on the EXPR_KIND_
			 * for an index expression.
			 */</comment>

			<comment type="block">/*
			 * Strip any top-level COLLATE clause.  This ensures that we treat
			 * "x COLLATE y" and "(x COLLATE y)" alike.
			 */</comment>
			<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * User wrote "(column)" or "(column COLLATE something)".
				 * Treat it like simple attribute anyway.
				 */</comment>
				<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* marks expression */</comment>
				<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>,
													<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * transformExpr() should have already rejected subqueries,
				 * aggregates, and window functions, based on the EXPR_KIND_
				 * for an index expression.
				 */</comment>

				<comment type="block">/*
				 * An expression using mutable functions is probably wrong,
				 * since if you aren't going to get the same result for the
				 * same data every time, it's not clear what the index entries
				 * mean at all.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>CheckMutability</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"functions in index expression must be marked IMMUTABLE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>typeOidP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>atttype</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Included columns have no collation, no opclass and no ordering
		 * options.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>&gt;=</operator> <name>nkeycols</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"including column does not support a collation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>opclass</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"including column does not support an operator class"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>ordering</name></name> <operator>!=</operator> <name>SORTBY_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"including column does not support ASC/DESC options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>!=</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"including column does not support NULLS FIRST/LAST options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>classOidP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>colOptionP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>collationOidP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attn</name><operator>++</operator></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Apply collation override if any
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>get_collation_oid</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check we have a collation iff it's a collatable type.  The only
		 * expected failures here are (1) COLLATE applied to a noncollatable
		 * type, or (2) index expression had an unresolved collation.  But we
		 * might as well code this to be a complete consistency check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for index expression"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations are not supported by type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>collationOidP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>attcollation</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Identify the opclass to use.
		 */</comment>
		<expr_stmt><expr><name><name>classOidP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>ResolveOpClass</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>,
										 <argument><expr><name>atttype</name></expr></argument>,
										 <argument><expr><name>accessMethodName</name></expr></argument>,
										 <argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Identify the exclusion operator, if any.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nextExclOp</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opname</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>nextExclOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>strat</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Find the operator --- it must accept the column datatype
			 * without runtime coercion (but binary compatibility is OK)
			 */</comment>
			<expr_stmt><expr><name>opid</name> <operator>=</operator> <call><name>compatible_oper_opid</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Only allow commutative operators to be used in exclusion
			 * constraints. If X conflicts with Y, but Y does not conflict
			 * with X, bad things will happen.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>get_commutator</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>opid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator %s is not commutative"</literal></expr></argument>,
								<argument><expr><call><name>format_operator</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only commutative operators can be used in exclusion constraints."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Operator must be a member of the right opfamily, too
			 */</comment>
			<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name><name>classOidP</name><index>[<expr><name>attn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>strat</name> <operator>=</operator> <call><name>get_op_opfamily_strategy</name><argument_list>(<argument><expr><name>opid</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>strat</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opftuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_opfamily</name></type> <name>opfform</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * attribute-&gt;opclass might not explicitly name the opfamily,
				 * so fetch the name of the selected opfamily for use in the
				 * error message.
				 */</comment>
				<expr_stmt><expr><name>opftuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPFAMILYOID</name></expr></argument>,
										   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opftuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opfamily %u"</literal></expr></argument>,
						 <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>opfform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opfamily</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opftuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator %s is not a member of operator family \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>format_operator</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opfform</name><operator>-&gt;</operator><name>opfname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The exclusion operator must be related to the index operator class for the constraint."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>opid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>strat</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextExclOp</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>nextExclOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set up the per-column options (indoption field).  For now, this is
		 * zero for any un-ordered index, while ordered indexes have DESC and
		 * NULLS FIRST/LAST options.
		 */</comment>
		<expr_stmt><expr><name><name>colOptionP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>amcanorder</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* default ordering is ASC */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>ordering</name></name> <operator>==</operator> <name>SORTBY_DESC</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colOptionP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>|=</operator> <name>INDOPTION_DESC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* default null ordering is LAST for ASC, FIRST for DESC */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>==</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>ordering</name></name> <operator>==</operator> <name>SORTBY_DESC</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>colOptionP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>|=</operator> <name>INDOPTION_NULLS_FIRST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>==</operator> <name>SORTBY_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colOptionP</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>|=</operator> <name>INDOPTION_NULLS_FIRST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* index AM does not support ordering */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>ordering</name></name> <operator>!=</operator> <name>SORTBY_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not support ASC/DESC options"</literal></expr></argument>,
								<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>!=</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not support NULLS FIRST/LAST options"</literal></expr></argument>,
								<argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>attn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Resolve possibly-defaulted operator class specification
 *
 * Note: This is used to resolve operator class specification in index and
 * partition key definitions.
 */</comment>
<function><type><name>Oid</name></type>
<name>ResolveOpClass</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>attrType</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>accessMethodName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opClassId</name></decl>,
				<decl><type ref="prev"/><name>opInputType</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Release 7.0 removed network_ops, timespan_ops, and datetime_ops, so we
	 * ignore those opclass names so the default *_ops is used.  This can be
	 * removed in some later release.  bjm 2000/02/07
	 *
	 * Release 7.1 removes lztext_ops, so suppress that too for a while.  tgl
	 * 2000/07/30
	 *
	 * Release 7.2 renames timestamp_ops to timestamptz_ops, so suppress that
	 * too for awhile.  I'm starting to think we need a better approach. tgl
	 * 2000/10/01
	 *
	 * Release 8.0 removes bigbox_ops (which was dead code for a long while
	 * anyway).  tgl 2003/11/11
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>claname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>claname</name></expr></argument>, <argument><expr><literal type="string">"network_ops"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>claname</name></expr></argument>, <argument><expr><literal type="string">"timespan_ops"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>claname</name></expr></argument>, <argument><expr><literal type="string">"datetime_ops"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>claname</name></expr></argument>, <argument><expr><literal type="string">"lztext_ops"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>claname</name></expr></argument>, <argument><expr><literal type="string">"timestamp_ops"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>claname</name></expr></argument>, <argument><expr><literal type="string">"bigbox_ops"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>opclass</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>opclass</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no operator class specified, so find the default */</comment>
		<expr_stmt><expr><name>opClassId</name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>attrType</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opClassId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In GPDB, this function is also used for DISTRIBUTED BY. That's why
			 * we've removed "for index" from the error message.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s has no default operator class for access method \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>attrType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You must specify an operator class or define a default operator class for the data type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>opClassId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Specific opclass name given, so look up the opclass.
	 */</comment>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Look in specific schema only */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>CLAAMNAMENSP</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Unqualified opclass name, so search the search path */</comment>
		<expr_stmt><expr><name>opClassId</name> <operator>=</operator> <call><name>OpclassnameGetOpcid</name><argument_list>(<argument><expr><name>accessMethodId</name></expr></argument>, <argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opClassId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class \"%s\" does not exist for access method \"%s\""</literal></expr></argument>,
							<argument><expr><name>opcname</name></expr></argument>, <argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opClassId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class \"%s\" does not exist for access method \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Verify that the index operator class accepts this datatype.  Note we
	 * will accept binary compatibility.
	 */</comment>
	<expr_stmt><expr><name>opform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opClassId</name> <operator>=</operator> <name><name>opform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>opInputType</name> <operator>=</operator> <name><name>opform</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>attrType</name></expr></argument>, <argument><expr><name>opInputType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class \"%s\" does not accept data type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>attrType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>opClassId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetDefaultOpClass
 *
 * Given the OIDs of a datatype and an access method, find the default
 * operator class, if any.  Returns InvalidOid if there is none.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetDefaultOpClass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>am_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nexact</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncompatible</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncompatiblepreferred</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TYPCATEGORY</name></type> <name>tcategory</name></decl>;</decl_stmt>

	<comment type="block">/* If it's a domain, look at the base type instead */</comment>
	<expr_stmt><expr><name>type_id</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tcategory</name> <operator>=</operator> <call><name>TypeCategory</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We scan through all the opclasses available for the access method,
	 * looking for one that is marked default and matches the target type
	 * (either exactly or binary-compatibly, but prefer an exact match).
	 *
	 * We could find more than one binary-compatible match.  If just one is
	 * for a preferred type, use that one; otherwise we fail, forcing the user
	 * to specify which one he wants.  (The preferred-type special case is a
	 * kluge for varchar: it's binary-compatible to both text and bpchar, so
	 * we need a tiebreaker.)  If we find more than one exact match, then
	 * someone put bogus entries in pg_opclass.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OperatorClassRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_opclass_opcmethod</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>am_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>OpclassAmNameNspIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opclass</name> <init>= <expr><operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ignore altogether if not a default opclass */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opclass</name><operator>-&gt;</operator><name>opcdefault</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>opclass</name><operator>-&gt;</operator><name>opcintype</name></name> <operator>==</operator> <name>type_id</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nexact</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>opclass</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>nexact</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name><name>opclass</name><operator>-&gt;</operator><name>opcintype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsPreferredType</name><argument_list>(<argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name><name>opclass</name><operator>-&gt;</operator><name>opcintype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ncompatiblepreferred</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>opclass</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>ncompatiblepreferred</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ncompatible</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>opclass</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* raise error if pg_opclass contains inconsistent data */</comment>
	<if_stmt><if>if <condition>(<expr><name>nexact</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there are multiple default operator classes for data type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nexact</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
		<name>ncompatiblepreferred</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
		<operator>(</operator><name>ncompatiblepreferred</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ncompatible</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	makeObjectName()
 *
 *	Create a name for an implicitly created index, sequence, constraint,
 *	extended statistics, etc.
 *
 *	The parameters are typically: the original table name, the original field
 *	name, and a "type" string (such as "seq" or "pkey").    The field name
 *	and/or type can be NULL if not relevant.
 *
 *	The result is a palloc'd string.
 *
 *	The basic result we want is "name1_name2_label", omitting "_name2" or
 *	"_label" when those parameters are NULL.  However, we must generate
 *	a name with less than NAMEDATALEN characters!  So, we truncate one or
 *	both names if necessary to make a short-enough string.  The label part
 *	is never truncated (so it had better be reasonably short).
 *
 *	The caller is responsible for checking uniqueness of the generated
 *	name and retrying as needed; retrying will be done by altering the
 *	"label" string (which is why we never truncate that part).
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>makeObjectName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>overhead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* chars needed for label and underscores */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>availchars</name></decl>;</decl_stmt>		<comment type="block">/* chars available for name(s) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>name1chars</name></decl>;</decl_stmt>		<comment type="block">/* chars allocated to name1 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>name2chars</name></decl>;</decl_stmt>		<comment type="block">/* chars allocated to name2 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>name1chars</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>name2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>name2chars</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>overhead</name><operator>++</operator></expr>;</expr_stmt>				<comment type="block">/* allow for separating underscore */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>name2chars</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>label</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>overhead</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>availchars</name> <operator>=</operator> <name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>overhead</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>availchars</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else caller chose a bad label */</comment>

	<comment type="block">/*
	 * If we must truncate,  preferentially truncate the longer name. This
	 * logic could be expressed without a loop, but it's simple and obvious as
	 * a loop.
	 */</comment>
	<while>while <condition>(<expr><name>name1chars</name> <operator>+</operator> <name>name2chars</name> <operator>&gt;</operator> <name>availchars</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>name1chars</name> <operator>&gt;</operator> <name>name2chars</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>name1chars</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>name2chars</name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>name1chars</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name1chars</name></expr></argument>, <argument><expr><name>name1chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>name2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>name2chars</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>name2</name></expr></argument>, <argument><expr><name>name2chars</name></expr></argument>, <argument><expr><name>name2chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now construct the string using the chosen lengths */</comment>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>name1chars</name> <operator>+</operator> <name>name2chars</name> <operator>+</operator> <name>overhead</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name1chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndx</name> <operator>=</operator> <name>name1chars</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>name2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>name</name><index>[<expr><name>ndx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>ndx</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>name2chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndx</name> <operator>+=</operator> <name>name2chars</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>label</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>name</name><index>[<expr><name>ndx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>ndx</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>name</name><index>[<expr><name>ndx</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select a nonconflicting name for a new relation.  This is ordinarily
 * used to choose index names (which is why it's here) but it can also
 * be used for sequences, or any autogenerated relation kind.
 *
 * name1, name2, and label are used the same way as for makeObjectName(),
 * except that the label can't be NULL; digits will be appended to the label
 * if needed to create a name that is unique within the specified namespace.
 *
 * If isconstraint is true, we also avoid choosing a name matching any
 * existing constraint in the same namespace.  (This is stricter than what
 * Postgres itself requires, but the SQL standard says that constraint names
 * should be unique within schemas, so we follow that for autogenerated
 * constraint names.)
 *
 * Note: it is theoretically possible to get a collision anyway, if someone
 * else chooses the same name concurrently.  This is fairly unlikely to be
 * a problem in practice, especially if one is holding an exclusive lock on
 * the relation identified by name1.  However, if choosing multiple names
 * within a single command, you'd better create the new object and do
 * CommandCounterIncrement before choosing the next one!
 *
 * Returns a palloc'd string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ChooseRelationName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespaceid</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>isconstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pass</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>modlabel</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>GP_ROLE_EXECUTE</name> <operator>==</operator> <name>Gp_role</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation names cannot be chosen on QE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* try the unmodified label first */</comment>
	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>modlabel</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>modlabel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>makeObjectName</name><argument_list>(<argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>modlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>namespaceid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isconstraint</name> <operator>||</operator>
				<operator>!</operator><call><name>ConstraintNameExists</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>namespaceid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* found a conflict, so try a new name component */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>modlabel</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>modlabel</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><operator>++</operator><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>relname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select the name to be used for an index.
 *
 * The argument list is pretty ad-hoc :-(
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ChooseIndexName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exclusionOpNames</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>primary</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isconstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indexname</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>primary</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* the primary key's name does not depend on the specific column(s) */</comment>
		<expr_stmt><expr><name>indexname</name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name>tabname</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><literal type="string">"pkey"</literal></expr></argument>,
									   <argument><expr><name>namespaceId</name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>exclusionOpNames</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>indexname</name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name>tabname</name></expr></argument>,
									   <argument><expr><call><name>ChooseIndexNameAddition</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><literal type="string">"excl"</literal></expr></argument>,
									   <argument><expr><name>namespaceId</name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>isconstraint</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>indexname</name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name>tabname</name></expr></argument>,
									   <argument><expr><call><name>ChooseIndexNameAddition</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><literal type="string">"key"</literal></expr></argument>,
									   <argument><expr><name>namespaceId</name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>indexname</name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name>tabname</name></expr></argument>,
									   <argument><expr><call><name>ChooseIndexNameAddition</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><literal type="string">"idx"</literal></expr></argument>,
									   <argument><expr><name>namespaceId</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>indexname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate "name2" for a new index given the list of column names for it
 * (as produced by ChooseIndexColumnNames).  This will be passed to
 * ChooseRelationName along with the parent table name and a suitable label.
 *
 * We know that less than NAMEDATALEN characters will actually be used,
 * so we can truncate the result once we've generated that many.
 *
 * XXX See also ChooseForeignKeyConstraintNameAddition and
 * ChooseExtendedStatisticNameAddition.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ChooseIndexNameAddition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>NAMEDATALEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>buflen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* insert _ between names */</comment>

		<comment type="block">/*
		 * At this point we have buflen &lt;= NAMEDATALEN.  name should be less
		 * than NAMEDATALEN already, but use strlcpy for paranoia.
		 */</comment>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>buflen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buflen</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select the actual names to be used for the columns of an index, given the
 * list of IndexElems for the columns.  This is mostly about ensuring the
 * names are unique so we don't get a conflicting-attribute-names error.
 *
 * Returns a List of plain strings (char *, not String nodes).
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ChooseIndexColumnNames</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexElems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexElems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>ielem</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* Get the preliminary name from the IndexElem */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>indexcolname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>origname</name> <operator>=</operator> <name><name>ielem</name><operator>-&gt;</operator><name>indexcolname</name></name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* caller-specified name */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>origname</name> <operator>=</operator> <name><name>ielem</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* simple column reference */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>origname</name> <operator>=</operator> <literal type="string">"expr"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* default name for expression */</comment>

		<comment type="block">/* If it conflicts with any previous column, tweak it */</comment>
		<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>origname</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init><condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>nbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nlen</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>result</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>lc2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* found nonconflicting name */</comment>

			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Ensure generated names are shorter than NAMEDATALEN */</comment>
			<expr_stmt><expr><name>nlen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>origname</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>origname</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>origname</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>nlen</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* And attach to the result list */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReindexIndex
 *		Recreate a specific index.
 */</comment>
<function><type><name>void</name></type>
<name>ReindexIndex</name><parameter_list>(<parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>indexRelation</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>options</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>concurrent</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ReindexIndexCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>persistence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On QE, we already know the index relation oid since we set it before
	 * dispatch the reindex statement.
	 * Other checks should already done on QD when calling RangeVarGetRelidExtended.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>persistence</name> <operator>=</operator> <call><name>get_rel_persistence</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>reindex_index</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find and lock index, and check permissions on table; use callback to
	 * obtain lock on table first, to avoid deadlock hazard.  The lock level
	 * used here must match the index lock obtained in reindex_index().
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>concurrent</name></name> <operator>=</operator> <name>concurrent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>locked_table_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>indOid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>,
									  <argument><expr><ternary><condition><expr><name>concurrent</name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>,
									  <argument><expr><name>RangeVarCallbackForReindexIndex</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Obtain the current persistence and kind of the existing index.  We
	 * already hold a lock on the index.
	 */</comment>
	<expr_stmt><expr><name>persistence</name> <operator>=</operator> <call><name>get_rel_persistence</name><argument_list>(<argument><expr><name>indOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>indOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReindexPartitions</name><argument_list>(<argument><expr><name>indOid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>concurrent</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>concurrent</name> <operator>&amp;&amp;</operator>
			 <name>persistence</name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReindexRelationConcurrently</name><argument_list>(<argument><expr><name>indOid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>reindex_index</name><argument_list>(<argument><expr><name>indOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Reindex on partitioned index will do the reindex for each index in
	 * it's own transaction, so dispatch the statement under ReindexPartitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReindexStmt</name>	   <modifier>*</modifier></type><name>qestmt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>qestmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ReindexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>REINDEX_OBJECT_INDEX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>=</operator> <name>concurrent</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>indOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qestmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name></expr></argument>,
									<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check permissions on table before acquiring relation lock; also lock
 * the heap before the RangeVarGetRelidExtended takes the index lock, to avoid
 * deadlocks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForReindexIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ReindexIndexCallbackState</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>table_lockmode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Lock level here should match table lock in reindex_index() for
	 * non-concurrent case and table locks used by index_concurrently_*() for
	 * concurrent case.
	 */</comment>
	<expr_stmt><expr><name>table_lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>ShareLock</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we previously locked some other index's heap, and the name we're
	 * looking up no longer refers to that relation, release the now-useless
	 * lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relId</name> <operator>!=</operator> <name>oldRelId</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>locked_table_oid</name></name></expr></argument>, <argument><expr><name>table_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>locked_table_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If the relation does not exist, there's nothing more to do. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the relation does exist, check whether it's an index.  But note that
	 * the relation might have been dropped between the time we did the name
	 * lookup and now.  In that case, there's nothing to do.
	 */</comment>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relkind</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check permissions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_INDEX</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Lock heap before index to avoid deadlock. */</comment>
	<if_stmt><if>if <condition>(<expr><name>relId</name> <operator>!=</operator> <name>oldRelId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>table_oid</name> <init>= <expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the OID isn't valid, it means the index was concurrently
		 * dropped, which is not a problem for us; just return normally.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>table_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>locked_table_oid</name></name> <operator>=</operator> <name>table_oid</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReindexTable
 *		Recreate all indexes of a table (and of its toast table, if any)
 */</comment>
<function><type><name>Oid</name></type>
<name>ReindexTable</name><parameter_list>(<parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>options</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>concurrent</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On QE, we already know the table relation oid since we set it before
	 * dispatch the reindex statement. reindex_relation will take care of the lock directly.
	 * Other checks should already done on QD when calling RangeVarGetRelidExtended.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
						 <argument><expr><name>REINDEX_REL_PROCESS_TOAST</name> <operator>|</operator>
						 <name>REINDEX_REL_CHECK_CONSTRAINTS</name></expr></argument>,
						 <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>stmt</name><operator>-&gt;</operator><name>relid</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The lock level used here should match reindex_relation().
	 *
	 * If it's a temporary table, we will perform a non-concurrent reindex,
	 * even if CONCURRENTLY was requested.  In that case, reindex_relation()
	 * will upgrade the lock, but that's OK, because other sessions can't hold
	 * locks on our temporary table.
	 */</comment>
	<expr_stmt><expr><name>heapOid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
									   <argument><expr><ternary><condition><expr><name>concurrent</name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>ShareLock</name></expr></else></ternary></expr></argument>,
									   <argument><expr><literal type="number">0</literal></expr></argument>,
									   <argument><expr><name>RangeVarCallbackOwnsTable</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>heapOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReindexPartitions</name><argument_list>(<argument><expr><name>heapOid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>concurrent</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>concurrent</name> <operator>&amp;&amp;</operator>
			 <call><name>get_rel_persistence</name><argument_list>(<argument><expr><name>heapOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReindexRelationConcurrently</name><argument_list>(<argument><expr><name>heapOid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has no indexes that can be reindexed concurrently"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>reindex_relation</name><argument_list>(<argument><expr><name>heapOid</name></expr></argument>,
								  <argument><expr><name>REINDEX_REL_PROCESS_TOAST</name> <operator>|</operator>
								  <name>REINDEX_REL_CHECK_CONSTRAINTS</name></expr></argument>,
								  <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has no indexes to reindex"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Reindex on partitioned table will do the reindex for each index in
	 * it's own transaction, so dispatch the statement under ReindexPartitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>heapOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReindexStmt</name>	   <modifier>*</modifier></type><name>qestmt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>qestmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ReindexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>REINDEX_OBJECT_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>=</operator> <name>concurrent</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qestmt</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>heapOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qestmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name></expr></argument>,
									<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>heapOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReindexMultipleTables
 *		Recreate indexes of tables selected by objectName/objectKind.
 *
 * To reduce the probability of deadlocks, each table is reindexed in a
 * separate transaction, so we can release the lock on it right away.
 * That means this must not be called within a user transaction block!
 */</comment>
<function><type><name>void</name></type>
<name>ReindexMultipleTables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objectName</name></decl></parameter>, <parameter><decl><type><name>ReindexObjectType</name></type> <name>objectKind</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>concurrent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>objectOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relationRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>private_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_keys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>concurrent_warning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>objectKind</name> <operator>==</operator> <name>REINDEX_OBJECT_SCHEMA</name> <operator>||</operator>
		   <name>objectKind</name> <operator>==</operator> <name>REINDEX_OBJECT_SYSTEM</name> <operator>||</operator>
		   <name>objectKind</name> <operator>==</operator> <name>REINDEX_OBJECT_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>objectKind</name> <operator>==</operator> <name>REINDEX_OBJECT_SYSTEM</name> <operator>&amp;&amp;</operator> <name>concurrent</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reindex system catalogs concurrently"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"reindex_db"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get OID of object to reindex, being the database currently being used
	 * by session for a database or for system catalogs, or the schema defined
	 * by caller. At the same time do permission checks that need different
	 * processing depending on the object type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>objectKind</name> <operator>==</operator> <name>REINDEX_OBJECT_SCHEMA</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>objectOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>objectName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_namespace_ownercheck</name><argument_list>(<argument><expr><name>objectOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
						   <argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>objectOid</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>objectName</name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>objectOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can only reindex the currently open database"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_database_ownercheck</name><argument_list>(<argument><expr><name>objectOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_DATABASE</name></expr></argument>,
						   <argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Create a memory context that will survive forced transaction commits we
	 * do below.  Since it is a child of PortalContext, it will go away
	 * eventually even if we suffer an error; there's no need for special
	 * abort cleanup logic.
	 */</comment>
	<expr_stmt><expr><name>private_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>,
											<argument><expr><literal type="string">"ReindexMultipleTables"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Define the search keys to find the objects to reindex. For a schema, we
	 * select target relations using relnamespace, something not necessary for
	 * a database-wide operation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>objectKind</name> <operator>==</operator> <name>REINDEX_OBJECT_SCHEMA</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>num_keys</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_class_relnamespace</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objectOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_keys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Scan pg_class to build a list of the relations we need to reindex.
	 *
	 * We only consider plain relations and materialized views here (toast
	 * rels will be processed indirectly by reindex_relation).
	 */</comment>
	<expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>num_keys</name></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classtuple</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name><name>classtuple</name><operator>-&gt;</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Only regular tables and matviews can have indexes, so ignore any
		 * other kind of relation.
		 *
		 * Partitioned tables/indexes are skipped but matching leaf partitions
		 * are processed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classtuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>classtuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Skip temp tables of other backends; we can't reindex them at all */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classtuple</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>isTempNamespace</name><argument_list>(<argument><expr><name><name>classtuple</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Check user/system classification, and optionally skip */</comment>
		<if_stmt><if>if <condition>(<expr><name>objectKind</name> <operator>==</operator> <name>REINDEX_OBJECT_SYSTEM</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The table can be reindexed if the user is superuser, the table
		 * owner, or the database/schema owner (but in the latter case, only
		 * if it's not a shared relation).  pg_class_ownercheck includes the
		 * superuser case, and depending on objectKind we already know that
		 * the user has permission to run REINDEX on this database or schema
		 * per the permission checks at the beginning of this routine.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classtuple</name><operator>-&gt;</operator><name>relisshared</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Skip system tables, since index_create() would reject indexing them
		 * concurrently (and it would likely fail if we tried).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>concurrent</name> <operator>&amp;&amp;</operator>
			<call><name>IsCatalogRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>concurrent_warning</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reindex system catalogs concurrently, skipping all"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>concurrent_warning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Save the list of relation OIDs in private context */</comment>
		<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We always want to reindex pg_class first if it's selected to be
		 * reindexed.  This ensures that if there is any corruption in
		 * pg_class' indexes, they will be fixed before we process any other
		 * tables.  This is critical because reindexing itself will try to
		 * update pg_class.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process each relation listed in a separate transaction.  Note that this
	 * commits and then starts a new transaction immediately.
	 */</comment>
	<expr_stmt><expr><call><name>ReindexMultipleInternal</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error callback specific to ReindexPartitions().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reindex_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReindexErrorInfo</name> <modifier>*</modifier></type><name>errinfo</name> <init>= <expr><operator>(</operator><name>ReindexErrorInfo</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>||</operator>
		   <name><name>errinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>errinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while reindexing partitioned table \"%s.%s\""</literal></expr></argument>,
				   <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>errinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while reindexing partitioned index \"%s.%s\""</literal></expr></argument>,
				   <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReindexPartitions
 *
 * Reindex a set of partitions, per the partitioned index or table given
 * by the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReindexPartitions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>concurrent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partitions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relnamespace</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>reindex_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inhoids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReindexErrorInfo</name></type> <name>errinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>||</operator>
		   <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check if this runs in a transaction block, with an error callback to
	 * provide more context under which a problem happens.
	 */</comment>
	<expr_stmt><expr><name><name>errinfo</name><operator>.</operator><name>relname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errinfo</name><operator>.</operator><name>relnamespace</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errinfo</name><operator>.</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>reindex_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>errinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
							  <argument><expr><ternary><condition><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
							  <expr><literal type="string">"REINDEX TABLE"</literal></expr> </then><else>: <expr><literal type="string">"REINDEX INDEX"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create special memory context for cross-transaction storage.
	 *
	 * Since it is a child of PortalContext, it will go away eventually even
	 * if we suffer an error so there is no need for special abort cleanup
	 * logic.
	 */</comment>
	<expr_stmt><expr><name>reindex_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>, <argument><expr><literal type="string">"Reindex"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ShareLock is enough to prevent schema modifications */</comment>
	<expr_stmt><expr><name>inhoids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The list of relations to reindex are the physical partitions of the
	 * tree so discard any partitioned table or index.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>inhoids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>partkind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * This discards partitioned tables, partitioned indexes and foreign
		 * tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RELKIND_HAS_STORAGE</name><argument_list>(<argument><expr><name>partkind</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
			   <name>partkind</name> <operator>==</operator> <name>RELKIND_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Save partition OID */</comment>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>reindex_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partitions</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>partoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Process each partition listed in a separate transaction.  Note that
	 * this commits and then starts a new transaction immediately.
	 */</comment>
	<expr_stmt><expr><call><name>ReindexMultipleInternal</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clean up working storage --- note we must do this after
	 * StartTransactionCommand, else we might be trying to delete the active
	 * context!
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>reindex_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReindexMultipleInternal
 *
 * Reindex a list of relations, each one being processed in its own
 * transaction.  This commits the existing transaction immediately,
 * and starts a new transaction when finished.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReindexMultipleInternal</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>concurrent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>relids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>		<name>heapId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>relpersistence</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* functions in indexes may want a snapshot set */</comment>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check if the relation still exists */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relpersistence</name> <operator>=</operator> <call><name>get_rel_persistence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name>concurrent</name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>:
			   <expr><operator>(</operator><ternary><condition><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name></expr> ?</condition><then> <expr><name>AccessExclusiveLock</name></expr> </then><else>: <expr><name>ShareLock</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
		<comment type="block">/*
 		 * If the relation is index, lock the table first to prevent dead lock.
 		 * ShareLock is sufficient since we only need to be sure no schema or
 		 * data changes are going on.
 		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>heapId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
 		 * Now that we have the lock, double-check to see if the relation
 		 * really exists or not.  If not, assume it was dropped while we
 		 * waited to acquire lock, and ignore it.
 		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Partitioned tables and indexes can never be processed directly, and
		 * a list of their leaves should be built first.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
			   <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>concurrent</name> <operator>&amp;&amp;</operator>
			<name>relpersistence</name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReindexRelationConcurrently</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* ReindexRelationConcurrently() does the verbose output */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>reindex_index</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>,
						  <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* reindex_index() does the verbose output */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>reindex_relation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
									  <argument><expr><name>REINDEX_REL_PROCESS_TOAST</name> <operator>|</operator>
									  <name>REINDEX_REL_CHECK_CONSTRAINTS</name></expr></argument>,
									  <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>REINDEXOPT_VERBOSE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s.%s\" was reindexed"</literal></expr></argument>,
								<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Dispatch a separate REINDEX command for each table. */</comment>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ReindexStmt</name>	   <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ReindexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <ternary><condition><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name></expr> ?</condition><then>
						 <expr><name>REINDEX_OBJECT_INDEX</name></expr> </then><else>: <expr><name>REINDEX_OBJECT_TABLE</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>=</operator> <name>concurrent</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
										<argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
										<name>DF_WITH_SNAPSHOT</name></expr></argument>,
										<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReindexRelationConcurrently - process REINDEX CONCURRENTLY for given
 * relation OID
 *
 * 'relationOid' can either belong to an index, a table or a materialized
 * view.  For tables and materialized views, all its indexes will be rebuilt,
 * excluding invalid indexes and any indexes used in exclusion constraints,
 * but including its associated toast table indexes.  For indexes, the index
 * itself will be rebuilt.
 *
 * The locks taken on parent tables and involved indexes are kept until the
 * transaction is committed, at which point a session lock is taken on each
 * relation.  Both of these protect against concurrent schema changes.
 *
 * Returns true if any indexes have been rebuilt (including toast table's
 * indexes, when relevant), otherwise returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReindexRelationConcurrently</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>heapRelationIds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexIds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newIndexIds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relationLocks</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lockTags</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>private_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relationName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relationNamespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create a memory context that will survive forced transaction commits we
	 * do below.  Since it is a child of PortalContext, it will go away
	 * eventually even if we suffer an error; there's no need for special
	 * abort cleanup logic.
	 */</comment>
	<expr_stmt><expr><name>private_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>,
											<argument><expr><literal type="string">"ReindexConcurrent"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>REINDEXOPT_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Save data needed by REINDEX VERBOSE in private context */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>relationName</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relationNamespace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract the list of indexes that are going to be rebuilt based on the
	 * list of relation Oids given by caller.
	 */</comment>
	<switch>switch <condition>(<expr><name>relkind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * In the case of a relation, find all its indexes including
				 * toast indexes.
				 */</comment>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRelation</name></decl>;</decl_stmt>

				<comment type="block">/* Save the list of relation OIDs in private context */</comment>
				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Track this relation for session locks */</comment>
				<expr_stmt><expr><name>heapRelationIds</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>heapRelationIds</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsCatalogRelationOid</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reindex system catalogs concurrently"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Open relation to get its indexes */</comment>
				<expr_stmt><expr><name>heapRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Add all the valid indexes of relation to list */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>RelationGetIndexList(heapRelation)</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>cellOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRelation</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>cellOid</name></expr></argument>,
														   <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reindex invalid index \"%s.%s\" concurrently, skipping"</literal></expr></argument>,
										<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>cellOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cellOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reindex exclusion constraint index \"%s.%s\" concurrently, skipping"</literal></expr></argument>,
										<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>cellOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cellOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Save the list of relation OIDs in private context */</comment>
						<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>indexIds</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>indexIds</name></expr></argument>, <argument><expr><name>cellOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* Also add the toast indexes */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>toastOid</name> <init>= <expr><name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type>	<name>toastRelation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>toastOid</name></expr></argument>,
														   <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* Save the list of relation OIDs in private context */</comment>
					<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Track this relation for session locks */</comment>
					<expr_stmt><expr><name>heapRelationIds</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>heapRelationIds</name></expr></argument>, <argument><expr><name>toastOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>RelationGetIndexList(toastRelation)</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>cellOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRelation</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>cellOid</name></expr></argument>,
															   <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reindex invalid index \"%s.%s\" concurrently, skipping"</literal></expr></argument>,
											<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>cellOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cellOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/*
							 * Save the list of relation OIDs in private
							 * context
							 */</comment>
							<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><name>indexIds</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>indexIds</name></expr></argument>, <argument><expr><name>cellOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>

						<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>

					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name> <init>= <expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsCatalogRelationOid</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reindex system catalogs concurrently"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Save the list of relation OIDs in private context */</comment>
				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Track the heap relation of this index for session locks */</comment>
				<expr_stmt><expr><name>heapRelationIds</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Save the list of relation OIDs in private context.  Note
				 * that invalid indexes are allowed here.
				 */</comment>
				<expr_stmt><expr><name>indexIds</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>indexIds</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
		<default>default:</default>
			<comment type="block">/* Return error if type of relation is not supported */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reindex this type of relation concurrently"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Definitely no indexes, so leave */</comment>
	<if_stmt><if>if <condition>(<expr><name>indexIds</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>heapRelationIds</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*-----
	 * Now we have all the indexes we want to process in indexIds.
	 *
	 * The phases now are:
	 *
	 * 1. create new indexes in the catalog
	 * 2. build new indexes
	 * 3. let new indexes catch up with tuples inserted in the meantime
	 * 4. swap index names
	 * 5. mark old indexes as dead
	 * 6. drop old indexes
	 *
	 * We process each phase for all indexes before moving to the next phase,
	 * for efficiency.
	 */</comment>

	<comment type="block">/*
	 * Phase 1 of REINDEX CONCURRENTLY
	 *
	 * Create a new index with the same properties as the old one, but it is
	 * only registered in catalogs and will be built later.  Then get session
	 * locks on all involved tables.  See analogous code in DefineIndex() for
	 * more detailed comments.
	 */</comment>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>concurrentName</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>newIndexId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>newIndexRel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockRelId</name>  <modifier>*</modifier></type><name>lockrelid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>,
							 <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pgstat_progress_start_command</name><argument_list>(<argument><expr><name>PROGRESS_COMMAND_CREATE_INDEX</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_COMMAND</name></expr></argument>,
									 <argument><expr><name>PROGRESS_CREATEIDX_COMMAND_REINDEX_CONCURRENTLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_INDEX_OID</name></expr></argument>,
									 <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_ACCESS_METHOD_OID</name></expr></argument>,
									 <argument><expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Choose a temporary relation name for the new index */</comment>
		<expr_stmt><expr><name>concurrentName</name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><literal type="string">"ccnew"</literal></expr></argument>,
											<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create new index definition based on given index */</comment>
		<expr_stmt><expr><name>newIndexId</name> <operator>=</operator> <call><name>index_concurrently_create_copy</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>,
													<argument><expr><name>indexId</name></expr></argument>,
													<argument><expr><name>concurrentName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now open the relation of the new index, a lock is also needed on it */</comment>
		<expr_stmt><expr><name>newIndexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Save the list of OIDs and locks in private context
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newIndexIds</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>newIndexIds</name></expr></argument>, <argument><expr><name>newIndexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Save lockrelid to protect each relation from drop then close
		 * relations. The lockrelid on parent relation is not taken here to
		 * avoid multiple locks taken on the same relation, instead we rely on
		 * parentRelationIds built earlier.
		 */</comment>
		<expr_stmt><expr><name>lockrelid</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lockrelid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>lockrelid</name> <operator>=</operator> <name><name>indexRel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relationLocks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relationLocks</name></expr></argument>, <argument><expr><name>lockrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lockrelid</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lockrelid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>lockrelid</name> <operator>=</operator> <name><name>newIndexRel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relationLocks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relationLocks</name></expr></argument>, <argument><expr><name>lockrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>newIndexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Save the heap lock for following visibility checks with other backends
	 * might conflict with this session.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>heapRelationIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRelation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockRelId</name>  <modifier>*</modifier></type><name>lockrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKTAG</name>    <modifier>*</modifier></type><name>heaplocktag</name></decl>;</decl_stmt>

		<comment type="block">/* Save the list of locks in private context */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add lockrelid of heap relation to the list of locked relations */</comment>
		<expr_stmt><expr><name>lockrelid</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lockrelid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>lockrelid</name> <operator>=</operator> <name><name>heapRelation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relationLocks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relationLocks</name></expr></argument>, <argument><expr><name>lockrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>heaplocktag</name> <operator>=</operator> <operator>(</operator><name>LOCKTAG</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LOCKTAG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Save the LOCKTAG for this parent relation for the wait phase */</comment>
		<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><operator>*</operator><name>heaplocktag</name></expr></argument>, <argument><expr><name><name>lockrelid</name><operator>-&gt;</operator><name>dbId</name></name></expr></argument>, <argument><expr><name><name>lockrelid</name><operator>-&gt;</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lockTags</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lockTags</name></expr></argument>, <argument><expr><name>heaplocktag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Close heap relation */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Get a session-level lock on each table. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>relationLocks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LockRelId</name>  <modifier>*</modifier></type><name>lockrelid</name> <init>= <expr><operator>(</operator><name>LockRelId</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LockRelationIdForSession</name><argument_list>(<argument><expr><name>lockrelid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Phase 2 of REINDEX CONCURRENTLY
	 *
	 * Build the new indexes in a separate transaction for each index to avoid
	 * having open transactions for an unnecessary long time.  But before
	 * doing that, wait until no running transactions could have the table of
	 * the index open with the old list of indexes.  See "phase 2" in
	 * DefineIndex() for more details.
	 */</comment>

	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CREATEIDX_PHASE_WAIT_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WaitForLockersMultiple</name><argument_list>(<argument><expr><name>lockTags</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>indexIds</argument>, <argument>lc2</argument>, <argument>newIndexIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldIndexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>newIndexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Start new transaction for this index's concurrent build */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set ActiveSnapshot since functions in the indexes may need it */</comment>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Index relation has been closed by previous commit, so reopen it to
		 * get its information.
		 */</comment>
		<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>oldIndexId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>heapId</name> <operator>=</operator> <name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Perform concurrent build of new index */</comment>
		<expr_stmt><expr><call><name>index_concurrently_build</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>newIndexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Phase 3 of REINDEX CONCURRENTLY
	 *
	 * During this phase the old indexes catch up with any new tuples that
	 * were created during the previous phase.  See "phase 3" in DefineIndex()
	 * for more details.
	 */</comment>

	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CREATEIDX_PHASE_WAIT_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WaitForLockersMultiple</name><argument_list>(<argument><expr><name>lockTags</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>newIndexIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>newIndexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>limitXmin</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>heapId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>newIndexId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Take the "reference snapshot" that will be used by validate_index()
		 * to filter candidate tuples.
		 */</comment>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>validate_index</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>newIndexId</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can now do away with our active snapshot, we still need to save
		 * the xmin limit to wait for older snapshots.
		 */</comment>
		<expr_stmt><expr><name>limitXmin</name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * To ensure no deadlocks, we must commit and start yet another
		 * transaction, and do our wait before any snapshot has been taken in
		 * it.
		 */</comment>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The index is now valid in the sense that it contains all currently
		 * interesting tuples.  But since it might not contain tuples deleted
		 * just before the reference snap was taken, we have to wait out any
		 * transactions that might have older snapshots.
		 */</comment>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PHASE</name></expr></argument>,
									 <argument><expr><name>PROGRESS_CREATEIDX_PHASE_WAIT_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WaitForOlderSnapshots</name><argument_list>(<argument><expr><name>limitXmin</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Phase 4 of REINDEX CONCURRENTLY
	 *
	 * Now that the new indexes have been validated, swap each new index with
	 * its corresponding old index.
	 *
	 * We mark the new indexes as valid and the old indexes as not valid at
	 * the same time to make sure we only get constraint violations from the
	 * indexes with the correct names.
	 */</comment>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>indexIds</argument>, <argument>lc2</argument>, <argument>newIndexIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldName</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldIndexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>newIndexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>heapId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>oldIndexId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Choose a relation name for old index */</comment>
		<expr_stmt><expr><name>oldName</name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>oldIndexId</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><literal type="string">"ccold"</literal></expr></argument>,
									 <argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Swap old index with the new one.  This also marks the new one as
		 * valid and the old one as not valid.
		 */</comment>
		<expr_stmt><expr><call><name>index_concurrently_swap</name><argument_list>(<argument><expr><name>newIndexId</name></expr></argument>, <argument><expr><name>oldIndexId</name></expr></argument>, <argument><expr><name>oldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Invalidate the relcache for the table, so that after this commit
		 * all sessions will refresh any cached plans that might reference the
		 * index.
		 */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * CCI here so that subsequent iterations see the oldName in the
		 * catalog and can choose a nonconflicting name for their oldName.
		 * Otherwise, this could lead to conflicts if a table has two indexes
		 * whose names are equal for the first NAMEDATALEN-minus-a-few
		 * characters.
		 */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Commit this transaction and make index swaps visible */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Phase 5 of REINDEX CONCURRENTLY
	 *
	 * Mark the old indexes as dead.  First we must wait until no running
	 * transaction could be using the index for a query.  See also
	 * index_drop() for more details.
	 */</comment>

	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CREATEIDX_PHASE_WAIT_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WaitForLockersMultiple</name><argument_list>(<argument><expr><name>lockTags</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldIndexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>heapId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>oldIndexId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_concurrently_set_dead</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>oldIndexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Commit this transaction to make the updates visible. */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Phase 6 of REINDEX CONCURRENTLY
	 *
	 * Drop the old indexes.
	 */</comment>

	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CREATEIDX_PHASE_WAIT_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WaitForLockersMultiple</name><argument_list>(<argument><expr><name>lockTags</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name> <init>= <expr><call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexIds</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>oldIndexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>oldIndexId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Use PERFORM_DELETION_CONCURRENT_LOCK so that index_drop() uses the
		 * right lock level.
		 */</comment>
		<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>,
								 <argument><expr><name>PERFORM_DELETION_CONCURRENT_LOCK</name> <operator>|</operator> <name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally, release the session-level lock on the table.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>relationLocks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LockRelId</name>  <modifier>*</modifier></type><name>lockrelid</name> <init>= <expr><operator>(</operator><name>LockRelId</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><name>lockrelid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Start a new transaction to finish process properly */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log what we did */</comment>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>REINDEXOPT_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s.%s\" was reindexed"</literal></expr></argument>,
							<argument><expr><name>relationNamespace</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s."</literal></expr></argument>,
							   <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>newIndexIds</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>indOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s.%s\" was reindexed"</literal></expr></argument>,
								<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>indOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Don't show rusage here, since it's not per index. */</comment>
			</block_content>}</block>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s.%s\" was reindexed"</literal></expr></argument>,
							<argument><expr><name>relationNamespace</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s."</literal></expr></argument>,
							   <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>private_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert or delete an appropriate pg_inherits tuple to make the given index
 * be a partition of the indicated parent index.
 *
 * This also corrects the pg_depend information for the affected index.
 */</comment>
<function><type><name>void</name></type>
<name>IndexSetParentIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partitionIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_inherits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partRelid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partitionIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fix_dependencies</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure this is an index */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partitionIdx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		   <name><name>partitionIdx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan pg_inherits for rows linking our index to some parent.
	 */</comment>
	<expr_stmt><expr><name>pg_inherits</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhseqno</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_inherits</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>parentOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No pg_inherits row, and no parent wanted: nothing to do in this
			 * case.
			 */</comment>
			<expr_stmt><expr><name>fix_dependencies</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_inherits</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>Natts_pg_inherits</name></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/*
			 * No pg_inherits row exists, and we want a parent for this index,
			 * so insert it.
			 */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_inherits_inhrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_inherits_inhparent</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
				<call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_inherits_inhseqno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_inherits</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_inherits</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>fix_dependencies</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>inhForm</name> <init>= <expr><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>parentOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * There exists a pg_inherits row, which we want to clear; do so.
			 */</comment>
			<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>pg_inherits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fix_dependencies</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * A pg_inherits row exists.  If it's the same we want, then we're
			 * good; if it differs, that amounts to a corrupt catalog and
			 * should not happen.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhparent</name></name> <operator>!=</operator> <name>parentOid</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* unexpected: we should not get called in this case */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus pg_inherit row: inhrelid %u inhparent %u"</literal></expr></argument>,
					 <argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhrelid</name></name></expr></argument>, <argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhparent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* already in the right state */</comment>
			<expr_stmt><expr><name>fix_dependencies</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* done with pg_inherits */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>pg_inherits</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set relhassubclass if an index partition has been added to the parent */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetRelationHasSubclass</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* set relispartition correctly on the partition */</comment>
	<expr_stmt><expr><call><name>update_relispartition</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>, <argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fix_dependencies</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Insert/delete pg_depend rows.  If setting a parent, add PARTITION
		 * dependencies on the parent index and the table; if removing a
		 * parent, delete PARTITION dependencies.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>partIdx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>parentIdx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>partitionTbl</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>partitionTbl</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
							 <argument><expr><name><name>partitionIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partIdx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentIdx</name></expr></argument>,
							   <argument><expr><name>DEPENDENCY_PARTITION_PRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partIdx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partitionTbl</name></expr></argument>,
							   <argument><expr><name>DEPENDENCY_PARTITION_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>partRelid</name></expr></argument>,
											<argument><expr><name>RelationRelationId</name></expr></argument>,
											<argument><expr><name>DEPENDENCY_PARTITION_PRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>partRelid</name></expr></argument>,
											<argument><expr><name>RelationRelationId</name></expr></argument>,
											<argument><expr><name>DEPENDENCY_PARTITION_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* make our updates visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine of IndexSetParentIndex to update the relispartition flag of the
 * given index to the given value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_relispartition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>classRel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name> <operator>!=</operator> <name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
