<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/analyzeutils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * analyzeutils.c
 *
 *	  Provides utils functions for analyze.c
 *
 * Copyright (c) 2015, VMware, Inc. or its affiliates.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/analyzeutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/binaryheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>MCVFreqEntry</name>
<block>{
	<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
}</block></struct></type> <name>MCVFreqEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>PartDatum</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>partId</name></decl>;</decl_stmt>			<comment type="block">/* id of the partition histogram where the
								 * datum is from */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
}</block></struct></type> <name>PartDatum</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type><name>buildMCVArrayForStatsEntry</name><parameter_list>(<parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvpairArray</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nEntries</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>ndistinct</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>nrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float4</name> <modifier>*</modifier></type><name>buildFreqArrayForStatsEntry</name><parameter_list>(<parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvpairArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nEntries</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>reltuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>datumHashTableMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>datumHashTableHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>createDatumHashTable</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nEntries</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MCVFreqPair</name> <modifier>*</modifier></type><name>MCVFreqPairCopy</name><parameter_list>(<parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>containsDatum</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>datumHash</name></decl></parameter>, <parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addLeafPartitionMCVsToHashTable</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>datumHash</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heaptupleStats</name></decl></parameter>,
			 <parameter><decl><type><name>float4</name></type> <name>partReltuples</name></decl></parameter>, <parameter><decl><type><name>TypInfo</name> <modifier>*</modifier></type><name>typInfo</name></decl></parameter>
)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addMCVToHashTable</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>datumHash</name></decl></parameter>, <parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>mcvpair_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initTypInfo</name><parameter_list>(<parameter><decl><type><name>TypInfo</name> <modifier>*</modifier></type><name>typInfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DatumHeapComparator</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>advanceCursor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cursors</name></decl></parameter>, <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>getMinBound</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cursors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>ltFuncOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>getMaxBound</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ltFuncOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
						 <name>collid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>getHistogramHeapTuple</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>heaptupleStats</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numNotNullParts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initDatumHeap</name><parameter_list>(<parameter><decl><type><name>binaryheap</name> <modifier>*</modifier></type><name>hp</name></decl></parameter>, <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cursors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>float4</name></type> <name>getBucketSizes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HeapTuple</name> <modifier>*</modifier></type><name>heaptupleStats</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float4</name> <modifier>*</modifier></type><name>relTuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>,
			   <parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvPairRemaining</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rem_mcv</name></decl></parameter>,
			   <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>eachBucket</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>float4</name></type>
<name>get_rel_reltuples</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>relTuples</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>relTuples</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>relTuples</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32</name></type>
<name>get_rel_relpages</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>relPages</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>relPages</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>relPages</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given column stats of an attribute, build an MCVFreqPair and add it to the hash table.
 * If the MCV to be added already exist in the hash table, we increment its count value.
 * Input:
 * 	- datumHash: hash table
 * 	- partOid: Oid of current partition
 *  - partReltuples: Number of tuples in that partition
 * 	- typInfo: type information
 * Output:
 *  - partReltuples: the number of tuples in this partition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addLeafPartitionMCVsToHashTable</name> <parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>datumHash</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heaptupleStats</name></decl></parameter>,
								 <parameter><decl><type><name>float4</name></type> <name>partReltuples</name></decl></parameter>, <parameter><decl><type><name>TypInfo</name> <modifier>*</modifier></type> <name>typInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>mcvSlot</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcvSlot</name></expr></argument>, <argument><expr><name>heaptupleStats</name></expr></argument>, <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>,
							<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mcvSlot</name><operator>.</operator><name>nvalues</name></name> <operator>==</operator> <name><name>mcvSlot</name><operator>.</operator><name>nnumbers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvSlot</name><operator>.</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>mcv</name> <init>= <expr><name><name>mcvSlot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type>		<name>count</name> <init>= <expr><name>partReltuples</name> <operator>*</operator> <name><name>mcvSlot</name><operator>.</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair</name> <init>= <expr><operator>(</operator><name>MCVFreqPair</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MCVFreqPair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>mcvFreqPair</name><operator>-&gt;</operator><name>mcv</name></name> <operator>=</operator> <name>mcv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mcvFreqPair</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mcvFreqPair</name><operator>-&gt;</operator><name>typinfo</name></name> <operator>=</operator> <name>typInfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addMCVToHashTable</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>, <argument><expr><name>mcvFreqPair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mcvFreqPair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcvSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Main function for aggregating leaf partition MCV/Freq to compute
 * root or interior partition MCV/Freq
 *
 * Input:
 * 	- relationOid: Oid of root or interior partition
 * 	- attnum: column number
 *  - numPartitions: # of elements in heaptupleStats and relTuples arrays
 *  - heaptupleStats: pg_statistics tuples for each partition
 *  - relTuples: number of tuples in each partition (pg_class.reltuples)
 * 	- nEntries: target number of MCVs/Freqs to be collected, the real number of
 * 	MCVs/Freqs returned may be less
 *
 * Output:
 * 	- result: two dimensional arrays of MCVs and Freqs
 */</comment>
<function><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>aggregate_leaf_partition_MCVs</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
							  <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>numPartitions</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>heaptupleStats</name></decl></parameter>,
							  <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>relTuples</name></decl></parameter>,
							  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nEntries</name></decl></parameter>,
							  <parameter><decl><type><name>double</name></type> <name>ndistinct</name></decl></parameter>,
							  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_mcv</name></decl></parameter>,
							  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rem_mcv</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypInfo</name>    <modifier>*</modifier></type><name>typInfo</name> <init>= <expr><operator>(</operator><name>TypInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TypInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initTypInfo</name><argument_list>(<argument><expr><name>typInfo</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Hash table for storing combined MCVs */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>datumHash</name> <init>= <expr><call><name>createDatumHashTable</name><argument_list>(<argument><expr><name>nEntries</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>sumReltuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numPartitions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>addLeafPartitionMCVsToHashTable</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>, <argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>relTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>typInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sumReltuples</name> <operator>+=</operator> <name><name>relTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>rem_mcv</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>*</operator><name>rem_mcv</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* in the unlikely event of an empty hash table, return early */</comment>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MCVFreqEntry</name> <modifier>*</modifier></type><name>mcvfreq</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvpairArray</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>rem_mcv</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MCVFreqPair</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* put MCVFreqPairs in an array in order to sort */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>datumHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>mcvfreq</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mcvpairArray</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>mcvfreq</name><operator>-&gt;</operator><name>entry</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<comment type="block">/* sort MCVFreqPairs in descending order of frequency */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>mcvpairArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MCVFreqPair</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>mcvpair_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prepare returning MCV and Freq arrays */</comment>
	<expr_stmt><expr><operator>*</operator><name>num_mcv</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nEntries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>buildMCVArrayForStatsEntry</name><argument_list>(<argument><expr><name>mcvpairArray</name></expr></argument>, <argument><expr><name>num_mcv</name></expr></argument>,
												  <argument><expr><name>ndistinct</name></expr></argument>, <argument><expr><name>sumReltuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>num_mcv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>mcvpairArray</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name><operator>++</operator></expr>;</expr_stmt>					<comment type="block">/* now switch to frequency array (result[1]) */</comment>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>buildFreqArrayForStatsEntry</name><argument_list>(<argument><expr><name>mcvpairArray</name></expr></argument>, <argument><expr><operator>*</operator><name>num_mcv</name></expr></argument>,
												   <argument><expr><name>sumReltuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>typInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>rem_mcv</name> <operator>-=</operator> <operator>*</operator><name>num_mcv</name></expr>;</expr_stmt>
	<return>return <expr><name>mcvpairArray</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return an array of MCVs from the resultant MCVFreqPair array
 * Input:
 * 	- mcvpairArray: contains MCVs and corresponding counts in desc order
 * 	- nEntries: number of MCVs to be returned
 * 	- typoid: type oid of the MCV datum
 * 	- nrows: number of tuples from all partitions
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type>
<name>buildMCVArrayForStatsEntry</name><parameter_list>(<parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvpairArray</name></decl></parameter>,
						   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nEntries</name></decl></parameter>,
						   <parameter><decl><type><name>float4</name></type> <name>ndistinct</name></decl></parameter>,
						   <parameter><decl><type><name>float4</name></type> <name>nrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mcvpairArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>nEntries</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><operator>*</operator><name>nEntries</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>mincount</name> <init>= <expr><operator>-</operator><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nEntries</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>ndistinct</name> <operator>&amp;&amp;</operator> <name>ndistinct</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Track list includes all values seen, and all will fit */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>avgcount</name></decl>,
					<decl><type ref="prev"/><name>maxmincount</name></decl>;</decl_stmt>

		<comment type="block">/* estimate # of occurrences in sample of a typical value */</comment>
		<expr_stmt><expr><name>avgcount</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nrows</name> <operator>/</operator> <name>ndistinct</name></expr>;</expr_stmt>
		<comment type="block">/* set minimum threshold count to store a value */</comment>
		<expr_stmt><expr><name>mincount</name> <operator>=</operator> <name>avgcount</name> <operator>*</operator> <literal type="number">1.25</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mincount</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mincount</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* don't let threshold exceed 1/K, however */</comment>
		<expr_stmt><expr><name>maxmincount</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nrows</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>*</operator><name>nEntries</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mincount</name> <operator>&gt;</operator> <name>maxmincount</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mincount</name> <operator>=</operator> <name>maxmincount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block></else></if_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>nEntries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mcvpairArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>count</name> <operator>&lt;</operator> <name>mincount</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>nEntries</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>mcv</name> <init>= <expr><operator>(</operator><name><name>mcvpairArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>mcv</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>mcv</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return an array of frequencies from the resultant MCVFreqPair array
 * Input:
 * 	- mcvpairArray: contains MCVs and corresponding counts in desc order
 * 	- nEntries: number of frequencies to be returned
 * 	- reltuples: number of tuples of the root or interior partition (all leaf partitions combined)
 */</comment>
<function><type><specifier>static</specifier> <name>float4</name> <modifier>*</modifier></type>
<name>buildFreqArrayForStatsEntry</name><parameter_list>(<parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvpairArray</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>nEntries</name></decl></parameter>,
							<parameter><decl><type><name>float4</name></type> <name>reltuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mcvpairArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nEntries</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reltuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* otherwise ANALYZE will not collect stats */</comment>

	<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nEntries</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nEntries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>float4</name></type>		<name>freq</name> <init>= <expr><name><name>mcvpairArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>count</name> <operator>/</operator> <name>reltuples</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>freq</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function to sort an array of MCVFreqPairs in desc order
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>mcvpair_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>MCVFreqPair</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>MCVFreqPair</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mcvFreqPair1</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <name><name>mcvFreqPair2</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mcvFreqPair1</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;</operator> <name><name>mcvFreqPair2</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Add an MCVFreqPair to the hash table, if the same datum already exists
 * in the hash table, update its count
 * Input:
 * 	datumHash - hash table
 * 	mcvFreqPair - MCVFreqPair to be added
 * 	typbyval - whether the datum inside is passed by value
 * 	typlen - pg_type.typlen of the datum type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addMCVToHashTable</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>datumHash</name></decl></parameter>, <parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mcvFreqPair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MCVFreqEntry</name> <modifier>*</modifier></type><name>mcvfreq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* required by hash_search */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>containsDatum</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>, <argument><expr><name>mcvFreqPair</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* create a deep copy of MCVFreqPair and put it in the hash table */</comment>
		<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>MCVFreqPairCopy</name><argument_list>(<argument><expr><name>mcvFreqPair</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>mcvfreq</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mcvfreq</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>mcvfreq</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mcvFreqPair</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mcvfreq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mcvfreq</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name><name>mcvFreqPair</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Copy function for MCVFreqPair
 * Input:
 * 	mcvFreqPair - input MCVFreqPair
 * 	typbyval - whether the datum inside is passed by value
 * 	typlen - pg_type.typlen of the datum type
 * Output:
 * 	result - a deep copy of input MCVFreqPair
 */</comment>
<function><type><specifier>static</specifier> <name>MCVFreqPair</name> <modifier>*</modifier></type>
<name>MCVFreqPairCopy</name><parameter_list>(<parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>MCVFreqPair</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MCVFreqPair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name><name>mcvFreqPair</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>typinfo</name></name> <operator>=</operator> <name><name>mcvFreqPair</name><operator>-&gt;</operator><name>typinfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>mcv</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>mcvFreqPair</name><operator>-&gt;</operator><name>mcv</name></name></expr></argument>,
							<argument><expr><name><name>mcvFreqPair</name><operator>-&gt;</operator><name>typinfo</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
							<argument><expr><name><name>mcvFreqPair</name><operator>-&gt;</operator><name>typinfo</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Test whether an MCVFreqPair is in the hash table
 * Input:
 * 	datumHash - hash table
 * 	mcvFreqPair - pointer to an MCVFreqPair
 * Output:
 * 	found - whether the MCVFreqPair is found
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>containsDatum</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>datumHash</name></decl></parameter>, <parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>datumHash</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>datumHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mcvFreqPair</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Create a hash table with both hash key and hash entry as a pointer
 * to a MCVFreqPair struct
 * Input:
 * 	nEntries - estimated number of elements in the hash table, the size
 * 	of the hash table can grow dynamically
 * Output:
 * 	a pointer to the created hash table
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>createDatumHashTable</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nEntries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MCVFreqPair</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MCVFreqEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>datumHashTableHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>datumHashTableMatch</name></expr>;</expr_stmt>

	<return>return <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"DatumHashTable"</literal></expr></argument>, <argument><expr><name>nEntries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
					   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Hash function for MCVFreqPair struct pointer.
 * Input:
 * 	keyPtr - pointer to hash key
 * 	keysize - not used, hash function must have this signature
 * Output:
 * 	result - hash value as an unsigned integer
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>datumHashTableHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>mcvFreqPair</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>MCVFreqPair</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>keyPtr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>hashfunc</name> <init>= <expr><operator>&amp;</operator><name><name>mcvFreqPair</name><operator>-&gt;</operator><name>typinfo</name><operator>-&gt;</operator><name>hashfunc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name> <init>= <expr><name><name>mcvFreqPair</name><operator>-&gt;</operator><name>typinfo</name><operator>-&gt;</operator><name>collid</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><name>hashfunc</name></expr></argument>, <argument><expr><name>collid</name></expr></argument>, <argument><expr><name><name>mcvFreqPair</name><operator>-&gt;</operator><name>mcv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Match function for MCVFreqPair struct pointer.
 * Input:
 * 	keyPtr1, keyPtr2 - pointers to two hash keys
 * 	keysize - not used, hash function must have this signature
 * Output:
 * 	0 if two hash keys match, 1 otherwise
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>datumHashTableMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keyPtr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keyPtr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>MCVFreqPair</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>keyPtr1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>MCVFreqPair</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>keyPtr2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>left</name><operator>-&gt;</operator><name>typinfo</name><operator>-&gt;</operator><name>typOid</name></name> <operator>==</operator> <name><name>right</name><operator>-&gt;</operator><name>typinfo</name><operator>-&gt;</operator><name>typOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name><name>left</name><operator>-&gt;</operator><name>typinfo</name><operator>-&gt;</operator><name>eqFuncOp</name></name></expr></argument>,
								<argument><expr><name><name>left</name><operator>-&gt;</operator><name>typinfo</name><operator>-&gt;</operator><name>collid</name></name></expr></argument>,
								<argument><expr><name><name>left</name><operator>-&gt;</operator><name>mcv</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>mcv</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize type information
 * Input:
 * 	relationOid - oid of the relation
 * 	attnum - attribute numbe
 * Output:
 *  members of typInfo are initialized
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initTypInfo</name><parameter_list>(<parameter><decl><type><name>TypInfo</name> <modifier>*</modifier></type><name>typInfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ltOpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>eqOpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>hashFunc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>typInfo</name><operator>-&gt;</operator><name>typOid</name></name> <operator>=</operator> <name>typoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typInfo</name><operator>-&gt;</operator><name>collid</name></name> <operator>=</operator> <name>collid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typInfo</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typInfo</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ltOpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqOpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typInfo</name><operator>-&gt;</operator><name>ltFuncOp</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>ltOpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typInfo</name><operator>-&gt;</operator><name>eqFuncOp</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>eqOpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_op_hash_functions</name><argument_list>(<argument><expr><name>eqOpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashFunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find hash function for hash operator %u"</literal></expr></argument>, <argument><expr><name>eqOpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>hashFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typInfo</name><operator>-&gt;</operator><name>hashfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Comparator function of heap element PartDatum
 * Input:
 * 	lhs, rhs - pointers to heap elements
 * 	context - pointer to comparison context
 * Output:
 *  -1 if lhs &lt; rhs
 *  0 if lhs == rhs
 *  1 if lhs &gt; rhs
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DatumHeapComparator</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d1</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PartDatum</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>datum</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d2</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PartDatum</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>datum</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypInfo</name>    <modifier>*</modifier></type><name>typInfo</name> <init>= <expr><operator>(</operator><name>TypInfo</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name><name>typInfo</name><operator>-&gt;</operator><name>ltFuncOp</name></name></expr></argument>,
							 <argument><expr><name><name>typInfo</name><operator>-&gt;</operator><name>collid</name></name></expr></argument>,
							 <argument><expr><name>d1</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name><name>typInfo</name><operator>-&gt;</operator><name>eqFuncOp</name></name></expr></argument>,
							 <argument><expr><name><name>typInfo</name><operator>-&gt;</operator><name>collid</name></name></expr></argument>,
							 <argument><expr><name>d1</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Advance the cursor of a partition by 1, set to -1 if the end is reached
 * Input:
 * 	pid - partition id
 * 	cursors - cursor vector
 * 	nBounds - array of the number of bounds
 * */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>advanceCursor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cursors</name></decl></parameter>, <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cursors</name><index>[<expr><name>pid</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cursors</name><index>[<expr><name>pid</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name>nvalues</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cursors</name><index>[<expr><name>pid</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the minimum bound of all partition bounds. Only need to iterate over
 * the first bound of each partition since the bounds in a histogram are ordered.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>getMinBound</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cursors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ltFuncOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>histSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>histSlots</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cursors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nParts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type>		<name>minDatum</name> <init>= <expr><name><name>histSlots</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pid</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>pid</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name>ltFuncOid</name></expr></argument>, <argument><expr><name>collid</name></expr></argument>,
								 <argument><expr><name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>minDatum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>minDatum</name> <operator>=</operator> <name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>advanceCursor</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>cursors</name></expr></argument>, <argument><expr><name>histSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>minDatum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the maximum bound of all partition bounds. Only need to iterate over
 * the last bound of each partition since the bounds in a histogram are ordered.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>getMaxBound</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ltFuncOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>histSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>histSlots</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nParts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type>		<name>maxDatum</name> <init>= <expr><name><name>histSlots</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><name><name>histSlots</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pid</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>pid</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name>ltFuncOid</name></expr></argument>, <argument><expr><name>collid</name></expr></argument>,
								 <argument><expr><name>maxDatum</name></expr></argument>, <argument><expr><name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name>nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxDatum</name> <operator>=</operator> <name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name>nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>maxDatum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Preparing the output array of histogram bounds, removing any duplicates
 * Input:
 * 	ldatum - list of pointers to the aggregated bounds, may contain duplicates
 * 	typInfo - type information
 * Output:
 *  an array containing the aggregated histogram bounds
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type>
<name>buildHistogramEntryForStats</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ldatum</name></decl></parameter>, <parameter><decl><type><name>TypInfo</name> <modifier>*</modifier></type><name>typInfo</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_hist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ldatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>histArray</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>ldatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>prevDatum</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>ldatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_hist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach_with_count</name><argument_list>(<argument>lc</argument>, <argument>ldatum</argument>, <argument>idx</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>pdatum</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* remove duplicate datum in the list, starting from the second datum */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name><name>typInfo</name><operator>-&gt;</operator><name>eqFuncOp</name></name></expr></argument>, <argument><expr><name><name>typInfo</name><operator>-&gt;</operator><name>collid</name></name></expr></argument>,
								 <argument><expr><operator>*</operator><name>pdatum</name></expr></argument>, <argument><expr><operator>*</operator><name>prevDatum</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>histArray</name><index>[<expr><operator>*</operator><name>num_hist</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>pdatum</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>num_hist</name> <operator>=</operator> <operator>*</operator><name>num_hist</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>prevDatum</name> <operator>=</operator> <operator>*</operator><name>pdatum</name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>histArray</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Obtain all histogram bounds from every partition and store them in a 2D array (histData)
 * Input:
 * 	lRelOids - list of part Oids
 * 	typInfo - type info
 * 	attnum - attribute number
 * Output:
 * 	histData - 2D array of all histogram bounds from every partition
 * 	nBounds - array of the number of histogram bounds (from each partition)
 * 	partsReltuples - array of the number of tuples (from each partition)
 * 	sumReltuples - sum of number of tuples in all partitions
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getHistogramHeapTuple</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>heaptupleStats</name></decl></parameter>,
					  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numNotNullParts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>AttStatsSlot</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttStatsSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name>nvalues</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pid</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>numNotNullParts</name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain all histogram bounds from every partition and store them in a 2D array (histData)
 * Input:
 * 	lRelOids - list of part Oids
 * 	typInfo - type info
 * 	attnum - attribute number
 * Output:
 * 	histData - 2D array of all histogram bounds from every partition
 * 	nBounds - array of the number of histogram bounds (from each partition)
 * 	partsReltuples - array of the number of tuples (from each partition)
 * 	sumReltuples - sum of number of tuples in all partitions
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getHistogramMCVTuple</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>, <parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvRemaining</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>start_idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rem_mcv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>rem_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>histSlots</name><index>[<expr><name>start_idx</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>AttStatsSlot</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttStatsSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>histSlots</name><index>[<expr><name>start_idx</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nvalues</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>histSlots</name><index>[<expr><name>start_idx</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>-&gt;</operator><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>histSlots</name><index>[<expr><name>start_idx</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>mcvRemaining</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>mcv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>histSlots</name><index>[<expr><name>start_idx</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>mcvRemaining</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>mcv</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize heap by inserting the second histogram bound from each partition histogram.
 * Input:
 * 	hp - heap
 * 	histData - all histogram bounds from each part
 * 	cursors - cursor vector
 * 	nParts - number of partitions
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initDatumHeap</name><parameter_list>(<parameter><decl><type><name>binaryheap</name> <modifier>*</modifier></type><name>hp</name></decl></parameter>, <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier> <modifier>*</modifier></type><name>histSlots</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cursors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartDatum</name> <modifier>*</modifier></type><name>pds</name> <init>= <expr><operator>(</operator><name>PartDatum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nParts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartDatum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pid</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>pid</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* do nothing if part histogram only has one element */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cursors</name><index>[<expr><name>pid</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pds</name><index>[<expr><name>pid</name></expr>]</index></name><operator>.</operator><name>partId</name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pds</name><index>[<expr><name>pid</name></expr>]</index></name><operator>.</operator><name>datum</name> <operator>=</operator> <name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><name><name>cursors</name><index>[<expr><name>pid</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>binaryheap_add_unordered</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pds</name><index>[<expr><name>pid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>binaryheap_build</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main function for aggregating leaf partition histogram to compute
 * root or interior partition histogram
 * Input:
 * 	- relationOid: Oid of root or interior partition
 * 	- attnum: column number
 *  - nParts: # of elements in heaptupleStats and relTuples arrays
 *  - heaptupleStats: pg_statistics tuples for each partition
 * 	- nEntries: target number of histogram bounds to be collected, the real number of
 * 	histogram bounds returned may be less
 * Output:
 * 	- result: an array of aggregated histogram bounds
 * Algorithm:
 *
 * 	We use the following example to explain how the aggregating algorithm works.

	Suppose a parent table 'lineitem' has 3 partitions 'lineitem_prt_1', 'lineitem_prt_2',
	'lineitem_prt_3'. The histograms of the column of interest of the parts are:

	hist(prt_1): {0,19,38,59}
	hist(prt_2): {2,18,40,62}
	hist(prt_3): {1,22,39,61}

	Note the histograms are equi-depth, which implies each bucket should contain the same number of tuples.

	The number of tuples in each part is:

	nTuples(prt_1) = 300
	nTuples(prt_2) = 270
	nTuples(prt_3) = 330

	Some notation:

	hist(agg): the aggregated histogram
	hist(parts): the histograms of the partitions, i.e., {hist(prt_1), hist(prt_2), hist(prt_3)}
	nEntries: the target number of histogram buckets in hist(agg). Usually this is the same as in the partitions. In this example, nEntries = 3.
	nParts: the number of partitions. nParts = 3 in this example.

	Since we know the target number of tuples in each bucket of hist(agg), the basic idea is to fill the buckets of hist(agg) using the buckets in hist(parts). And once a bucket in hist(agg) is filled up, we look at which bucket from hist(parts) is the current bucket, and use its bound as the bucket bound in hist(agg).
	Continue with our example we have,

	bucketSize(prt_1) = 300/3 = 100
	bucketSize(prt_2) = 270/3 = 90
	bucketSize(prt_3) = 330/3 = 110
	bucketSize(agg) = (300+270+330)/3 = 300

	Now, to begin with, we find the minimum of the first boundary point across hist(parts) and use it as the first boundary of hist(agg), i.e.,
	hist(agg) = {min({0,2,1})} = {0}

	We need to maintain a priority queue in order to decide on the next bucket from hist(parts) to work with.
	Each element in the queue is a (Datum, partID) pair, where Datum is a boundary from hist(parts) and partID is the ID of the part the Datum comes from.
	Each time we dequeue(), we get the minimum datum in the queue as the next datum we will work on.
	The priority queue contains up to nParts entries. In our example, we first enqueue
	the second boundary across hist(parts), i.e., 19, 18, 22, along with their part ID.

	Continue with filling the bucket of hist(agg), we dequeue '18' from the queue and fill in
	the first bucket (having 90 tuples). Since bucketSize(agg) = 300, we need more buckets
	from hist(parts) to fill it. At the same time, we dequeue 18 and enqueue the next bound (which is 40).
	The first bucket of hist(agg) will be filled up by '22' (90+100+110 &gt;= 300), at this time we put '22' as the next boundary value in hist(agg), i.e.
	hist(agg) = {0,22}

	Continue with the iteration, we will finally fill all the buckets
	hist(agg) = {0,22,40,62}
 *
 */</comment>
<function><type><name>int</name></type>
<name>aggregate_leaf_partition_histograms</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
									<parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>,
									<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>heaptupleStats</name></decl></parameter>,
									<parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>relTuples</name></decl></parameter>,
									<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nEntries</name></decl></parameter>,
									<parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvpairArray</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>rem_mcv</name></decl></parameter>,
									<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name>rem_mcv</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>mcvpairArray</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nParts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get type information */</comment>
	<decl_stmt><decl><type><name>TypInfo</name></type>		<name>typInfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initTypInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typInfo</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>AttStatsSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>histSlots</name> <init>= <expr><operator>(</operator><name>AttStatsSlot</name> <operator>*</operator> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>nParts</name> <operator>+</operator> <name>rem_mcv</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttStatsSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>sumReltuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>numNotNullParts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* populate histData, nBounds, partsReltuples and sumReltuples */</comment>
	<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>eachBucket</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>nParts</name> <operator>+</operator> <name>rem_mcv</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* the number of data
																			 * points in each bucket
																			 * for each histogram */</comment>

	<expr_stmt><expr><call><name>getHistogramHeapTuple</name><argument_list>(<argument><expr><name>histSlots</name></expr></argument>, <argument><expr><name>heaptupleStats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numNotNullParts</name></expr></argument>, <argument><expr><name>nParts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>numNotNullParts</name> <operator>+</operator> <name>rem_mcv</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if all the parts histograms are empty, we return nothing */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>getHistogramMCVTuple</name><argument_list>(<argument><expr><name>histSlots</name></expr></argument>, <argument><expr><name>mcvpairArray</name></expr></argument>, <argument><expr><name>numNotNullParts</name></expr></argument>, <argument><expr><name>rem_mcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumReltuples</name> <operator>=</operator> <call><name>getBucketSizes</name><argument_list>(<argument><expr><name>heaptupleStats</name></expr></argument>, <argument><expr><name>relTuples</name></expr></argument>, <argument><expr><name>nParts</name></expr></argument>, <argument><expr><name>mcvpairArray</name></expr></argument>, <argument><expr><name>rem_mcv</name></expr></argument>, <argument><expr><name>eachBucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset nParts to the number of non-null parts */</comment>
	<expr_stmt><expr><name>nParts</name> <operator>=</operator> <name>numNotNullParts</name> <operator>+</operator> <name>rem_mcv</name></expr>;</expr_stmt>

	<comment type="block">/* now define the state variables needed for the aggregation loop */</comment>
	<decl_stmt><decl><type><name>float4</name></type>		<name>bucketSize</name> <init>= <expr><name>sumReltuples</name> <operator>/</operator> <name>nEntries</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* target bucket size in
														 * the aggregated
														 * histogram */</comment>
	<decl_stmt><decl><type><name>float4</name></type>		<name>nTuplesToFill</name> <init>= <expr><name>bucketSize</name></expr></init></decl>;</decl_stmt> <comment type="block">/* remaining number of tuples to
											 * fill in the current bucket of
											 * the aggregated histogram, reset
											 * to bucketSize when a new bucket
											 * is added */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>cursors</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>nParts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* the index of current
															 * bucket for each
															 * histogram, set to -1
															 * after the histogram
															 * has been traversed */</comment>
	<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>remainingSize</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>nParts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* remaining number of
																	 * tuples in the current
																	 * bucket of a part */</comment>

	<comment type="block">/* initialize eachBucket[] and remainingSize[] */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name><name>histSlots</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nvalues</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>remainingSize</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>eachBucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we maintain a priority queue (min heap) of PartDatum */</comment>
	<decl_stmt><decl><type><name>binaryheap</name> <modifier>*</modifier></type><name>dhp</name> <init>= <expr><call><name>binaryheap_allocate</name><argument_list>(<argument><expr><name>nParts</name></expr></argument>,
										  <argument><expr><name>DatumHeapComparator</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>typInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ldatum</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* list of pointers to the selected bounds */</comment>

	<comment type="block">/*
	 * the first bound in the aggregated histogram will be the minimum of the
	 * first bounds of all parts
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>minBound</name> <init>= <expr><call><name>getMinBound</name><argument_list>(<argument><expr><name>histSlots</name></expr></argument>, <argument><expr><name>cursors</name></expr></argument>, <argument><expr><name>nParts</name></expr></argument>,
									   <argument><expr><name><name>typInfo</name><operator>.</operator><name>ltFuncOp</name></name></expr></argument>, <argument><expr><name><name>typInfo</name><operator>.</operator><name>collid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ldatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * continue filling the aggregated histogram, starting from the second
	 * bound
	 */</comment>
	<expr_stmt><expr><call><name>initDatumHeap</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><name>histSlots</name></expr></argument>, <argument><expr><name>cursors</name></expr></argument>, <argument><expr><name>nParts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * loop continues when DatumHeap is not empty yet and the number of
	 * histogram boundaries has not reached nEntries
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>binaryheap_empty</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>ldatum</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nEntries</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartDatum</name>  <modifier>*</modifier></type><name>pd</name> <init>= <expr><operator>(</operator><name>PartDatum</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>binaryheap_first</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>pid</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>partId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>remainingSize</name><index>[<expr><name>pid</name></expr>]</index></name> <operator>&lt;</operator> <name>nTuplesToFill</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nTuplesToFill</name> <operator>-=</operator> <name><name>remainingSize</name><index>[<expr><name>pid</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>advanceCursor</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>cursors</name></expr></argument>, <argument><expr><name>histSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>remainingSize</name><index>[<expr><name>pid</name></expr>]</index></name> <operator>=</operator> <name><name>eachBucket</name><index>[<expr><name>pid</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cursors</name><index>[<expr><name>pid</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>datum</name></name> <operator>=</operator> <name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><name><name>cursors</name><index>[<expr><name>pid</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>binaryheap_replace_first</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>pd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>binaryheap_remove_first</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ldatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>histSlots</name><index>[<expr><name>pid</name></expr>]</index></name><operator>-&gt;</operator><name><name>values</name><index>[<expr><name><name>cursors</name><index>[<expr><name>pid</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>remainingSize</name><index>[<expr><name>pid</name></expr>]</index></name> <operator>-=</operator> <name>nTuplesToFill</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nTuplesToFill</name> <operator>=</operator> <name>bucketSize</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * adding the max boundary across all histograms to the aggregated
	 * histogram
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>maxBound</name> <init>= <expr><call><name>getMaxBound</name><argument_list>(<argument><expr><name>histSlots</name></expr></argument>, <argument><expr><name>nParts</name></expr></argument>, <argument><expr><name><name>typInfo</name><operator>.</operator><name>ltFuncOp</name></name></expr></argument>, <argument><expr><name><name>typInfo</name><operator>.</operator><name>collid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ldatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now ldatum contains the resulting boundaries */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_hist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>buildHistogramEntryForStats</name><argument_list>(<argument><expr><name>ldatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_hist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* clean up */</comment>
	<expr_stmt><expr><call><name>binaryheap_free</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>

	<return>return <expr><name>num_hist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>float4</name></type>
<name>getBucketSizes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HeapTuple</name> <modifier>*</modifier></type><name>heaptupleStats</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float4</name> <modifier>*</modifier></type><name>relTuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParts</name></decl></parameter>,
			   <parameter><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvPairRemaining</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rem_mcv</name></decl></parameter>,
			   <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>eachBucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>total</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>nParts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>sumTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>total</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>mcvSlot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>total</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>relTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stat</name> <init>= <expr><operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcvSlot</name></expr></argument>, <argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mcvSlot</name><operator>.</operator><name>nvalues</name></name> <operator>==</operator> <name><name>mcvSlot</name><operator>.</operator><name>nnumbers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>mcvSlot</name><operator>.</operator><name>nnumbers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>total</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-=</operator> <name><name>relTuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>mcvSlot</name><operator>.</operator><name>numbers</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>total</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-=</operator> <name><name>relTuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>stat</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>total</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition>		<comment type="block">/* will this happen? */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>total</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We assume eachBucket[i] is initialized to 0.0 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcvSlot</name></expr></argument>, <argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							 <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>eachBucket</name><index>[<expr><name>pid</name></expr>]</index></name> <operator>=</operator> <name><name>total</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <operator>(</operator><name><name>mcvSlot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>pid</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>sumTotal</name> <operator>+=</operator> <name><name>total</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>pid</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pid</name> <operator>+</operator> <name>rem_mcv</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>eachBucket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>mcvPairRemaining</name><index>[<expr><name>i</name> <operator>-</operator> <name>pid</name></expr>]</index></name><operator>-&gt;</operator><name>count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sumTotal</name> <operator>+=</operator> <name><name>eachBucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>sumTotal</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	needs_sample() -- checks if the analyze requires sampling the actual data
 */</comment>
<function><type><name>bool</name></type>
<name>needs_sample</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attr_cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vacattrstats</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>statext_oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>merge_stats</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we must acquire sample rows to build extend statisics */</comment>
	<expr_stmt><expr><name>statext_oids</name> <operator>=</operator> <call><name>RelationGetStatExtList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>statext_oids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>statext_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fetch_leaf_attnum - retrieve leaf table's attribute number by the
 * attribute name through index scan on pg_attribute table.
 */</comment>
<function><type><name>AttrNumber</name></type>
<name>fetch_leaf_attnum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>leafRelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>attname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>result</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>leafRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AttributeRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>attForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>attForm</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fetch_leaf_att_stats - retrieve leaf table's stats info
 * through index scan on pg_statistic table and copy the tuple.
 *
 * Remember to free the returned tuple if not NULL.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>fetch_leaf_att_stats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>leafRelid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>leafAttNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_statistic_starelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>leafRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_statistic_staattnum</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
				<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>leafAttNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_statistic_stainherit</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_BOOLEQ</name></expr></argument>,
				<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>StatisticRelidAttnumInhIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	leaf_parts_analyzed() -- checks if all the leaf partitions are analyzed
 *                           for each requested column to be analyzed
 *
 *	We use this function to determine if all the leaf partitions are analyzed
 *  for the requested columns and the statistics are in place to be able to
 *  merge and generate meaningful statistics for the root partition. If any
 *  partition is analyzed and the attstattarget is set to collect stats, but
 *  there are no statistics for the partition in pg_statistics, root
 *  statistics will be bogus if we continue merging.
 *  0. A requested column in a single partition is not analyzed - return FALSE
 *  1. All partitions are analyzed
 *	  1.1. All partitions are empty - return FALSE
 *    1.2. Some empty &amp; rest have stats - return TRUE
 *    1.3. Some empty &amp; at least one don't have stats - return FALSE
 *    1.4. None empty &amp; at least one don't have stats - return FALSE
 *    1.5. None empty &amp; all have stats - return TRUE
 *
 *
 *  attrelid - the relation id of the root table
 *  relid_exclude - it is the relid that is excluded to check for the stats.
 *  It is used when we are asked to auto merge statistics when analyzing a
 *  single leaf partition. As we are going to produce stats for that
 *  specific leaf partition, we should not check its stats availability.
 *  va_cols - list of column names to be analyzed. (The corresponding attnums
 *             in partitions might differ.)
 */</comment>
<function><type><name>bool</name></type>
<name>leaf_parts_analyzed</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>attrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid_exclude</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oid_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_parts_empty</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc_col</name></decl>;</decl_stmt>

	<comment type="block">/* empty list means "all columns" */</comment>
	<if_stmt><if>if <condition>(<expr><name>va_cols</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>        <name>parentrel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>attrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>       <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator> <name><name>att</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>va_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>va_cols</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The first loop only make sure all leaf tables are analyzed through
	 * pg_class catalog, and don't touch any leaf tables' pg_statistic
	 * and pg_attribute tuples to avoid overhead cost if there still leaf
	 * tables not analyzed. Return false once find a leaf table not analyzed.
	 */</comment>
	<expr_stmt><expr><name>oid_list</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>attrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>oid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partRelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>partRelid</name> <operator>==</operator> <name>relid_exclude</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Ignore all but leaf partition */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>float4</name></type>		<name>relTuples</name> <init>= <expr><call><name>get_rel_reltuples</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>relpages</name> <init>= <expr><call><name>get_rel_relpages</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Partition is not analyzed */</comment>
		<if_stmt><if>if <condition>(<expr><name>relTuples</name> <operator>==</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <name>relpages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>relid_exclude</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition %s is not analyzed, so ANALYZE will collect sample for stats calculation"</literal></expr></argument>,
								<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"auto merging of leaf partition stats to calculate root partition stats is not possible because partition %s is not analyzed"</literal></expr></argument>,
								<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>oid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partRelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>partRelid</name> <operator>==</operator> <name>relid_exclude</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>float4</name></type>		<name>relTuples</name> <init>= <expr><call><name>get_rel_reltuples</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Partition is analyzed and we detect it is empty */</comment>
		<if_stmt><if>if <condition>(<expr><name>relTuples</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>all_parts_empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc_col</argument>, <argument>va_cols</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Check stats availability for each column that asked to be
			 * analyzed.
			 */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * fetch_leaf_attnum and fetch_leaf_att_stats retrieve leaf partition
			 * table's pg_attribute tuple and pg_statistic tuple through index scan
			 * instead of system catalog cache. Since if using system catalog cache,
			 * the total tuple entries insert into the cache will up to:
			 * (number_of_leaf_tables * number_of_column_in_this_table) pg_attribute tuples
			 * +
			 * (number_of_leaf_tables * number_of_column_in_this_table) pg_statistic tuples
			 * which could use extremely large memroy in CacheMemoryContext.
			 * This happens when most of the leaf tables are analyzed. And the current loop
			 * will loop lots of leaf tables.
			 *
			 * fetch_leaf_att_stats copy the original tuple, so remember to free it.
			 *
			 * As a side-effect, if insert/update/copy several leaf tables which under same
			 * root partition table in same session will be much slower since auto_stats
			 * will call this function everytime the leaf table gets update, and we don't
			 * rely on system catalog cache now.
			 */</comment>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>child_attno</name> <init>= <expr><call><name>fetch_leaf_attnum</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heaptupleStats</name> <init>= <expr><call><name>fetch_leaf_att_stats</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>, <argument><expr><name>child_attno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* if there is no colstats */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heaptupleStats</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>relid_exclude</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %s of partition %s is not analyzed, so ANALYZE will collect sample for stats calculation"</literal></expr></argument>,
									<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"auto merging of leaf partition stats to calculate root partition stats is not possible because column %s of partition %s is not analyzed"</literal></expr></argument>,
									<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>heaptupleStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><operator>!</operator><name>all_parts_empty</name></expr>;</return>
</block_content>}</block></function>
</unit>
