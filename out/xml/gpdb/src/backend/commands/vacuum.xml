<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/vacuum.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * vacuum.c
 *	  The postgres vacuum cleaner.
 *
 * This file now includes only control and dispatch code for VACUUM and
 * ANALYZE commands.  Regular VACUUM is implemented in vacuumlazy.c,
 * ANALYZE in analyze.c, and VACUUM FULL is a variant of CLUSTER, handled
 * in cluster.c.
 *
 * Also have a look at vacuum_ao.c, which contains VACUUM related code for
 * Append-Optimized tables.
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/vacuum.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/analyzeutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>VacuumStatsContext</name>
<block>{
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>updated_stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nsegs</name></decl>;</decl_stmt>
}</block></struct></type> <name>VacuumStatsContext</name>;</typedef>

<comment type="block">/*
 * GUC parameters
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>vacuum_freeze_min_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>vacuum_freeze_table_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>vacuum_multixact_freeze_min_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>vacuum_multixact_freeze_table_age</name></decl>;</decl_stmt>


<comment type="block">/* A few variables that don't seem worth passing around as parameters */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>vac_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BufferAccessStrategy</name></type> <name>vac_strategy</name></decl>;</decl_stmt>


<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>expand_vacuum_rel</name><parameter_list>(<parameter><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>vrel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_all_vacuum_rels</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vac_truncate_clog</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>frozenXID</name></decl></parameter>,
							  <parameter><decl><type><name>MultiXactId</name></type> <name>minMulti</name></decl></parameter>,
							  <parameter><decl><type><name>TransactionId</name></type> <name>lastSaneFrozenXid</name></decl></parameter>,
							  <parameter><decl><type><name>MultiXactId</name></type> <name>lastSaneMinMulti</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>vacuum_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VacOptTernaryValue</name></type> <name>get_vacopt_ternary_value</name><parameter_list>(<parameter><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dispatchVacuum</name><parameter_list>(<parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
						   <parameter><decl><type><name>VacuumStatsContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>vacuum_params_to_options_list</name><parameter_list>(<parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vacuum_combine_stats</name><parameter_list>(<parameter><decl><type><name>VacuumStatsContext</name> <modifier>*</modifier></type><name>stats_context</name></decl></parameter>,
								 <parameter><decl><type><name>CdbPgResults</name> <modifier>*</modifier></type><name>cdb_pgresults</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vac_update_relstats_from_list</name><parameter_list>(<parameter><decl><type><name>VacuumStatsContext</name> <modifier>*</modifier></type><name>stats_context</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Primary entry point for manual VACUUM and ANALYZE commands
 *
 * This is mainly a preparation wrapper for the real operations that will
 * happen in vacuum().
 */</comment>
<function><type><name>void</name></type>
<name>ExecVacuum</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacstmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>auto_stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumParams</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>verbose</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_locked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>analyze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>freeze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>full</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>disable_page_skipping</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rootonly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fullscan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ao_phase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Set default value */</comment>
	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>index_cleanup</name></name> <operator>=</operator> <name>VACOPT_TERNARY_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>truncate</name></name> <operator>=</operator> <name>VACOPT_TERNARY_DEFAULT</name></expr>;</expr_stmt>

	<comment type="block">/* Parse options list */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>vacstmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Parse common options for VACUUM and ANALYZE */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"verbose"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>verbose</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"skip_locked"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skip_locked</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"rootpartition"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rootonly</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fullscan"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fullscan</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>vacstmt</name><operator>-&gt;</operator><name>is_vacuumcmd</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized ANALYZE option \"%s\""</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/* Parse options available on VACUUM */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>analyze</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"freeze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>freeze</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"full"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>full</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"disable_page_skipping"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>disable_page_skipping</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"index_cleanup"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>params</name><operator>.</operator><name>index_cleanup</name></name> <operator>=</operator> <call><name>get_vacopt_ternary_value</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"truncate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>params</name><operator>.</operator><name>truncate</name></name> <operator>=</operator> <call><name>get_vacopt_ternary_value</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"ao_phase"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ao_phase</name> <operator>=</operator> <call><name>defGetInt32</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ao_phase</name> <operator>&amp;</operator> <name>VACUUM_AO_PHASE_MASK</name><operator>)</operator> <operator>==</operator> <name>ao_phase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized VACUUM option \"%s\""</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Set vacuum options */</comment>
	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>options</name></name> <operator>=</operator>
		<operator>(</operator><ternary><condition><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>is_vacuumcmd</name></name></expr> ?</condition><then> <expr><name>VACOPT_VACUUM</name></expr> </then><else>: <expr><name>VACOPT_ANALYZE</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><name>VACOPT_VERBOSE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name>skip_locked</name></expr> ?</condition><then> <expr><name>VACOPT_SKIP_LOCKED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name>analyze</name></expr> ?</condition><then> <expr><name>VACOPT_ANALYZE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name>freeze</name></expr> ?</condition><then> <expr><name>VACOPT_FREEZE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name>full</name></expr> ?</condition><then> <expr><name>VACOPT_FULL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name>disable_page_skipping</name></expr> ?</condition><then> <expr><name>VACOPT_DISABLE_PAGE_SKIPPING</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rootonly</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>options</name></name> <operator>|=</operator> <name>VACOPT_ROOTONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>fullscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>options</name></name> <operator>|=</operator> <name>VACOPT_FULLSCAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>options</name></name> <operator>|=</operator> <name>ao_phase</name></expr>;</expr_stmt>

	<comment type="block">/* sanity checks on options */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <operator>(</operator><name>VACOPT_VACUUM</name> <operator>|</operator> <name>VACOPT_ANALYZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>params</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>||</operator>
		   <operator>!</operator><operator>(</operator><name><name>params</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <operator>(</operator><name>VACOPT_FULL</name> <operator>|</operator> <name>VACOPT_FREEZE</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>params</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_SKIPTOAST</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure VACOPT_ANALYZE is specified if any column lists are present.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>params</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>vacstmt-&gt;rels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>vrel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>VacuumRelation</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>vrel</name><operator>-&gt;</operator><name>va_cols</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ANALYZE option must be specified when a column list is provided"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * All freeze ages are zero if the FREEZE option is given; otherwise pass
	 * them as -1 which means to use the default values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FREEZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>freeze_min_age</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>freeze_table_age</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>multixact_freeze_min_age</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>multixact_freeze_table_age</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>freeze_min_age</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>freeze_table_age</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>multixact_freeze_min_age</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>.</operator><name>multixact_freeze_table_age</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* user-invoked vacuum is never "for wraparound" */</comment>
	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>is_wraparound</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* user-invoked vacuum never uses this parameter */</comment>
	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>log_min_duration</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>auto_stats</name></name> <operator>=</operator> <name>auto_stats</name></expr>;</expr_stmt>

	<comment type="block">/* Now go through the common routine */</comment>
	<expr_stmt><expr><call><name>vacuum</name><argument_list>(<argument><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>rels</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Internal entry point for VACUUM and ANALYZE commands.
 *
 * relations, if not NIL, is a list of VacuumRelation to process; otherwise,
 * we process all relevant tables in the database.  For each VacuumRelation,
 * if a valid OID is supplied, the table with that OID is what to process;
 * otherwise, the VacuumRelation's RangeVar indicates what to process.
 *
 * params contains a set of parameters that can be used to customize the
 * behavior.
 *
 * bstrategy is normally given as NULL, but in autovacuum it can be passed
 * in to use the same buffer strategy object across multiple vacuum() calls.
 *
 * isTopLevel should be passed down from ProcessUtility.
 *
 * It is the caller's responsibility that all parameters are allocated in a
 * memory context that will not disappear at transaction commit.
 */</comment>
<function><type><name>void</name></type>
<name>vacuum</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relations</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
	   <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>in_vacuum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>in_outer_xact</name></decl>,
				<decl><type ref="prev"/><name>use_own_xacts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>params</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * VACUUM does not support ROOTPARTITION option. Normally it's not possible
	 * that VACOPT_VACUUM and VACOPT_ROOTONLY set at same time.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_ROOTONLY</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>stmttype</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"VACUUM"</literal></expr> </then><else>: <expr><literal type="string">"ANALYZE"</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * We cannot run VACUUM inside a user transaction block; if we were inside
	 * a transaction, then our commit- and start-transaction-command calls
	 * would not have the intended effect!	There are numerous other subtle
	 * dependencies on this, too.
	 *
	 * GPDB: AO vacuum's compaction phase has to run in a distributed
	 * transaction though.
	 *
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACUUM_AO_PHASE_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>stmttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_outer_xact</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>in_outer_xact</name> <operator>=</operator> <call><name>IsInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Due to static variables vac_context, anl_context and vac_strategy,
	 * vacuum() is not reentrant.  This matters when VACUUM FULL or ANALYZE
	 * calls a hostile index expression that itself calls ANALYZE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>in_vacuum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be executed from VACUUM or ANALYZE"</literal></expr></argument>,
						<argument><expr><name>stmttype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Sanity check DISABLE_PAGE_SKIPPING option.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_DISABLE_PAGE_SKIPPING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VACUUM option DISABLE_PAGE_SKIPPING cannot be used with FULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Send info about dead objects to the statistics collector, unless we are
	 * in autovacuum --- autovacuum.c does this for itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_vacuum_stat</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create special memory context for cross-transaction storage.
	 *
	 * Since it is a child of PortalContext, it will go away eventually even
	 * if we suffer an error; there's no need for special abort cleanup logic.
	 */</comment>
	<expr_stmt><expr><name>vac_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>,
										<argument><expr><literal type="string">"Vacuum"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If caller didn't give us a buffer strategy object, make one in the
	 * cross-transaction memory context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bstrategy</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>bstrategy</name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>vac_strategy</name> <operator>=</operator> <name>bstrategy</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build list of relation(s) to process, putting any new data in
	 * vac_context for safekeeping.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relations</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newrels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>relations</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>vrel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>VacuumRelation</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>expand_vacuum_rel</name><argument_list>(<argument><expr><name>vrel</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newrels</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>newrels</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>relations</name> <operator>=</operator> <name>newrels</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>get_all_vacuum_rels</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Decide whether we need to start/commit our own transactions.
	 *
	 * For VACUUM (with or without ANALYZE): always do so, so that we can
	 * release locks as soon as possible.  (We could possibly use the outer
	 * transaction for a one-table VACUUM, but handling TOAST tables would be
	 * problematic.)
	 *
	 * For ANALYZE (no VACUUM): if inside a transaction block, we cannot
	 * start/commit our own transactions.  Also, there's no need to do so if
	 * only processing one relation.  For multiple relations when not within a
	 * transaction block, and also in an autovacuum worker, use own
	 * transactions so we can release locks sooner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_AO_COMPACT_PHASE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>in_outer_xact</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * vacuum_rel expects to be entered with no transaction active; it will
	 * start and commit its own transaction.  But we are called by an SQL
	 * command, and so we are executing inside a transaction already. We
	 * commit the transaction started in PostgresMain() here, and start
	 * another one before exiting to match the commit waiting for us back in
	 * PostgresMain().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_own_xacts</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>in_outer_xact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ActiveSnapshot is not set by autovacuum */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PreserveOidAssignmentsOnCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* matches the StartTransaction in PostgresMain() */</comment>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Turn vacuum cost accounting on or off, and set/clear in_vacuum */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>in_vacuum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumCostActive</name> <operator>=</operator> <operator>(</operator><name>VacuumCostDelay</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumCostBalance</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumPageHit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumPageMiss</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumPageDirty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Loop to process each selected relation.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>relations</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>vrel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>VacuumRelation</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vacuum_rel</name><argument_list>(<argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If using separate xacts, start one for analyze. Otherwise,
				 * we can use the outer transaction.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>use_own_xacts</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* functions in indexes may want a snapshot set */</comment>
					<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>analyze_rel</name><argument_list>(<argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
							<argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>va_cols</name></name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>vac_strategy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>use_own_xacts</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * If we're not using separate xacts, better separate the
					 * ANALYZE actions with CCIs.  This avoids trouble if user
					 * says "ANALYZE t, t".
					 */</comment>
					<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
						<argument><expr><literal type="string">"analyze_finished_one_relation"</literal></expr></argument>, <argument><expr><name>DDLNotSpecified</name></expr></argument>,
						<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>in_vacuum</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumCostActive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>in_vacuum</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>VacuumCostActive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finish up processing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_own_xacts</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* here, we are not in a transaction */</comment>

		<comment type="block">/*
		 * This matches the CommitTransaction waiting for us in
		 * PostgresMain().
		 */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ClearOidAssignmentsOnCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Update pg_database.datfrozenxid, and truncate pg_xact if possible.
		 * (autovacuum.c does this for itself.)
		 */</comment>
		<expr_stmt><expr><call><name>vac_update_datfrozenxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clean up working storage --- note we must do this after
	 * StartTransactionCommand, else we might be trying to delete the active
	 * context!
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vac_context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a given relation can be safely vacuumed or analyzed.  If the
 * user is not the relation owner, issue a WARNING log message and return
 * false to let the caller decide what to do with this relation.  This
 * routine is used to decide if a relation can be processed for VACUUM or
 * ANALYZE.
 */</comment>
<function><type><name>bool</name></type>
<name>vacuum_is_relation_owner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>(</operator><name>VACOPT_VACUUM</name> <operator>|</operator> <name>VACOPT_ANALYZE</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check permissions.
	 *
	 * We allow the user to vacuum or analyze a table if he is superuser, the
	 * table owner, or the database owner (but in the latter case, only if
	 * it's not a shared relation).  pg_class_ownercheck includes the
	 * superuser case.
	 *
	 * Note we choose to treat permissions failure as a WARNING and keep
	 * trying to vacuum or analyze the rest of the DB --- is this appropriate?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><call><name>pg_database_ownercheck</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>reltuple</name><operator>-&gt;</operator><name>relisshared</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>reltuple</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser can vacuum it"</literal></expr></argument>,
							<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>reltuple</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser or database owner can vacuum it"</literal></expr></argument>,
							<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only table or database owner can vacuum it"</literal></expr></argument>,
							<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * For VACUUM ANALYZE, both logs could show up, but just generate
		 * information for VACUUM as that would be the first one to be
		 * processed.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>reltuple</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser can analyze it"</literal></expr></argument>,
							<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>reltuple</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser or database owner can analyze it"</literal></expr></argument>,
							<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only table or database owner can analyze it"</literal></expr></argument>,
							<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * vacuum_open_relation
 *
 * This routine is used for attempting to open and lock a relation which
 * is going to be vacuumed or analyzed.  If the relation cannot be opened
 * or locked, a log is emitted if possible.
 */</comment>
<function><type><name>Relation</name></type>
<name>vacuum_open_relation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>onerel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rel_lock</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>(</operator><name>VACOPT_VACUUM</name> <operator>|</operator> <name>VACOPT_ANALYZE</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the relation and get the appropriate lock on it.
	 *
	 * There's a race condition here: the relation may have gone away since
	 * the last time we saw it.  If so, we don't need to vacuum or analyze it.
	 *
	 * If we've been asked not to wait for the relation lock, acquire it first
	 * in non-blocking mode, before calling try_relation_open().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_SKIP_LOCKED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>onerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel_lock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* if relation is opened, leave */</comment>
	<if_stmt><if>if <condition>(<expr><name>onerel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>onerel</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Relation could not be opened, hence generate if possible a log
	 * informing on the situation.
	 *
	 * If the RangeVar is not defined, we do not have enough information to
	 * provide a meaningful log statement.  Chances are that the caller has
	 * intentionally not provided this information so that this logging is
	 * skipped, anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Determine the log level.
	 *
	 * For manual VACUUM or ANALYZE, we emit a WARNING to match the log
	 * statements in the permission checks; otherwise, only log if the caller
	 * so requested.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>LOG</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping vacuum of \"%s\" --- lock not available"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping vacuum of \"%s\" --- relation no longer exists"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * For VACUUM ANALYZE, both logs could show up, but just generate
		 * information for VACUUM as that would be the first one to be
		 * processed.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s\" --- lock not available"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s\" --- relation no longer exists"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Given a VacuumRelation, fill in the table OID if it wasn't specified,
 * and optionally add VacuumRelations for partitions of the table.
 *
 * If a VacuumRelation does not have an OID supplied and is a partitioned
 * table, an extra entry will be added to the output for each partition.
 * Presently, only autovacuum supplies OIDs when calling vacuum(), and
 * it does not want us to expand partitioned tables.
 *
 * We take care not to modify the input data structure, but instead build
 * new VacuumRelation(s) to return.  (But note that they will reference
 * unmodified parts of the input, eg column lists.)  New data structures
 * are made in vac_context.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>expand_vacuum_rel</name><parameter_list>(<parameter><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>vrel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vacrels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* If caller supplied OID, there's nothing we need do here. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vacrels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vacrels</name></expr></argument>, <argument><expr><name>vrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Process a specific relation, and possibly partitions thereof */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ispartition</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>include_parts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rvr_opts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>skip_this</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>skip_children</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>skip_midlevel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since autovacuum workers supply OIDs when calling vacuum(), no
		 * autovacuum worker should reach this code.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We transiently take AccessShareLock to protect the syscache lookup
		 * below, as well as find_all_inheritors's expectation that the caller
		 * holds some lock on the starting relation.
		 */</comment>
		<expr_stmt><expr><name>rvr_opts</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_SKIP_LOCKED</name><operator>)</operator></expr> ?</condition><then> <expr><name>RVR_SKIP_LOCKED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
										 <argument><expr><name>AccessShareLock</name></expr></argument>,
										 <argument><expr><name>rvr_opts</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the lock is unavailable, emit the same log statement that
		 * vacuum_rel() and analyze_rel() would.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping vacuum of \"%s\" --- lock not available"</literal></expr></argument>,
								<argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s\" --- lock not available"</literal></expr></argument>,
								<argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<return>return <expr><name>vacrels</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * To check whether the relation is a partitioned table and its
		 * ownership, fetch its syscache entry.
		 */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ispartition</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relispartition</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Handle GPDB's extra options and GUCs that affect how we recurse
		 * into partitions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_ROOTONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
				<name><name>classForm</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot analyze a non-root partition using ANALYZE ROOTPARTITION"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>skip_this</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>skip_children</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/*
		 * disable analyzing mid-level partitions directly since the users are encouraged
		 * to work with the root partition only. To gather stats on mid-level partitions
		 * (for Orca's use), the user should run ANALYZE or ANALYZE ROOTPARTITION on the
		 * root level with optimizer_analyze_midlevel_partition GUC set to ON.
		 * Planner uses the stats on leaf partitions, so it's unnecessary to collect stats on
		 * midlevel partitions.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
				 <name><name>classForm</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name>optimizer_analyze_midlevel_partition</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot analyze a mid-level partition. "</literal>
							<literal type="string">"Please run ANALYZE on the root partition table."</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* do nothing at all */</comment>
			<expr_stmt><expr><name>skip_this</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>skip_children</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If current table is root partition table, optimizer_analyze_root_partition
			 * is set to 'off' and ROOTPARTITION option was not explicitly specified,
			 * analyze all the children, but skip the partitioned table itself.
			 *
			 * Analyzing the children will update the root table's statistics
			 * too, by merging the stats of the children.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name>optimizer_analyze_root_partition</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>skip_this</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optimizer_analyze_midlevel_partition</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>skip_midlevel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Make a returnable VacuumRelation for this rel if user is a proper
		 * owner.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>vacuum_is_relation_owner</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>classForm</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>skip_this</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>vacrels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vacrels</name></expr></argument>, <argument><expr><call><name>makeVacuumRelation</name><argument_list>(<argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
														  <argument><expr><name>relid</name></expr></argument>,
														  <argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>va_cols</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>include_parts</name> <operator>=</operator> <operator>(</operator><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it is, make relation list entries for its partitions.  Note that
		 * the list returned by find_all_inheritors() includes the passed-in
		 * OID, so we have to skip that.  There's no point in taking locks on
		 * the individual partitions yet, and doing so would just add
		 * unnecessary deadlock risk.  For this last reason we do not check
		 * yet the ownership of the partitions, which get added to the list to
		 * process.  Ownership will be checked later on anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>include_parts</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>skip_children</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>part_oids</name> <init>= <expr><call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>part_lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>part_lc</argument>, <argument>part_oids</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>part_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>part_lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>part_oid</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* ignore original table */</comment>

				<if_stmt><if>if <condition>(<expr><name>skip_midlevel</name> <operator>&amp;&amp;</operator>
					<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>part_oid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * We omit a RangeVar since it wouldn't be appropriate to
				 * complain about failure to open one of these relations
				 * later.
				 */</comment>
				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>vacrels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vacrels</name></expr></argument>, <argument><expr><call><name>makeVacuumRelation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
															  <argument><expr><name>part_oid</name></expr></argument>,
															  <argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>va_cols</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Release lock again.  This means that by the time we actually try to
		 * process the table, it might be gone or renamed.  In the former case
		 * we'll silently ignore it; in the latter case we'll process it
		 * anyway, but we must beware that the RangeVar doesn't necessarily
		 * identify it anymore.  This isn't ideal, perhaps, but there's little
		 * practical alternative, since we're typically going to commit this
		 * transaction and begin a new one between now and then.  Moreover,
		 * holding locks on multiple relations would create significant risk
		 * of deadlock.
		 */</comment>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB: The above code builds the list so that the partitions of a table
		 * come after the parent. In GPDB, we have code to build the stats of a parent
		 * table by merge the stats of leaf partitions, but that obviously won't work
		 * if the leaf partition stats haven't been built yet. Reverse the list
		 * so that the partitions are always analyzed before the parent table, so
		 * the partition stats merging code can kick in.
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>reverse_vacrels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>vacrels</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>reverse_vacrels</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reverse_vacrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name>vacrels</name> <operator>=</operator> <name>reverse_vacrels</name></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * GPDB: If you explicitly ANALYZE a partition, also update the
		 * parent's stats after the partition has been ANALYZEd. (Thanks to
		 * the code to merge leaf statistics, it should be fast.)
		 *
		 * If ROOTPARTITION is specified, that means we only analyze on root
		 * partition table. The root table's ispartition is false. And the root
		 * table doesn't have parent to merge stats.
		 * If current table is skipped, no need to merge stats for it's parent
		 * since current table's stats is not get updated.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>optimizer_analyze_root_partition</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>skip_this</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>child_relid</name> <init>= <expr><name>relid</name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>ispartition</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>parent_relid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name><operator>)</operator></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG2</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>parent_relid</name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><name>child_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Only ANALYZE the parent if the stats can be updated by merging
				 * child stats.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>leaf_parts_analyzed</name><argument_list>(<argument><expr><name>parent_relid</name></expr></argument>, <argument><expr><name>child_relid</name></expr></argument>, <argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>va_cols</name></name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>vacrels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vacrels</name></expr></argument>, <argument><expr><call><name>makeVacuumRelation</name><argument_list>(<argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
															  <argument><expr><name>parent_relid</name></expr></argument>,
															  <argument><expr><name><name>vrel</name><operator>-&gt;</operator><name>va_cols</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* If the parent is also a partition, update its parent too. */</comment>
				<expr_stmt><expr><name>ispartition</name> <operator>=</operator> <call><name>get_rel_relispartition</name><argument_list>(<argument><expr><name>parent_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>child_relid</name> <operator>=</operator> <name>parent_relid</name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>vacrels</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a list of VacuumRelations for all vacuumable rels in
 * the current database.  The list is built in vac_context.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_all_vacuum_rels</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vacrels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pgclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pgclass</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name><name>classForm</name><operator>-&gt;</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* check permissions of relation */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vacuum_is_relation_owner</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>classForm</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We include partitioned tables here; depending on which operation is
		 * to be performed, caller will decide whether to process or ignore
		 * them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* skip mid-level partition tables if we have disabled collecting statistics for them */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optimizer_analyze_midlevel_partition</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Likewise, skip root partition, if disabled. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optimizer_analyze_root_partition</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_ROOTONLY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>classForm</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Build VacuumRelation(s) specifying the table OIDs to be processed.
		 * We omit a RangeVar since it wouldn't be appropriate to complain
		 * about failure to open one of these relations later.
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vacrels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vacrels</name></expr></argument>, <argument><expr><call><name>makeVacuumRelation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
													  <argument><expr><name>relid</name></expr></argument>,
													  <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>vacrels</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * vacuum_set_xid_limits() -- compute oldest-Xmin and freeze cutoff points
 *
 * The output parameters are:
 * - oldestXmin is the cutoff value used to distinguish whether tuples are
 *	 DEAD or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum).
 * - freezeLimit is the Xid below which all Xids are replaced by
 *	 FrozenTransactionId during vacuum.
 * - xidFullScanLimit (computed from table_freeze_age parameter)
 *	 represents a minimum Xid value; a table whose relfrozenxid is older than
 *	 this will have a full-table vacuum applied to it, to freeze tuples across
 *	 the whole table.  Vacuuming a table younger than this value can use a
 *	 partial scan.
 * - multiXactCutoff is the value below which all MultiXactIds are removed from
 *	 Xmax.
 * - mxactFullScanLimit is a value against which a table's relminmxid value is
 *	 compared to produce a full-table vacuum, as with xidFullScanLimit.
 *
 * xidFullScanLimit and mxactFullScanLimit can be passed as NULL if caller is
 * not interested.
 */</comment>
<function><type><name>void</name></type>
<name>vacuum_set_xid_limits</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>freeze_min_age</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>freeze_table_age</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>multixact_freeze_min_age</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>multixact_freeze_table_age</name></decl></parameter>,
					  <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>oldestXmin</name></decl></parameter>,
					  <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>freezeLimit</name></decl></parameter>,
					  <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xidFullScanLimit</name></decl></parameter>,
					  <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>multiXactCutoff</name></decl></parameter>,
					  <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>mxactFullScanLimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>freezemin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mxid_freezemin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>effective_multixact_freeze_max_age</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>limit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>safeLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>mxactLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>safeMxactLimit</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can always ignore processes running lazy vacuum.  This is because we
	 * use these values only for deciding which tuples we must keep in the
	 * tables.  Since lazy vacuum doesn't write its XID anywhere, it's safe to
	 * ignore it.  In theory it could be problematic to ignore lazy vacuums in
	 * a full vacuum, but keep in mind that only one vacuum process can be
	 * working on a particular table at any time, and that each vacuum is
	 * always an independent transaction.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>oldestXmin</name> <operator>=</operator>
		<call><name>TransactionIdLimitedForOldSnapshots</name><argument_list>(<argument><expr><call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><operator>*</operator><name>oldestXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the minimum freeze age to use: as specified by the caller, or
	 * vacuum_freeze_min_age, but in any case not more than half
	 * autovacuum_freeze_max_age, so that autovacuums to prevent XID
	 * wraparound won't occur too frequently.
	 */</comment>
	<expr_stmt><expr><name>freezemin</name> <operator>=</operator> <name>freeze_min_age</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>freezemin</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>freezemin</name> <operator>=</operator> <name>vacuum_freeze_min_age</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>freezemin</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>freezemin</name></expr></argument>, <argument><expr><name>autovacuum_freeze_max_age</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>freezemin</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the cutoff XID, being careful not to generate a "permanent" XID
	 */</comment>
	<expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>*</operator><name>oldestXmin</name> <operator>-</operator> <name>freezemin</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>limit</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If oldestXmin is very far back (in practice, more than
	 * autovacuum_freeze_max_age / 2 XIDs old), complain and force a minimum
	 * freeze age of zero.
	 */</comment>
	<expr_stmt><expr><name>safeLimit</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call> <operator>-</operator> <name>autovacuum_freeze_max_age</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>safeLimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>safeLimit</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>safeLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"oldest xmin is far in the past"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Close open transactions soon to avoid wraparound problems.\n"</literal>
						 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>*</operator><name>oldestXmin</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>freezeLimit</name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the multixact age for which freezing is urgent.  This is
	 * normally autovacuum_multixact_freeze_max_age, but may be less if we are
	 * short of multixact member space.
	 */</comment>
	<expr_stmt><expr><name>effective_multixact_freeze_max_age</name> <operator>=</operator> <call><name>MultiXactMemberFreezeThreshold</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the minimum multixact freeze age to use: as specified by
	 * caller, or vacuum_multixact_freeze_min_age, but in any case not more
	 * than half effective_multixact_freeze_max_age, so that autovacuums to
	 * prevent MultiXact wraparound won't occur too frequently.
	 */</comment>
	<expr_stmt><expr><name>mxid_freezemin</name> <operator>=</operator> <name>multixact_freeze_min_age</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mxid_freezemin</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mxid_freezemin</name> <operator>=</operator> <name>vacuum_multixact_freeze_min_age</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>mxid_freezemin</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>mxid_freezemin</name></expr></argument>,
						 <argument><expr><name>effective_multixact_freeze_max_age</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mxid_freezemin</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute the cutoff multi, being careful to generate a valid value */</comment>
	<expr_stmt><expr><name>oldestMxact</name> <operator>=</operator> <call><name>GetOldestMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <name>oldestMxact</name> <operator>-</operator> <name>mxid_freezemin</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mxactLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>safeMxactLimit</name> <operator>=</operator>
		<call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call> <operator>-</operator> <name>effective_multixact_freeze_max_age</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>safeMxactLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>safeMxactLimit</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>mxactLimit</name></expr></argument>, <argument><expr><name>safeMxactLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"oldest multixact is far in the past"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Close open transactions with multixacts soon to avoid wraparound problems."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Use the safe limit, unless an older mxact is still running */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>oldestMxact</name></expr></argument>, <argument><expr><name>safeMxactLimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <name>oldestMxact</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <name>safeMxactLimit</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>multiXactCutoff</name> <operator>=</operator> <name>mxactLimit</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xidFullScanLimit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>freezetable</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mxactFullScanLimit</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine the table freeze age to use: as specified by the caller,
		 * or vacuum_freeze_table_age, but in any case not more than
		 * autovacuum_freeze_max_age * 0.95, so that if you have e.g nightly
		 * VACUUM schedule, the nightly VACUUM gets a chance to freeze tuples
		 * before anti-wraparound autovacuum is launched.
		 */</comment>
		<expr_stmt><expr><name>freezetable</name> <operator>=</operator> <name>freeze_table_age</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>freezetable</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>freezetable</name> <operator>=</operator> <name>vacuum_freeze_table_age</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>freezetable</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>freezetable</name></expr></argument>, <argument><expr><name>autovacuum_freeze_max_age</name> <operator>*</operator> <literal type="number">0.95</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>freezetable</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute XID limit causing a full-table vacuum, being careful not to
		 * generate a "permanent" XID.
		 */</comment>
		<expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call> <operator>-</operator> <name>freezetable</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>limit</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>xidFullScanLimit</name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Similar to the above, determine the table freeze age to use for
		 * multixacts: as specified by the caller, or
		 * vacuum_multixact_freeze_table_age, but in any case not more than
		 * autovacuum_multixact_freeze_table_age * 0.95, so that if you have
		 * e.g. nightly VACUUM schedule, the nightly VACUUM gets a chance to
		 * freeze multixacts before anti-wraparound autovacuum is launched.
		 */</comment>
		<expr_stmt><expr><name>freezetable</name> <operator>=</operator> <name>multixact_freeze_table_age</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>freezetable</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>freezetable</name> <operator>=</operator> <name>vacuum_multixact_freeze_table_age</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>freezetable</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>freezetable</name></expr></argument>,
						  <argument><expr><name>effective_multixact_freeze_max_age</name> <operator>*</operator> <literal type="number">0.95</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>freezetable</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute MultiXact limit causing a full-table vacuum, being careful
		 * to generate a valid MultiXact value.
		 */</comment>
		<expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call> <operator>-</operator> <name>freezetable</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mxactLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>mxactFullScanLimit</name> <operator>=</operator> <name>mxactLimit</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mxactFullScanLimit</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * vac_estimate_reltuples() -- estimate the new value for pg_class.reltuples
 *
 *		If we scanned the whole relation then we should just use the count of
 *		live tuples seen; but if we did not, we should not blindly extrapolate
 *		from that number, since VACUUM may have scanned a quite nonrandom
 *		subset of the table.  When we have only partial information, we take
 *		the old value of pg_class.reltuples as a measurement of the
 *		tuple density in the unscanned pages.
 *
 *		Note: scanned_tuples should count only *live* tuples, since
 *		pg_class.reltuples is defined that way.
 */</comment>
<function><type><name>double</name></type>
<name>vac_estimate_reltuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
					   <parameter><decl><type><name>BlockNumber</name></type> <name>total_pages</name></decl></parameter>,
					   <parameter><decl><type><name>BlockNumber</name></type> <name>scanned_pages</name></decl></parameter>,
					   <parameter><decl><type><name>double</name></type> <name>scanned_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>old_rel_pages</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>old_rel_tuples</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>old_density</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>unscanned_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_tuples</name></decl>;</decl_stmt>

	<comment type="block">/* If we did scan the whole table, just use the count as-is */</comment>
	<if_stmt><if>if <condition>(<expr><name>scanned_pages</name> <operator>&gt;=</operator> <name>total_pages</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>scanned_tuples</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If scanned_pages is zero but total_pages isn't, keep the existing value
	 * of reltuples.  (Note: callers should avoid updating the pg_class
	 * statistics in this situation, since no new information has been
	 * provided.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>scanned_pages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>old_rel_tuples</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If old value of relpages is zero, old density is indeterminate; we
	 * can't do much except scale up scanned_tuples to match total_pages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>old_rel_pages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>scanned_tuples</name> <operator>/</operator> <name>scanned_pages</name><operator>)</operator> <operator>*</operator> <name>total_pages</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Okay, we've covered the corner cases.  The normal calculation is to
	 * convert the old measurement to a density (tuples per page), then
	 * estimate the number of tuples in the unscanned pages using that figure,
	 * and finally add on the number of tuples in the scanned pages.
	 */</comment>
	<expr_stmt><expr><name>old_density</name> <operator>=</operator> <name>old_rel_tuples</name> <operator>/</operator> <name>old_rel_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>unscanned_pages</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>total_pages</name> <operator>-</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>scanned_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_tuples</name> <operator>=</operator> <name>old_density</name> <operator>*</operator> <name>unscanned_pages</name> <operator>+</operator> <name>scanned_tuples</name></expr>;</expr_stmt>
	<return>return <expr><call><name>floor</name><argument_list>(<argument><expr><name>total_tuples</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	vac_update_relstats() -- update statistics for one relation
 *
 *		Update the whole-relation statistics that are kept in its pg_class
 *		row.  There are additional stats that will be updated if we are
 *		doing ANALYZE, but we always update these stats.  This routine works
 *		for both index and heap relation entries in pg_class.
 *
 *		We violate transaction semantics here by overwriting the rel's
 *		existing pg_class tuple with the new values.  This is reasonably
 *		safe as long as we're sure that the new values are correct whether or
 *		not this transaction commits.  The reason for doing this is that if
 *		we updated these tuples in the usual way, vacuuming pg_class itself
 *		wouldn't work very well --- by the time we got done with a vacuum
 *		cycle, most of the tuples in pg_class would've been obsoleted.  Of
 *		course, this only works for fixed-size not-null columns, but these are.
 *
 *		Another reason for doing it this way is that when we are in a lazy
 *		VACUUM and have PROC_IN_VACUUM set, we mustn't do any regular updates.
 *		Somebody vacuuming pg_class might think they could delete a tuple
 *		marked with xmin = our xid.
 *
 *		In addition to fundamentally nontransactional statistics such as
 *		relpages and relallvisible, we try to maintain certain lazily-updated
 *		DDL flags such as relhasindex, by clearing them if no longer correct.
 *		It's safe to do this in VACUUM, which can't run in parallel with
 *		CREATE INDEX/RULE/TRIGGER and can't be part of a transaction block.
 *		However, it's *not* safe to do it in an ANALYZE that's within an
 *		outer transaction, because for example the current transaction might
 *		have dropped the last index; then we'd think relhasindex should be
 *		cleared, but if the transaction later rolls back this would be wrong.
 *		So we refrain from updating the DDL flags if we're inside an outer
 *		transaction.  This is OK since postponing the flag maintenance is
 *		always allowable.
 *
 *		Note: num_tuples should count only *live* tuples, since
 *		pg_class.reltuples is defined that way.
 *
 *		This routine is shared by VACUUM and ANALYZE.
 */</comment>
<function><type><name>void</name></type>
<name>vac_update_relstats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
					<parameter><decl><type><name>BlockNumber</name></type> <name>num_pages</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>num_tuples</name></decl></parameter>,
					<parameter><decl><type><name>BlockNumber</name></type> <name>num_all_visible_pages</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>hasindex</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>frozenxid</name></decl></parameter>,
					<parameter><decl><type><name>MultiXactId</name></type> <name>minmulti</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>isvacuum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pgcform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In GPDB, all the data is stored in the segments, and the
	 * relpages/reltuples in the master reflect the sum of the values in
	 * all the segments. In VACUUM, don't overwrite relpages/reltuples with
	 * the values we counted in the QD node itself. We will dispatch the
	 * VACUUM to the segments after processing the QD node, and we will
	 * update relpages/reltuples then.
	 *
	 * Update stats for system tables normally, though (it'd better say
	 * "non-distributed" tables than system relations here, but for now
	 * it's effectively the same.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>isvacuum</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>num_pages</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_tuples</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_all_visible_pages</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>vac_send_relstats_to_qd</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
									<argument><expr><name>num_pages</name></expr></argument>,
									<argument><expr><name>num_tuples</name></expr></argument>,
									<argument><expr><name>num_all_visible_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/*
	 * We need a way to distinguish these 2 cases:
	 * a) ANALYZEd/VACUUMed table is empty
	 * b) Table has never been ANALYZEd/VACUUMed
	 * To do this, in case (a), we set relPages = 1. For case (b), relPages = 0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_pages</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When running in utility mode in the QD node, we get the number of
		 * tuples of an AO table from the pg_aoseg table, but we don't know
		 * the file size, so that's always 0. Ignore the tuple count we got,
		 * and set reltuples to 0 instead, to avoid storing a confusing
		 * combination, and to avoid hitting the Assert below (which we
		 * inherited from upstream).
		 *
		 * It's perhaps not such a great idea to overwrite perfectly good
		 * relpages/reltuples estimates in utility mode, but that's what we
		 * do for heap tables, too, because we don't have even a tuple count
		 * for them. At least this is consistent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_tuples</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_tuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_tuples</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_pages</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rd</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch a copy of the tuple to scribble on */</comment>
	<expr_stmt><expr><name>ctup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_class entry for relid %u vanished during vacuuming"</literal></expr></argument>,
			 <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pgcform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Apply statistical updates, if any, to copied tuple */</comment>

	<comment type="block">/* GPDB-specific not allow change relpages and reltuples when vacuum in utility mode on QD
	 * Because there's a chance that we overwrite perfectly good stats with zeros
	 */</comment>

	<decl_stmt><decl><type><name>bool</name></type> <name>ifUpdate</name> <init>= <expr><operator>!</operator> <operator>(</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relpages</name></name> <operator>!=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>num_pages</name> <operator>&amp;&amp;</operator> <name>ifUpdate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>num_pages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>!=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>num_tuples</name> <operator>&amp;&amp;</operator> <name>ifUpdate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>num_tuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>!=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>num_all_visible_pages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>num_all_visible_pages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Vacuum oid=%u pages=%d tuples=%f"</literal></expr></argument>,
		 <argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relpages</name></name></expr></argument>, <argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>reltuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Apply DDL updates, but not inside an outer transaction (see above) */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_outer_xact</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we didn't find any indexes, reset relhasindex.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasindex</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We also clear relhasrules and relhastriggers if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhasrules</name></name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhasrules</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhastriggers</name></name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhastriggers</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update relfrozenxid, unless caller passed InvalidTransactionId
	 * indicating it has no new data.
	 *
	 * Ordinarily, we don't let relfrozenxid go backwards: if things are
	 * working correctly, the only way the new frozenxid could be older would
	 * be if a previous VACUUM was done with a tighter freeze_min_age, in
	 * which case we don't want to forget the work it already did.  However,
	 * if the stored relfrozenxid is "in the future", then it must be corrupt
	 * and it seems best to overwrite it with the cutoff we used this time.
	 * This should match vac_update_datfrozenxid() concerning what we consider
	 * to be "in the future".
	 *
	 * GPDB: We check if pgcform-&gt;relfrozenxid is valid because AO and CO
	 * tables should have relfrozenxid as InvalidTransactionId.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>frozenxid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>pgcform</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>!=</operator> <name>frozenxid</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>, <argument><expr><name>frozenxid</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr></argument>,
							   <argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>frozenxid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Similarly for relminmxid */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>minmulti</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>pgcform</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>!=</operator> <name>minmulti</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>, <argument><expr><name>minmulti</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>=</operator> <name>minmulti</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If anything changed, write out the tuple. */</comment>
	<if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_inplace_update</name><argument_list>(<argument><expr><name>rd</name></expr></argument>, <argument><expr><name>ctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rd</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fetch_database_tuple - Fetch a copy of database tuple from pg_database.
 *
 * This using disk heap table instead of system cache.
 * relation: opened pg_database relation in vac_update_datfrozenxid().
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>fetch_database_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dbOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_database_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>DatabaseOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	vac_update_datfrozenxid() -- update pg_database.datfrozenxid for our DB
 *
 *		Update pg_database's datfrozenxid entry for our database to be the
 *		minimum of the pg_class.relfrozenxid values.
 *
 *		Similarly, update our datminmxid to be the minimum of the
 *		pg_class.relminmxid values.
 *
 *		If we are able to advance either pg_database value, also try to
 *		truncate pg_xact and pg_multixact.
 *
 *		We violate transaction semantics here by overwriting the database's
 *		existing pg_database tuple with the new values.  This is reasonably
 *		safe since the new values are correct whether or not this transaction
 *		commits.  As with vac_update_relstats, this avoids leaving dead tuples
 *		behind after a VACUUM.
 */</comment>
<function><type><name>void</name></type>
<name>vac_update_datfrozenxid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>cached_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_database</name></type>	<name>cached_dbform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>newFrozenXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>newMinMulti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>lastSaneFrozenXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>lastSaneMinMulti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bogus</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize the "min" calculation with GetOldestXmin, which is a
	 * reasonable approximation to the minimum relfrozenxid for not-yet-
	 * committed pg_class entries for new tables; see AddNewRelationTuple().
	 * So we cannot produce a wrong minimum by starting with this.
	 *
	 * GPDB: Use GetLocalOldestXmin here, rather than GetOldestXmin. We don't
	 * want to include effects of distributed transactions in this. If a
	 * database's datfrozenxid is past the oldest XID as determined by
	 * distributed transactions, we will nevertheless never encounter such
	 * XIDs on disk.
	 */</comment>
	<expr_stmt><expr><name>newFrozenXid</name> <operator>=</operator> <call><name>GetLocalOldestXmin</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Similarly, initialize the MultiXact "min" with the value that would be
	 * used on pg_class for new tables.  See AddNewRelationTuple().
	 */</comment>
	<expr_stmt><expr><name>newMinMulti</name> <operator>=</operator> <call><name>GetOldestMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Identify the latest relfrozenxid and relminmxid values that we could
	 * validly see during the scan.  These are conservative values, but it's
	 * not really worth trying to be more exact.
	 */</comment>
	<expr_stmt><expr><name>lastSaneFrozenXid</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastSaneMinMulti</name> <operator>=</operator> <call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must seqscan pg_class to find the minimum Xid, because there is no
	 * index that can help us here.
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>classTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Only consider relations able to hold unfrozen XIDs (anything else
		 * should have InvalidTransactionId in relfrozenxid anyway).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOSEGMENTS</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOVISIMAP</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOBLOCKDIR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Some table AMs might not need per-relation xid / multixid horizons.
		 * It therefore seems reasonable to allow relfrozenxid and relminmxid
		 * to not be set (i.e. set to their respective Invalid*Id)
		 * independently. Thus validate and compute horizon for each only if
		 * set.
		 *
		 * If things are working properly, no relation should have a
		 * relfrozenxid or relminmxid that is "in the future".  However, such
		 * cases have been known to arise due to bugs in pg_upgrade.  If we
		 * see any entries that are "in the future", chicken out and don't do
		 * anything.  This ensures we won't truncate clog &amp; multixact SLRUs
		 * before those relations have been scanned and cleaned up.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* check for values in the future */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneFrozenXid</name></expr></argument>, <argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>bogus</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* determine new horizon */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>, <argument><expr><name>newFrozenXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newFrozenXid</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* check for values in the future */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneMinMulti</name></expr></argument>, <argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>bogus</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* determine new horizon */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>, <argument><expr><name>newMinMulti</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newMinMulti</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* we're done with pg_class */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* chicken out if bogus data found */</comment>
	<if_stmt><if>if <condition>(<expr><name>bogus</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>newFrozenXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>newMinMulti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now fetch the pg_database tuple we need to update. */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cached_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cached_dbform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>cached_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * As in vac_update_relstats(), we ordinarily don't want to let
	 * datfrozenxid go backward; but if it's "in the future" then it must be
	 * corrupt and it seems best to overwrite it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cached_dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name> <operator>!=</operator> <name>newFrozenXid</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>cached_dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name></expr></argument>, <argument><expr><name>newFrozenXid</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneFrozenXid</name></expr></argument>, <argument><expr><name><name>cached_dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newFrozenXid</name> <operator>=</operator> <name><name>cached_dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Ditto for datminmxid */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cached_dbform</name><operator>-&gt;</operator><name>datminmxid</name></name> <operator>!=</operator> <name>newMinMulti</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>cached_dbform</name><operator>-&gt;</operator><name>datminmxid</name></name></expr></argument>, <argument><expr><name>newMinMulti</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneMinMulti</name></expr></argument>, <argument><expr><name><name>cached_dbform</name><operator>-&gt;</operator><name>datminmxid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newMinMulti</name> <operator>=</operator> <name><name>cached_dbform</name><operator>-&gt;</operator><name>datminmxid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>			<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_database</name></type>	<name>tmp_dbform</name></decl>;</decl_stmt>
		<comment type="block">/*
		 * Fetch a copy of the tuple to scribble on from pg_database disk
		 * heap table instead of system cache
		 * "SearchSysCacheCopy1(DATABASEOID, ObjectIdGetDatum(MyDatabaseId))".
		 * Since the cache already flatten toast tuple, so the
		 * heap_inplace_update will fail with "wrong tuple length".
		 */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>fetch_database_tuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for database %u"</literal></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tmp_dbform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp_dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name> <operator>=</operator> <name>newFrozenXid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp_dbform</name><operator>-&gt;</operator><name>datminmxid</name></name> <operator>=</operator> <name>newMinMulti</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_inplace_update</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
			<argument><expr><literal type="string">"vacuum_update_dat_frozen_xid"</literal></expr></argument>, <argument><expr><name>DDLNotSpecified</name></expr></argument>,
			<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cached_dbform</name><operator>-&gt;</operator><name>datname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>cached_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we were able to advance datfrozenxid or datminmxid, see if we can
	 * truncate pg_xact and/or pg_multixact.  Also do it if the shared
	 * XID-wrap-limit info is stale, since this action will update that too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dirty</name> <operator>||</operator> <call><name>ForceTransactionIdLimitUpdate</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vac_truncate_clog</name><argument_list>(<argument><expr><name>newFrozenXid</name></expr></argument>, <argument><expr><name>newMinMulti</name></expr></argument>,
						  <argument><expr><name>lastSaneFrozenXid</name></expr></argument>, <argument><expr><name>lastSaneMinMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	vac_truncate_clog() -- attempt to truncate the commit log
 *
 *		Scan pg_database to determine the system-wide oldest datfrozenxid,
 *		and use it to truncate the transaction commit log (pg_xact).
 *		Also update the XID wrap limit info maintained by varsup.c.
 *		Likewise for datminmxid.
 *
 *		The passed frozenXID and minMulti are the updated values for my own
 *		pg_database entry. They're used to initialize the "min" calculations.
 *		The caller also passes the "last sane" XID and MXID, since it has
 *		those at hand already.
 *
 *		This routine is only invoked when we've managed to change our
 *		DB's datfrozenxid/datminmxid values, or we found that the shared
 *		XID-wrap-limit info is stale.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vac_truncate_clog</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>frozenXID</name></decl></parameter>,
				  <parameter><decl><type><name>MultiXactId</name></type> <name>minMulti</name></decl></parameter>,
				  <parameter><decl><type><name>TransactionId</name></type> <name>lastSaneFrozenXid</name></decl></parameter>,
				  <parameter><decl><type><name>MultiXactId</name></type> <name>lastSaneMinMulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXID</name> <init>= <expr><call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldestxid_datoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>minmulti_datoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bogus</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>frozenAlreadyWrapped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* init oldest datoids to sync with my frozenXID/minMulti values */</comment>
	<expr_stmt><expr><name>oldestxid_datoid</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minmulti_datoid</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan pg_database to compute the minimum datfrozenxid/datminmxid
	 *
	 * Since vac_update_datfrozenxid updates datfrozenxid/datminmxid in-place,
	 * the values could change while we look at them.  Fetch each one just
	 * once to ensure sane behavior of the comparison logic.  (Here, as in
	 * many other places, we assume that fetching or updating an XID in shared
	 * storage is atomic.)
	 *
	 * Note: we need not worry about a race condition with new entries being
	 * inserted by CREATE DATABASE.  Any such entry will have a copy of some
	 * existing DB's datfrozenxid, and that source DB cannot be ours because
	 * of the interlock against copying a DB containing an active backend.
	 * Hence the new entry will not reduce the minimum.  Also, if two VACUUMs
	 * concurrently modify the datfrozenxid's of different databases, the
	 * worst possible outcome is that pg_xact is not truncated as aggressively
	 * as it could be.
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>FormData_pg_database</name> <modifier>*</modifier></type><name>dbform</name> <init>= <expr><operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>datfrozenxid</name> <init>= <expr><name><name>dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>datminmxid</name> <init>= <expr><name><name>dbform</name><operator>-&gt;</operator><name>datminmxid</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>datfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>datminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If things are working properly, no database should have a
		 * datfrozenxid or datminmxid that is "in the future".  However, such
		 * cases have been known to arise due to bugs in pg_upgrade.  If we
		 * see any entries that are "in the future", chicken out and don't do
		 * anything.  This ensures we won't truncate clog before those
		 * databases have been scanned and cleaned up.  (We will issue the
		 * "already wrapped" warning if appropriate, though.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneFrozenXid</name></expr></argument>, <argument><expr><name>datfrozenxid</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneMinMulti</name></expr></argument>, <argument><expr><name>datminmxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bogus</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>nextXID</name></expr></argument>, <argument><expr><name>datfrozenxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>frozenAlreadyWrapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>datfrozenxid</name></expr></argument>, <argument><expr><name>frozenXID</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>frozenXID</name> <operator>=</operator> <name>datfrozenxid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldestxid_datoid</name> <operator>=</operator> <name><name>dbform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>datminmxid</name></expr></argument>, <argument><expr><name>minMulti</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>minMulti</name> <operator>=</operator> <name>datminmxid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>minmulti_datoid</name> <operator>=</operator> <name><name>dbform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do not truncate CLOG if we seem to have suffered wraparound already;
	 * the computed minimum XID might be bogus.  This case should now be
	 * impossible due to the defenses in GetNewTransactionId, but we keep the
	 * test anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>frozenAlreadyWrapped</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"some databases have not been vacuumed in over 2 billion transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"You might have already suffered transaction-wraparound data loss."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* chicken out if data is bogus in any other way */</comment>
	<if_stmt><if>if <condition>(<expr><name>bogus</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Advance the oldest value for commit timestamps before truncating, so
	 * that if a user requests a timestamp for a transaction we're truncating
	 * away right after this point, they get NULL instead of an ugly "file not
	 * found" error from slru.c.  This doesn't matter for xact/multixact
	 * because they are not subject to arbitrary lookups from users.
	 */</comment>
	<expr_stmt><expr><call><name>AdvanceOldestCommitTsXid</name><argument_list>(<argument><expr><name>frozenXID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Truncate CLOG, multixact and CommitTs to the oldest computed value.
	 */</comment>
	<expr_stmt><expr><call><name>TruncateCLOG</name><argument_list>(<argument><expr><name>frozenXID</name></expr></argument>, <argument><expr><name>oldestxid_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TruncateCommitTs</name><argument_list>(<argument><expr><name>frozenXID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TruncateMultiXact</name><argument_list>(<argument><expr><name>minMulti</name></expr></argument>, <argument><expr><name>minmulti_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the wrap limit for GetNewTransactionId and creation of new
	 * MultiXactIds.  Note: these functions will also signal the postmaster
	 * for an(other) autovac cycle if needed.   XXX should we avoid possibly
	 * signalling twice?
	 */</comment>
	<expr_stmt><expr><call><name>SetTransactionIdLimit</name><argument_list>(<argument><expr><name>frozenXID</name></expr></argument>, <argument><expr><name>oldestxid_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetMultiXactIdLimit</name><argument_list>(<argument><expr><name>minMulti</name></expr></argument>, <argument><expr><name>minmulti_datoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	vacuum_rel() -- vacuum one heap relation
 *
 *		relid identifies the relation to vacuum.  If relation is supplied,
 *		use the name therein for reporting any failure to open/lock the rel;
 *		do not use it once we've successfully opened the rel, since it might
 *		be stale.
 *
 *		Returns true if it's okay to proceed with a requested ANALYZE
 *		operation on this table.
 *
 *		Doing one heap at a time incurs extra overhead, since we need to
 *		check that the heap exists again just before we vacuum it.  The
 *		reason that we do this is so that vacuuming can be spread across
 *		many small transactions.  Otherwise, two-phase locking would require
 *		us to lock the entire database during one pass of the vacuum cleaner.
 *
 *		At entry and exit, we are not inside a transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>vacuum_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>onerel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockRelId</name></type>	<name>onerelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>toast_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aoseg_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>aoblkdir_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>aovisimap_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>	<modifier>*</modifier></type><name>this_rangevar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ao_vacuum_phase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_appendoptimized</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_toast</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>params</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 	<expr_stmt><expr><name>ao_vacuum_phase</name> <operator>=</operator> <operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACUUM_AO_PHASE_MASK</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Begin a transaction for vacuuming this relation */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Functions in indexes may want a snapshot set.  Also, setting a snapshot
	 * ensures that RecentGlobalXmin is kept truly recent.
	 */</comment>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * PostgreSQL does this:
		 * In lazy vacuum, we can set the PROC_IN_VACUUM flag, which lets
		 * other concurrent VACUUMs know that they can ignore this one while
		 * determining their OldestXmin.  (The reason we don't set it during a
		 * full VACUUM is exactly that we may have to run user-defined
		 * functions for functional indexes, and we want to make sure that if
		 * they use the snapshot set above, any tuples it requires can't get
		 * removed from other tables.  An index function that depends on the
		 * contents of other tables is arguably broken, but we won't break it
		 * here by violating transaction semantics.)
		 *
		 * GPDB doesn't use PROC_IN_VACUUM, as lazy vacuum for bitmap
		 * indexed tables performs reindex causing updates to pg_class
		 * tuples for index entries.
		 *
		 * We also set the VACUUM_FOR_WRAPAROUND flag, which is passed down by
		 * autovacuum; it's used to avoid canceling a vacuum that was invoked
		 * in an emergency.
		 *
		 * Note: these flags remain set until CommitTransaction or
		 * AbortTransaction.  We don't want to clear them until we reset
		 * MyPgXact-&gt;xid/xmin, else OldestXmin might appear to go backwards,
		 * which is probably Not Good.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* Upstream code not applicable to GPDB */</comment>
		MyPgXact-&gt;vacuumFlags |= PROC_IN_VACUUM;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>is_wraparound</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>|=</operator> <name>PROC_VACUUM_FOR_WRAPAROUND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check for user-requested abort.  Note we want this to be inside a
	 * transaction, so xact.c doesn't issue useless WARNING.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the type of lock we want --- hard exclusive lock for a FULL
	 * vacuum, but just ShareUpdateExclusiveLock for concurrent vacuum. Either
	 * way, we can be sure that no other backend is vacuuming the same table.
	 */</comment>
	<comment type="line">// FIXME: This fault point was roughly here before. It's kept here to keep</comment>
	<comment type="line">// the regression tests from hanging, but need to check that the tests</comment>
	<comment type="line">// still make sense. And "drop phase" isn't a term we use anymore.</comment>
	<if_stmt><if>if <condition>(<expr><name>ao_vacuum_phase</name> <operator>==</operator> <name>VACOPT_AO_POST_CLEANUP_PHASE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"vacuum_relation_open_relation_during_drop_phase"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// FIXME: what's the right level for AO tables?</comment>
	<expr_stmt><expr><name>lmode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr> ?</condition><then>
		<expr><name>AccessExclusiveLock</name></expr> </then><else>: <expr><name>ShareUpdateExclusiveLock</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* open the relation and get the appropriate lock on it */</comment>
	<expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>vacuum_open_relation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
								  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* leave if relation could not be opened or locked */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>onerel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if relation needs to be skipped based on ownership.  This check
	 * happens also when building the relation list to vacuum for a manual
	 * operation, and needs to be done additionally here as VACUUM could
	 * happen across multiple transactions where relation ownership could have
	 * changed in-between.  Make sure to only generate logs for VACUUM in this
	 * case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vacuum_is_relation_owner</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>,
								  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that it's of a vacuumable relkind.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOSEGMENTS</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOBLOCKDIR</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOVISIMAP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot vacuum non-tables or special system tables"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Silently ignore tables that are temp tables of other backends ---
	 * trying to vacuum these will lead to great unhappiness, since their
	 * contents are probably not up-to-date on disk.  (We don't throw a
	 * warning here; it would just lead to chatter during a database-wide
	 * VACUUM.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Silently ignore partitioned tables as there is no work to be done.  The
	 * useful work is on their child partitions, which have been queued up for
	 * us separately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* It's OK to proceed with ANALYZE on this table */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get a session-level lock too. This will protect our access to the
	 * relation across multiple transactions, so that we can vacuum the
	 * relation's TOAST table (if any) secure in the knowledge that no one is
	 * deleting the parent relation.
	 *
	 * NOTE: this cannot block, even if someone else is waiting for access,
	 * because the lock manager knows that both lock requests are from the
	 * same process.
	 */</comment>
	<expr_stmt><expr><name>onerelid</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>onerelid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set index cleanup option based on reloptions if not yet */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name> <operator>==</operator> <name>VACOPT_TERNARY_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_options</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_options</name></name><operator>)</operator><operator>-&gt;</operator><name>vacuum_index_cleanup</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name> <operator>=</operator> <name>VACOPT_TERNARY_ENABLED</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name> <operator>=</operator> <name>VACOPT_TERNARY_DISABLED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set truncate option based on reloptions if not yet */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>truncate</name></name> <operator>==</operator> <name>VACOPT_TERNARY_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_options</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_options</name></name><operator>)</operator><operator>-&gt;</operator><name>vacuum_truncate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>truncate</name></name> <operator>=</operator> <name>VACOPT_TERNARY_ENABLED</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>truncate</name></name> <operator>=</operator> <name>VACOPT_TERNARY_DISABLED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remember the relation's TOAST relation for later, if the caller asked
	 * us to process it.  In VACUUM FULL, though, the toast table is
	 * automatically rebuilt by cluster_rel so we shouldn't recurse to it.
	 *
	 * GPDB: Also remember the AO segment relations for later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_SKIPTOAST</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>aoseg_relid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>aoblkdir_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>aovisimap_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check permissions.
	 *
	 * We allow the user to vacuum a table if he is superuser, the table
	 * owner, or the database owner (but in the latter case, only if it's not
	 * a shared relation).	pg_class_ownercheck includes the superuser case.
	 *
	 * Note we choose to treat permissions failure as a WARNING and keep
	 * trying to vacuum the rest of the DB --- is this appropriate?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
		  <operator>(</operator><call><name>pg_database_ownercheck</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser can vacuum it"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser or database owner can vacuum it"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only table or database owner can vacuum it"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that it's a vacuumable relation; we used to do this in
	 * get_rel_oids() but seems safer to check after we've locked the
	 * relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		 <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		 <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		 <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOSEGMENTS</name> <operator>&amp;&amp;</operator>
		 <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOBLOCKDIR</name> <operator>&amp;&amp;</operator>
		 <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOVISIMAP</name><operator>)</operator>
		<operator>||</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot vacuum non-tables, external tables, foreign tables or special system tables"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>ao_vacuum_phase</name> <operator>==</operator> <name>VACOPT_AO_POST_CLEANUP_PHASE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
			<argument><expr><literal type="string">"compaction_before_cleanup_phase"</literal></expr></argument>,
			<argument><expr><name>DDLNotSpecified</name></expr></argument>,
			<argument><expr><literal type="string">""</literal></expr></argument>,	<comment type="line">// databaseName</comment>
			<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// tableName</comment>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Silently ignore tables that are temp tables of other backends ---
	 * trying to vacuum these will lead to great unhappiness, since their
	 * contents are probably not up-to-date on disk.  (We don't throw a
	 * warning here; it would just lead to chatter during a database-wide
	 * VACUUM.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>is_appendoptimized</name> <operator>=</operator> <call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_toast</name> <operator>=</operator> <operator>(</operator><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ao_vacuum_phase</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>is_appendoptimized</name> <operator>||</operator> <name>is_toast</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We were asked to some phase of AO vacuum, but it's not an AO table. Huh? */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AO vacuum phase was invoked on a non-AO table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's a partitioned relation, on entry 'relation' refers to the table
	 * that the original command was issued on, and 'relid' is the actual partition
	 * we're processing. Build a rangevar representing this partition, so that we
	 * can dispatch it.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>this_rangevar</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to the table owner's userid, so that any index functions are run
	 * as that user.  Also lock down security-restricted operations and
	 * arrange to make GUC variable changes local to this command.
	 */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
						   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are any bitmap indexes, we have to acquire a ShareLock for the
	 * table, since reindex is used later. Otherwise, concurrent vacuum and
	 * inserts may cause deadlock. MPP-5960
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> 		<name>i</name></decl>, <decl><type ref="prev"/><name>nindexes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> 		<name>has_bitmap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>i_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vac_open_indexes</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nindexes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i_rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>RelationIsBitmapIndex</name><argument_list>(<argument><expr><name><name>i_rel</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>has_bitmap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>vac_close_indexes</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>i_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>has_bitmap</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_appendoptimized</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cluster_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* close relation before vacuuming, but hold lock until commit */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>onerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cluster_options</name> <operator>|=</operator> <name>CLUOPT_VERBOSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* VACUUM FULL is now a variant of CLUSTER; see cluster.c */</comment>
		<expr_stmt><expr><call><name>cluster_rel</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>cluster_options</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content> <comment type="block">/* Heap vacuum or AO/CO vacuum in specific phase */</comment>
		<expr_stmt><expr><call><name>table_relation_vacuum</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore userid and security context */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* all done with this class, but hold lock until commit */</comment>
	<if_stmt><if>if <condition>(<expr><name>onerel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Complete the transaction and free all temporary memory used.
	 */</comment>
	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* entrance of Append-Optimized table vacuum */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_appendoptimized</name> <operator>&amp;&amp;</operator> <name>ao_vacuum_phase</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>orig_options</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* orchestrate the AO vacuum phases */</comment>

		<comment type="block">/*
		 * Do cleanup first, to reclaim as much space as possible that
		 * was left behind from previous VACUUMs. This runs under local
		 * transactions.
		 */</comment>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>orig_options</name> <operator>|</operator> <name>VACOPT_AO_PRE_CLEANUP_PHASE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>this_rangevar</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Compact. This runs in a distributed transaction.  */</comment>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>orig_options</name> <operator>|</operator> <name>VACOPT_AO_COMPACT_PHASE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>this_rangevar</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 
		 * Do a final round of cleanup. Hopefully, this can drop the segments
		 * that were compacted in the previous phase.
		 */</comment>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>orig_options</name> <operator>|</operator> <name>VACOPT_AO_POST_CLEANUP_PHASE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>this_rangevar</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>orig_options</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In an append-only table, the auxiliary tables are cleaned up in
	 * the POST_CLEANUP phase. Ignore them in other phases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_appendoptimized</name> <operator>&amp;&amp;</operator> <name>ao_vacuum_phase</name> <operator>!=</operator> <name>VACOPT_AO_POST_CLEANUP_PHASE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aoseg_relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aoblkdir_relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aovisimap_relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>orig_option</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>VACUUM_AO_PHASE_MASK</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation has a secondary toast rel, vacuum that too while we
	 * still hold the session lock on the master table.  Note however that
	 * "analyze" will not get done on the toast table.  This is good, because
	 * the toaster always uses hardcoded index access and statistics are
	 * totally unimportant for toast relations.
	 * 
	 * Note, for GPDB, set recursing to true for auxilary tables to avoid
	 * being dispatched vacuum separately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>toast_relid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* do the same for an AO segments table, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>aoseg_relid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>aoseg_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> , <argument><expr><name>params</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* do the same for an AO block directory table, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>aoblkdir_relid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>aoblkdir_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* do the same for an AO visimap, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>aovisimap_relid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>aovisimap_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>orig_option</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't dispatch auto-vacuum. Each segment performs auto-vacuum as per
	 * its own need.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>!</operator><name>is_appendoptimized</name> <operator>||</operator> <name>ao_vacuum_phase</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VacuumStatsContext</name></type> <name>stats_context</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>vsubtype</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Dispatching needs a transaction. At least in some error scenarios,
		 * it uses TopTransactionContext to store stuff.
		 */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>stats_context</name><operator>.</operator><name>updated_stats</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dispatchVacuum</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>vac_update_relstats_from_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stats_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also update pg_stat_last_operation */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>vsubtype</name> <operator>=</operator> <literal type="string">"AUTO"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><literal type="number">0</literal> <operator>==</operator> <name><name>params</name><operator>-&gt;</operator><name>freeze_min_age</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>vsubtype</name> <operator>=</operator> <literal type="string">"FULL FREEZE"</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>vsubtype</name> <operator>=</operator> <literal type="string">"FULL"</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>params</name><operator>-&gt;</operator><name>freeze_min_age</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>vsubtype</name> <operator>=</operator> <literal type="string">"FREEZE"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>vsubtype</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><name>relid</name></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"VACUUM"</literal></expr></argument>,
						   <argument><expr><name>vsubtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restore userid and security context */</comment>
		<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now release the session-level lock on the master table.
	 */</comment>
	<expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>onerelid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report that we really did it. */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Open all the vacuumable indexes of the given relation, obtaining the
 * specified kind of lock on each.  Return an array of Relation pointers for
 * the indexes into *Irel, and the number of indexes into *nindexes.
 *
 * We consider an index vacuumable if it is marked insertable (indisready).
 * If it isn't, probably a CREATE INDEX CONCURRENTLY command failed early in
 * execution, and what we have is too corrupt to be processable.  We will
 * vacuum even if the index isn't indisvalid; this is important because in a
 * unique index, uniqueness checks will be performed anyway and had better not
 * hit dangling index pointers.
 */</comment>
<function><type><name>void</name></type>
<name>vac_open_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
				 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nindexes</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier><modifier>*</modifier></type><name>Irel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lockmode</name> <operator>!=</operator> <name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate enough memory for all indexes */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>Irel</name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>Irel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* collect just the ready indexes */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>indrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indrel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>indrel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisready</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>Irel</name><operator>)</operator><index>[<expr><name>i</name><operator>++</operator></expr>]</index> <operator>=</operator> <name>indrel</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>nindexes</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release the resources acquired by vac_open_indexes.  Optionally release
 * the locks (say NoLock to keep 'em).
 */</comment>
<function><type><name>void</name></type>
<name>vac_close_indexes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Irel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>nindexes</name><operator>--</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>ind</name> <init>= <expr><name><name>Irel</name><index>[<expr><name>nindexes</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>Irel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * vacuum_delay_point --- check for interrupts and cost-based delay.
 *
 * This should be called in each major loop of VACUUM processing,
 * typically once per page processed.
 */</comment>
<function><type><name>void</name></type>
<name>vacuum_delay_point</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Always check for interrupts */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nap if appropriate */</comment>
	<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>InterruptPending</name> <operator>&amp;&amp;</operator>
		<name>VacuumCostBalance</name> <operator>&gt;=</operator> <name>VacuumCostLimit</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>msec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>msec</name> <operator>=</operator> <name>VacuumCostDelay</name> <operator>*</operator> <name>VacuumCostBalance</name> <operator>/</operator> <name>VacuumCostLimit</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>msec</name> <operator>&gt;</operator> <name>VacuumCostDelay</name> <operator>*</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>msec</name> <operator>=</operator> <name>VacuumCostDelay</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>msec</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>VacuumCostBalance</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* update balance values for workers */</comment>
		<expr_stmt><expr><call><name>AutoVacuumUpdateDelay</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Might have gotten an interrupt while sleeping */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A wrapper function of defGetBoolean().
 *
 * This function returns VACOPT_TERNARY_ENABLED and VACOPT_TERNARY_DISABLED
 * instead of true and false.
 */</comment>
<function><type><specifier>static</specifier> <name>VacOptTernaryValue</name></type>
<name>get_vacopt_ternary_value</name><parameter_list>(<parameter><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>VACOPT_TERNARY_ENABLED</name></expr> </then><else>: <expr><name>VACOPT_TERNARY_DISABLED</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Dispatch a Vacuum command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dispatchVacuum</name><parameter_list>(<parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>VacuumStatsContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPgResults</name></type> <name>cdb_pgresults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>VacuumStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator> <name>DF_WITH_SNAPSHOT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The AO compaction phase needs to run in a distributed transaction,
	 * but other phases and heap VACUUM could run in local transactions. See
	 * comments in vacuum_ao.c "Overview" section. (In practice, though,
	 * this function is called with a distributed transaction open for the
	 * other phases too, so we end up using distributed transactions for
	 * all, anyway.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACUUM_AO_PHASE_MASK</name><operator>)</operator> <operator>==</operator> <name>VACOPT_AO_COMPACT_PHASE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>DF_NEED_TWO_PHASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* convert the VacuumParams back into an options list */</comment>

	<expr_stmt><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>vacuum_params_to_options_list</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>is_vacuumcmd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>is_vacuumcmd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>VacuumRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>va_cols</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>rels</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX: Some kinds of VACUUM assign a new relfilenode. bitmap indexes maybe? */</comment>
	<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>vacstmt</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
								<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vacuum_combine_stats</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* convert VacuumParams back into an options list, for dispatch */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>vacuum_params_to_options_list</name><parameter_list>(<parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>optmask</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* VACOPT_VACUUM and ANALYZE are derived from the VacuumStmt */</comment>
	<expr_stmt><expr><name>optmask</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>VACOPT_VACUUM</name> <operator>|</operator> <name>VACOPT_ANALYZE</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>optmask</name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"verbose"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optmask</name> <operator>&amp;=</operator> <operator>~</operator><name>VACOPT_VERBOSE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>optmask</name> <operator>&amp;</operator> <name>VACOPT_FREEZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"freeze"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optmask</name> <operator>&amp;=</operator> <operator>~</operator><name>VACOPT_FREEZE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>optmask</name> <operator>&amp;</operator> <name>VACOPT_FULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"full"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optmask</name> <operator>&amp;=</operator> <operator>~</operator><name>VACOPT_FULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>optmask</name> <operator>&amp;</operator> <name>VACOPT_SKIP_LOCKED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"skip_locked"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optmask</name> <operator>&amp;=</operator> <operator>~</operator><name>VACOPT_SKIP_LOCKED</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>optmask</name> <operator>&amp;</operator> <name>VACOPT_SKIPTOAST</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"skip_toast"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optmask</name> <operator>&amp;=</operator> <operator>~</operator><name>VACOPT_SKIPTOAST</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>optmask</name> <operator>&amp;</operator> <name>VACOPT_DISABLE_PAGE_SKIPPING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"disable_page_skipping"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optmask</name> <operator>&amp;=</operator> <operator>~</operator><name>VACOPT_DISABLE_PAGE_SKIPPING</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>optmask</name> <operator>&amp;</operator> <name>VACUUM_AO_PHASE_MASK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"ao_phase"</literal></expr></argument>,
											   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>optmask</name> <operator>&amp;</operator> <name>VACUUM_AO_PHASE_MASK</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optmask</name> <operator>&amp;=</operator> <operator>~</operator><name>VACUUM_AO_PHASE_MASK</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>optmask</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized vacuum option %x"</literal></expr></argument>, <argument><expr><name>optmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * NOTE:
	 *
	 * User-invoked vacuum will never have special values for VacuumParams's
	 * freeze_min_age, freeze_table_age, multixact_freeze_min_age,
	 * multixact_freeze_table_age, is_wraparound and log_min_duration. So no need
	 * to convert them back and dispatch to QEs for now.
	 * For autovacuum, it may set these values per table. Right now, only
	 * auto-ANALYZE is enabled which will dispatch analyze from QD, but these vaules
	 * are not needed for analyze.
	 * Vacuum through autovacuum is not enabled yet, and if each segment's autovacuum
	 * launcher take care it's own vacuum process, we don't need to dispatch these
	 * values as well.
	 *
	 * We should consider dispatch these values only if we do vacuum
	 * as how we do analyze through autovacuum on coordinator.
	 *
	 * GPDB has no plan to support distributed auto vacuum (do vacuum as how we do
	 * analyze, i.e. to trigger auto vacuum on QD, and QD manages to dispatch the
	 * vacuum request to QEs as distributed transaction) for GPDB7.
	 * See more details in the head comments of autovacuum.c.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>truncate</name></name> <operator>==</operator> <name>VACOPT_TERNARY_DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"truncate"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>truncate</name></name> <operator>==</operator> <name>VACOPT_TERNARY_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"truncate"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected VACUUM 'truncate' option '%d'"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>truncate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name> <operator>==</operator> <name>VACOPT_TERNARY_DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"index_cleanup"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name> <operator>==</operator> <name>VACOPT_TERNARY_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"index_cleanup"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected VACUUM 'index_cleanup' option '%d'"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * vacuum_combine_stats
 * This function combine the stats information sent by QEs to generate
 * the final stats for QD relations.
 *
 * Note that the mirrorResults is ignored by this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuum_combine_stats</name><parameter_list>(<parameter><decl><type><name>VacuumStatsContext</name> <modifier>*</modifier></type><name>stats_context</name></decl></parameter>, <parameter><decl><type><name>CdbPgResults</name> <modifier>*</modifier></type><name>cdb_pgresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cdb_pgresults</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>cdb_pgresults</name><operator>-&gt;</operator><name>numResults</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>stats_context</name><operator>-&gt;</operator><name>nsegs</name></name> <operator>=</operator> <name><name>cdb_pgresults</name><operator>-&gt;</operator><name>numDispatches</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process the dispatch results from the primary. Note that the QE
	 * processes also send back the new stats info, such as stats on
	 * pg_class, for the relevant table and its
	 * indexes. We parse this information, and compute the final stats
	 * for the QD.
	 *
	 * For pg_class stats, we compute the maximum number of tuples and
	 * maximum number of pages after processing the stats from each QE.
	 *
	 */</comment>
	<for>for<control>(<init><expr><name>result_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>result_no</name> <operator>&lt;</operator> <name><name>cdb_pgresults</name><operator>-&gt;</operator><name>numResults</name></name></expr>;</condition> <incr><expr><name>result_no</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>		
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier></type><name>pgresult</name> <init>= <expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>pg_results</name><index>[<expr><name>result_no</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pgresult</name><operator>-&gt;</operator><name>extras</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pgresult</name><operator>-&gt;</operator><name>extraType</name></name> <operator>!=</operator> <name>PGExtraTypeVacuumStats</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pgresult</name><operator>-&gt;</operator><name>extraslen</name></name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Process the stats for pg_class. We simply compute the maximum
		 * number of rel_tuples and rel_pages.
		 */</comment>
		<decl_stmt><decl><type><name>VPgClassStatsCombo</name> <modifier>*</modifier></type><name>pgclass_stats_combo</name> <init>= <expr><operator>(</operator><name>VPgClassStatsCombo</name> <operator>*</operator><operator>)</operator> <name><name>pgresult</name><operator>-&gt;</operator><name>extras</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stats_context-&gt;updated_stats</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VPgClassStatsCombo</name> <modifier>*</modifier></type><name>tmp_stats_combo</name> <init>= <expr><operator>(</operator><name>VPgClassStatsCombo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tmp_stats_combo</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name><name>pgclass_stats_combo</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tmp_stats_combo</name><operator>-&gt;</operator><name>rel_pages</name></name> <operator>+=</operator> <name><name>pgclass_stats_combo</name><operator>-&gt;</operator><name>rel_pages</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tmp_stats_combo</name><operator>-&gt;</operator><name>rel_tuples</name></name> <operator>+=</operator> <name><name>pgclass_stats_combo</name><operator>-&gt;</operator><name>rel_tuples</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tmp_stats_combo</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>+=</operator> <name><name>pgclass_stats_combo</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>
				<comment type="block">/* 
				 * Accumulate the number of QEs, assuming sending only once
				 * per QE for each relid in the VACUUM scenario.
				 */</comment>
				<expr_stmt><expr><name><name>tmp_stats_combo</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <comment type="block">/* get the first stats result of the current relid */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pgresult</name><operator>-&gt;</operator><name>extraslen</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VPgClassStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pgclass_stats_combo</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VPgClassStatsCombo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pgclass_stats_combo</name></expr></argument>, <argument><expr><name><name>pgresult</name><operator>-&gt;</operator><name>extras</name></name></expr></argument>, <argument><expr><name><name>pgresult</name><operator>-&gt;</operator><name>extraslen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pgclass_stats_combo</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats_context</name><operator>-&gt;</operator><name>updated_stats</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>stats_context</name><operator>-&gt;</operator><name>updated_stats</name></name></expr></argument>, <argument><expr><name>pgclass_stats_combo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Update relpages/reltuples of all the relations in the list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vac_update_relstats_from_list</name><parameter_list>(<parameter><decl><type><name>VacuumStatsContext</name> <modifier>*</modifier></type><name>stats_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>updated_stats</name> <init>= <expr><name><name>stats_context</name><operator>-&gt;</operator><name>updated_stats</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This function is only called in the context of the QD, so let's be
	 * explicit about that given the assumptions taken.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>updated_stats</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VPgClassStatsCombo</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><operator>(</operator><name>VPgClassStatsCombo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rel_pages</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>rel_pages</name></name> <operator>/</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rel_tuples</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>rel_tuples</name></name> <operator>/</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>/</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Update QD stats only when receiving all dispatched QEs' stats, to
		 * avoid being overwritten by a partial accumulated value (i.e., index-&gt;reltuples)
		 * in case when not receiving all QEs' stats.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stats_context</name><operator>-&gt;</operator><name>nsegs</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stats</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <name><name>stats_context</name><operator>-&gt;</operator><name>nsegs</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Pass 'false' for isvacuum, so that the stats are
			 * actually updated.
			 */</comment>
			<expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>rel_pages</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>rel_tuples</name></name></expr></argument>,
								<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>relallvisible</name></name></expr></argument>,
								<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr></argument>,
								<argument><expr><name>InvalidTransactionId</name></expr></argument>,
								<argument><expr><name>InvalidMultiXactId</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument> <comment type="block">/* isvacuum */</comment>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We do have chance to enter this branch in the case when in compact phase.
			 * For example, in compact phase, some QEs may need to drop dead segfiles,
			 * while others may not. Only the QEs which dropping dead segfiles could go to
			 * vacuum indexes path then update and send the statistics to QD, QD just
			 * collected part of QEs' stats hence should not be as the final result to
			 * overwrite QD's stats. 
			 * 
			 * One may think why not having the stats update only happens in the final
			 * phase (POST_CLEANUP_PHASE), yes that's an alternative to get a final stats
			 * accurately for QD. 
			 * 
			 * Given the AO/CO VACUUM is a multi-phases process which may have an interval
			 * between each phase. In real circumstance, concurrent VACUUM is mostly a heavy
			 * job and this interval could get longer than normal cases, hence it seems
			 * better to collect and update QD's stats timely. So current strategy is, QD always 
			 * collect QE's stats across phases, once we collected the expected number (means
			 * same as dispatched QE number) of QE's stats, we update QD's stats subsequently,
			 * instead of updating at the final phase.
			 * 
			 * Set the logging level to LOG as skipping sending stats here is not considered as
			 * a real issue, displaying it in log may be helpful to hint.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Vacuum update stats oid=%u pages=%d tuples=%f was skipped because "</literal>
				 <literal type="string">"collected segment number %d didn't match the expected %d."</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
				 <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>rel_pages</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>rel_tuples</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>stats_context</name><operator>-&gt;</operator><name>nsegs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * CDB: Build a special message, to send the number of tuples
 * and the number of pages in pg_class located at QEs through
 * the dispatcher.
 */</comment>
<function><type><name>void</name></type>
<name>vac_send_relstats_to_qd</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						<parameter><decl><type><name>BlockNumber</name></type> <name>num_pages</name></decl></parameter>,
						<parameter><decl><type><name>double</name></type> <name>num_tuples</name></decl></parameter>,
						<parameter><decl><type><name>BlockNumber</name></type> <name>num_all_visible_pages</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VPgClassStats</name></type> <name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'y'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VACUUM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>rel_pages</name></name> <operator>=</operator> <name>num_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>rel_tuples</name></name> <operator>=</operator> <name>num_tuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>relallvisible</name></name> <operator>=</operator> <name>num_all_visible_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Mark the result ready when receive this message */</comment>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>PGExtraTypeVacuumStats</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGExtraType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VPgClassStats</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>stats</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VPgClassStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>vacuumStatement_IsTemporary</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>bTemp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* MPP-7576: don't track internal namespace tables */</comment>
	<switch>switch <condition>(<expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_CATALOG_NAMESPACE</name></expr>:</case>
			<comment type="block">/* MPP-7773: don't track objects in system namespace
			 * if modifying system tables (eg during upgrade)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>allowSystemTableMods</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>bTemp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>PG_TOAST_NAMESPACE</name></expr>:</case>
		<case>case <expr><name>PG_BITMAPINDEX_NAMESPACE</name></expr>:</case>
		<case>case <expr><name>PG_AOSEGMENT_NAMESPACE</name></expr>:</case>
			<expr_stmt><expr><name>bTemp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* MPP-7572: Don't track metadata if table in any
	 * temporary namespace
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bTemp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bTemp</name> <operator>=</operator> <call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>bTemp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GPDB: Check whether needs to update or send stats from QE to QD.
 * This is GPDB specific check in vacuum-index scenario for collecting
 * QEs' stats (such as index-&gt;relpages and index-&gt;reltuples) on QD.
 * GPDB needs accumulating all QEs' stats for updating corresponding 
 * statistics into QD's pg_class correctly. So if current instance is
 * acting as QE, it should scan and send its current stats to QD instead
 * of skipping them for cost saving.
 */</comment>
<function><type><name>bool</name></type>
<name>gp_vacuum_needs_update_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
