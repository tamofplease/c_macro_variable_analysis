<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/prep/prepqual.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * prepqual.c
 *	  Routines for preprocessing qualification expressions
 *
 *
 * While the parser will produce flattened (N-argument) AND/OR trees from
 * simple sequences of AND'ed or OR'ed clauses, there might be an AND clause
 * directly underneath another AND, or OR underneath OR, if the input was
 * oddly parenthesized.  Also, rule expansion and subquery flattening could
 * produce such parsetrees.  The planner wants to flatten all such cases
 * to ensure consistent optimization behavior.
 *
 * Formerly, this module was responsible for doing the initial flattening,
 * but now we leave it to eval_const_expressions to do that since it has to
 * make a complete pass over the expression tree anyway.  Instead, we just
 * have to ensure that our manipulations preserve AND/OR flatness.
 * pull_ands() and pull_ors() are used to maintain flatness of the AND/OR
 * tree after local transformations that might introduce nested AND/ORs.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/prep/prepqual.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>pull_ands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>andlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>pull_ors</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>find_duplicate_ors</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_check</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>process_duplicate_ors</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orlist</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * negate_clause
 *	  Negate a Boolean expression.
 *
 * Input is a clause to be negated (e.g., the argument of a NOT clause).
 * Returns a new clause equivalent to the negation of the given clause.
 *
 * Although this can be invoked on its own, it's mainly intended as a helper
 * for eval_const_expressions(), and that context drives several design
 * decisions.  In particular, if the input is already AND/OR flat, we must
 * preserve that property.  We also don't bother to recurse in situations
 * where we can assume that lower-level executions of eval_const_expressions
 * would already have simplified sub-clauses of the input.
 *
 * The difference between this and a simple make_notclause() is that this
 * tries to get rid of the NOT node by logical simplification.  It's clearly
 * always a win if the NOT node can be eliminated altogether.  However, our
 * use of DeMorgan's laws could result in having more NOT nodes rather than
 * fewer.  We do that unconditionally anyway, because in WHERE clauses it's
 * important to expose as much top-level AND/OR structure as possible.
 * Also, eliminating an intermediate NOT may allow us to flatten two levels
 * of AND or OR together that we couldn't have otherwise.  Finally, one of
 * the motivations for doing this is to ensure that logically equivalent
 * expressions will be seen as physically equal(), so we should always apply
 * the same transformations.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>negate_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't negate an empty subexpression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* NOT NULL is still NULL */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* otherwise pretty easy */</comment>
				<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Negate operator if possible: (NOT (&lt; A B)) =&gt; (&gt;= A B)
				 */</comment>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>negator</name> <init>= <expr><call><name>get_negator</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>negator</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>newopexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>negator</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>opretset</name></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>opretset</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>opcollid</name></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>opcollid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newopexpr</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Negate a ScalarArrayOpExpr if its operator has a negator;
				 * for example x = ANY (list) becomes x &lt;&gt; ALL (list)
				 */</comment>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saopexpr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>negator</name> <init>= <expr><call><name>get_negator</name><argument_list>(<argument><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>negator</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>newopexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>negator</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>useOr</name></name> <operator>=</operator> <operator>!</operator><name><name>saopexpr</name><operator>-&gt;</operator><name>useOr</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>saopexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name><name>saopexpr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newopexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>saopexpr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newopexpr</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
				<block>{<block_content>
						<comment type="block">/*--------------------
						 * Apply DeMorgan's Laws:
						 *		(NOT (AND A B)) =&gt; (OR (NOT A) (NOT B))
						 *		(NOT (OR A B))	=&gt; (AND (NOT A) (NOT B))
						 * i.e., swap AND for OR and negate each subclause.
						 *
						 * If the input is already AND/OR flat and has no NOT
						 * directly above AND or OR, this transformation preserves
						 * those properties.  For example, if no direct child of
						 * the given AND clause is an AND or a NOT-above-OR, then
						 * the recursive calls of negate_clause() can't return any
						 * OR clauses.  So we needn't call pull_ors() before
						 * building a new OR clause.  Similarly for the OR case.
						 *--------------------
						 */</comment>
					<case>case <expr><name>AND_EXPR</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>nargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

							<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
							<block>{<block_content>
								<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>,
												<argument><expr><call><name>negate_clause</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block>
							<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_orclause</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>
						</block_content>}</block>
						<break>break;</break>
					<case>case <expr><name>OR_EXPR</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>nargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

							<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
							<block>{<block_content>
								<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>,
												<argument><expr><call><name>negate_clause</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block>
							<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_andclause</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>
						</block_content>}</block>
						<break>break;</break>
					<case>case <expr><name>NOT_EXPR</name></expr>:</case>

						<comment type="block">/*
						 * NOT underneath NOT: they cancel.  We assume the
						 * input is already simplified, so no need to recurse.
						 */</comment>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * In the rowtype case, the two flavors of NullTest are *not*
				 * logical inverses, so we can't simplify.  But it does work
				 * for scalar datatypes.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>expr</name><operator>-&gt;</operator><name>argisrow</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>newexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>expr</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name></expr> ?</condition><then>
											 <expr><name>IS_NOT_NULL</name></expr> </then><else>: <expr><name>IS_NULL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>argisrow</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>newexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>IS_TRUE</name></expr>:</case>
						<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>=</operator> <name>IS_NOT_TRUE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
						<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>=</operator> <name>IS_TRUE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_FALSE</name></expr>:</case>
						<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>=</operator> <name>IS_NOT_FALSE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
						<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>=</operator> <name>IS_FALSE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
						<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>=</operator> <name>IS_NOT_UNKNOWN</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
						<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>=</operator> <name>IS_UNKNOWN</name></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* else fall through */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Otherwise we don't know how to simplify this, so just tack on an
	 * explicit NOT node.
	 */</comment>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_notclause</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * canonicalize_qual
 *	  Convert a qualification expression to the most useful form.
 *
 * This is primarily intended to be used on top-level WHERE (or JOIN/ON)
 * clauses.  It can also be used on top-level CHECK constraints, for which
 * pass is_check = true.  DO NOT call it on any expression that is not known
 * to be one or the other, as it might apply inappropriate simplifications.
 *
 * The name of this routine is a holdover from a time when it would try to
 * force the expression into canonical AND-of-ORs or OR-of-ANDs form.
 * Eventually, we recognized that that had more theoretical purity than
 * actual usefulness, and so now the transformation doesn't involve any
 * notion of reaching a canonical form.
 *
 * NOTE: we assume the input has already been through eval_const_expressions
 * and therefore possesses AND/OR flatness.  Formerly this function included
 * its own flattening logic, but that requires a useless extra pass over the
 * tree.
 *
 * Returns the modified qualification.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>canonicalize_qual</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_check</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>newqual</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit for empty qual */</comment>
	<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* This should not be invoked on quals in implicit-AND format */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pull up redundant subclauses in OR-of-AND trees.  We do this only
	 * within the top-level AND/OR structure; there's no point in looking
	 * deeper.  Also remove any NULL constants in the top-level structure.
	 */</comment>
	<expr_stmt><expr><name>newqual</name> <operator>=</operator> <call><name>find_duplicate_ors</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>is_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newqual</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pull_ands
 *	  Recursively flatten nested AND clauses into a single and-clause list.
 *
 * Input is the arglist of an AND clause.
 * Returns the rebuilt arglist (note original list structure is not touched).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>pull_ands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>andlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>out_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>andlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>subexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note: we can destructively concat the subexpression's arglist
		 * because we know the recursive invocation of pull_ands will have
		 * built a new arglist not shared with any other expr. Otherwise we'd
		 * need a list_copy here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_andclause</name><argument_list>(<argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_list</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>out_list</name></expr></argument>,
								   <argument><expr><call><name>pull_ands</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>subexpr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>out_list</name></expr></argument>, <argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>out_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pull_ors
 *	  Recursively flatten nested OR clauses into a single or-clause list.
 *
 * Input is the arglist of an OR clause.
 * Returns the rebuilt arglist (note original list structure is not touched).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>pull_ors</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>out_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>orlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>subexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note: we can destructively concat the subexpression's arglist
		 * because we know the recursive invocation of pull_ors will have
		 * built a new arglist not shared with any other expr. Otherwise we'd
		 * need a list_copy here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_orclause</name><argument_list>(<argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_list</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>out_list</name></expr></argument>,
								   <argument><expr><call><name>pull_ors</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>subexpr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>out_list</name></expr></argument>, <argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>out_list</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*--------------------
 * The following code attempts to apply the inverse OR distributive law:
 *		((A AND B) OR (A AND C))  =&gt;  (A AND (B OR C))
 * That is, locate OR clauses in which every subclause contains an
 * identical term, and pull out the duplicated terms.
 *
 * This may seem like a fairly useless activity, but it turns out to be
 * applicable to many machine-generated queries, and there are also queries
 * in some of the TPC benchmarks that need it.  This was in fact almost the
 * sole useful side-effect of the old prepqual code that tried to force
 * the query into canonical AND-of-ORs form: the canonical equivalent of
 *		((A AND B) OR (A AND C))
 * is
 *		((A OR A) AND (A OR C) AND (B OR A) AND (B OR C))
 * which the code was able to simplify to
 *		(A AND (A OR C) AND (B OR A) AND (B OR C))
 * thus successfully extracting the common condition A --- but at the cost
 * of cluttering the qual with many redundant clauses.
 *--------------------
 */</comment>

<comment type="block">/*
 * find_duplicate_ors
 *	  Given a qualification tree with the NOTs pushed down, search for
 *	  OR clauses to which the inverse OR distributive law might apply.
 *	  Only the top-level AND/OR structure is searched.
 *
 * While at it, we remove any NULL constants within the top-level AND/OR
 * structure, eg in a WHERE clause, "x OR NULL::boolean" is reduced to "x".
 * In general that would change the result, so eval_const_expressions can't
 * do it; but at top level of WHERE, we don't need to distinguish between
 * FALSE and NULL results, so it's valid to treat NULL::boolean the same
 * as FALSE and then simplify AND/OR accordingly.  Conversely, in a top-level
 * CHECK constraint, we may treat a NULL the same as TRUE.
 *
 * Returns the modified qualification.  AND/OR flatness is preserved.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>find_duplicate_ors</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_check</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>is_orclause</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>orlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

		<comment type="block">/* Recurse */</comment>
		<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>((BoolExpr *) qual)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>find_duplicate_ors</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>is_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get rid of any constant inputs */</comment>
			<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>carg</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>is_check</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Within OR in CHECK, drop constant FALSE */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>carg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<comment type="block">/* Constant TRUE or NULL, so OR reduces to TRUE */</comment>
					<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Within OR in WHERE, drop constant FALSE or NULL */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>||</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>carg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<comment type="block">/* Constant TRUE, so OR reduces to TRUE */</comment>
					<return>return <expr><name>arg</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>orlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>orlist</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Flatten any ORs pulled up to just below here */</comment>
		<expr_stmt><expr><name>orlist</name> <operator>=</operator> <call><name>pull_ors</name><argument_list>(<argument><expr><name>orlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can look for duplicate ORs */</comment>
		<return>return <expr><call><name>process_duplicate_ors</name><argument_list>(<argument><expr><name>orlist</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>is_andclause</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>andlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

		<comment type="block">/* Recurse */</comment>
		<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>((BoolExpr *) qual)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>find_duplicate_ors</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>is_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get rid of any constant inputs */</comment>
			<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>carg</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>is_check</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Within AND in CHECK, drop constant TRUE or NULL */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>||</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>carg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<comment type="block">/* Constant FALSE, so AND reduces to FALSE */</comment>
					<return>return <expr><name>arg</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Within AND in WHERE, drop constant TRUE */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>carg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<comment type="block">/* Constant FALSE or NULL, so AND reduces to FALSE */</comment>
					<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>andlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>andlist</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Flatten any ANDs introduced just below here */</comment>
		<expr_stmt><expr><name>andlist</name> <operator>=</operator> <call><name>pull_ands</name><argument_list>(<argument><expr><name>andlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* AND of no inputs reduces to TRUE */</comment>
		<if_stmt><if>if <condition>(<expr><name>andlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Single-expression AND just reduces to that expression */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>andlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>andlist</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Else we still need an AND node */</comment>
		<return>return <expr><call><name>make_andclause</name><argument_list>(<argument><expr><name>andlist</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>qual</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * process_duplicate_ors
 *	  Given a list of exprs which are ORed together, try to apply
 *	  the inverse OR distributive law.
 *
 * Returns the resulting expression (could be an AND clause, an OR
 * clause, or maybe even a single subexpression).
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>process_duplicate_ors</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>reference</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_subclauses</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>winners</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>neworlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<comment type="block">/* OR of no inputs reduces to FALSE */</comment>
	<if_stmt><if>if <condition>(<expr><name>orlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Single-expression OR just reduces to that expression */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>orlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>orlist</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Choose the shortest AND clause as the reference list --- obviously, any
	 * subclause not in this clause isn't in all the clauses. If we find a
	 * clause that's not an AND, we can treat it as a one-element AND clause,
	 * which necessarily wins as shortest.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>orlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_andclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subclauses</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nclauses</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>subclauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>reference</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name>nclauses</name> <operator>&lt;</operator> <name>num_subclauses</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>reference</name> <operator>=</operator> <name>subclauses</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>num_subclauses</name> <operator>=</operator> <name>nclauses</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>reference</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Just in case, eliminate any duplicates in the reference list.
	 */</comment>
	<expr_stmt><expr><name>reference</name> <operator>=</operator> <call><name>list_union</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>reference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check each element of the reference list to see if it's in all the OR
	 * clauses.  Build a new list of winning clauses.
	 */</comment>
	<expr_stmt><expr><name>winners</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>reference</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>refclause</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>win</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>temp2</argument>, <argument>orlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>is_andclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><name>refclause</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>win</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>refclause</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>win</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>win</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>winners</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>winners</name></expr></argument>, <argument><expr><name>refclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If no winners, we can't transform the OR
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>winners</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>orlist</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Generate new OR list consisting of the remaining sub-clauses.
	 *
	 * If any clause degenerates to empty, then we have a situation like (A
	 * AND B) OR (A), which can be reduced to just A --- that is, the
	 * additional conditions in other arms of the OR are irrelevant.
	 *
	 * Note that because we use list_difference, any multiple occurrences of a
	 * winning clause in an AND sub-clause will be removed automatically.
	 */</comment>
	<expr_stmt><expr><name>neworlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>orlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_andclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subclauses</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>subclauses</name> <operator>=</operator> <call><name>list_difference</name><argument_list>(<argument><expr><name>subclauses</name></expr></argument>, <argument><expr><name>winners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>subclauses</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>subclauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>neworlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>neworlist</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>subclauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>neworlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>neworlist</name></expr></argument>, <argument><expr><call><name>make_andclause</name><argument_list>(<argument><expr><name>subclauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>neworlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* degenerate case, see above */</comment>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name>winners</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>neworlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>neworlist</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>neworlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* degenerate case, see above */</comment>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Append reduced OR to the winners list, if it's not degenerate, handling
	 * the special case of one element correctly (can that really happen?).
	 * Also be careful to maintain AND/OR flatness in case we pulled up a
	 * sub-sub-OR-clause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>neworlist</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>neworlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>winners</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>winners</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>neworlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>winners</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>winners</name></expr></argument>, <argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><call><name>pull_ors</name><argument_list>(<argument><expr><name>neworlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * And return the constructed AND clause, again being wary of a single
	 * element and AND/OR flatness.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>winners</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>winners</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>make_andclause</name><argument_list>(<argument><expr><call><name>pull_ands</name><argument_list>(<argument><expr><name>winners</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
