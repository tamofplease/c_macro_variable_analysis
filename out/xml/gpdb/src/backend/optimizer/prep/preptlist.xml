<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/prep/preptlist.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * preptlist.c
 *	  Routines to preprocess the parse tree target list
 *
 * For INSERT and UPDATE queries, the targetlist must contain an entry for
 * each attribute of the target relation in the correct order.  For UPDATE and
 * DELETE queries, it must also contain junk tlist entries needed to allow the
 * executor to identify the rows to be updated or deleted.  For all query
 * types, we may need to add junk tlist entries for Vars used in the RETURNING
 * list and row ID information needed for SELECT FOR UPDATE locking and/or
 * EvalPlanQual checking.
 *
 * The query rewrite phase also does preprocessing of the targetlist (see
 * rewriteTargetListIU).  The division of labor between here and there is
 * partially historical, but it's not entirely arbitrary.  In particular,
 * consider an UPDATE across an inheritance tree.  What rewriteTargetListIU
 * does need be done only once (because it depends only on the properties of
 * the parent relation).  What's done here has to be done over again for each
 * child relation, because it depends on the properties of the child, which
 * might be of a different relation type, or have more columns and/or a
 * different column order than the parent.
 *
 * The fact that rewriteTargetListIU sorts non-resjunk tlist entries by column
 * position, which expand_targetlist depends on, violates the above comment
 * because the sorting is only valid for the parent relation.  In inherited
 * UPDATE cases, adjust_inherited_tlist runs in between to take care of fixing
 * the tlists for child tables to keep expand_targetlist happy.  We do it like
 * that because it's faster in typical non-inherited cases.
 *
 *
 * Portions Copyright (c) 2006-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/prep/preptlist.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_distribution_policy.h"</cpp:file></cpp:include>     <comment type="block">/* CDB: POLICYTYPE_PARTITIONED */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>expand_targetlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>command_type</name></decl></parameter>,
							   <parameter><decl><type><name>Index</name></type> <name>result_relation</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>supplement_simply_updatable_targetlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
													<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>range_table</name></decl></parameter>,
													<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * preprocess_targetlist
 *	  Driver for preprocessing the parse tree targetlist.
 *
 *	  Returns the new targetlist.
 *
 * As a side effect, if there's an ON CONFLICT UPDATE clause, its targetlist
 * is also preprocessed (and updated in-place).
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>preprocess_targetlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_relation</name> <init>= <expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>range_table</name> <init>= <expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>command_type</name> <init>= <expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>target_rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>target_relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If there is a result relation, open it so we can look for missing
	 * columns and so on.  We assume that previous code already acquired at
	 * least AccessShareLock on the relation, so we need no lock here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result_relation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>target_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>result_relation</name></expr></argument>, <argument><expr><name>range_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sanity check: it'd better be a real relation not, say, a subquery.
		 * Else parser or rewriter messed up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>target_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"result relation must be a regular relation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>target_relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>target_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>command_type</name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For UPDATE/DELETE, add any junk column(s) needed to allow the executor
	 * to identify the rows to be updated or deleted.  Note that this step
	 * scribbles on parse-&gt;targetList, which is not very desirable, but we
	 * keep it that way to avoid changing APIs used by FDWs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>command_type</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>command_type</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>rewriteTargetListUD</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>target_rte</name></expr></argument>, <argument><expr><name>target_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * for heap_form_tuple to work, the targetlist must match the exact order
	 * of the attributes. We also need to fill in any missing attributes. -ay
	 * 10/94
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>command_type</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>command_type</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>expand_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>command_type</name></expr></argument>,
								  <argument><expr><name>result_relation</name></expr></argument>, <argument><expr><name>target_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* simply updatable cursors */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>simplyUpdatableRel</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>supplement_simply_updatable_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>range_table</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add necessary junk columns for rowmarked rels.  These values are needed
	 * for locking of rels selected FOR UPDATE/SHARE, and to do EvalPlanQual
	 * rechecking.  See comments for PlanRowMark in plannodes.h.  If you
	 * change this stanza, see also expand_inherited_rtentry(), which has to
	 * be able to add on junk columns equivalent to these.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>resname</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<comment type="block">/* child rels use the same junk attrs as their parents */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>!=</operator> <name><name>rc</name><operator>-&gt;</operator><name>prti</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ROW_MARK_COPY</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Need to fetch TID */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
						  <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>,
						  <argument><expr><name>TIDOID</name></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						  <argument><expr><name>InvalidOid</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"ctid%u"</literal></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ROW_MARK_COPY</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Need the whole row as a junk var */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeWholeRowVar</name><argument_list>(<argument><expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>range_table</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"wholerow%u"</literal></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If parent of inheritance tree, always fetch the tableoid too. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>isParent</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
						  <argument><expr><name>TableOidAttributeNumber</name></expr></argument>,
						  <argument><expr><name>OIDOID</name></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						  <argument><expr><name>InvalidOid</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"tableoid%u"</literal></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If the query has a RETURNING list, add resjunk entries for any Vars
	 * used in RETURNING that belong to other relations.  We need to do this
	 * to make these Vars available for the RETURNING calculation.  Vars that
	 * belong to the result rel don't need to be added, because they will be
	 * made to refer to the actual heap tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>,
							   <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
							   <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
							   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>vars</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>result_relation</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* don't need it */</comment>

			<if_stmt><if>if <condition>(<expr><call><name>tlist_member</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* already got it */</comment>

			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there's an ON CONFLICT UPDATE clause, preprocess its targetlist too
	 * while we have the relation open.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator>
			<call><name>expand_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
							  <argument><expr><name>CMD_UPDATE</name></expr></argument>,
							  <argument><expr><name>result_relation</name></expr></argument>,
							  <argument><expr><name>target_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>target_relation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *		TARGETLIST EXPANSION
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * expand_targetlist
 *	  Given a target list as generated by the parser and a result relation,
 *	  add targetlist entries for any missing attributes, and ensure the
 *	  non-junk attributes appear in proper field order.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>expand_targetlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>command_type</name></decl></parameter>,
				  <parameter><decl><type><name>Index</name></type> <name>result_relation</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlist_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>,
				<decl><type ref="prev"/><name>numattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>changed_cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tlist_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The rewriter should have already ensured that the TLEs are in correct
	 * order; but we have to insert TLEs for any missing attributes.
	 *
	 * Scan the tuple description in the relation's relcache entry to make
	 * sure we have all the user attributes in the right order.
	 */</comment>
	<expr_stmt><expr><name>numattrs</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrno</name> <operator>&lt;=</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>attrno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>new_tle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>tlist_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>old_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlist_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>old_tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator> <name><name>old_tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>attrno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>new_tle</name> <operator>=</operator> <name>old_tle</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tlist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>tlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * GPDB: If it's an UPDATE, keep track of which columns are being
		 * updated, and which ones are just passed through from old relation.
		 * We need that information later, to determine whether this UPDATE
		 * can move tuples from one segment to another.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_tle</name> <operator>&amp;&amp;</operator> <name>command_type</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>col_changed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * The column is unchanged, if the new value is a Var that refers
			 * directly to the same attribute in the same table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>new_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>new_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>result_relation</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>attrno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>col_changed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>col_changed</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>changed_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>changed_cols</name></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_tle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Didn't find a matching tlist entry, so make one.
			 *
			 * For INSERT, generate a NULL constant.  (We assume the rewriter
			 * would have inserted any available default value.) Also, if the
			 * column isn't dropped, apply any domain constraints that might
			 * exist --- this is to catch domain NOT NULL.
			 *
			 * For UPDATE, generate a Var reference to the existing value of
			 * the attribute, so that it gets copied to the new tuple. But
			 * generate a NULL for dropped columns (we want to drop any old
			 * values).
			 *
			 * When generating a NULL constant for a dropped column, we label
			 * it INT4 (any other guaranteed-to-exist datatype would do as
			 * well). We can't label it with the dropped column's datatype
			 * since that might not exist anymore.  It does not really matter
			 * what we claim the type is, since NULL is NULL --- its
			 * representation is datatype-independent.  This could perhaps
			 * confuse code comparing the finished plan to the target
			 * relation, however.
			 */</comment>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>atttype</name> <init>= <expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>atttypmod</name> <init>= <expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name> <init>= <expr><name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>new_expr</name></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name>command_type</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>,
													  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
													  <argument><expr><name>attcollation</name></expr></argument>,
													  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
													  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* isnull */</comment>
													  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <call><name>coerce_to_domain</name><argument_list>(<argument><expr><name>new_expr</name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
													<argument><expr><name>atttype</name></expr></argument>,
													<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
													<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
													<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
													<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Insert NULL for dropped column */</comment>
						<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
													  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
													  <argument><expr><name>InvalidOid</name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
													  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
													  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* isnull */</comment>
													  <argument><expr><name>true</name></expr></argument> <comment type="block">/* byval */</comment> )</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>result_relation</name></expr></argument>,
													<argument><expr><name>attrno</name></expr></argument>,
													<argument><expr><name>atttype</name></expr></argument>,
													<argument><expr><name>atttypmod</name></expr></argument>,
													<argument><expr><name>attcollation</name></expr></argument>,
													<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Insert NULL for dropped column */</comment>
						<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
													  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
													  <argument><expr><name>InvalidOid</name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
													  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
													  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* isnull */</comment>
													  <argument><expr><name>true</name></expr></argument> <comment type="block">/* byval */</comment> )</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized command_type: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>command_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
					<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><name>new_tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>new_expr</name></expr></argument>,
									  <argument><expr><name>attrno</name></expr></argument>,
									  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>new_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>


	<comment type="block">/*
	 * If an UPDATE can move the tuples from one segment to another, we will
	 * need to create a Split Update node for it. The node is created later
	 * in the planning.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>command_type</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>targetPolicy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>key_col_updated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Was any distribution key column among the changed columns? */</comment>
		<expr_stmt><expr><name>targetPolicy</name> <operator>=</operator> <call><name>GpPolicyFetch</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>changed_cols</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>key_col_updated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>key_col_updated</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Since we just went through a lot of work to determine whether a
			 * Split Update is needed, memorize that in the PlannerInfo, so that
			 * we don't need redo all that work later in the planner, when it's
			 * time to actually create the ModifyTable, and SplitUpdate, node.
			 */</comment>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>is_split_update</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The remaining tlist entries should be resjunk; append them all to the
	 * end of the new tlist, making sure they have resnos higher than the last
	 * real attribute.  (Note: although the rewriter already did such
	 * renumbering, we have to do it again here in case we are doing an UPDATE
	 * in a table with dropped columns, or an inheritance child table with
	 * extra columns.)
	 */</comment>
	<while>while <condition>(<expr><name>tlist_item</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>old_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlist_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>old_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"targetlist is not sorted correctly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Get the resno right, but don't copy unnecessarily */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>old_tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>!=</operator> <name>attrno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_tle</name> <operator>=</operator> <call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>old_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>old_tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>attrno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>old_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attrno</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>tlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>new_tlist</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Locate PlanRowMark for given RT index, or return NULL if none
 *
 * This probably ought to be elsewhere, but there's no very good place
 */</comment>
<function><type><name>PlanRowMark</name> <modifier>*</modifier></type>
<name>get_plan_rowmark</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowmarks</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rowmarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>==</operator> <name>rtindex</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * supplement_simply_updatable_targetlist
 * 
 * For a simply updatable cursor, we supplement the targetlist with junk
 * metadata for gp_segment_id, ctid, and tableoid. The handling of a CURRENT OF
 * invocation will rely on this junk information, in execCurrentOf(). Thus, in
 * a nutshell, it is the responsibility of this routine to ensure whatever
 * information needed to uniquely identify the currently positioned tuple is
 * available in the tuple itself.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>supplement_simply_updatable_targetlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>range_table</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We determined that this is simply updatable earlier already. Simply
	 * updatable implies that there is exactly one range table entry.
	 * (More might be added later by expanding partitioned tables, but not
	 * yet.) So we should not get here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>range_table</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>simplyUpdatableRel</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>varno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* ctid */</comment>
	<decl_stmt><decl><type><name>Var</name>         <modifier>*</modifier></type><name>varCtid</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
								   <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>,
								   <argument><expr><name>TIDOID</name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><name>InvalidOid</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tleCtid</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>varCtid</name></expr></argument>,
										   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,   <comment type="block">/* resno */</comment>
										   <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr></argument>,          <comment type="block">/* resname */</comment>
										   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                    <comment type="block">/* resjunk */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tleCtid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* gp_segment_id */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>reloid</name> 		<init>= <expr><name>InvalidOid</name></expr></init></decl>,
				<decl><type ref="prev"/><name>vartypeid</name> 	<init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>       <name>type_mod</name> 	<init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>type_coll</name>	<init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>range_table</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>GpSegmentIdAttributeNumber</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>vartypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_mod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Var</name>         <modifier>*</modifier></type><name>varSegid</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
									<argument><expr><name>GpSegmentIdAttributeNumber</name></expr></argument>,
									<argument><expr><name>vartypeid</name></expr></argument>,
									<argument><expr><name>type_mod</name></expr></argument>,
									<argument><expr><name>type_coll</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tleSegid</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>varSegid</name></expr></argument>,
											<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,   <comment type="block">/* resno */</comment>
											<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"gp_segment_id"</literal></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* resname */</comment>
											<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                    <comment type="block">/* resjunk */</comment>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tleSegid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * tableoid is only needed in the case of inheritance, in order to supplement 
	 * our ability to uniquely identify a tuple. Without inheritance, we omit tableoid
	 * to avoid the overhead of carrying tableoid for each tuple in the result set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>         <modifier>*</modifier></type><name>varTableoid</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
										   <argument><expr><name>TableOidAttributeNumber</name></expr></argument>,
										   <argument><expr><name>OIDOID</name></expr></argument>,
										   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tleTableoid</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>varTableoid</name></expr></argument>,
												   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,  <comment type="block">/* resno */</comment>
												   <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr></argument>,     <comment type="block">/* resname */</comment>
												   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                   <comment type="block">/* resjunk */</comment>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tleTableoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>
</unit>
