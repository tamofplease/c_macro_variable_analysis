<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/plan/createplan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * createplan.c
 *	  Routines to create the desired plan for processing a query.
 *	  Planning is complete, we just need to convert the selected
 *	  Path into a Plan.
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/plan/createplan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paramassign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/placeholder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/subselect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/uri.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbllize.h"</cpp:file></cpp:include>		<comment type="block">/* cdbllize_adjust_init_plan_path() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmutate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpath.h"</cpp:file></cpp:include>		<comment type="block">/* cdbpath_rows() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpathtoplan.h"</cpp:file></cpp:include>	<comment type="block">/* cdbpathtoplan_create_flow() etc. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpullup.h"</cpp:file></cpp:include>		<comment type="block">/* cdbpullup_targetlist() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsetop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtargeteddispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/joinpartprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planshare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>	<comment type="block">/* ordering_oper_opid */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Flag bits that can appear in the flags argument of create_plan_recurse().
 * These can be OR-ed together.
 *
 * CP_EXACT_TLIST specifies that the generated plan node must return exactly
 * the tlist specified by the path's pathtarget (this overrides both
 * CP_SMALL_TLIST and CP_LABEL_TLIST, if those are set).  Otherwise, the
 * plan node is allowed to return just the Vars and PlaceHolderVars needed
 * to evaluate the pathtarget.
 *
 * CP_SMALL_TLIST specifies that a narrower tlist is preferred.  This is
 * passed down by parent nodes such as Sort and Hash, which will have to
 * store the returned tuples.
 *
 * CP_LABEL_TLIST specifies that the plan node must return columns matching
 * any sortgrouprefs specified in its pathtarget, with appropriate
 * ressortgroupref labels.  This is passed down by parent nodes such as Sort
 * and Group, which need these values to be available in their inputs.
 *
 * CP_IGNORE_TLIST specifies that the caller plans to replace the targetlist,
 * and therefore it doesn't matter a bit what target list gets generated.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_EXACT_TLIST</name></cpp:macro>		<cpp:value>0x0001</cpp:value></cpp:define>	<comment type="block">/* Plan must return specified tlist */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_SMALL_TLIST</name></cpp:macro>		<cpp:value>0x0002</cpp:value></cpp:define>	<comment type="block">/* Prefer narrower tlists */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_LABEL_TLIST</name></cpp:macro>		<cpp:value>0x0004</cpp:value></cpp:define>	<comment type="block">/* tlist must contain sortgrouprefs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_IGNORE_TLIST</name></cpp:macro>		<cpp:value>0x0008</cpp:value></cpp:define>	<comment type="block">/* caller will replace tlist */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>            <modifier>*</modifier></type><name>seen_subplans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>                  <name>result</name></decl>;</decl_stmt>
}</block></struct></type> <name>contain_motion_walk_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_scan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>build_path_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>use_physical_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_gating_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_gating_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>gating_quals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_join_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_append_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_merge_append_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type><name>create_group_result_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										<parameter><decl><type><name>GroupResultPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type><name>create_project_set_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ProjectSetPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Material</name> <modifier>*</modifier></type><name>create_material_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_unique_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_motion_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_splitupdate_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SplitUpdatePath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type><name>create_gather_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_projection_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									<parameter><decl><type><name>ProjectionPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>inject_projection_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parallel_safe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type><name>create_sort_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SortPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type><name>create_upper_unique_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UpperUniquePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Agg</name> <modifier>*</modifier></type><name>create_agg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleSplit</name> <modifier>*</modifier></type><name>create_tup_split_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>TupleSplitPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_groupingsets_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GroupingSetsPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type><name>create_minmaxagg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MinMaxAggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type><name>create_windowagg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowAggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type><name>create_setop_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SetOpPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type><name>create_recursiveunion_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RecursiveUnionPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type><name>create_lockrows_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>LockRowsPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type><name>create_modifytable_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Limit</name> <modifier>*</modifier></type><name>create_limit_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>LimitPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type><name>create_seqscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type><name>create_samplescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Scan</name> <modifier>*</modifier></type><name>create_indexscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>indexonly</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type><name>create_bitmap_scan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											   <parameter><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
											   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_bitmap_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexqual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexECs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type><name>create_tidscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>TidPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type><name>create_subqueryscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											  <parameter><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type><name>create_functionscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableFunctionScan</name> <modifier>*</modifier></type><name>create_tablefunction_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>TableFunctionScanPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type><name>create_valuesscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type><name>create_tablefuncscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
												<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_ctescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>create_namedtuplestorescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
															<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type><name>create_resultscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
									  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type><name>create_worktablescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
												<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type><name>create_foreignscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CustomScan</name> <modifier>*</modifier></type><name>create_customscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										  <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NestLoop</name> <modifier>*</modifier></type><name>create_nestloop_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>NestPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MergeJoin</name> <modifier>*</modifier></type><name>create_mergejoin_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MergePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type><name>create_hashjoin_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>HashPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>replace_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>replace_nestloop_params_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fix_indexqual_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>stripped_indexquals_p</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>fixed_indexquals_p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>fix_indexorderby_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>fix_indexqual_clause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								  <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexcol</name></decl></parameter>,
								  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexcolnos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>fix_indexqual_operand</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexcol</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_switched_clauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>order_qual_clauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_generic_path_info</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_plan_costsize</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>label_sort_with_costsize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Sort</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
									 <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type><name>make_seqscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type><name>make_samplescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
								   <parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexScan</name> <modifier>*</modifier></type><name>make_indexscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderby</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbyorig</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbyops</name></decl></parameter>,
								 <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexOnlyScan</name> <modifier>*</modifier></type><name>make_indexonlyscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
										 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderby</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indextlist</name></decl></parameter>,
										 <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapIndexScan</name> <modifier>*</modifier></type><name>make_bitmap_indexscan</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type><name>make_bitmap_heapscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
											<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapqualorig</name></decl></parameter>,
											<parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type><name>make_tidscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tidquals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type><name>make_subqueryscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
									   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
									   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type><name>make_functionscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
									   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>functions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>funcordinality</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableFunctionScan</name> <modifier>*</modifier></type><name>make_tablefunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
				   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type><name>make_valuesscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
								   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values_lists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type><name>make_tablefuncscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
										 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>TableFunc</name> <modifier>*</modifier></type><name>tablefunc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CteScan</name> <modifier>*</modifier></type><name>make_ctescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
							 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ctePlanId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cteParam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>make_namedtuplestorescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
													 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>enrname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type><name>make_worktablescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
										 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type><name>make_recursive_union</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
											<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
											<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>,
											<parameter><decl><type><name>long</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapAnd</name> <modifier>*</modifier></type><name>make_bitmap_and</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapplans</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapOr</name> <modifier>*</modifier></type><name>make_bitmap_or</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapplans</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NestLoop</name> <modifier>*</modifier></type><name>make_nestloop</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nestParams</name></decl></parameter>,
							   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
							   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type><name>make_hashjoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashclauses</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
							   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Hash</name> <modifier>*</modifier></type><name>make_hash</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>skewTable</name></decl></parameter>,
					   <parameter><decl><type><name>AttrNumber</name></type> <name>skewColumn</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>skewInherit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MergeJoin</name> <modifier>*</modifier></type><name>make_mergejoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergefamilies</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergecollations</name></decl></parameter>,
								 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mergestrategies</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>mergenullsfirst</name></decl></parameter>,
								 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
								 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>skip_mark_restore</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type><name>make_sort</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>,
					   <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>prepare_sort_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
										<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>reqColIdx</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>adjust_tlist_in_place</name></decl></parameter>,
										<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p_numsortkeys</name></decl></parameter>,
										<parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortColIdx</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortOperators</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_collations</name></decl></parameter>,
										<parameter><decl><type><name>bool</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_nullsFirst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type><name>find_ec_member_for_tle</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
												 <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
												 <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type><name>make_sort_from_groupcols</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupcls</name></decl></parameter>,
									  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl></parameter>,
									  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type><name>make_windowagg</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>winref</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>partNumCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partCollations</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>ordNumCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>ordColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ordOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ordCollations</name></decl></parameter>,
								 <parameter><decl><type><name>AttrNumber</name></type> <name>firstOrderCol</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>firstOrderCmpOperator</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>firstOrderNullsFirst</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>frameOptions</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>startOffset</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>endOffset</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>startInRangeFunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>endInRangeFunc</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>inRangeColl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inRangeAsc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inRangeNullsFirst</name></decl></parameter>,
								 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type><name>make_unique_from_sortclauses</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type><name>make_unique_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type><name>make_gather</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>nworkers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rescan_param</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>single_copy</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type><name>make_setop</name><parameter_list>(<parameter><decl><type><name>SetOpCmd</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>SetOpStrategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>flagColIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>firstFlag</name></decl></parameter>,
						 <parameter><decl><type><name>long</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type><name>make_lockrows</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type><name>make_project_set</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type><name>make_modifytable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									 <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
									 <parameter><decl><type><name>Index</name></type> <name>nominalRelation</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rootRelation</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>partColsUpdated</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultRelations</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subplans</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subroots</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>withCheckOptionLists</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningLists</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>is_split_updates</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>onconflict</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GatherMerge</name> <modifier>*</modifier></type><name>create_gather_merge_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											 <parameter><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>find_junk_tle</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>junkAttrName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Motion</name> <modifier>*</modifier></type><name>cdbpathtoplan_create_motion_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
								 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>append_initplan_for_function_scan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_motion_walk</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>contain_motion_walk_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * create_plan
 *	  Creates the access plan for a query by recursively processing the
 *	  desired tree of pathnodes, starting at the node 'best_path'.  For
 *	  every pathnode found, we create a corresponding plan node containing
 *	  appropriate id, target list, and qualification information.
 *
 *	  The tlists and quals in the plan tree are still in planner format,
 *	  ie, Vars still correspond to the parser's numbering.  This will be
 *	  fixed later by setrefs.c.
 *
 *	  best_path is the best access path
 *
 *	  Returns a Plan tree.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>create_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>curSlice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name> <operator>=</operator> <name>curSlice</name></expr>;</expr_stmt>

	<comment type="block">/* plan_params should not be in use in current query level */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize this module's workspace in PlannerInfo */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Recursively process the path tree, demanding the correct tlist result */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 'partition_selector_candidates' is a stack, should be empty now
	 * that we're back from create_plan_recurse().
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>partition_selector_candidates</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure the topmost plan node's targetlist exposes the original
	 * column names and other decorative info.  Targetlists generated within
	 * the planner don't bother with that stuff, but we must have it on the
	 * top-level tlist seen at execution time.  However, ModifyTable plan
	 * nodes don't have a tlist matching the querytree targetlist.
	 *
	 * The ModifyTable might be under a Motion, so peek underneath it.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>topplan</name> <init>= <expr><name>plan</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>topplan</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>topplan</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>apply_tlist_labeling</name><argument_list>(<argument><expr><name><name>topplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Attach any initPlans created in this query level to the topmost plan
	 * node.  (In principle the initplans could go in any plan node at or
	 * above where they're referenced, but there seems no reason to put them
	 * any lower than the topmost node for the query level.  Also, see
	 * comments for SS_finalize_plan before you try to change this.)
	 */</comment>
	<expr_stmt><expr><call><name>SS_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check we successfully assigned all NestLoopParams to plan nodes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to assign all NestLoopParams to plan nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Reset plan_params to ensure param IDs used for nestloop params are not
	 * re-used later
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_plan_recurse
 *	  Recursive guts of create_plan().
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>create_plan_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex plans */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_scan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_join_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Append</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_append_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>AppendPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
									  <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_merge_append_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><operator>(</operator><name>MergeAppendPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
											<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_projection_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>ProjectionPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
											  <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>MinMaxAggPath</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_minmaxagg_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>MinMaxAggPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>GroupResultPath</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_group_result_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>GroupResultPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Simple RTE_RESULT base relation */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_scan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ProjectSet</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_project_set_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													<argument><expr><operator>(</operator><name>ProjectSetPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Material</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_material_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>MaterialPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
												 <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Unique</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>UpperUniquePath</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_upper_unique_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>UpperUniquePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
														 <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_unique_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>UniquePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
										  <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Gather</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_gather_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>GatherPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Sort</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>SortPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
											 <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Agg</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>GroupingSetsPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_groupingsets_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><operator>(</operator><name>GroupingSetsPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>AggPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TupleSplit</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>create_tup_split_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>TupleSplitPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_windowagg_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>WindowAggPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_setop_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>SetOpPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
											  <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_recursiveunion_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													   <argument><expr><operator>(</operator><name>RecursiveUnionPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_LockRows</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_lockrows_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>LockRowsPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
												 <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_modifytable_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													<argument><expr><operator>(</operator><name>ModifyTablePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Limit</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_limit_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>LimitPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
											  <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GatherMerge</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_gather_merge_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>GatherMergePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Motion</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_motion_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>CdbMotionPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_partition_selector_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>PartitionSelectorPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_splitupdate_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>SplitUpdatePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_scan_plan
 *	 Create a scan plan for the parent relation of 'best_path'.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_scan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>scan_clauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gating_clauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extract the relevant restriction clauses from the parent relation. The
	 * executor must apply all these restrictions during the scan, except for
	 * pseudoconstants which we'll take care of below.
	 *
	 * If this is a plain indexscan or index-only scan, we need not consider
	 * restriction clauses that are implied by the index's predicate, so use
	 * indrestrictinfo not baserestrictinfo.  Note that we can't do that for
	 * bitmap indexscans, since there's not necessarily a single index
	 * involved; but it doesn't matter since create_bitmap_scan_plan() will be
	 * able to get rid of such clauses anyway via predicate proof.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>indexinfo</name><operator>-&gt;</operator><name>indrestrictinfo</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If this is a parameterized scan, we also need to enforce all the join
	 * clauses available from the outer relation(s).
	 *
	 * For paranoia's sake, don't modify the stored baserestrictinfo list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Detect whether we have any pseudoconstant quals to deal with.  Then, if
	 * we'll need a gating Result node, it will be able to project, so there
	 * are no requirements on the child's tlist.
	 */</comment>
	<expr_stmt><expr><name>gating_clauses</name> <operator>=</operator> <call><name>get_gating_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>gating_clauses</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For table scans, rather than using the relation targetlist (which is
	 * only those Vars actually needed by the query), we prefer to generate a
	 * tlist containing all Vars in order.  This will allow the executor to
	 * optimize away projection of the table tuples, if possible.
	 *
	 * But if the caller is going to ignore our tlist anyway, then don't
	 * bother generating one at all.  We use an exact equality test here, so
	 * that this only applies when CP_IGNORE_TLIST is the only flag set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <name>CP_IGNORE_TLIST</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>use_physical_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_IndexOnlyScan</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* For index-only scan, the preferred tlist is the index's */</comment>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name><operator>)</operator><operator>-&gt;</operator><name><name>indexinfo</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Transfer sortgroupref data to the replacement tlist, if
			 * requested (use_physical_tlist checked that this will work).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CP_LABEL_TLIST</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>apply_pathtarget_labeling_to_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_physical_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Failed because of dropped cols, so use regular method */</comment>
				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* As above, transfer sortgroupref data to replacement tlist */</comment>
				<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CP_LABEL_TLIST</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>apply_pathtarget_labeling_to_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<switch>switch <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_seqscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name>best_path</name></expr></argument>,
												<argument><expr><name>tlist</name></expr></argument>,
												<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_samplescan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>best_path</name></expr></argument>,
												   <argument><expr><name>tlist</name></expr></argument>,
												   <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_indexscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
												  <argument><expr><name>tlist</name></expr></argument>,
												  <argument><expr><name>scan_clauses</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_indexscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
												  <argument><expr><name>tlist</name></expr></argument>,
												  <argument><expr><name>scan_clauses</name></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_bitmap_scan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													<argument><expr><operator>(</operator><name>BitmapHeapPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
													<argument><expr><name>tlist</name></expr></argument>,
													<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_tidscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><operator>(</operator><name>TidPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
												<argument><expr><name>tlist</name></expr></argument>,
												<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_subqueryscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>SubqueryScanPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
													 <argument><expr><name>tlist</name></expr></argument>,
													 <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_functionscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>best_path</name></expr></argument>,
													 <argument><expr><name>tlist</name></expr></argument>,
													 <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>append_initplan_for_function_scan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_tablefunction_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>TableFunctionScanPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
													  <argument><expr><name>tlist</name></expr></argument>,
													  <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_tablefuncscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><name>best_path</name></expr></argument>,
													  <argument><expr><name>tlist</name></expr></argument>,
													  <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_valuesscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>best_path</name></expr></argument>,
												   <argument><expr><name>tlist</name></expr></argument>,
												   <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CteScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_ctescan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name>best_path</name></expr></argument>,
												<argument><expr><name>tlist</name></expr></argument>,
												<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_namedtuplestorescan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name>best_path</name></expr></argument>,
															<argument><expr><name>tlist</name></expr></argument>,
															<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Result</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_resultscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>best_path</name></expr></argument>,
												   <argument><expr><name>tlist</name></expr></argument>,
												   <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_worktablescan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><name>best_path</name></expr></argument>,
													  <argument><expr><name>tlist</name></expr></argument>,
													  <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_foreignscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													<argument><expr><operator>(</operator><name>ForeignPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
													<argument><expr><name>tlist</name></expr></argument>,
													<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_customscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><operator>(</operator><name>CustomPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
												   <argument><expr><name>tlist</name></expr></argument>,
												   <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>gp_enable_direct_dispatch</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DirectDispatchUpdateContentIdsFromPlan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there are any pseudoconstant clauses attached to this node, insert a
	 * gating Result node that evaluates the pseudoconstants as one-time
	 * quals.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>gating_clauses</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_gating_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>gating_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a target list (ie, a list of TargetEntry) for the Path's output.
 *
 * This is almost just make_tlist_from_pathtarget(), but we also have to
 * deal with replacing nestloop params.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>build_path_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name>	   <modifier>*</modifier></type><name>sortgrouprefs</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>v</argument>, <argument>path-&gt;pathtarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If it's a parameterized path, there might be lateral references in
		 * the tlist, which need to be replaced with Params.  There's no need
		 * to remake the TargetEntry nodes, so apply this to each list item
		 * separately.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
							  <argument><expr><name>resno</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sortgrouprefs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>sortgrouprefs</name><index>[<expr><name>resno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * use_physical_tlist
 *		Decide whether to use a tlist matching relation structure,
 *		rather than only those Vars actually referenced.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>use_physical_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Forget it if either exact tlist or small tlist is demanded.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CP_EXACT_TLIST</name> <operator>|</operator> <name>CP_SMALL_TLIST</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can do this for real relation scans, subquery scans, function scans,
	 * tablefunc scans, values scans, and CTE scans (but not for, eg, joins).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_FUNCTION</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_TABLEFUNC</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_VALUES</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_TABLEFUNCTION</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_CTE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't do it with inheritance cases either (mainly because Append
	 * doesn't project; this test may be unnecessary now that
	 * create_append_plan instructs its children to return an exact tlist).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also, don't do it to a CustomPath; the premise that we're extracting
	 * columns from a simple physical tuple is unlikely to hold for those.
	 * (When it does make sense, the custom path creator can set up the path's
	 * pathtarget that way.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CustomPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If a bitmap scan's tlist is empty, keep it as-is.  This may allow the
	 * executor to skip heap page fetches, and in any case, the benefit of
	 * using a physical tlist instead would be minimal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapHeapPath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't do it if any system columns or whole-row Vars are requested.
	 * (This could possibly be fixed but would take some fragile assumptions
	 * in setrefs.c, I think.)
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>i</name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Can't do it if the rel is required to emit any placeholder expressions,
	 * either.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_nonempty_difference</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Also, can't do it if CP_LABEL_TLIST is specified and path is requested
	 * to emit any sort/group columns that are not simple Vars.  (If they are
	 * simple Vars, they should appear in the physical tlist, and
	 * apply_pathtarget_labeling_to_tlist will take care of getting them
	 * labeled again.)	We also have to check that no two sort/group columns
	 * are the same Var, else that element of the physical tlist would need
	 * conflicting ressortgroupref labels.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CP_LABEL_TLIST</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>sortgroupatts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>path-&gt;pathtarget-&gt;exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>attno</name> <operator>-=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attno</name></expr></argument>, <argument><expr><name>sortgroupatts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>sortgroupatts</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>sortgroupatts</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_gating_quals
 *	  See if there are pseudoconstant quals in a node's quals list
 *
 * If the node's quals list includes any pseudoconstant quals,
 * return just those quals.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_gating_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No need to look if we know there are no pseudoconstants */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasPseudoConstantQuals</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Sort into desirable execution order while still in RestrictInfo form */</comment>
	<expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pull out any pseudoconstant quals from the RestrictInfo list */</comment>
	<return>return <expr><call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_gating_plan
 *	  Deal with pseudoconstant qual clauses
 *
 * Add a gating Result node atop the already-built plan.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_gating_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>gating_quals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>gplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>splan</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gating_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We might have a trivial Result plan already.  Stacking one Result atop
	 * another is silly, so if that applies, just discard the input plan.
	 * (We're assuming its targetlist is uninteresting; it should be either
	 * the same as the result of build_path_tlist, or a simplified version.)
	 */</comment>
	<expr_stmt><expr><name>splan</name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>rplan</name> <init>= <expr><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>rplan</name><operator>-&gt;</operator><name>resconstantqual</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>splan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we need a Result node anyway, always return the path's requested
	 * tlist; that's never a wrong choice, even if the parent node didn't ask
	 * for CP_EXACT_TLIST.
	 */</comment>
	<expr_stmt><expr><name>gplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>gating_quals</name></expr></argument>,
								 <argument><expr><name>splan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Notice that we don't change cost or size estimates when doing gating.
	 * The costs of qual eval were already included in the subplan's cost.
	 * Leaving the size alone amounts to assuming that the gating qual will
	 * succeed, which is the conservative estimate for planning upper queries.
	 * We certainly don't want to assume the output size is zero (unless the
	 * gating qual is actually constant FALSE, and that case is dealt with in
	 * clausesel.c).  Interpolating between the two cases is silly, because it
	 * doesn't reflect what will really happen at runtime, and besides which
	 * in most cases we have only a very bad idea of the probability of the
	 * gating qual being true.
	 */</comment>
	<expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>gplan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Gating quals could be unsafe, so better use the Path's safety flag */</comment>
	<expr_stmt><expr><name><name>gplan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

	<return>return <expr><name>gplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_join_plan
 *	  Create a join plan for 'best_path' and (recursively) plans for its
 *	  inner and outer paths.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_join_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gating_clauses</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_mergejoin_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>MergePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_hashjoin_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>HashPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_nestloop_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>NestPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* CDB: if the join's locus is bottleneck which means the
	 * join gang only contains one process, so there is no
	 * risk for motion deadlock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>prefetch_inner</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>prefetch_joinqual</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>prefetch_qual</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We may set prefetch_joinqual to true if there is
	 * potential risk when create_xxxjoin_plan. Here, we
	 * have all the information at hand, this is the final
	 * logic to set prefetch_joinqual.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>prefetch_joinqual</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinqual</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>prefetch_joinqual</name> <operator>=</operator> <call><name>contain_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Similar for non join qual. If it contains a motion and outer relation
	 * also contains a motion, then we should set prefetch_qual to true.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>prefetch_qual</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>plan</name><operator>.</operator><name>qual</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>prefetch_qual</name> <operator>=</operator> <call><name>contain_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there are any pseudoconstant clauses attached to this node, insert a
	 * gating Result node that evaluates the pseudoconstants as one-time
	 * quals.
	 */</comment>
	<expr_stmt><expr><name>gating_clauses</name> <operator>=</operator> <call><name>get_gating_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>gating_clauses</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_gating_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>,
								  <argument><expr><name>gating_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>

	<comment type="block">/*
	 * * Expensive function pullups may have pulled local predicates * into
	 * this path node.  Put them in the qpqual of the plan node. * JMH,
	 * 6/15/92
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_loc_restrictinfo</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_qpqual</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name><operator>)</operator> <name>plan</name></expr></argument>,
				   <argument><expr><call><name>list_concat</name><argument_list>(<argument><expr><call><name>get_qpqual</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name><operator>)</operator> <name>plan</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>get_actual_clauses</name><argument_list>(<argument><expr><call><name>get_loc_restrictinfo</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_append_plan
 *	  Create an Append plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 *
 *	  Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_append_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Append</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>orig_tlist_length</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tlist_was_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>subpaths</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionPruneInfo</name> <modifier>*</modifier></type><name>partpruneinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nodenumsortkeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>nodeSortColIdx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>nodeSortOperators</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>nodeCollations</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nodeNullsFirst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The subpaths list could be empty, if every child was proven empty by
	 * constraint exclusion.  In that case generate a dummy plan that returns
	 * no rows.
	 *
	 * Note that an AppendPath with no members is also generated in certain
	 * cases where there was no appending construct at all, but we know the
	 * relation is empty (see set_dummy_rel_pathlist and mark_dummy_rel).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate a Result plan with constant-FALSE gating qual */</comment>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
									<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>,
																	  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>plan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise build an Append plan.  Note that if there's just one child,
	 * the Append is pretty useless; but we wait till setrefs.c to get rid of
	 * it.  Doing so here doesn't work because the varno of the child scan
	 * plan won't match the parent-rel Vars it'll be asked to emit.
	 *
	 * We don't have the actual creation of the Append node split out into a
	 * separate make_xxx function.  This is because we want to run
	 * prepare_sort_from_pathkeys on it before we do so on the individual
	 * child plans, to make cross-checking the sort info easier.
	 */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Compute sort column info, and adjust the Append's tlist as needed.
		 * Because we pass adjust_tlist_in_place = true, we may ignore the
		 * function result; it must be the same plan node.  However, we then
		 * need to detect whether any tlist entries were added.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
										  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>nodenumsortkeys</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>nodeSortColIdx</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>nodeSortOperators</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>nodeCollations</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>nodeNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist_was_changed</name> <operator>=</operator> <operator>(</operator><name>orig_tlist_length</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Build the plan for each child */</comment>
	<macro><name>foreach</name><argument_list>(<argument>subpaths</argument>, <argument>best_path-&gt;subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

		<comment type="block">/* Must insist that all children return the same tlist */</comment>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For ordered Appends, we must insert a Sort node if subplan isn't
		 * sufficiently ordered.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>numsortkeys</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Compute sort column info, and adjust subplan's tlist as needed.
			 * We must apply prepare_sort_from_pathkeys even to subplans that
			 * don't need an explicit sort, to make sure they are returning
			 * the same sort key columns the Append expects.
			 */</comment>
			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
												 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
												 <argument><expr><name>nodeSortColIdx</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>numsortkeys</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check that we got the same sort key information.  We just
			 * Assert that the sortops match, since those depend only on the
			 * pathkeys; but it seems like a good idea to check the sort
			 * column numbers explicitly, to ensure the tlists match up.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>==</operator> <name>nodenumsortkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>nodeSortColIdx</name></expr></argument>,
					   <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Append child's targetlist doesn't match Append"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name>nodeSortOperators</name></expr></argument>,
						  <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nodeCollations</name></expr></argument>,
						  <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name>nodeNullsFirst</name></expr></argument>,
						  <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Now, insert a Sort node if subplan isn't sufficiently ordered */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>sort</name> <init>= <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
											 <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
											 <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>sort</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If any quals exist, they may be useful to perform further partition
	 * pruning during execution.  Gather information needed by the executor to
	 * do partition pruning.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_partition_pruning</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prunequal</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prunequal</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prmquals</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>prmquals</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>prmquals</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prmquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prmquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>prunequal</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>prunequal</name></expr></argument>, <argument><expr><name>prmquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>prunequal</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>partpruneinfo</name> <operator>=</operator>
				<call><name>make_partition_pruneinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>,
										 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name></expr></argument>,
										 <argument><expr><name>prunequal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * GPDB: Also perform join-pruning, if possible
		 *
		 * XXX: Skip this for parameterized paths for now. We could probably
		 * handle them somehow, but not implemented yet..
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>join_prune_paramids</name></name> <operator>=</operator> <call><name>make_partition_join_pruneinfos</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
																	   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>,
																	   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>appendplans</name></name> <operator>=</operator> <name>subplans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>first_partial_plan</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>first_partial_path</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>part_prune_info</name></name> <operator>=</operator> <name>partpruneinfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If prepare_sort_from_pathkeys added sort columns, but we were told to
	 * produce either the exact tlist or a narrow tlist, we should get rid of
	 * the sort columns again.  We must inject a projection node to do so.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tlist_was_changed</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CP_EXACT_TLIST</name> <operator>|</operator> <name>CP_SMALL_TLIST</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>orig_tlist_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>inject_projection_plan</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>,
									  <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_merge_append_plan
 *	  Create a MergeAppend plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 *
 *	  Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_merge_append_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>orig_tlist_length</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tlist_was_changed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>subpaths</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionPruneInfo</name> <modifier>*</modifier></type><name>partpruneinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't have the actual creation of the MergeAppend node split out
	 * into a separate make_xxx function.  This is because we want to run
	 * prepare_sort_from_pathkeys on it before we do so on the individual
	 * child plans, to make cross-checking the sort info easier.
	 */</comment>
	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute sort column info, and adjust MergeAppend's tlist as needed.
	 * Because we pass adjust_tlist_in_place = true, we may ignore the
	 * function result; it must be the same plan node.  However, we then need
	 * to detect whether any tlist entries were added.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
									  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tlist_was_changed</name> <operator>=</operator> <operator>(</operator><name>orig_tlist_length</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now prepare the child plans.  We must apply prepare_sort_from_pathkeys
	 * even to subplans that don't need an explicit sort, to make sure they
	 * are returning the same sort key columns the MergeAppend expects.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>subpaths</argument>, <argument>best_path-&gt;subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numsortkeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

		<comment type="block">/* Build the child plan */</comment>
		<comment type="block">/* Must insist that all children return the same tlist */</comment>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Compute sort column info, and adjust subplan's tlist as needed */</comment>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
											 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>numsortkeys</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check that we got the same sort key information.  We just Assert
		 * that the sortops match, since those depend only on the pathkeys;
		 * but it seems like a good idea to check the sort column numbers
		 * explicitly, to ensure the tlists really do match up.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
				   <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"MergeAppend child's targetlist doesn't match MergeAppend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
					  <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
					  <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>,
					  <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now, insert a Sort node if subplan isn't sufficiently ordered */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>sort</name> <init>= <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
										 <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
										 <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>sort</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If any quals exist, they may be useful to perform further partition
	 * pruning during execution.  Gather information needed by the executor to
	 * do partition pruning.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_partition_pruning</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prunequal</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prunequal</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prmquals</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>prmquals</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>prmquals</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prmquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prmquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>prunequal</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>prunequal</name></expr></argument>, <argument><expr><name>prmquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>prunequal</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>partpruneinfo</name> <operator>=</operator> <call><name>make_partition_pruneinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>,
													 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name></expr></argument>,
													 <argument><expr><name>prunequal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * GPDB: Also perform join-pruning, if possible
		 *
		 * XXX: Skip this for parameterized paths for now. We could probably
		 * handle them somehow, but not implemented yet..
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join_prune_paramids</name></name> <operator>=</operator> <call><name>make_partition_join_pruneinfos</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
																	   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>,
																	   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeplans</name></name> <operator>=</operator> <name>subplans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>part_prune_info</name></name> <operator>=</operator> <name>partpruneinfo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If prepare_sort_from_pathkeys added sort columns, but we were told to
	 * produce either the exact tlist or a narrow tlist, we should get rid of
	 * the sort columns again.  We must inject a projection node to do so.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tlist_was_changed</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CP_EXACT_TLIST</name> <operator>|</operator> <name>CP_SMALL_TLIST</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>orig_tlist_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>inject_projection_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>plan</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_group_result_plan
 *	  Create a Result plan for 'best_path'.
 *	  This is only used for degenerate grouping cases.
 *
 *	  Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type>
<name>create_group_result_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GroupResultPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* best_path-&gt;quals is just bare clauses */</comment>
	<expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>quals</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_project_set_plan
 *	  Create a ProjectSet plan for 'best_path'.
 *
 *	  Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type>
<name>create_project_set_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ProjectSetPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProjectSet</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

	<comment type="block">/* Since we intend to project, we don't need to constrain child tlist */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_project_set</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_material_plan
 *	  Create a Material plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 *
 *	  Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Material</name> <modifier>*</modifier></type>
<name>create_material_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Material</name>   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't want any excess columns in the materialized tuples, so request
	 * a smaller tlist.  Otherwise, since Material doesn't project, tlist
	 * requirements pass through.
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
								  <argument><expr><name>flags</name> <operator>|</operator> <name>CP_SMALL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>cdb_strict</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>cdb_strict</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>cdb_shield_child_from_rescans</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>cdb_shield_child_from_rescans</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_unique_plan
 *	  Create a Unique plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 *
 *	  Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_unique_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>in_operators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>uniq_exprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newtlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nextresno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroupCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>groupColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>groupCollations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>groupColPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Unique doesn't project, so tlist requirements pass through */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return naked subplan if we don't need to do any actual unique-ifying */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_NOOP</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>subplan</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * As constructed, the subplan has a "flat" tlist containing just the Vars
	 * needed here and at upper levels.  The values we are supposed to
	 * unique-ify may be expressions in these variables.  We have to add any
	 * such expressions to the subplan's tlist.
	 *
	 * The subplan may have a "physical" tlist if it is a simple scan plan. If
	 * we're going to sort, this should be reduced to the regular tlist, so
	 * that we don't sort more data than we need to.  For hashing, the tlist
	 * should be left as-is if we don't need to add any expressions; but if we
	 * do have to add expressions, then a projection step will be needed at
	 * runtime anyway, so we may as well remove unneeded items. Therefore
	 * newtlist starts from build_path_tlist() not just a copy of the
	 * subplan's tlist; and we don't install it into the subplan unless we are
	 * sorting or stuff has to be added.
	 */</comment>
	<expr_stmt><expr><name>in_operators</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>in_operators</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>uniq_exprs</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>uniq_exprs</name></name></expr>;</expr_stmt>

	<comment type="block">/* initialize modified subplan tlist as just the "required" vars */</comment>
	<expr_stmt><expr><name>newtlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextresno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>newitems</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>uniq_exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>uniqexpr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><name>uniqexpr</name></expr></argument>, <argument><expr><name>newtlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>uniqexpr</name></expr></argument>,
								  <argument><expr><name>nextresno</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newtlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextresno</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>newitems</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Use change_plan_targetlist in case we need to insert a Result node */</comment>
	<if_stmt><if>if <condition>(<expr><name>newitems</name> <operator>||</operator> <name><name>best_path</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_SORT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>change_plan_targetlist</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>newtlist</name></expr></argument>,
										 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build control information showing which subplan output columns are to
	 * be examined by the grouping step.  Unfortunately we can't merge this
	 * with the previous loop, since we didn't then know which version of the
	 * subplan tlist we'd end up using.
	 */</comment>
	<expr_stmt><expr><name>newtlist</name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numGroupCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>uniq_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>groupColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numGroupCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>groupCollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numGroupCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>groupColPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>uniq_exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>uniqexpr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><name>uniqexpr</name></expr></argument>, <argument><expr><name>newtlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find unique expression in subplan tlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>groupColIdx</name><index>[<expr><name>groupColPos</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>groupCollations</name><index>[<expr><name>groupColPos</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>groupColPos</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_HASH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>groupOperators</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get the hashable equality operators for the Agg node to use.
		 * Normally these are the same as the IN clause operators, but if
		 * those are cross-type operators then the equality operators are the
		 * ones for the IN clause operators' RHS datatype.
		 */</comment>
		<expr_stmt><expr><name>groupOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numGroupCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>groupColPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>in_operators</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>in_oper</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_oper</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_compatible_hash_operators</name><argument_list>(<argument><expr><name>in_oper</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eq_oper</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find compatible hash operator for operator %u"</literal></expr></argument>,
					 <argument><expr><name>in_oper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>groupOperators</name><index>[<expr><name>groupColPos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>eq_oper</name></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Since the Agg node is going to project anyway, we can give it the
		 * minimum output tlist, without any stuff we might have added to the
		 * subplan tlist.
		 */</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_agg</name><argument_list>(<argument><expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>NIL</name></expr></argument>,
								 <argument><expr><name>AGG_HASHED</name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
								 <argument><expr><name>numGroupCols</name></expr></argument>,
								 <argument><expr><name>groupColIdx</name></expr></argument>,
								 <argument><expr><name>groupOperators</name></expr></argument>,
								 <argument><expr><name>groupCollations</name></expr></argument>,
								 <argument><expr><name>NIL</name></expr></argument>,
								 <argument><expr><name>NIL</name></expr></argument>,
								 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>,
								 <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>sort</name></decl>;</decl_stmt>

		<comment type="block">/* Create an ORDER BY list to sort the input compatibly */</comment>
		<expr_stmt><expr><name>groupColPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>in_operators</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>in_oper</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>sortop</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>eqop</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_ordering_op_for_equality_op</name><argument_list>(<argument><expr><name>in_oper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find ordering operator for equality operator %u"</literal></expr></argument>,
					 <argument><expr><name>in_oper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * The Unique node will need equality operators.  Normally these
			 * are the same as the IN clause operators, but if those are
			 * cross-type operators then the equality operators are the ones
			 * for the IN clause operators' RHS datatype.
			 */</comment>
			<expr_stmt><expr><name>eqop</name> <operator>=</operator> <call><name>get_equality_op_for_ordering_op</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find equality operator for ordering operator %u"</literal></expr></argument>,
					 <argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
								   <argument><expr><name><name>groupColIdx</name><index>[<expr><name>groupColPos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>sortcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <call><name>assignSortGroupRef</name><argument_list>(<argument><expr><name>tle</name></expr></argument>,
														 <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* no need to make this accurate */</comment>
			<expr_stmt><expr><name>sortList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sortList</name></expr></argument>, <argument><expr><name>sortcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>groupColPos</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>sort</name> <operator>=</operator> <call><name>make_sort_from_sortclauses</name><argument_list>(<argument><expr><name>sortList</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_unique_from_sortclauses</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>sort</name></expr></argument>, <argument><expr><name>sortList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Copy cost data from Path to Plan */</comment>
	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we changed the target list, and CP_EXACT_TLIST was requested, insert
	 * a Result node to change the target list back.
	 *
	 * We need to do this because the topmost plan node's targetlist should be
	 * consistent with the original targetlist, otherwise an assertion failure
	 * would be triggered in apply_tlist_labeling(). In GPDB, it's possible
	 * that the Unique plan node created here is the topmost plan, or there is
	 * no projection capable node above it (such as for RowIdExpr Unique
	 * paths). So we need to make sure its targetlist is consistent with the
	 * original targetlist. In PostgreSQL, we don't have this same problem,
	 * because there would always be a join node above the Unique plan node
	 * created here, which is projection capable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newitems</name> <operator>||</operator> <name><name>best_path</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_SORT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oldtlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>change_plan_targetlist</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>oldtlist</name></expr></argument>,
									  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_gather_plan
 *
 *	  Create a Gather plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type>
<name>create_gather_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Gather</name>	   <modifier>*</modifier></type><name>gather_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Although the Gather node can project, we prefer to push down such work
	 * to its child node, so demand an exact tlist from the child.
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>gather_plan</name> <operator>=</operator> <call><name>make_gather</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							  <argument><expr><name>NIL</name></expr></argument>,
							  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>,
							  <argument><expr><call><name>assign_special_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>single_copy</name></name></expr></argument>,
							  <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* use parallel mode for parallel plans. */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>gather_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_gather_merge_plan
 *
 *	  Create a Gather Merge plan for 'best_path' and (recursively)
 *	  plans for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>GatherMerge</name> <modifier>*</modifier></type>
<name>create_gather_merge_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GatherMerge</name> <modifier>*</modifier></type><name>gm_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* As with Gather, it's best to project away columns in the workers. */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a shell for a GatherMerge plan. */</comment>
	<expr_stmt><expr><name>gm_plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GatherMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assign the rescan Param. */</comment>
	<expr_stmt><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>rescan_param</name></name> <operator>=</operator> <call><name>assign_special_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Gather Merge is pointless with no pathkeys; use Gather instead. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathkeys</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute sort column info, and adjust subplan's tlist as needed */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
										 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										 <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* Now, insert a Sort node if subplan isn't sufficiently ordered */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_sort</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
									 <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
									 <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
									 <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
									 <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now insert the subplan under GatherMerge. */</comment>
	<expr_stmt><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>

	<comment type="block">/* use parallel mode for parallel plans. */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>gm_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the target list of 'pathtarget' contain a RowIdExpr?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pathtarget_contains_rowidexpr</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pathtarget</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pathtarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RowIdExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_projection_plan
 *
 *	  Create a plan tree to do a projection step and (recursively) plans
 *	  for its subpaths.  We may need a Result node for the projection,
 *	  but sometimes we can just let the subplan do the work.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_projection_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ProjectionPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needs_result_node</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Convert our subpath to a Plan and determine whether we need a Result
	 * node.
	 *
	 * In most cases where we don't need to project, creation_projection_path
	 * will have set dummypp, but not always.  First, some createplan.c
	 * routines change the tlists of their nodes.  (An example is that
	 * create_merge_append_plan might add resjunk sort columns to a
	 * MergeAppend.)  Second, create_projection_path has no way of knowing
	 * what path node will be placed on top of the projection path and
	 * therefore can't predict whether it will require an exact tlist. For
	 * both of these reasons, we have to recheck here.
	 *
	 * If this projection was created to evaluate a RowIdExpr, make sure
	 * we don't optimize it away.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>best_path</name><operator>-&gt;</operator><name>cdb_restrict_clauses</name></name> <operator>&amp;&amp;</operator> <call><name>use_physical_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>best_path</name><operator>-&gt;</operator><name>force</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>pathtarget_contains_rowidexpr</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Our caller doesn't really care what tlist we return, so we don't
		 * actually need to project.  However, we may still need to ensure
		 * proper sortgroupref labels, if the caller cares about those.
		 */</comment>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CP_LABEL_TLIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>apply_pathtarget_labeling_to_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
											   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>best_path</name><operator>-&gt;</operator><name>cdb_restrict_clauses</name></name> <operator>&amp;&amp;</operator>
			 <operator>!</operator><name><name>best_path</name><operator>-&gt;</operator><name>force</name></name> <operator>&amp;&amp;</operator>
			 <call><name>is_projection_capable_path</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Our caller requires that we return the exact tlist, but no separate
		 * result node is needed because the subpath is projection-capable.
		 * Tell create_plan_recurse that we're going to ignore the tlist it
		 * produces.
		 */</comment>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
									  <argument><expr><name>CP_IGNORE_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * It looks like we need a result node, unless by good fortune the
		 * requested tlist is exactly the one the child wants to produce.
		 */</comment>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>force</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needs_result_node</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>needs_result_node</name> <operator>=</operator> <operator>!</operator><call><name>tlist_same_exprs</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we make a different decision about whether to include a Result node
	 * than create_projection_path did, we'll have made slightly wrong cost
	 * estimates; but label the plan with the cost estimates we actually used,
	 * not "corrected" ones.  (XXX this could be cleaned up if we moved more
	 * of the sortcolumn setup logic into Path creation, but that would add
	 * expense to creating Paths we might end up not using.)
	 */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>best_path</name><operator>-&gt;</operator><name>cdb_restrict_clauses</name></name> <operator>&amp;&amp;</operator>
            <operator>!</operator><name>needs_result_node</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Don't need a separate Result, just assign tlist to subplan */</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

		<comment type="block">/* Label plan with the estimated costs we actually used */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
		<comment type="block">/* ... but don't change subplan's parallel_aware flag */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>scan_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pseudoconstants</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>cdb_restrict_clauses</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>all_clauses</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>cdb_restrict_clauses</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Sort clauses into best execution order */</comment>
			<expr_stmt><expr><name>all_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>all_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
			<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>all_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* but we actually also want the pseudoconstants */</comment>
			<expr_stmt><expr><name>pseudoconstants</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>all_clauses</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
					<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We need a Result node */</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pseudoconstants</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>scan_clauses</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Greenplum specific behavior:
	 * We may use the Result plan with resconstantqual to be
	 * One-Time Filter: (gp_execution_segment() = &lt;some segid&gt;).
	 * We should re-consider direct dispatch info in this case.
	 * See function `set_append_path_locus` and Github Issue
	 * https://github.com/greenplum-db/gpdb/issues/9874 for more
	 * detailed info.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>direct_dispath_contentIds</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DirectDispatchInfo</name></type> <name>dispatchInfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>dispatchInfo</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dispatchInfo</name><operator>.</operator><name>contentIds</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>direct_dispath_contentIds</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dispatchInfo</name><operator>.</operator><name>haveProcessedAnyCalculations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MergeDirectDispatchCalculationInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>directDispatch</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * inject_projection_plan
 *	  Insert a Result node to do a projection step.
 *
 * This is used in a few places where we decide on-the-fly that we need a
 * projection step as part of the tree generated for some Path node.
 * We should try to get rid of this in favor of doing it more honestly.
 *
 * One reason it's ugly is we have to be told the right parallel_safe marking
 * to apply (since the tlist might be unsafe even if the child plan is safe).
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>inject_projection_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parallel_safe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In principle, we should charge tlist eval cost plus cpu_per_tuple per
	 * row for the Result node.  But the former has probably been factored in
	 * already and the latter was not accounted for during Path construction,
	 * so being formally correct might just make the EXPLAIN output look less
	 * consistent not more so.  Hence, just copy the subplan's cost.
	 */</comment>
	<expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>parallel_safe</name></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * change_plan_targetlist
 *	  Externally available wrapper for inject_projection_plan.
 *
 * This is meant for use by FDW plan-generation functions, which might
 * want to adjust the tlist computed by some subplan tree.  In general,
 * a Result node is needed to compute the new tlist, but we can optimize
 * some cases.
 *
 * In most cases, tlist_parallel_safe can just be passed as the parallel_safe
 * flag of the FDW's own Path node.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>change_plan_targetlist</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tlist_parallel_safe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the top plan node can't do projections and its existing target list
	 * isn't already what we need, we need to add a Result node to help it
	 * along.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>tlist_same_exprs</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>inject_projection_plan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>,
										 <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
										 <name>tlist_parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Else we can just replace the plan node's tlist */</comment>
		<expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;=</operator> <name>tlist_parallel_safe</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>subplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_sort_plan
 *
 *	  Create a Sort plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>create_sort_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SortPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't want any excess columns in the sorted tuples, so request a
	 * smaller tlist.  Otherwise, since Sort doesn't project, tlist
	 * requirements pass through.
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
								  <argument><expr><name>flags</name> <operator>|</operator> <name>CP_SMALL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * make_sort_from_pathkeys() indirectly calls find_ec_member_for_tle(),
	 * which will ignore any child EC members that don't belong to the given
	 * relids. Thus, if this sort path is based on a child relation, we must
	 * pass its relids.
	 */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
								   <argument><expr><ternary><condition><expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
								   <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_upper_unique_plan
 *
 *	  Create a Unique plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type>
<name>create_upper_unique_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UpperUniquePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Unique</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unique doesn't project, so tlist requirements pass through; moreover we
	 * need grouping columns to be labeled.
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
								  <argument><expr><name>flags</name> <operator>|</operator> <name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_unique_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>,
									 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
									 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>numkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_agg_plan
 *
 *	  Create an Agg plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Agg</name> <modifier>*</modifier></type>
<name>create_agg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Agg can project, so no need to be terribly picky about child tlist, but
	 * we do need grouping columns to be available
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_agg</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>quals</name></expr></argument>,
					<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr></argument>,
					<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>,
					<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>streaming</name></name></expr></argument>,
					<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>extract_grouping_cols</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										  <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>extract_grouping_ops</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>extract_grouping_collations</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>NIL</name></expr></argument>,
					<argument><expr><name>NIL</name></expr></argument>,
					<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
					<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* assign the agg_expr_id, indicate which DQA is this agg for */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tl</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>tl</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>AggExprId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* id is zero indexed */</comment>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>agg_expr_id</name></name> <operator>=</operator> <name>id</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>id</name> <operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tup_split_plan
 *
 *	  Create an TupleSplit plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleSplit</name> <modifier>*</modifier></type>
<name>create_tup_split_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>TupleSplitPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleSplit</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_tup_split</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>dqa_expr_lst</name></name></expr></argument>,
						  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>extract_grouping_cols</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a groupclause for a collection of grouping sets, produce the
 * corresponding groupColIdx.
 *
 * root-&gt;grouping_map maps the tleSortGroupRef to the actual column position in
 * the input tuple. So we get the ref from the entries in the groupclause and
 * look them up there.
 */</comment>
<function><type><specifier>static</specifier> <name>AttrNumber</name> <modifier>*</modifier></type>
<name>remap_groupColIdx</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grouping_map</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>new_grpColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>grouping_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_grpColIdx</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>new_grpColIdx</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>grouping_map</name><index>[<expr><name><name>clause</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_grpColIdx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_groupingsets_plan
 *	  Create a plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 *
 *	  What we emit is an Agg plan with some vestigial Agg and Sort nodes
 *	  hanging off the side.  The top Agg implements the last grouping set
 *	  specified in the GroupingSetsPath, and any additional grouping sets
 *	  each give rise to a subsidiary Agg and Sort node in the top Agg's
 *	  "chain" list.  These nodes don't participate in the plan directly,
 *	  but they are a convenient way to represent the required data for
 *	  the extra steps.
 *
 *	  Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_groupingsets_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GroupingSetsPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rollups</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>rollups</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grouping_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>chain</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't get here without grouping sets */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rollups</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Agg can project, so no need to be terribly picky about child tlist, but
	 * we do need grouping columns to be available
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the mapping from tleSortGroupRef to column index in the child's
	 * tlist.  First, identify max SortGroupRef in groupClause, for array
	 * sizing.
	 */</comment>
	<expr_stmt><expr><name>maxref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>&gt;</operator> <name>maxref</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxref</name> <operator>=</operator> <name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>grouping_map</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>maxref</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now look up the column numbers in the child's tlist */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>grouping_map</name><index>[<expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * During setrefs.c, we'll need the grouping_map to fix up the cols lists
	 * in GroupingFunc nodes.  Save it for setrefs.c to use.
	 *
	 * This doesn't work if we're in an inheritance subtree (see notes in
	 * create_modifytable_plan).  Fortunately we can't be because there would
	 * never be grouping in an UPDATE/DELETE; but let's Assert that.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>inhTargetKind</name></name> <operator>==</operator> <name>INHKIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map</name></name> <operator>=</operator> <name>grouping_map</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map_size</name></name> <operator>=</operator> <name>maxref</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate the side nodes that describe the other sort and group
	 * operations besides the top one.  Note that we don't worry about putting
	 * accurate cost estimates in the side nodes; only the topmost Agg node's
	 * costs will be shown by EXPLAIN.
	 */</comment>
	<expr_stmt><expr><name>chain</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_first_sort</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RollupData</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>is_hashed</name></expr></init></decl>;</decl_stmt>

		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lc2</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>new_grpColIdx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>sort_plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>agg_plan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStrategy</name></type> <name>strat</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_grpColIdx</name> <operator>=</operator> <call><name>remap_groupColIdx</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_first_sort</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sort_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator>
					<call><name>make_sort_from_groupcols</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											 <argument><expr><name>new_grpColIdx</name></expr></argument>,
											 <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_first_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_HASHED</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_PLAIN</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_SORTED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>agg_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_agg</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>,
										 <argument><expr><name>strat</name></expr></argument>,
										 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>new_grpColIdx</name></expr></argument>,
										 <argument><expr><call><name>extract_grouping_ops</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>extract_grouping_collations</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>,
										 <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
										 <argument><expr><name>sort_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remove stuff we don't need to avoid bloating debug output.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>sort_plan</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sort_plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sort_plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>chain</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>chain</name></expr></argument>, <argument><expr><name>agg_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now make the real Agg node
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>top_grpColIdx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numGroupCols</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>top_grpColIdx</name> <operator>=</operator> <call><name>remap_groupColIdx</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>numGroupCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_agg</name><argument_list>(<argument><expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
						<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr></argument>,
						<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
						<argument><expr><name>numGroupCols</name></expr></argument>,
						<argument><expr><name>top_grpColIdx</name></expr></argument>,
						<argument><expr><call><name>extract_grouping_ops</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>extract_grouping_collations</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>,
						<argument><expr><name>chain</name></expr></argument>,
						<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
						<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Copy cost data from Path to Plan */</comment>
		<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_minmaxagg_plan
 *
 *	  Create a Result plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type>
<name>create_minmaxagg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MinMaxAggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Prepare an InitPlan for each aggregate's subquery. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>best_path-&gt;mmaggregates</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>mminfo</name> <init>= <expr><operator>(</operator><name>MinMaxAggInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><name><name>mminfo</name><operator>-&gt;</operator><name>subroot</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subparse</name> <init>= <expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>cdbllize_adjust_init_plan_path</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate the plan for the subquery. We already have a Path, but we
		 * have to convert it to a Plan and attach a LIMIT node above it.
		 * Since we are entering a different planner context (subroot),
		 * recurse to create_plan not create_plan_recurse.
		 */</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decorate the top node of the plan with a Flow node. */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <call><name>cdbpathtoplan_create_flow</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_limit</name><argument_list>(<argument><expr><name>plan</name></expr></argument>,
								   <argument><expr><name><name>subparse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
								   <argument><expr><name><name>subparse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>flow</name></name></expr>;</expr_stmt>

		<comment type="block">/* Must apply correct cost/width data to Limit node */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>pathcost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

		<comment type="block">/* Convert the plan into an InitPlan in the outer query. */</comment>
		<expr_stmt><expr><call><name>SS_make_initplan_from_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name></expr></argument>, <argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>param</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Generate the output plan --- basically just a Result */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>best_path</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * During setrefs.c, we'll need to replace references to the Agg nodes
	 * with InitPlan output params.  (We can't just do that locally in the
	 * MinMaxAgg node, because path nodes above here may have Agg references
	 * as well.)  Save the mmaggregates list to tell setrefs.c to do that.
	 *
	 * This doesn't work if we're in an inheritance subtree (see notes in
	 * create_modifytable_plan).  Fortunately we can't be because there would
	 * never be aggregates in an UPDATE/DELETE; but let's Assert that.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>inhTargetKind</name></name> <operator>==</operator> <name>INHKIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>mmaggregates</name></name></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_windowagg_plan
 *
 *	  Create a WindowAgg plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type>
<name>create_windowagg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowAggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>winclause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPart</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numOrder</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partNumCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>partOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>partCollations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ordNumCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>ordColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>ordOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>ordCollations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstOrderCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>firstOrderCmpOperator</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>firstOrderNullsFirst</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * WindowAgg can project, so no need to be terribly picky about child
	 * tlist, but we do need grouping columns to be available
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Convert SortGroupClause lists into arrays of attr indexes and equality
	 * operators, as wanted by executor.  (Note: in principle, it's possible
	 * to drop some of the sort columns, if they were proved redundant by
	 * pathkey logic.  However, it doesn't seem worth going out of our way to
	 * optimize such cases.  In any case, we must *not* remove the ordering
	 * column for RANGE OFFSET cases, as the executor needs that for in_range
	 * tests even if it's known to be equal to some partitioning column.)
	 */</comment>
	<expr_stmt><expr><name>partColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partCollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partNumCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>wc-&gt;partitionClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partColIdx</name><index>[<expr><name>partNumCols</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partOperators</name><index>[<expr><name>partNumCols</name></expr>]</index></name> <operator>=</operator> <name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partCollations</name><index>[<expr><name>partNumCols</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partNumCols</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>ordColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ordOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ordCollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ordNumCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>wc-&gt;orderClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ordColIdx</name><index>[<expr><name>ordNumCols</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ordOperators</name><index>[<expr><name>ordNumCols</name></expr>]</index></name> <operator>=</operator> <name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ordCollations</name><index>[<expr><name>ordNumCols</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ordNumCols</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>l_tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>firstOrderCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l_tle</argument>, <argument>subplan-&gt;targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l_tle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>firstOrderCol</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>l_tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to locate ORDER BY column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>firstOrderCmpOperator</name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstOrderNullsFirst</name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* And finally we can make the WindowAgg node */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_windowagg</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
						  <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>,
						  <argument><expr><name>partNumCols</name></expr></argument>,
						  <argument><expr><name>partColIdx</name></expr></argument>,
						  <argument><expr><name>partOperators</name></expr></argument>,
						  <argument><expr><name>partCollations</name></expr></argument>,
						  <argument><expr><name>ordNumCols</name></expr></argument>,
						  <argument><expr><name>ordColIdx</name></expr></argument>,
						  <argument><expr><name>ordOperators</name></expr></argument>,
						  <argument><expr><name>ordCollations</name></expr></argument>,
						  <argument><expr><name>firstOrderCol</name></expr></argument>,
						  <argument><expr><name>firstOrderCmpOperator</name></expr></argument>,
						  <argument><expr><name>firstOrderNullsFirst</name></expr></argument>,
						  <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></argument>,
						  <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>,
						  <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>,
						  <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startInRangeFunc</name></name></expr></argument>,
						  <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endInRangeFunc</name></name></expr></argument>,
						  <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>inRangeColl</name></name></expr></argument>,
						  <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>inRangeAsc</name></name></expr></argument>,
						  <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>inRangeNullsFirst</name></name></expr></argument>,
						  <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_setop_plan
 *
 *	  Create a SetOp plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type>
<name>create_setop_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SetOpPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOp</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>numGroups</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SetOp doesn't project, so tlist requirements pass through; moreover we
	 * need grouping columns to be labeled.
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
								  <argument><expr><name>flags</name> <operator>|</operator> <name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert numGroups to long int --- but 'ware overflow! */</comment>
	<expr_stmt><expr><name>numGroups</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>LONG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_setop</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>,
					  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>,
					  <argument><expr><name>subplan</name></expr></argument>,
					  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>distinctList</name></name></expr></argument>,
					  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>flagColIdx</name></name></expr></argument>,
					  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>firstFlag</name></name></expr></argument>,
					  <argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_recursiveunion_plan
 *
 *	  Create a RecursiveUnion plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type>
<name>create_recursiveunion_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RecursiveUnionPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecursiveUnion</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>leftplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>rightplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>numGroups</name></decl>;</decl_stmt>

	<comment type="block">/* Need both children to produce same tlist, so force it */</comment>
	<expr_stmt><expr><name>leftplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>leftpath</name></name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>rightpath</name></name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert numGroups to long int --- but 'ware overflow! */</comment>
	<expr_stmt><expr><name>numGroups</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>LONG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_recursive_union</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
								<argument><expr><name>leftplan</name></expr></argument>,
								<argument><expr><name>rightplan</name></expr></argument>,
								<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>wtParam</name></name></expr></argument>,
								<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>distinctList</name></name></expr></argument>,
								<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_lockrows_plan
 *
 *	  Create a LockRows plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type>
<name>create_lockrows_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>LockRowsPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockRows</name>   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<comment type="block">/* LockRows doesn't project, so tlist requirements pass through */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_lockrows</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>epqParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_modifytable_plan
 *	  Create a ModifyTable plan for 'best_path'.
 *
 *	  Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type>
<name>create_modifytable_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>subpaths</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>subroots</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>is_split_updates</name></decl>;</decl_stmt>

	<comment type="block">/* Build the plan for each input path */</comment>
	<macro><name>forthree</name><argument_list>(<argument>subpaths</argument>, <argument>best_path-&gt;subpaths</argument>,
			 <argument>subroots</argument>, <argument>best_path-&gt;subroots</argument>,
			 <argument>is_split_updates</argument>, <argument>best_path-&gt;is_split_updates</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subroots</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_split_update</name> <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>is_split_updates</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>save_curSlice</name> <init>= <expr><name><name>subroot</name><operator>-&gt;</operator><name>curSlice</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>curSlice</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name></expr>;</expr_stmt>

		<comment type="block">/* Try the Single-Row-Insert optimization first. */</comment>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>cdbpathtoplan_create_sri_plan</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In an inherited UPDATE/DELETE, reference the per-child modified
		 * subroot while creating Plans from Paths for the child rel.  This is
		 * a kluge, but otherwise it's too hard to ensure that Plan creation
		 * functions (particularly in FDWs) don't depend on the contents of
		 * "root" matching what they saw at Path creation time.  The main
		 * downside is that creation functions for Plans that might appear
		 * below a ModifyTable cannot expect to modify the contents of "root"
		 * and have it "stick" for subsequent processing such as setrefs.c.
		 * That's not great, but it seems better than the alternative.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subplan</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Transfer resname/resjunk labeling, too, to keep executor happy.
			 * But not if it's a Split Update. A Split Update contains an extra
			 * DMLActionExpr column in its target list, so it doesn't match
			 * subroot-&gt;processed_tlist. The code to create the Split Update node
			 * takes care to label junk columns correctly, instead.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_split_update</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>apply_tlist_labeling</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>curSlice</name></name> <operator>=</operator> <name>save_curSlice</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_modifytable</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>rootRelation</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>partColsUpdated</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>,
							<argument><expr><name>subplans</name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>is_split_updates</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>onconflict</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>epqParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GpPolicyType</name></type> <name>policyType</name> <init>= <expr><name>POLICYTYPE_ENTRY</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isfirst</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>plan-&gt;resultRelations</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name> <init>= <expr><call><name>GpPolicyFetch</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We cannot update tables on segments and on the entry DB in the
			 * same process.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>isfirst</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>policyType</name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name>policyType</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ModifyTable mixes distributed and entry-only tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>policyType</name> <operator>!=</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>isfirst</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator>
						<call><name>Max</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>isfirst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_limit_plan
 *
 *	  Create a Limit plan for 'best_path' and (recursively) plans
 *	  for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Limit</name> <modifier>*</modifier></type>
<name>create_limit_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>LimitPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Limit</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<comment type="block">/* Limit doesn't project, so tlist requirements pass through */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_limit</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>,
					  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
					  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * create_motion_plan
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>create_motion_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>subpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>save_curOuterRels</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_curOuterParams</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>before_numMotions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>save_curSlice</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>sendSlice</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * singleQE--&gt;entry:  Elide the motion.  The subplan will run in the same
	 * process with its parent: either the qDisp (if it is a top slice) or a
	 * singleton gang on the entry db (otherwise).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Push the MotionPath's locus down onto subpath. */</comment>
		<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>subplan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remember old value of 'numMotions', before recursing. By comparing
	 * the old value with the new value after the call returns, we know
	 * if there were any Motions in the subtree.
	 */</comment>
	<expr_stmt><expr><name>before_numMotions</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>numMotions</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up a new slice struct, to represent the sending slice.
	 */</comment>
	<expr_stmt><expr><name>sendSlice</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_PRIMARY_READER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name> <operator>=</operator> <name>sendSlice</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name> <operator>=</operator> <name>save_curSlice</name></expr>;</expr_stmt>

	<comment type="block">/* Check we successfully assigned all NestLoopParams to plan nodes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to assign all NestLoopParams to plan nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Reset plan_params to ensure param IDs used for nestloop params are not
	 * re-used later
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Elide explicit motion, if the subplan doesn't contain any motions.
	 *
	 * The idea is that if an Explicit Motion has no Motions underneath it,
	 * then the row to update must originate from the same segment, and no
	 * Motion is needed. This is quite conservative, we could elide the motion
	 * even if there are Motions, as long as they are not between the scan
	 * on the target table and the ModifyTable.
	 *
	 * A SplitUpdate also computes the target segment ID, based on other columns,
	 * so we treat it the same as a Motion node for this purpose.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>numMotions</name></name> <operator>==</operator> <name>before_numMotions</name> <operator>&amp;&amp;</operator> <name><name>path</name><operator>-&gt;</operator><name>is_explicit_motion</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name> <operator>=</operator> <name>save_curOuterRels</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Combine any new direct dispatch information from the subplan to
		 * the parent slice.
		 */</comment>
		<expr_stmt><expr><call><name>MergeDirectDispatchCalculationInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>directDispatch</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>sendSlice</name><operator>-&gt;</operator><name>directDispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>subplan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>locustype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CdbLocusType_Entry</name></expr>:</case>
			<comment type="block">/* cannot motion from Entry DB */</comment>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_ENTRYDB_READER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CdbLocusType_SingleQE</name></expr>:</case>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_SINGLETON_READER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <name>gp_session_id</name> <operator>%</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CdbLocusType_General</name></expr>:</case>
			<comment type="block">/*  */</comment>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_SINGLETON_READER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <name>gp_session_id</name> <operator>%</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CdbLocusType_SegmentGeneral</name></expr>:</case>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_SINGLETON_READER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <name>gp_session_id</name> <operator>%</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CdbLocusType_Replicated</name></expr>:</case>
			<comment type="line">// is probably writer, set already</comment>
			<comment type="line">//sendSlice-&gt;gangType == GANGTYPE_PRIMARY_READER;</comment>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CdbLocusType_OuterQuery</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected Motion requested from OuterQuery locus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CdbLocusType_Hashed</name></expr>:</case>
		<case>case <expr><name>CdbLocusType_HashedOJ</name></expr>:</case>
		<case>case <expr><name>CdbLocusType_Strewn</name></expr>:</case>
			<comment type="line">// might be writer, set already</comment>
			<comment type="line">//sendSlice-&gt;gangType == GANGTYPE_PRIMARY_READER;</comment>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown locus type %d"</literal></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>locustype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* Add motion operator. */</comment>
	<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>cdbpathtoplan_create_motion_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>senderSliceInfo</name></name> <operator>=</operator> <name>sendSlice</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>locustype</name></name> <operator>==</operator> <name>CdbLocusType_Replicated</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <name>MOTIONTYPE_GATHER_SINGLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* The topmost Plan in the sender slice must have 'flow' set correctly. */</comment>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <call><name>cdbpathtoplan_create_flow</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>motion</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name> <operator>=</operator> <name>save_curOuterRels</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <name>save_curOuterParams</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's currently not allowed to direct-dispatch a slice that has a
	 * Motion that sends tuples to it. It would be possible in principle,
	 * but the interconnect initialization code gets confused. Give the
	 * direct dispatch machinery a chance to react to this Motion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>gp_enable_direct_dispatch</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DirectDispatchUpdateContentIdsFromPlan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>motion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>motion</name></expr>;</return>
</block_content>}</block></function>	<comment type="block">/* create_motion_plan */</comment>

<comment type="block">/*
 * create_splitupdate_plan
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_splitupdate_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SplitUpdatePath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>subpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SplitUpdate</name> <modifier>*</modifier></type><name>splitupdate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>resultDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>cdbpolicy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attrIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lastresno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>hashFuncs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>resultRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cdbpolicy</name> <operator>=</operator> <name><name>resultRel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Transfer resname/resjunk labeling, too, to keep executor happy */</comment>
	<expr_stmt><expr><call><name>apply_tlist_labeling</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>splitupdate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SplitUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt> <comment type="block">/* filled in below */</comment>
	<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the insertColIdx and deleteColIdx arrays, to indicate how the
	 * inputs are mapped to the output tuples, for the DELETE and INSERT
	 * actions.
	 *
	 * For the DELETE rows, we only need the 'gp_segment_id' and 'ctid'
	 * junk columns, so we fill deleteColIdx with -1. The gp_segment_id
	 * column is used to indicate the target segment. In other words,
	 * there should be an Explicit Motion on top of the Split Update node.
	 * NOTE: ORCA uses SplitUpdate differently. It puts a Redistribute
	 * Motion on top of the SplitUpdate, and fills in the distribution key
	 * columns on DELETE rows with the old values. The Redistribute Motion
	 * then computes the target segment. So deleteColIdx is needed for
	 * ORCA, but we don't use it here.
	 */</comment>
	<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attrIdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrIdx</name> <operator>&lt;=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>attrIdx</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name>			<modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type>	<name>attr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>&amp;</operator><name><name>resultDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attrIdx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>insertColIdx</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>insertColIdx</name></name></expr></argument>, <argument><expr><name>attrIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>deleteColIdx</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>deleteColIdx</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>lastresno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy all junk attributes. */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newtle</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>newtle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
								 <argument><expr><operator>++</operator><name>lastresno</name></expr></argument>,
								 <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
								 <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>newtle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										   <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DMLActionExpr</name></expr></argument>)</argument_list></call></expr></argument>,
														   <argument><expr><operator>++</operator><name>lastresno</name></expr></argument>,
														   <argument><expr><literal type="string">"DMLAction"</literal></expr></argument>,
														   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the right hash functions for the hash expressions */</comment>
	<expr_stmt><expr><name>hashFuncs</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>cdbpolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbpolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>cdbpolicy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typeoid</name> <init>= <expr><name><name>resultDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>atttypid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name><name>cdbpolicy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hashFuncs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>cdb_hashproc_in_opfamily</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>numHashAttrs</name></name> <operator>=</operator> <name><name>cdbpolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>hashAttnos</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>cdbpolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>hashAttnos</name></name></expr></argument>, <argument><expr><name><name>cdbpolicy</name><operator>-&gt;</operator><name>attrs</name></name></expr></argument>, <argument><expr><name><name>cdbpolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>hashFuncs</name></name> <operator>=</operator> <name>hashFuncs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdate</name><operator>-&gt;</operator><name>numHashSegments</name></name> <operator>=</operator> <name><name>cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * A SplitUpdate also computes the target segment ID, based on other columns,
	 * so we treat it the same as a Motion node for this purpose.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>numMotions</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>splitupdate</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	BASE-RELATION SCAN METHODS
 *
 *****************************************************************************/</comment>


<comment type="block">/*
 * create_seqscan_plan
 *	 Returns a seqscan plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type>
<name>create_seqscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SeqScan</name>    <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* it should be a base rel... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_seqscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							 <argument><expr><name>scan_clauses</name></expr></argument>,
							 <argument><expr><name>scan_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_samplescan_plan
 *	 Returns a samplescan plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type>
<name>create_samplescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SampleScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name></decl>;</decl_stmt>

	<comment type="block">/* it should be a base rel with a tablesample clause... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tsc</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tsc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tsc</name> <operator>=</operator> <operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_samplescan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
								<argument><expr><name>scan_clauses</name></expr></argument>,
								<argument><expr><name>scan_relid</name></expr></argument>,
								<argument><expr><name>tsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_indexscan_plan
 *	  Returns an indexscan plan for the base relation scanned by 'best_path'
 *	  with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 *
 * We use this for both plain IndexScans and IndexOnlyScans, because the
 * qual preprocessing work is the same for both.  Note that the caller tells
 * us which to build --- we don't look at best_path-&gt;path.pathtype, because
 * create_bitmap_subplan needs to be able to override the prior decision.
 */</comment>
<function><type><specifier>static</specifier> <name>Scan</name> <modifier>*</modifier></type>
<name>create_indexscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>indexonly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Scan</name>	   <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexclauses</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>indexclauses</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexorderbys</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>indexorderbys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>baserelid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>indexoid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qpqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stripped_indexquals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fixed_indexquals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fixed_indexorderbys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexorderbyops</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* it should be a base rel... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>baserelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract the index qual expressions (stripped of RestrictInfos) from the
	 * IndexClauses list, and prepare a copy with index Vars substituted for
	 * table Vars.  (This step also does replace_nestloop_params on the
	 * fixed_indexquals.)
	 */</comment>
	<expr_stmt><expr><call><name>fix_indexqual_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>stripped_indexquals</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>fixed_indexquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise fix up index attr references in the ORDER BY expressions.
	 */</comment>
	<expr_stmt><expr><name>fixed_indexorderbys</name> <operator>=</operator> <call><name>fix_indexorderby_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The qpqual list must contain all restrictions not automatically handled
	 * by the index, other than pseudoconstant clauses which will be handled
	 * by a separate gating plan node.  All the predicates in the indexquals
	 * will be checked (either by the index itself, or by nodeIndexscan.c),
	 * but if there are any "special" operators involved then they must be
	 * included in qpqual.  The upshot is that qpqual must contain
	 * scan_clauses minus whatever appears in indexquals.
	 *
	 * is_redundant_with_indexclauses() detects cases where a scan clause is
	 * present in the indexclauses list or is generated from the same
	 * EquivalenceClass as some indexclause, and is therefore redundant with
	 * it, though not equal.  (The latter happens when indxpath.c prefers a
	 * different derived equality than what generate_join_implied_equalities
	 * picked for a parameterized scan's ppi_clauses.)  Note that it will not
	 * match to lossy index clauses, which is critical because we have to
	 * include the original clause in qpqual in that case.
	 *
	 * In some situations (particularly with OR'd index conditions) we may
	 * have scan_clauses that are not equal to, but are logically implied by,
	 * the index quals; so we also try a predicate_implied_by() check to see
	 * if we can discard quals that way.  (predicate_implied_by assumes its
	 * first input contains only immutable functions, so we have to check
	 * that.)
	 *
	 * Note: if you change this bit of code you should also look at
	 * extract_nonindex_conditions() in costsize.c.
	 */</comment>
	<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>scan_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* we may drop pseudoconstants here */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_redundant_with_indexclauses</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>indexclauses</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* dup or derived from same EquivalenceClass */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>predicate_implied_by</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stripped_indexquals</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* provably implied by indexquals */</comment>
		<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>qpqual</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>qpqual</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to replace any outer-relation variables with nestloop params in
	 * the indexqualorig, qpqual, and indexorderbyorig expressions.  A bit
	 * annoying to have to do this separately from the processing in
	 * fix_indexqual_references --- rethink this when generalizing the inner
	 * indexscan support.  But note we can't really do this earlier because
	 * it'd break the comparisons to predicates above ... (or would it?  Those
	 * wouldn't have outer refs)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stripped_indexquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stripped_indexquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexorderbys</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>indexorderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there are ORDER BY expressions, look up the sort operators for their
	 * result datatypes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>indexorderbys</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pathkeyCell</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>exprCell</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * PathKey contains OID of the btree opfamily we're sorting by, but
		 * that's not quite enough because we need the expression's datatype
		 * to look up the sort operator in the operator family.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexorderbys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>pathkeyCell</argument>, <argument>best_path-&gt;path.pathkeys</argument>, <argument>exprCell</argument>, <argument>indexorderbys</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pathkeyCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>exprCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>exprtype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>sortop</name></decl>;</decl_stmt>

			<comment type="block">/* Get sort operator from opfamily */</comment>
			<expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
										 <argument><expr><name>exprtype</name></expr></argument>,
										 <argument><expr><name>exprtype</name></expr></argument>,
										 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
					 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>, <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>indexorderbyops</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>indexorderbyops</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Finally ready to build the plan node */</comment>
	<if_stmt><if>if <condition>(<expr><name>indexonly</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <call><name>make_indexonlyscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
												<argument><expr><name>qpqual</name></expr></argument>,
												<argument><expr><name>baserelid</name></expr></argument>,
												<argument><expr><name>indexoid</name></expr></argument>,
												<argument><expr><name>fixed_indexquals</name></expr></argument>,
												<argument><expr><name>stripped_indexquals</name></expr></argument>,
												<argument><expr><name>fixed_indexorderbys</name></expr></argument>,
												<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>,
												<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>indexscandir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <call><name>make_indexscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
											<argument><expr><name>qpqual</name></expr></argument>,
											<argument><expr><name>baserelid</name></expr></argument>,
											<argument><expr><name>indexoid</name></expr></argument>,
											<argument><expr><name>fixed_indexquals</name></expr></argument>,
											<argument><expr><name>stripped_indexquals</name></expr></argument>,
											<argument><expr><name>fixed_indexorderbys</name></expr></argument>,
											<argument><expr><name>indexorderbys</name></expr></argument>,
											<argument><expr><name>indexorderbyops</name></expr></argument>,
											<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>indexscandir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_bitmap_scan_plan
 *	  Returns a bitmap scan plan for the base relation scanned by 'best_path'
 *	  with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type>
<name>create_bitmap_scan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>baserelid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>bitmapqualplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>bitmapqualorig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexquals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexECs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qpqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>

	<comment type="block">/* it should be a base rel... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>baserelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process the bitmapqual tree into a Plan tree and qual lists */</comment>
	<expr_stmt><expr><name>bitmapqualplan</name> <operator>=</operator> <call><name>create_bitmap_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>bitmapqual</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>bitmapqualorig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexquals</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>indexECs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* GPDB_12_MERGE_FEATURE_NOT_SUPPORTED: the parallel StreamBitmap scan is not implemented */</comment>
	<comment type="block">/*
	 * if (best_path-&gt;path.parallel_aware)
	 *     bitmap_subplan_mark_shared(bitmapqualplan);
	 */</comment>

	<comment type="block">/*
	 * The qpqual list must contain all restrictions not automatically handled
	 * by the index, other than pseudoconstant clauses which will be handled
	 * by a separate gating plan node.  All the predicates in the indexquals
	 * will be checked (either by the index itself, or by
	 * nodeBitmapHeapscan.c), but if there are any "special" operators
	 * involved then they must be added to qpqual.  The upshot is that qpqual
	 * must contain scan_clauses minus whatever appears in indexquals.
	 *
	 * This loop is similar to the comparable code in create_indexscan_plan(),
	 * but with some differences because it has to compare the scan clauses to
	 * stripped (no RestrictInfos) indexquals.  See comments there for more
	 * info.
	 *
	 * In normal cases simple equal() checks will be enough to spot duplicate
	 * clauses, so we try that first.  We next see if the scan clause is
	 * redundant with any top-level indexqual by virtue of being generated
	 * from the same EC.  After that, try predicate_implied_by().
	 *
	 * Unlike create_indexscan_plan(), the predicate_implied_by() test here is
	 * useful for getting rid of qpquals that are implied by index predicates,
	 * because the predicate conditions are included in the "indexquals"
	 * returned by create_bitmap_subplan().  Bitmap scans have to do it that
	 * way because predicate conditions need to be rechecked if the scan
	 * becomes lossy, so they have to be included in bitmapqualorig.
	 */</comment>
	<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>scan_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* we may drop pseudoconstants here */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>indexquals</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* simple duplicate */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name> <operator>&amp;&amp;</operator> <call><name>list_member_ptr</name><argument_list>(<argument><expr><name>indexECs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* derived from same EquivalenceClass */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>predicate_implied_by</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indexquals</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* provably implied by indexquals */</comment>
		<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>qpqual</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>qpqual</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When dealing with special operators, we will at this point have
	 * duplicate clauses in qpqual and bitmapqualorig.  We may as well drop
	 * 'em from bitmapqualorig, since there's no point in making the tests
	 * twice.
	 */</comment>
	<expr_stmt><expr><name>bitmapqualorig</name> <operator>=</operator> <call><name>list_difference_ptr</name><argument_list>(<argument><expr><name>bitmapqualorig</name></expr></argument>, <argument><expr><name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to replace any outer-relation variables with nestloop params in
	 * the qpqual and bitmapqualorig expressions.  (This was already done for
	 * expressions attached to plan nodes in the bitmapqualplan tree.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmapqualorig</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>bitmapqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Finally ready to build the plan node */</comment>
	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_bitmap_heapscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
									 <argument><expr><name>qpqual</name></expr></argument>,
									 <argument><expr><name>bitmapqualplan</name></expr></argument>,
									 <argument><expr><name>bitmapqualorig</name></expr></argument>,
									 <argument><expr><name>baserelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a bitmapqual tree, generate the Plan tree that implements it
 *
 * As byproducts, we also return in *qual and *indexqual the qual lists
 * (in implicit-AND form, without RestrictInfos) describing the original index
 * conditions and the generated indexqual conditions.  (These are the same in
 * simple cases, but when special index operators are involved, the former
 * list includes the special conditions while the latter includes the actual
 * indexable conditions derived from them.)  Both lists include partial-index
 * predicates, because we have to recheck predicates as well as index
 * conditions if the bitmap scan becomes lossy.
 *
 * In addition, we return a list of EquivalenceClass pointers for all the
 * top-level indexquals that were possibly-redundantly derived from ECs.
 * This allows removal of scan_clauses that are redundant with such quals.
 * (We do not attempt to detect such redundancies for quals that are within
 * OR subtrees.  This could be done in a less hacky way if we returned the
 * indexquals in RestrictInfo form, but that would be slower and still pretty
 * messy, since we'd have to build new RestrictInfos in many cases.)
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_bitmap_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexqual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexECs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>BitmapAndPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BitmapAndPath</name> <modifier>*</modifier></type><name>apath</name> <init>= <expr><operator>(</operator><name>BitmapAndPath</name> <operator>*</operator><operator>)</operator> <name>bitmapqual</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subindexquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subindexECs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>numsegments</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>cdbpolicy</name></name> <operator>&amp;&amp;</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>cdbpolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * There may well be redundant quals among the subplans, since a
		 * top-level WHERE qual might have gotten used to form several
		 * different index quals.  We don't try exceedingly hard to eliminate
		 * redundancies, but we do eliminate obvious duplicates by using
		 * list_concat_unique.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>apath-&gt;bitmapquals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subqual</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subindexqual</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subindexEC</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_bitmap_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>subqual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subindexqual</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>subindexEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subquals</name> <operator>=</operator> <call><name>list_concat_unique</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>, <argument><expr><name>subqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subindexquals</name> <operator>=</operator> <call><name>list_concat_unique</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>, <argument><expr><name>subindexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Duplicates in indexECs aren't worth getting rid of */</comment>
			<expr_stmt><expr><name>subindexECs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subindexECs</name></expr></argument>, <argument><expr><name>subindexEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_bitmap_and</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>bitmapselectivity</name></name> <operator>*</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* meaningless */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <name>subquals</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <name>subindexquals</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexECs</name> <operator>=</operator> <name>subindexECs</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>BitmapOrPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BitmapOrPath</name> <modifier>*</modifier></type><name>opath</name> <init>= <expr><operator>(</operator><name>BitmapOrPath</name> <operator>*</operator><operator>)</operator> <name>bitmapqual</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subindexquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>const_true_subqual</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>const_true_subindexqual</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Here, we only detect qual-free subplans.  A qual-free subplan would
		 * cause us to generate "... OR true ..."  which we may as well reduce
		 * to just "true".  We do not try to eliminate redundant subclauses
		 * because (a) it's not as likely as in the AND case, and (b) we might
		 * well be working with hundreds or even thousands of OR conditions,
		 * perhaps from a long IN list.  The performance of list_append_unique
		 * would be unacceptable.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>opath-&gt;bitmapquals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subqual</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subindexqual</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subindexEC</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_bitmap_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>subqual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subindexqual</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>subindexEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>subqual</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>const_true_subqual</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name>const_true_subqual</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>subquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>,
								   <argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>subqual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>subindexqual</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>const_true_subindexqual</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name>const_true_subindexqual</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>subindexquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>,
										<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>subindexqual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * In the presence of ScalarArrayOpExpr quals, we might have built
		 * BitmapOrPaths with just one subpath; don't add an OR step.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>numsegments</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>cdbpolicy</name></name> <operator>&amp;&amp;</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>cdbpolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_bitmap_or</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator>
				<call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>opath</name><operator>-&gt;</operator><name>bitmapselectivity</name></name> <operator>*</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* meaningless */</comment>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If there were constant-TRUE subquals, the OR reduces to constant
		 * TRUE.  Also, avoid generating one-element ORs, which could happen
		 * due to redundancy elimination or ScalarArrayOpExpr quals.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>const_true_subqual</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <name>subquals</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>const_true_subindexqual</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <name>subindexquals</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexECs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>ipath</name> <init>= <expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>bitmapqual</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>iscan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subquals</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subindexquals</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subindexECs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>numsegments</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ipath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>cdbpolicy</name></name> <operator>&amp;&amp;</operator> <name><name>ipath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>cdbpolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <name><name>ipath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Use the regular indexscan plan build machinery... */</comment>
		<expr_stmt><expr><name>iscan</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>IndexScan</name></expr></argument>,
						 <argument><expr><call><name>create_indexscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ipath</name></expr></argument>,
											   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* then convert to a bitmap indexscan */</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_bitmap_indexscan</name><argument_list>(<argument><expr><name><name>iscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>,
											  <argument><expr><name><name>iscan</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>,
											  <argument><expr><name><name>iscan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>,
											  <argument><expr><name><name>iscan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* and set its cost/width fields appropriately */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>ipath</name><operator>-&gt;</operator><name>indextotalcost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>ipath</name><operator>-&gt;</operator><name>indexselectivity</name></name> <operator>*</operator> <name><name>ipath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* meaningless */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>ipath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
		<comment type="block">/* Extract original index clauses, actual index quals, relevant ECs */</comment>
		<expr_stmt><expr><name>subquals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>subindexquals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>subindexECs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>ipath-&gt;indexclauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>iclause</name> <init>= <expr><operator>(</operator><name>IndexClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><name><name>iclause</name><operator>-&gt;</operator><name>rinfo</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subindexquals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>,
										<argument><expr><call><name>get_actual_clauses</name><argument_list>(<argument><expr><name><name>iclause</name><operator>-&gt;</operator><name>indexquals</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>subindexECs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subindexECs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<comment type="block">/* We can add any index predicate conditions, too */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>ipath-&gt;indexinfo-&gt;indpred</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>pred</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We know that the index predicate must have been implied by the
			 * query condition as a whole, but it may or may not be implied by
			 * the conditions that got pushed into the bitmapqual.  Avoid
			 * generating redundant conditions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_implied_by</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subquals</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>subquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>, <argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subindexquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>, <argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <name>subquals</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <name>subindexquals</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexECs</name> <operator>=</operator> <name>subindexECs</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>gp_enable_direct_dispatch</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DirectDispatchUpdateContentIdsFromPlan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tidscan_plan
 *	 Returns a tidscan plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type>
<name>create_tidscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>TidPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TidScan</name>    <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tidquals</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>tidquals</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* it should be a base rel... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The qpqual list must contain all restrictions not enforced by the
	 * tidquals list.  Since tidquals has OR semantics, we have to be careful
	 * about matching it up to scan_clauses.  It's convenient to handle the
	 * single-tidqual case separately from the multiple-tidqual case.  In the
	 * single-tidqual case, we look through the scan_clauses while they are
	 * still in RestrictInfo form, and drop any that are redundant with the
	 * tidqual.
	 *
	 * In normal cases simple pointer equality checks will be enough to spot
	 * duplicate RestrictInfos, so we try that first.
	 *
	 * Another common case is that a scan_clauses entry is generated from the
	 * same EquivalenceClass as some tidqual, and is therefore redundant with
	 * it, though not equal.
	 *
	 * Unlike indexpaths, we don't bother with predicate_implied_by(); the
	 * number of cases where it could win are pretty small.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qpqual</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>scan_clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* we may drop pseudoconstants here */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* simple duplicate */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>is_redundant_derived_clause</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* derived from same EquivalenceClass */</comment>
			<expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>qpqual</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo lists to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>tidquals</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have multiple tidquals, it's more convenient to remove duplicate
	 * scan_clauses after stripping the RestrictInfos.  In this situation,
	 * because the tidquals represent OR sub-clauses, they could not have come
	 * from EquivalenceClasses so we don't have to worry about matching up
	 * non-identical clauses.  On the other hand, because tidpath.c will have
	 * extracted those sub-clauses from some OR clause and built its own list,
	 * we will certainly not have pointer equality to any scan clause.  So
	 * convert the tidquals list to an explicit OR clause and see if we can
	 * match it via equal() to any scan clause.
	 *
	 * In the case of CURRENT OF, however, we do want the CurrentOfExpr to
	 * reside in both the tidlist and the qual, as CurrentOfExpr is effectively
	 * a ctid, gp_segment_id, and tableoid qual. Constant folding will
	 * finish up this qual rewriting to ensure what we dispatch is a sane interpretation
	 * of CURRENT OF behavior.
	 */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>list_difference</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>,
                                           <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tidquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_tidscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							 <argument><expr><name>scan_clauses</name></expr></argument>,
							 <argument><expr><name>scan_relid</name></expr></argument>,
							 <argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_subqueryscan_plan
 *	 Returns a subqueryscan plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type>
<name>create_subqueryscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<comment type="block">/* it should be a subquery base rel... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recursively create Plan from Path for subquery.  Since we are entering
	 * a different planner context (subroot), recurse to create_plan not
	 * create_plan_recurse.
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>numMotions</name></name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>subroot</name><operator>-&gt;</operator><name>numMotions</name></name></expr>;</expr_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>process_subquery_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subplan_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_subqueryscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
								  <argument><expr><name>scan_clauses</name></expr></argument>,
								  <argument><expr><name>scan_relid</name></expr></argument>,
								  <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_functionscan_plan
 *	 Returns a functionscan plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type>
<name>create_functionscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>functions</name></decl>;</decl_stmt>

	<comment type="block">/* it should be a function base rel... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>functions</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr>;</expr_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The function expressions could contain nestloop params, too */</comment>
		<expr_stmt><expr><name>functions</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_functionscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
								  <argument><expr><name>functions</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tablefunction_plan
 *	 Returns a TableFunction plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>TableFunctionScan</name> <modifier>*</modifier></type>
<name>create_tablefunction_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                          <parameter><decl><type><name>TableFunctionScanPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TableFunctionScan</name> <modifier>*</modifier></type><name>tablefunc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type> <name>scan_relid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtf</name></decl>;</decl_stmt>

    <comment type="block">/* it should be a function base rel... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rtf</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Recursively create Plan from Path for subquery.  Since we are entering
     * a different planner context (subroot), recurse to create_plan not
     * create_plan_recurse.
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
                <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>process_subquery_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                         <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subplan_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create the TableFunctionScan plan */</comment>
    <expr_stmt><expr><name>tablefunc</name> <operator>=</operator> <call><name>make_tablefunction</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>rtf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Cost is determined largely by the cost of the underlying subplan */</comment>
    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tablefunc</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>tablefunc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tablefuncscan_plan
 *	 Returns a tablefuncscan plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type>
<name>create_tablefuncscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableFuncScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>tablefunc</name></decl>;</decl_stmt>

	<comment type="block">/* it should be a function base rel... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tablefunc</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr>;</expr_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The function expressions could contain nestloop params, too */</comment>
		<expr_stmt><expr><name>tablefunc</name> <operator>=</operator> <operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_tablefuncscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
								   <argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_valuesscan_plan
 *	 Returns a valuesscan plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type>
<name>create_valuesscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ValuesScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>values_lists</name></decl>;</decl_stmt>

	<comment type="block">/* it should be a values base rel... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>values_lists</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr>;</expr_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The values lists could contain nestloop params, too */</comment>
		<expr_stmt><expr><name>values_lists</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_valuesscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
								<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_ctescan_plan
 *	 Returns a ctescan plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name><modifier>*</modifier></type>
<name>create_ctescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CtePlanInfo</name> <modifier>*</modifier></type><name>cteplaninfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>planinfo_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>cteroot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the referenced CTE, and locate the SubPlan previously made for it.
	 */</comment>
	<expr_stmt><expr><name>levelsup</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>levelsup</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name><name>cteroot</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cteroot</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Note: cte_plan_ids can be shorter than cteList, if we are still working
	 * on planning the CTEs (ie, this is a side-reference from another CTE).
	 * So we mustn't use forboth here.
	 */</comment>
	<expr_stmt><expr><name>ndx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cteroot-&gt;parse-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ndx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In PostgreSQL, we use the index to look up the plan ID in the
	 * cteroot-&gt;cte_plan_ids list. In GPDB, CTE plans work differently, and
	 * we look up the CtePlanInfo struct in the list_cteplaninfo instead.
	 */</comment>
	<expr_stmt><expr><name>planinfo_id</name> <operator>=</operator> <name>ndx</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>planinfo_id</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>planinfo_id</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cteroot</name><operator>-&gt;</operator><name>list_cteplaninfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find plan for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cteroot</name><operator>-&gt;</operator><name>list_cteplaninfo</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>planinfo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cteplaninfo</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>cteroot</name><operator>-&gt;</operator><name>list_cteplaninfo</name></name></expr></argument>, <argument><expr><name>planinfo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this CTE is not shared, then we have a pre-made sub-Path in the CtePath.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CtePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Recursively create Plan from Path for subquery.  Since we are entering
		 * a different planner context (subroot), recurse to create_plan not
		 * create_plan_recurse.
		 */</comment>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>CtePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This is a shared CTE. On first call, turn the sub-Path into a Plan, and store
		 * it in CtePlanInfo.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cteplaninfo</name><operator>-&gt;</operator><name>shared_plan</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>sub_final_rel</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sub_final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name><name>sub_final_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cteplaninfo</name><operator>-&gt;</operator><name>shared_plan</name></name> <operator>=</operator> <call><name>prepare_plan_for_sharing</name><argument_list>(<argument><expr><name>cteroot</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Wrap the common Plan tree in a ShareInputScan node */</comment>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>share_prepared_plan</name><argument_list>(<argument><expr><name>cteroot</name></expr></argument>, <argument><expr><name><name>cteplaninfo</name><operator>-&gt;</operator><name>shared_plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_subqueryscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
										   <argument><expr><name>scan_clauses</name></expr></argument>,
										   <argument><expr><name>scan_relid</name></expr></argument>,
										   <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>scan_plan</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_namedtuplestorescan_plan
 *	 Returns a tuplestorescan plan for the base relation scanned by
 *	'best_path' with restriction clauses 'scan_clauses' and targetlist
 *	'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type>
<name>create_namedtuplestorescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_NAMEDTUPLESTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_namedtuplestorescan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
										 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>enrname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_resultscan_plan
 *	 Returns a Result plan for the RTE_RESULT base relation scanned by
 *	'best_path' with restriction clauses 'scan_clauses' and targetlist
 *	'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type>
<name>create_resultscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><name>rte</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_worktablescan_plan
 *	 Returns a worktablescan plan for the base relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type>
<name>create_worktablescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkTableScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>cteroot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to find the worktable param ID, which is in the plan level
	 * that's processing the recursive UNION, which is one level *below* where
	 * the CTE comes from.
	 */</comment>
	<expr_stmt><expr><name>levelsup</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>levelsup</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>levelsup</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>levelsup</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name><name>cteroot</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cteroot</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name><name>cteroot</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find param ID for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Sort clauses into best execution order */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_worktablescan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
								   <argument><expr><name><name>cteroot</name><operator>-&gt;</operator><name>wt_param_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_foreignscan_plan
 *	 Returns a foreignscan plan for the relation scanned by 'best_path'
 *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type>
<name>create_foreignscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rel_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outer_plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* transform the child path if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>fdw_outerpath</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>fdw_outerpath</name></name></expr></argument>,
										 <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're scanning a base relation, fetch its OID.  (Irrelevant if
	 * scanning a join relation.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel_oid</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Sort clauses into best execution order.  We do this first since the FDW
	 * might have more info than we do and wish to adjust the ordering.
	 */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let the FDW perform its processing on the restriction clauses and
	 * generate the plan node.  Note that the FDW might remove restriction
	 * clauses that it intends to execute remotely, or even add more (if it
	 * has selected some join clauses for remote use but also wants them
	 * rechecked locally).
	 */</comment>
	<expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignPlan</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rel_oid</name></expr></argument>,
												<argument><expr><name>best_path</name></expr></argument>,
												<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>,
												<argument><expr><name>outer_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy cost data from Path to Plan; no need to make FDW do this */</comment>
	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy foreign server OID; likewise, no need to make FDW do this */</comment>
	<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fs_server</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise, copy the relids that are represented by this foreign scan. An
	 * upper rel doesn't have relids set, but it covers all the base relations
	 * participating in the underlying scan, so use root's all_baserels.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_UPPER_REL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fs_relids</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fs_relids</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If this is a foreign join, and to make it valid to push down we had to
	 * assume that the current user is the same as some user explicitly named
	 * in the query, mark the finished plan as depending on the current user.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Replace any outer-relation variables with nestloop params in the qual,
	 * fdw_exprs and fdw_recheck_quals expressions.  We do this last so that
	 * the FDW doesn't have to be involved.  (Note that parts of fdw_exprs or
	 * fdw_recheck_quals could have come from join clauses, so doing this
	 * beforehand on the scan_clauses wouldn't work.)  We assume
	 * fdw_scan_tlist contains no such variables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fdw_exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>scan_plan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>scan_plan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If rel is a base relation, detect whether any system columns are
	 * requested from the rel.  (If rel is a join relation, rel-&gt;relid will be
	 * 0, but there can be no Var with relid 0 in the rel's targetlist or the
	 * restriction clauses, so we skip this in that case.  Note that any such
	 * columns in base relations that were joined are assumed to be contained
	 * in fdw_scan_tlist.)	This is a bit of a kluge and might go away
	 * someday, so we intentionally leave it out of the API presented to FDWs.
	 */</comment>
	<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First, examine all the attributes needed for joins or final output.
		 * Note: we must look at rel's targetlist, not the attr_needed data,
		 * because attr_needed isn't computed for inheritance child rels.
		 */</comment>
		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add all the attributes used by restriction clauses. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Now, are any system columns requested from rel? */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>remove_isnotfalse_expr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>bt</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bt</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_FALSE</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name><name>bt</name><operator>-&gt;</operator><name>arg</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * remove_isnotfalse
 *	  Given a list of joinclauses, extract the bare clauses, removing any IS_NOT_FALSE
 *	  additions. The original data structure is not touched; a modified list is returned
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>remove_isnotfalse</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>t_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Expr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>remove_isnotfalse_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>t_list</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>rclause</name> <init>= <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>rclause</name> <operator>=</operator> <call><name>remove_isnotfalse_expr</name><argument_list>(<argument><expr><name>rclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>t_list</name></expr></argument>, <argument><expr><name>rclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else
		<block>{<block_content>
			<expr_stmt><expr><name>t_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>t_list</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>t_list</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * create_customscan_plan
 *
 * Transform a CustomPath into a Plan.
 */</comment>
<function><type><specifier>static</specifier> <name>CustomScan</name> <modifier>*</modifier></type>
<name>create_customscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>custom_plans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Recursively transform child paths. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>best_path-&gt;custom_paths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>custom_plans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Sort clauses into the best execution order, although custom-scan
	 * provider can reorder them again.
	 */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invoke custom plan provider to create the Plan node represented by the
	 * CustomPath.
	 */</comment>
	<expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>,
					 <argument><expr><call><name><name>best_path</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>PlanCustomPath</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><name>rel</name></expr></argument>,
														<argument><expr><name>best_path</name></expr></argument>,
														<argument><expr><name>tlist</name></expr></argument>,
														<argument><expr><name>scan_clauses</name></expr></argument>,
														<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy cost data from Path to Plan; no need to make custom-plan providers
	 * do this
	 */</comment>
	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Likewise, copy the relids that are represented by this custom scan */</comment>
	<expr_stmt><expr><name><name>cplan</name><operator>-&gt;</operator><name>custom_relids</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace any outer-relation variables with nestloop params in the qual
	 * and custom_exprs expressions.  We do this last so that the custom-plan
	 * provider doesn't have to be involved.  (Note that parts of custom_exprs
	 * could have come from join clauses, so doing this beforehand on the
	 * scan_clauses wouldn't work.)  We assume custom_scan_tlist contains no
	 * such variables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cplan</name><operator>-&gt;</operator><name>custom_exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cplan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cplan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	JOIN METHODS
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>NestLoop</name> <modifier>*</modifier></type>
<name>create_nestloop_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>NestPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>join_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outer_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>inner_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinrestrictclauses</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>otherclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>outerrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>nestParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>saveOuterRels</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partition_selectors_created</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prefetch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>push_partition_selector_candidate_for_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive>  <expr><literal type="number">0</literal></expr></cpp:if>
	<comment type="block">/*
	 * If the inner path is a nestloop inner indexscan, it might be using some
	 * of the join quals as index quals, in which case we don't have to check
	 * them again at the join node.  Remove any join quals that are redundant.
	 */</comment>
	joinrestrictclauses =
		select_nonredundant_join_clauses(root,
										 joinrestrictclauses,
										 best_path-&gt;innerjoinpath);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* NestLoop can project, so no need to be picky about child tlists */</comment>
	<expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the outer side contained Append nodes that can do partition pruning,
	 * inject Partition Selectors to the inner side.
	 */</comment>
	<expr_stmt><expr><name>partition_selectors_created</name> <operator>=</operator>
		<call><name>pop_and_inject_partition_selectors</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For a nestloop, include outer relids in curOuterRels for inner side */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>,
								   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * MPP-1459: subqueries are resolved after our deadlock checks in
	 * pathnode.c; so we have to check here to make sure that we catch all
	 * motion deadlocks.
	 *
	 * MPP-1487: if there is already a materialize node here, we don't want to
	 * insert another one. :-)
	 *
	 * NOTE: materialize_finished_plan() does *almost* what we want -- except
	 * we aren't finished.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>||</operator>
		<operator>!</operator><name><name>best_path</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>rescannable</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Material</name>   <modifier>*</modifier></type><name>mat</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>inner_plan</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>PartitionSelector</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>mat</name> <operator>=</operator> <operator>(</operator><name>Material</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name></type>		<name>matpath</name></decl>;</decl_stmt>	<comment type="block">/* dummy for cost fixup */</comment>

			<comment type="block">/* Set cost data */</comment>
			<expr_stmt><expr><call><name>cost_material</name><argument_list>(<argument><expr><operator>&amp;</operator><name>matpath</name></expr></argument>,
						  <argument><expr><name>root</name></expr></argument>,
						  <argument><expr><name><name>inner_plan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
						  <argument><expr><name><name>inner_plan</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
						  <argument><expr><name><name>inner_plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>,
						  <argument><expr><name><name>inner_plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>mat</name> <operator>=</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>mat</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>matpath</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mat</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>matpath</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mat</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>inner_plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mat</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_width</name></name> <operator>=</operator> <name><name>inner_plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>mat</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * MPP-1657: Even if there is already a materialize here, we
		 * may need to update its strictness.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>mat</name><operator>-&gt;</operator><name>cdb_strict</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prefetch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/* Restore curOuterRels */</comment>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name> <operator>=</operator> <name>saveOuterRels</name></expr>;</expr_stmt>

	<comment type="block">/* Sort join qual clauses into best execution order */</comment>
	<expr_stmt><expr><name>joinrestrictclauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrestrictclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the join qual clauses (in plain expression form) */</comment>
	<comment type="block">/* Any pseudoconstant clauses are ignored here */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>extract_actual_join_clauses</name><argument_list>(<argument><expr><name>joinrestrictclauses</name></expr></argument>,
									<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>joinclauses</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We can treat all clauses alike for an inner join */</comment>
		<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>joinrestrictclauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LASJ_NOTIN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>remove_isnotfalse</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Identify any nestloop parameters that should be supplied by this join
	 * node, and remove them from root-&gt;curOuterParams.
	 */</comment>
	<expr_stmt><expr><name>outerrelids</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nestParams</name> <operator>=</operator> <call><name>identify_current_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>join_plan</name> <operator>=</operator> <call><name>make_nestloop</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							  <argument><expr><name>joinclauses</name></expr></argument>,
							  <argument><expr><name>otherclauses</name></expr></argument>,
							  <argument><expr><name>nestParams</name></expr></argument>,
							  <argument><expr><name>outer_plan</name></expr></argument>,
							  <argument><expr><name>inner_plan</name></expr></argument>,
							  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
							  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>inner_unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>, <argument><expr><name>MaterialPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>(</operator><name>MaterialPath</name> <operator>*</operator><operator>)</operator> <name><name>best_path</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>mp</name><operator>-&gt;</operator><name>cdb_strict</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prefetch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>prefetch</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we injected a partition selector to the inner side, we must evaluate
	 * the inner side before the outer side, so that the partition selector
	 * can influence the execution of the outer side.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partition_selectors_created</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A motion deadlock can also happen when outer and joinqual both contain
	 * motions.  It is not easy to check for joinqual here, so we set the
	 * prefetch_joinqual mark only according to outer motion, and check for
	 * joinqual later in the executor.
	 *
	 * See ExecPrefetchJoinQual() for details.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name></name> <operator>&amp;&amp;</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>&amp;&amp;</operator>
		<name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_joinqual</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Similar for non join qual.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name></name> <operator>&amp;&amp;</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>&amp;&amp;</operator>
		<name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_qual</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>join_plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MergeJoin</name> <modifier>*</modifier></type>
<name>create_mergejoin_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>MergePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>join_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outer_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>inner_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>otherclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>mergeclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prefetch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>set_mat_cdb_strict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outerpathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>innerpathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nClauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>mergefamilies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>mergecollations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>mergestrategies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>mergenullsfirst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>opathkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>opeclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lip</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>outer_path</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>inner_path</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partition_selectors_created</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>push_partition_selector_candidate_for_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * MergeJoin can project, so we don't have to demand exact tlists from the
	 * inputs.  However, if we're intending to sort an input's result, it's
	 * best to request a small tlist so we aren't sorting more data than
	 * necessary.
	 */</comment>
	<expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>best_path</name><operator>-&gt;</operator><name>outersortkeys</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CP_SMALL_TLIST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the outer side contained Append nodes that can do partition pruning,
	 * inject Partition Selectors to the inner side.
	 */</comment>
	<expr_stmt><expr><name>partition_selectors_created</name> <operator>=</operator>
		<call><name>pop_and_inject_partition_selectors</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>best_path</name><operator>-&gt;</operator><name>innersortkeys</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CP_SMALL_TLIST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort join qual clauses into best execution order */</comment>
	<comment type="block">/* NB: do NOT reorder the mergeclauses */</comment>
	<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the join qual clauses (in plain expression form) */</comment>
	<comment type="block">/* Any pseudoconstant clauses are ignored here */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>extract_actual_join_clauses</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>,
									<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>joinclauses</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We can treat all clauses alike for an inner join */</comment>
		<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Remove the mergeclauses from the list of join qual clauses, leaving the
	 * list of quals that must be checked as qpquals.
	 */</comment>
	<expr_stmt><expr><name>mergeclauses</name> <operator>=</operator> <call><name>get_actual_clauses</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>list_difference</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>, <argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace any outer-relation variables with nestloop params.  There
	 * should not be any in the mergeclauses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Rearrange mergeclauses, if needed, so that the outer variable is always
	 * on the left; mark the mergeclause restrictinfos with correct
	 * outer_is_left status.
	 */</comment>
	<expr_stmt><expr><name>mergeclauses</name> <operator>=</operator> <call><name>get_switched_clauses</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></argument>,
										<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create explicit sort nodes for the outer and inner paths if necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>outersortkeys</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>outer_relids</name> <init>= <expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>sort</name> <init>= <expr><call><name>make_sort_from_pathkeys</name><argument_list>(<argument><expr><name>outer_plan</name></expr></argument>,
												   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>outersortkeys</name></name></expr></argument>,
												   <argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>sort</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>outerpathkeys</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>outersortkeys</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>outerpathkeys</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>innersortkeys</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_relids</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>sort</name> <init>= <expr><call><name>make_sort_from_pathkeys</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>,
												   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>innersortkeys</name></name></expr></argument>,
												   <argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>sort</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>innerpathkeys</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>innersortkeys</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>innerpathkeys</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * MPP-3300: very similar to the nested-loop join motion deadlock cases. But we may have already
	 * put some slackening operators below (e.g. a sort).
	 *
	 * We need some kind of strict slackening operator (something which consumes all of its
	 * input before producing a row of output) for our inner. And we need to prefetch that side
	 * first.
	 *
	 * See motion_sanity_walker() for details on how a deadlock may occur.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>&amp;&amp;</operator> <name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>prefetch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>, <argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>, <argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>best_path</name><operator>-&gt;</operator><name>materialize_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>set_mat_cdb_strict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If specified, add a materialize node to shield the inner plan from the
	 * need to handle mark/restore.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>materialize_inner</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>matplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>, <argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We assume the materialize will not spill to disk, and therefore
		 * charge just cpu_operator_cost per tuple.  (Keep this estimate in
		 * sync with final_cost_mergejoin.)
		 */</comment>
		<expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>matplan</name></expr></argument>, <argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name><name>matplan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <name>matplan</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_mat_cdb_strict</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Material</name> <operator>*</operator><operator>)</operator> <name>inner_plan</name><operator>)</operator><operator>-&gt;</operator><name>cdb_strict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute the opfamily/collation/strategy/nullsfirst arrays needed by the
	 * executor.  The information is in the pathkeys for the two inputs, but
	 * we need to be careful about the possibility of mergeclauses sharing a
	 * pathkey, as well as the possibility that the inner pathkeys are not in
	 * an order matching the mergeclauses.
	 */</comment>
	<expr_stmt><expr><name>nClauses</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nClauses</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mergefamilies</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mergecollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mergestrategies</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mergenullsfirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opathkey</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>opeclass</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lop</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>outerpathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lip</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>innerpathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>best_path-&gt;path_mergeclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>oeclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ieclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>ipathkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ipeclass</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>first_inner_match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* fetch outer/inner eclass from mergeclause */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oeclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ieclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>oeclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ieclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oeclass</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ieclass</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must identify the pathkey elements associated with this clause
		 * by matching the eclasses (which should give a unique match, since
		 * the pathkey lists should be canonical).  In typical cases the merge
		 * clauses are one-to-one with the pathkeys, but when dealing with
		 * partially redundant query conditions, things are more complicated.
		 *
		 * lop and lip reference the first as-yet-unmatched pathkey elements.
		 * If they're NULL then all pathkey elements have been matched.
		 *
		 * The ordering of the outer pathkeys should match the mergeclauses,
		 * by construction (see find_mergeclauses_for_outer_pathkeys()). There
		 * could be more than one mergeclause for the same outer pathkey, but
		 * no pathkey may be entirely skipped over.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>oeclass</name> <operator>!=</operator> <name>opeclass</name></expr>)</condition>	<comment type="block">/* multiple matches are not interesting */</comment>
		<block>{<block_content>
			<comment type="block">/* doesn't match the current opathkey, so must match the next */</comment>
			<if_stmt><if>if <condition>(<expr><name>lop</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"outer pathkeys do not match mergeclauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>opathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opeclass</name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lop</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>oeclass</name> <operator>!=</operator> <name>opeclass</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"outer pathkeys do not match mergeclauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The inner pathkeys likewise should not have skipped-over keys, but
		 * it's possible for a mergeclause to reference some earlier inner
		 * pathkey if we had redundant pathkeys.  For example we might have
		 * mergeclauses like "o.a = i.x AND o.b = i.y AND o.c = i.x".  The
		 * implied inner ordering is then "ORDER BY x, y, x", but the pathkey
		 * mechanism drops the second sort by x as redundant, and this code
		 * must cope.
		 *
		 * It's also possible for the implied inner-rel ordering to be like
		 * "ORDER BY x, y, x DESC".  We still drop the second instance of x as
		 * redundant; but this means that the sort ordering of a redundant
		 * inner pathkey should not be considered significant.  So we must
		 * detect whether this is the first clause matching an inner pathkey.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lip</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ipathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ipeclass</name> <operator>=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ieclass</name> <operator>==</operator> <name>ipeclass</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* successful first match to this inner pathkey */</comment>
				<expr_stmt><expr><name>lip</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>first_inner_match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_inner_match</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* redundant clause ... must match something before lip */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>innerpathkeys</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>l2</name> <operator>==</operator> <name>lip</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>ipathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ipeclass</name> <operator>=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ieclass</name> <operator>==</operator> <name>ipeclass</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>ieclass</name> <operator>!=</operator> <name>ipeclass</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inner pathkeys do not match mergeclauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The pathkeys should always match each other as to opfamily and
		 * collation (which affect equality), but if we're considering a
		 * redundant inner pathkey, its sort ordering might not match.  In
		 * such cases we may ignore the inner pathkey's sort ordering and use
		 * the outer's.  (In effect, we're lying to the executor about the
		 * sort direction of this inner column, but it does not matter since
		 * the run-time row comparisons would only reach this column when
		 * there's equality for the earlier column containing the same eclass.
		 * There could be only one value in this column for the range of inner
		 * rows having a given value in the earlier column, so it does not
		 * matter which way we imagine this column to be ordered.)  But a
		 * non-redundant inner pathkey had better match outer's ordering too.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>opathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>||</operator>
			<name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"left and right pathkeys do not match in mergejoin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>first_inner_match</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>opathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>||</operator>
			 <name><name>opathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"left and right pathkeys do not match in mergejoin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK, save info for executor */</comment>
		<expr_stmt><expr><name><name>mergefamilies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mergecollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mergestrategies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mergenullsfirst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Note: it is not an error if we have additional pathkey elements (i.e.,
	 * lop or lip isn't NULL here).  The input paths might be better-sorted
	 * than we need for the current mergejoin.
	 */</comment>

	<comment type="block">/*
	 * Now we can build the mergejoin node.
	 */</comment>
	<expr_stmt><expr><name>join_plan</name> <operator>=</operator> <call><name>make_mergejoin</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							   <argument><expr><name>joinclauses</name></expr></argument>,
							   <argument><expr><name>otherclauses</name></expr></argument>,
							   <argument><expr><name>mergeclauses</name></expr></argument>,
							   <argument><expr><name>mergefamilies</name></expr></argument>,
							   <argument><expr><name>mergecollations</name></expr></argument>,
							   <argument><expr><name>mergestrategies</name></expr></argument>,
							   <argument><expr><name>mergenullsfirst</name></expr></argument>,
							   <argument><expr><name>outer_plan</name></expr></argument>,
							   <argument><expr><name>inner_plan</name></expr></argument>,
							   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name></expr></argument>,
							   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>inner_unique</name></name></expr></argument>,
							   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>skip_mark_restore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>prefetch</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we injected a partition selector to the inner side, we must evaluate
	 * the inner side before the outer side, so that the partition selector
	 * can influence the execution of the outer side.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partition_selectors_created</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A motion deadlock can also happen when outer and joinqual both contain
	 * motions.  It is not easy to check for joinqual here, so we set the
	 * prefetch_joinqual mark only according to outer motion, and check for
	 * joinqual later in the executor.
	 *
	 * See ExecPrefetchJoinQual() for details.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name> <operator>&amp;&amp;</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>&amp;&amp;</operator>
		<name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_joinqual</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * If inner motion is not under a Material or Sort node then there could
	 * also be motion deadlock between inner and joinqual in mergejoin.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name> <operator>&amp;&amp;</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>&amp;&amp;</operator>
		<name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_joinqual</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Similar for non join qual.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name> <operator>&amp;&amp;</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>&amp;&amp;</operator>
		<name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_qual</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Costs of sort and material steps are included in path cost already */</comment>
	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>join_plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type>
<name>create_hashjoin_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>HashPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoin</name>   <modifier>*</modifier></type><name>join_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hash</name>	   <modifier>*</modifier></type><name>hash_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outer_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>inner_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>otherclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>skewTable</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>skewColumn</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skewInherit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partition_selectors_created</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>push_partition_selector_candidate_for_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * HashJoin can project, so we don't have to demand exact tlists from the
	 * inputs.  However, it's best to request a small tlist from the inner
	 * side, so that we aren't storing more data than necessary.  Likewise, if
	 * we anticipate batching, request a small tlist from the outer side so
	 * that we don't put extra data in the outer batch files.
	 */</comment>
	<expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>best_path</name><operator>-&gt;</operator><name>num_batches</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>CP_SMALL_TLIST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the outer side contained Append nodes that can do partition pruning,
	 * inject Partition Selectors to the inner side.
	 */</comment>
	<expr_stmt><expr><name>partition_selectors_created</name> <operator>=</operator>
		<call><name>pop_and_inject_partition_selectors</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>,
									 <argument><expr><name>CP_SMALL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort join qual clauses into best execution order */</comment>
	<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* There's no point in sorting the hash clauses ... */</comment>

	<comment type="block">/* Get the join qual clauses (in plain expression form) */</comment>
	<comment type="block">/* Any pseudoconstant clauses are ignored here */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>extract_actual_join_clauses</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>,
									<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>joinclauses</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We can treat all clauses alike for an inner join */</comment>
		<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Remove the hashclauses from the list of join qual clauses, leaving the
	 * list of quals that must be checked as qpquals.
	 */</comment>
	<expr_stmt><expr><name>hashclauses</name> <operator>=</operator> <call><name>get_actual_clauses</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_hashclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>list_difference</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>, <argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace any outer-relation variables with nestloop params.  There
	 * should not be any in the hashclauses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Rearrange hashclauses, if needed, so that the outer variable is always
	 * on the left.
	 */</comment>
	<expr_stmt><expr><name>hashclauses</name> <operator>=</operator> <call><name>get_switched_clauses</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_hashclauses</name></name></expr></argument>,
									   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a single join clause and we can identify the outer variable
	 * as a simple column reference, supply its identity for possible use in
	 * skew optimization.  (Note: in principle we could do skew optimization
	 * with multiple join clauses, but we'd have to be able to determine the
	 * most common combinations of outer values, which we don't currently have
	 * enough stats for.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>skewTable</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>skewColumn</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>skewInherit</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build the hash node and hash join node.
	 */</comment>
	<expr_stmt><expr><name>hash_plan</name> <operator>=</operator> <call><name>make_hash</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>,
						  <argument><expr><name>skewTable</name></expr></argument>,
						  <argument><expr><name>skewColumn</name></expr></argument>,
						  <argument><expr><name>skewInherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set Hash node's startup &amp; total costs equal to total cost of input
	 * plan; this only affects EXPLAIN display not decisions.
	 */</comment>
	<expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If parallel-aware, the executor will also need an estimate of the total
	 * number of rows expected from all participants so that it can size the
	 * shared hash table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_plan</name><operator>-&gt;</operator><name>rows_total</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>inner_rows_total</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>join_plan</name> <operator>=</operator> <call><name>make_hashjoin</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							  <argument><expr><name>joinclauses</name></expr></argument>,
							  <argument><expr><name>otherclauses</name></expr></argument>,
							  <argument><expr><name>hashclauses</name></expr></argument>,
							  <argument><expr><name>outer_plan</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>hash_plan</name></expr></argument>,
							  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name></expr></argument>,
							  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>inner_unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * MPP-4635.  best_path-&gt;jpath.outerjoinpath may be NULL.
	 * From the comment, it is adaptive nestloop join may cause this.
	 */</comment>
	<comment type="block">/*
	 * MPP-4165: we need to descend left-first if *either* of the
	 * subplans have any motion.
	 */</comment>
	<comment type="block">/*
	 * MPP-3300: unify motion-deadlock prevention for all join types.
	 * This allows us to undo the MPP-989 changes in nodeHashjoin.c
	 * (allowing us to check the outer for rows before building the
	 * hash-table).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>||</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we injected a partition selector to the inner side, we must evaluate
	 * the inner side before the outer side, so that the partition selector
	 * can influence the execution of the outer side.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partition_selectors_created</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A motion deadlock can also happen when outer and joinqual both contain
	 * motions.  It is not easy to check for joinqual here, so we set the
	 * prefetch_joinqual mark only according to outer motion, and check for
	 * joinqual later in the executor.
	 *
	 * See ExecPrefetchJoinQual() for details.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name> <operator>&amp;&amp;</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>&amp;&amp;</operator>
		<name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_joinqual</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Similar for non join qual.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name> <operator>&amp;&amp;</operator>
		<name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>&amp;&amp;</operator>
		<name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_qual</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>join_plan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	SUPPORTING ROUTINES
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * replace_nestloop_params
 *	  Replace outer-relation Vars and PlaceHolderVars in the given expression
 *	  with nestloop Params
 *
 * All Vars and PlaceHolderVars belonging to the relation(s) identified by
 * root-&gt;curOuterRels are replaced by Params, and entries are added to
 * root-&gt;curOuterParams if not already present.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No setup needed for tree walk, so away we go */</comment>
	<return>return <expr><call><name>replace_nestloop_params_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_nestloop_params_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Upper-level Vars should be long gone at this point */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If not to be replaced, we can just return the Var unmodified */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Replace the Var with a nestloop Param */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_param_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Upper-level PlaceHolderVars should be long gone at this point */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check whether we need to replace the PHV.  We use bms_overlap as a
		 * cheap/quick test to see if the PHV might be evaluated in the outer
		 * rels, and then grab its PlaceHolderInfo to tell for sure.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ph_eval_at</name></expr></argument>,
						   <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can't replace the whole PHV, but we might still need to
			 * replace Vars or PHVs within its expression, in case it ends up
			 * actually getting evaluated here.  (It might get evaluated in
			 * this plan node, or some child node; in the latter case we don't
			 * really need to process the expression here, but we haven't got
			 * enough info to tell if that's the case.)  Flat-copy the PHV
			 * node and then recurse on its expression.
			 *
			 * Note that after doing this, we might have different
			 * representations of the contents of the same PHV in different
			 * parts of the plan tree.  This is OK because equal() will just
			 * match on phid/phlevelsup, so setrefs.c will still recognize an
			 * upper-level reference to a lower-level copy of the same PHV.
			 */</comment>
			<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>newphv</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newphv</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newphv</name><operator>-&gt;</operator><name>phexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
				<call><name>replace_nestloop_params_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>,
												<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newphv</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Replace the PlaceHolderVar with a nestloop Param */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_param_placeholdervar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								   <argument><expr><name>replace_nestloop_params_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fix_indexqual_references
 *	  Adjust indexqual clauses to the form the executor's indexqual
 *	  machinery needs.
 *
 * We have three tasks here:
 *	* Select the actual qual clauses out of the input IndexClause list,
 *	  and remove RestrictInfo nodes from the qual clauses.
 *	* Replace any outer-relation Var or PHV nodes with nestloop Params.
 *	  (XXX eventually, that responsibility should go elsewhere?)
 *	* Index keys must be represented by Var nodes with varattno set to the
 *	  index's attribute number, not the attribute number in the original rel.
 *
 * *stripped_indexquals_p receives a list of the actual qual clauses.
 *
 * *fixed_indexquals_p receives a list of the adjusted quals.  This is a copy
 * that shares no substructure with the original; this is needed in case there
 * are subplans in it (we need two separate copies of the subplan tree, or
 * things will go awry).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fix_indexqual_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>stripped_indexquals_p</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>fixed_indexquals_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stripped_indexquals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fixed_indexquals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>stripped_indexquals</name> <operator>=</operator> <name>fixed_indexquals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>index_path-&gt;indexclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>iclause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>IndexClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>indexcol</name> <init>= <expr><name><name>iclause</name><operator>-&gt;</operator><name>indexcol</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>iclause-&gt;indexquals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>stripped_indexquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stripped_indexquals</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>fix_indexqual_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexcol</name></expr></argument>,
										  <argument><expr><name>clause</name></expr></argument>, <argument><expr><name><name>iclause</name><operator>-&gt;</operator><name>indexcols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fixed_indexquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fixed_indexquals</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>stripped_indexquals_p</name> <operator>=</operator> <name>stripped_indexquals</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fixed_indexquals_p</name> <operator>=</operator> <name>fixed_indexquals</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fix_indexorderby_references
 *	  Adjust indexorderby clauses to the form the executor's index
 *	  machinery needs.
 *
 * This is a simplified version of fix_indexqual_references.  The input is
 * bare clauses and a separate indexcol list, instead of IndexClauses.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fix_indexorderby_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fixed_indexorderbys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lci</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fixed_indexorderbys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>lcc</argument>, <argument>index_path-&gt;indexorderbys</argument>, <argument>lci</argument>, <argument>index_path-&gt;indexorderbycols</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>indexcol</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>fix_indexqual_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexcol</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fixed_indexorderbys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fixed_indexorderbys</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>fixed_indexorderbys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fix_indexqual_clause
 *	  Convert a single indexqual clause to the form needed by the executor.
 *
 * We replace nestloop params here, and replace the index key variables
 * or expressions by index Var nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_indexqual_clause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexcol</name></decl></parameter>,
					 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexcolnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Replace any outer-relation variables with nestloop params.
	 *
	 * This also makes a copy of the clause, so it's safe to modify it
	 * in-place below.
	 */</comment>
	<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Replace the indexkey expression with an index Var. */</comment>
		<expr_stmt><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fix_indexqual_operand</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>index</name></expr></argument>,
												   <argument><expr><name>indexcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lca</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lcai</name></decl>;</decl_stmt>

		<comment type="block">/* Replace the indexkey expressions with index Vars. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexcolnos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lca</argument>, <argument>rc-&gt;largs</argument>, <argument>lcai</argument>, <argument>indexcolnos</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lca</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fix_indexqual_operand</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lca</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>index</name></expr></argument>,
												<argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcai</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Replace the indexkey expression with an index Var. */</comment>
		<expr_stmt><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fix_indexqual_operand</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>index</name></expr></argument>,
													 <argument><expr><name>indexcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nt</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Replace the indexkey expression with an index Var. */</comment>
		<expr_stmt><expr><name><name>nt</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>fix_indexqual_operand</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
												 <argument><expr><name>index</name></expr></argument>,
												 <argument><expr><name>indexcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported indexqual type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>clause</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fix_indexqual_operand
 *	  Convert an indexqual expression to a Var referencing the index column.
 *
 * We represent index keys by Var nodes having varno == INDEX_VAR and varattno
 * equal to the index's attribute number (index column position).
 *
 * Most of the code here is just for sanity cross-checking that the given
 * expression actually matches the index column it's claimed to.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_indexqual_operand</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexcol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remove any binary-compatible relabeling of the indexkey
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexcol</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>indexcol</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>indexcol</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It's a simple index column */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>indexcol</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>INDEX_VAR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>indexcol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index key does not match expected index column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* It's an index expression, so find and cross-check the expression */</comment>
	<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>indexcol</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>indexkey</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>indexkey</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>INDEX_VAR</name></expr></argument>, <argument><expr><name>indexcol</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									 <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									 <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index key does not match expected index column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Oops... */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index key does not match expected index column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * get_switched_clauses
 *	  Given a list of merge or hash joinclauses (as RestrictInfo nodes),
 *	  extract the bare clauses, and rearrange the elements within the
 *	  clauses, if needed, so the outer join variable is on the left and
 *	  the inner is on the right.  The original clause data structure is not
 *	  touched; a modified list is returned.  We do, however, set the transient
 *	  outer_is_left field in each RestrictInfo to show which side was which.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_switched_clauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>t_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>rclause</name> <init>= <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

		<comment type="block" format="doxygen">/**
		 * If this is a IS NOT FALSE boolean test, we can peek underneath.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rclause</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>bt</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>rclause</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>bt</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_FALSE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rclause</name> <operator>=</operator> <name><name>bt</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>rclause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>rclause</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Duplicate just enough of the structure to allow commuting the
			 * clause without changing the original list.  Could use
			 * copyObject, but a complete deep copy is overkill.
			 */</comment>
			<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>temp</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>opresulttype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opretset</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>opretset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opcollid</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>opcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
			<comment type="block">/* Commute it --- note this modifies the temp node in-place. */</comment>
			<expr_stmt><expr><call><name>CommuteOpExpr</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>t_list</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>t_list</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>t_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * order_qual_clauses
 *		Given a list of qual clauses that will all be evaluated at the same
 *		plan node, sort the list into the order we want to check the quals
 *		in at runtime.
 *
 * When security barrier quals are used in the query, we may have quals with
 * different security levels in the list.  Quals of lower security_level
 * must go before quals of higher security_level, except that we can grant
 * exceptions to move up quals that are leakproof.  When security level
 * doesn't force the decision, we prefer to order clauses by estimated
 * execution cost, cheapest first.
 *
 * Ideally the order should be driven by a combination of execution cost and
 * selectivity, but it's not immediately clear how to account for both,
 * and given the uncertainty of the estimates the reliability of the decisions
 * would be doubtful anyway.  So we just order by security level then
 * estimated per-tuple cost, being careful not to change the order when
 * (as is often the case) the estimates are identical.
 *
 * Although this will work on either bare clauses or RestrictInfos, it's
 * much faster to apply it to RestrictInfos, since it can re-use cost
 * information that is cached in RestrictInfos.  XXX in the bare-clause
 * case, we are also not able to apply security considerations.  That is
 * all right for the moment, because the bare-clause case doesn't occur
 * anywhere that barrier quals could be present, but it would be better to
 * get rid of it.
 *
 * Note: some callers pass lists that contain entries that will later be
 * removed; this is the easiest way to let this routine see RestrictInfos
 * instead of bare clauses.  This is another reason why trying to consider
 * selectivity in the ordering would likely do the wrong thing.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>order_qual_clauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<typedef>typedef <type><struct>struct
	<block>{
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>cost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>security_level</name></decl>;</decl_stmt>
	}</block></struct></type> <name>QualItem</name>;</typedef>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualItem</name>   <modifier>*</modifier></type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* No need to work hard for 0 or 1 clause */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>clauses</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Collect the items and costs into an array.  This is to avoid repeated
	 * cost_qual_eval work if the inputs aren't RestrictInfos.
	 */</comment>
	<expr_stmt><expr><name>items</name> <operator>=</operator> <operator>(</operator><name>QualItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>QualItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>qcost</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qcost</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>clause</name> <operator>=</operator> <name>clause</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cost</name> <operator>=</operator> <name><name>qcost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If a clause is leakproof, it doesn't have to be constrained by
			 * its nominal security level.  If it's also reasonably cheap
			 * (here defined as 10X cpu_operator_cost), pretend it has
			 * security_level 0, which will allow it to go in front of
			 * more-expensive quals of lower security levels.  Of course, that
			 * will also force it to go in front of cheaper quals of its own
			 * security level, which is not so great, but we can alleviate
			 * that risk by applying the cost limit cutoff.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>leakproof</name></name> <operator>&amp;&amp;</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cost</name> <operator>&lt;</operator> <literal type="number">10</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>security_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>security_level</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>security_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Sort.  We don't use qsort() because it's not guaranteed stable for
	 * equal keys.  The expected number of entries is small enough that a
	 * simple insertion sort should be good enough.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QualItem</name></type>	<name>newitem</name> <init>= <expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<comment type="block">/* insert newitem into the already-sorted subarray */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>QualItem</name>   <modifier>*</modifier></type><name>olditem</name> <init>= <expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>newitem</name><operator>.</operator><name>security_level</name></name> <operator>&gt;</operator> <name><name>olditem</name><operator>-&gt;</operator><name>security_level</name></name> <operator>||</operator>
				<operator>(</operator><name><name>newitem</name><operator>.</operator><name>security_level</name></name> <operator>==</operator> <name><name>olditem</name><operator>-&gt;</operator><name>security_level</name></name> <operator>&amp;&amp;</operator>
				 <name><name>newitem</name><operator>.</operator><name>cost</name></name> <operator>&gt;=</operator> <name><name>olditem</name><operator>-&gt;</operator><name>cost</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>olditem</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Convert back to a list */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy cost and size info from a Path node to the Plan node created from it.
 * The executor usually won't use this info, but it's needed by EXPLAIN.
 * Also copy the parallel-related flags, which the executor *will* use.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_generic_path_info</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy cost and size info from a lower plan node to an inserted node.
 * (Most callers alter the info after copying it.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_plan_costsize</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
	<comment type="block">/* Assume the inserted node is not parallel-aware. */</comment>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* Assume the inserted node is parallel-safe, if child plan is. */</comment>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Some places in this file build Sort nodes that don't have a directly
 * corresponding Path node.  The cost of the sort is, or should have been,
 * included in the cost of the Path node we're working from, but since it's
 * not split out, we have to re-figure it using cost_sort().  This is just
 * to label the Sort node nicely for EXPLAIN.
 *
 * limit_tuples is as for cost_sort (in particular, pass -1 if no limit)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>label_sort_with_costsize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Sort</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>lefttree</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>sort_path</name></decl>;</decl_stmt>		<comment type="block">/* dummy for result of cost_sort */</comment>

	<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
			  <argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
			  <argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>,
			  <argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>,
			  <argument><expr><literal type="number">0.0</literal></expr></argument>,
			  <argument><expr><name>work_mem</name></expr></argument>,
			  <argument><expr><name>limit_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_width</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	PLAN NODE BUILDING ROUTINES
 *
 * In general, these functions are not passed the original Path and therefore
 * leave it to the caller to fill in the cost/width fields from the Path,
 * typically by calling copy_generic_path_info().  This convention is
 * somewhat historical, but it does support a few places above where we build
 * a plan node without having an exactly corresponding Path node.  Under no
 * circumstances should one of these functions do its own cost calculations,
 * as that would be redundant with calculations done while building Paths.
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type>
<name>make_seqscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
			 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
			 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SeqScan</name>    <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SeqScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type>
<name>make_samplescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
				<parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
				<parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SampleScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SampleScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <name>tsc</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IndexScan</name> <modifier>*</modifier></type>
<name>make_indexscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
			   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderby</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbyorig</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbyops</name></decl></parameter>,
			   <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <name>indexid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator> <name>indexqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqualorig</name></name> <operator>=</operator> <name>indexqualorig</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderby</name></name> <operator>=</operator> <name>indexorderby</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderbyorig</name></name> <operator>=</operator> <name>indexorderbyorig</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderbyops</name></name> <operator>=</operator> <name>indexorderbyops</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderdir</name></name> <operator>=</operator> <name>indexscandir</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IndexOnlyScan</name> <modifier>*</modifier></type>
<name>make_indexonlyscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
				   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderby</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indextlist</name></decl></parameter>,
				   <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <name>indexid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator> <name>indexqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqualorig</name></name> <operator>=</operator> <name>indexqualorig</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderby</name></name> <operator>=</operator> <name>indexorderby</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indextlist</name></name> <operator>=</operator> <name>indextlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderdir</name></name> <operator>=</operator> <name>indexscandir</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BitmapIndexScan</name> <modifier>*</modifier></type>
<name>make_bitmap_indexscan</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapIndexScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>		<comment type="block">/* not used */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>			<comment type="block">/* not used */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <name>indexid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator> <name>indexqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqualorig</name></name> <operator>=</operator> <name>indexqualorig</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type>
<name>make_bitmap_heapscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
					 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapqualorig</name></decl></parameter>,
					 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapHeapScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bitmapqualorig</name></name> <operator>=</operator> <name>bitmapqualorig</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type>
<name>make_tidscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
			 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
			 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
			 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tidquals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TidScan</name>    <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TidScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tidquals</name></name> <operator>=</operator> <name>tidquals</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SubqueryScan</name> <modifier>*</modifier></type>
<name>make_subqueryscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
				  <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
				  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that, in most scan nodes, scanrelid refers to an entry in the rtable of the
	 * containing plan; in a subqueryscan node, the containing plan is the higher
	 * level plan!
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>subplan</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type>
<name>make_functionscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
				  <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>functions</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>funcordinality</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FunctionScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <name>functions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>funcordinality</name></name> <operator>=</operator> <name>funcordinality</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>resultInTupleStore</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TableFunctionScan</name> <modifier>*</modifier></type>
<name>make_tablefunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>,
				   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableFunctionScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TableFunctionScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* only care about copying size */</comment>

	<comment type="block">/* FIXME: fix costing */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name>  <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name>    <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name>   <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name>			<operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name>	<operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name>		<operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Fill in information for the subplan */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name>		 <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>function</name></name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type>
<name>make_tablefuncscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
				   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
				   <parameter><decl><type><name>TableFunc</name> <modifier>*</modifier></type><name>tablefunc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableFuncScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TableFuncScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tablefunc</name></name> <operator>=</operator> <name>tablefunc</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type>
<name>make_valuesscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
				<parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values_lists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ValuesScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ValuesScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator> <name>values_lists</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <macro><name>pg_attribute_unused</name><argument_list>()</argument_list></macro> <name>CteScan</name> <operator>*</operator>
<macro><name>make_ctescan</name><argument_list>(<argument>List *qptlist</argument>,
			 <argument>List *qpqual</argument>,
			 <argument>Index scanrelid</argument>,
			 <argument>int ctePlanId</argument>,
			 <argument>int cteParam</argument>)</argument_list></macro>
<block>{
	<expr><name>CteScan</name>    <operator>*</operator><name>node</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CteScan</name></expr></argument>)</argument_list></call></expr>;
	<expr><name>Plan</name>	   <operator>*</operator><name>plan</name> <operator>=</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;

	<expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;
	<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;
	<expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;
	<expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;
	<expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;
	<expr><name><name>node</name><operator>-&gt;</operator><name>ctePlanId</name></name> <operator>=</operator> <name>ctePlanId</name></expr>;
	<expr><name><name>node</name><operator>-&gt;</operator><name>cteParam</name></name> <operator>=</operator> <name>cteParam</name></expr>;

	<return>return <expr><name>node</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type>
<name>make_namedtuplestorescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
						 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>enrname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NamedTuplestoreScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* cost should be inserted by caller */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>enrname</name></name> <operator>=</operator> <name>enrname</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type>
<name>make_worktablescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
				   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkTableScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WorkTableScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wtParam</name></name> <operator>=</operator> <name>wtParam</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ForeignScan</name> <modifier>*</modifier></type>
<name>make_foreignscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
				 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_exprs</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_scan_tlist</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_recheck_quals</name></decl></parameter>,
				 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>outer_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* cost will be filled in by create_foreignscan_plan */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>outer_plan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
	<comment type="block">/* fs_server will be filled in by create_foreignscan_plan */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fs_server</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_exprs</name></name> <operator>=</operator> <name>fdw_exprs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>fdw_private</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name> <operator>=</operator> <name>fdw_scan_tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name> <operator>=</operator> <name>fdw_recheck_quals</name></expr>;</expr_stmt>
	<comment type="block">/* fs_relids will be filled in by create_foreignscan_plan */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fs_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* fsSystemCol will be filled in by create_foreignscan_plan */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type>
<name>make_recursive_union</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
					 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>,
					 <parameter><decl><type><name>long</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecursiveUnion</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RecursiveUnion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>righttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wtParam</name></name> <operator>=</operator> <name>wtParam</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * convert SortGroupClause list into arrays of attr indexes and equality
	 * operators, as wanted by executor
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dupColIdx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>dupOperators</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>dupCollations</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>slitem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dupColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dupOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dupCollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>slitem</argument>, <argument>distinctList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>slitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>,
													   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>dupColIdx</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dupOperators</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dupCollations</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>dupOperators</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupColIdx</name></name> <operator>=</operator> <name>dupColIdx</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupOperators</name></name> <operator>=</operator> <name>dupOperators</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupCollations</name></name> <operator>=</operator> <name>dupCollations</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BitmapAnd</name> <modifier>*</modifier></type>
<name>make_bitmap_and</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BitmapAnd</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bitmapplans</name></name> <operator>=</operator> <name>bitmapplans</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BitmapOr</name> <modifier>*</modifier></type>
<name>make_bitmap_or</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BitmapOr</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bitmapplans</name></name> <operator>=</operator> <name>bitmapplans</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>NestLoop</name> <modifier>*</modifier></type>
<name>make_nestloop</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nestParams</name></decl></parameter>,
			  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
			  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
			  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>otherclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>righttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name>inner_unique</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator> <name>joinclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nestParams</name></name> <operator>=</operator> <name>nestParams</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type>
<name>make_hashjoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashclauses</name></decl></parameter>,
			  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
			  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
			  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoin</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>otherclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>righttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashclauses</name></name> <operator>=</operator> <name>hashclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashqualclauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name>inner_unique</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator> <name>joinclauses</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Hash</name> <modifier>*</modifier></type>
<name>make_hash</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
		  <parameter><decl><type><name>Oid</name></type> <name>skewTable</name></decl></parameter>,
		  <parameter><decl><type><name>AttrNumber</name></type> <name>skewColumn</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>skewInherit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hash</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skewTable</name></name> <operator>=</operator> <name>skewTable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skewColumn</name></name> <operator>=</operator> <name>skewColumn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skewInherit</name></name> <operator>=</operator> <name>skewInherit</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* CDB (unused for now) */</comment>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MergeJoin</name> <modifier>*</modifier></type>
<name>make_mergejoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergefamilies</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergecollations</name></decl></parameter>,
			   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mergestrategies</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>mergenullsfirst</name></decl></parameter>,
			   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
			   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
			   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>skip_mark_restore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>otherclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>righttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skip_mark_restore</name></name> <operator>=</operator> <name>skip_mark_restore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeclauses</name></name> <operator>=</operator> <name>mergeclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeFamilies</name></name> <operator>=</operator> <name>mergefamilies</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeCollations</name></name> <operator>=</operator> <name>mergecollations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeStrategies</name></name> <operator>=</operator> <name>mergestrategies</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeNullsFirst</name></name> <operator>=</operator> <name>mergenullsfirst</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name>inner_unique</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator> <name>joinclauses</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort --- basic routine to build a Sort plan node
 *
 * Caller must have built the sortColIdx, sortOperators, collations, and
 * nullsFirst arrays already.
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>make_sort</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>,
		  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>,
		  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name></name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sortColIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_sort_cost --- basic routine to accumulate Sort cost into a
 * plan node representing the input cost.
 *
 * Unused arguments (e.g., sortColIdx and sortOperators arrays) are
 * included to allow for future improvements to sort costing.  Note
 * that root may be NULL (e.g. when called outside make_sort).
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>add_sort_cost</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name></type>		<name>sort_path</name></decl>;</decl_stmt>		<comment type="block">/* dummy for result of cost_sort */</comment>

	<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
			  <argument><expr><name><name>input</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
			  <argument><expr><name><name>input</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>,
			  <argument><expr><name><name>input</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>,
			  <argument><expr><literal type="number">0.0</literal></expr></argument>,
			  <argument><expr><name>work_mem</name></expr></argument>,
			  <argument><expr><name>limit_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>

	<return>return <expr><name>input</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * prepare_sort_from_pathkeys
 *	  Prepare to sort according to given pathkeys
 *
 * This is used to set up for Sort, MergeAppend, and Gather Merge nodes.  It
 * calculates the executor's representation of the sort key information, and
 * adjusts the plan targetlist if needed to add resjunk sort columns.
 *
 * Input parameters:
 *	  'lefttree' is the plan node which yields input tuples
 *	  'pathkeys' is the list of pathkeys by which the result is to be sorted
 *	  'relids' identifies the child relation being sorted, if any
 *	  'reqColIdx' is NULL or an array of required sort key column numbers
 *	  'adjust_tlist_in_place' is true if lefttree must be modified in-place
 *
 * We must convert the pathkey information into arrays of sort key column
 * numbers, sort operator OIDs, collation OIDs, and nulls-first flags,
 * which is the representation the executor wants.  These are returned into
 * the output parameters *p_numsortkeys etc.
 *
 * When looking for matches to an EquivalenceClass's members, we will only
 * consider child EC members if they belong to given 'relids'.  This protects
 * against possible incorrect matches to child expressions that contain no
 * Vars.
 *
 * If reqColIdx isn't NULL then it contains sort key column numbers that
 * we should match.  This is used when making child plans for a MergeAppend;
 * it's an error if we can't match the columns.
 *
 * If the pathkeys include expressions that aren't simple Vars, we will
 * usually need to add resjunk items to the input plan's targetlist to
 * compute these expressions, since a Sort or MergeAppend node itself won't
 * do any such calculations.  If the input plan type isn't one that can do
 * projections, this means adding a Result node just to do the projection.
 * However, the caller can pass adjust_tlist_in_place = true to force the
 * lefttree tlist to be modified in-place regardless of whether the node type
 * can project --- we use this for fixing the tlist of MergeAppend itself.
 *
 * Returns the node which is to be the input to the Sort (either lefttree,
 * or a Result stacked atop lefttree).
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>prepare_sort_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>reqColIdx</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>adjust_tlist_in_place</name></decl></parameter>,
						   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p_numsortkeys</name></decl></parameter>,
						   <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortColIdx</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortOperators</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_collations</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsortkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We will need at most list_length(pathkeys) sort columns; possibly less
	 */</comment>
	<expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sortColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sortOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullsFirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_datatype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>sortop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the pathkey's EquivalenceClass is volatile, then it must
			 * have come from an ORDER BY clause, and we have to match it to
			 * that same targetlist entry.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* can't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"volatile EquivalenceClass has no sortref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>em_datatype</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>reqColIdx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we are given a sort column number to match, only consider
			 * the single TLE at that position.  It's possible that there is
			 * no such TLE, in which case fall through and generate a resjunk
			 * targetentry (we assume this must have happened in the parent
			 * plan as well).  If there is a TLE but it doesn't match the
			 * pathkey's EC, we do the same, which is probably the wrong thing
			 * but we'll leave it to caller to complain about the mismatch.
			 */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>reqColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tle</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_ec_member_for_tle</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>em</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* found expr at right place in tlist */</comment>
					<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, we can sort by any non-constant expression listed in
			 * the pathkey's EquivalenceClass.  For now, we take the first
			 * tlist item found in the EC. If there's no match, we'll generate
			 * a resjunk entry using the first EC member that is an expression
			 * in the input's vars.  (The non-const restriction only matters
			 * if the EC is below_outer_join; but if it isn't, it won't
			 * contain consts anyway, else we'd have discarded the pathkey as
			 * redundant.)
			 *
			 * XXX if we have a choice, is there any way of figuring out which
			 * might be cheapest to execute?  (For example, int4lt is likely
			 * much cheaper to execute than numericlt, but both might appear
			 * in the same equivalence class...)  Not clear that we ever will
			 * have an interesting choice in practice, so it may not matter.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>tlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_ec_member_for_tle</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>em</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* found expr already in tlist */</comment>
					<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No matching tlist item; look for a computable expression. Note
			 * that we treat Aggrefs as if they were variables; this is
			 * necessary when attempting to sort the output from an Agg node
			 * for use in a WindowFunc (since grouping_planner will have
			 * treated the Aggrefs as variables, too).  Likewise, if we find a
			 * WindowFunc in a sort expression, treat it as a variable.
			 */</comment>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>sortexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>exprvars</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * We shouldn't be trying to sort by an equivalence class that
				 * contains a constant, so no need to consider such cases any
				 * further.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Ignore child members unless they belong to the rel being
				 * sorted.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>sortexpr</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>exprvars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sortexpr</name></expr></argument>,
										   <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
										   <name>PVC_INCLUDE_WINDOWFUNCS</name> <operator>|</operator>
										   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>k</argument>, <argument>exprvars</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tlist_member_ignore_relabel</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>exprvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>k</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
					<break>break;</break>		<comment type="block">/* found usable expression */</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>j</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pathkey item to sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Do we need to insert a Result node?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>adjust_tlist_in_place</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* copy needed so we don't modify input's tlist below */</comment>
				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lefttree</name> <operator>=</operator> <call><name>inject_projection_plan</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>,
												  <argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Don't bother testing is_projection_capable_plan again */</comment>
			<expr_stmt><expr><name>adjust_tlist_in_place</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Add resjunk entry to input's tlist
			 */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>sortexpr</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>	<comment type="block">/* just in case NIL before */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Look up the correct sort operator from the PathKey's slightly
		 * abstracted representation.
		 */</comment>
		<expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
									 <argument><expr><name>pk_datatype</name></expr></argument>,
									 <argument><expr><name>pk_datatype</name></expr></argument>,
									 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
				 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>,
				 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Add the column to the sort arrays */</comment>
		<expr_stmt><expr><name><name>sortColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortOperators</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collations</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nullsFirst</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numsortkeys</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Return results */</comment>
	<expr_stmt><expr><operator>*</operator><name>p_numsortkeys</name> <operator>=</operator> <name>numsortkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_sortColIdx</name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_sortOperators</name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_collations</name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_nullsFirst</name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>

	<return>return <expr><name>lefttree</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_ec_member_for_tle
 *		Locate an EquivalenceClass member matching the given TLE, if any
 *
 * Child EC members are ignored unless they belong to given 'relids'.
 */</comment>
<function><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type>
<name>find_ec_member_for_tle</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
					   <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>tlexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* We ignore binary-compatible relabeling on both ends */</comment>
	<expr_stmt><expr><name>tlexpr</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>tlexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>tlexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tlexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>tlexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>emexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We shouldn't be trying to sort by an equivalence class that
		 * contains a constant, so no need to consider such cases any further.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore child members unless they belong to the rel being sorted.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Match if same expression (after stripping relabel) */</comment>
		<expr_stmt><expr><name>emexpr</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>emexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>emexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>emexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>emexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>emexpr</name></expr></argument>, <argument><expr><name>tlexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>em</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort_from_pathkeys
 *	  Create sort plan to sort according to given pathkeys
 *
 *	  'lefttree' is the node which yields input tuples
 *	  'pathkeys' is the list of pathkeys by which the result is to be sorted
 *	  'relids' is the set of relations required by prepare_sort_from_pathkeys()
 *	  'add_keys_to_targetlist' is true if it is ok to append to the subplan's
 *				targetlist or insert a Result node atop the subplan to
 *				evaluate sort key exprs that are not already present in the
 *				subplan's tlist.
 */</comment>
<function><type><name>Sort</name> <modifier>*</modifier></type>
<name>make_sort_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsortkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

	<comment type="block">/* Compute sort column info, and adjust lefttree as needed */</comment>
	<expr_stmt><expr><name>lefttree</name> <operator>=</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
										  <argument><expr><name>relids</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>numsortkeys</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now build the Sort node */</comment>
	<return>return <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
					 <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
					 <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort_from_sortclauses
 *	  Create sort plan to sort according to given sortclauses
 *
 *	  'sortcls' is a list of SortGroupClauses
 *	  'lefttree' is the node which yields input tuples
 */</comment>
<function><type><name>Sort</name> <modifier>*</modifier></type>
<name>make_sort_from_sortclauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortcls</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_tlist</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsortkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

	<comment type="block">/* Convert list-ish representation to arrays wanted by executor */</comment>
	<expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sortcls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sortColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sortOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullsFirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>sortcls</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name>sub_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sortColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortOperators</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collations</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nullsFirst</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numsortkeys</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
					 <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
					 <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort_from_groupcols
 *	  Create sort plan to sort based on grouping columns
 *
 * 'groupcls' is the list of SortGroupClauses
 * 'grpColIdx' gives the column numbers to use
 *
 * This might look like it could be merged with make_sort_from_sortclauses,
 * but presently we *must* use the grpColIdx[] array to locate sort columns,
 * because the child plan's tlist is not marked with ressortgroupref info
 * appropriate to the grouping node.  So, only the sort ordering info
 * is used from the SortGroupClause entries.
 */</comment>
<function><type><name>Sort</name> <modifier>*</modifier></type>
<name>make_sort_from_groupcols</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupcls</name></decl></parameter>,
						 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl></parameter>,
						 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_tlist</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsortkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

	<comment type="block">/* Convert list-ish representation to arrays wanted by executor */</comment>
	<expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>groupcls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sortColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sortOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullsFirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>groupcls</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>sub_tlist</name></expr></argument>, <argument><expr><name><name>grpColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not retrieve tle for sort-from-groupcols"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>sortColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortOperators</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collations</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nullsFirst</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numsortkeys</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
					 <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
					 <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------
 * make_motion -- creates a Motion node.
 * Caller must have built the pHashDefn, pFixedDefn,
 * and pSortDefn structs already.
 * This call only make a motion node, without filling in flow info
 * After calling this function, caller need to call add_slice_to_motion
 * --------------------------------------------------------------------
 */</comment>
<function><type><name>Motion</name> <modifier>*</modifier></type>
<name>make_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>numSortCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mtplan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>lefttree</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* See setrefs.c. A ModifyTable doesn't have a valid targetlist */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mtplan</name><operator>-&gt;</operator><name>returningLists</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>mtplan</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>=</operator> <name>numSortCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name></name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<comment type="block">/*
	 * If the child node was a Sort, then surely the order the caller gave us
	 * must match that of the underlying sort.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numSortCols</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>childsort</name> <init>= <expr><operator>(</operator><name>Sort</name> <operator>*</operator><operator>)</operator> <name>lefttree</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childsort</name><operator>-&gt;</operator><name>numCols</name></name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>childsort</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>childsort</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>childsort</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sendSorted</name></name> <operator>=</operator> <operator>(</operator><name>numSortCols</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Material</name> <modifier>*</modifier></type>
<name>make_material</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Material</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cdb_strict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * materialize_finished_plan: stick a Material node atop a completed plan
 *
 * There are a couple of places where we want to attach a Material node
 * after completion of create_plan(), without any MaterialPath path.
 * Those places should probably be refactored someday to do this on the
 * Path representation, but it's not worth the trouble yet.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>materialize_finished_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>matplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>matpath</name></decl>;</decl_stmt>		<comment type="block">/* dummy for result of cost_material */</comment>

	<expr_stmt><expr><name>matplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX horrid kluge: if there are any initPlans attached to the subplan,
	 * move them up to the Material node, which is now effectively the top
	 * plan node in its query level.  This prevents failure in
	 * SS_finalize_plan(), which see for comments.  We don't bother adjusting
	 * the subplan's cost estimate for this.
	 */</comment>
	<expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>initPlan</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Set cost data */</comment>
	<expr_stmt><expr><call><name>cost_material</name><argument_list>(<argument><expr><operator>&amp;</operator><name>matpath</name></expr></argument>,
				  <argument><expr><name>root</name></expr></argument>,
				  <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
				  <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
				  <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>,
				  <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>matpath</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>matpath</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since this is applied after calling create_plan(), this becomes the
	 * topmost node in the (sub)plan. We have to keep the 'flow' up to date.
	 */</comment>
	<expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>flow</name></name></expr>;</expr_stmt>

	<return>return <expr><name>matplan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Agg</name> <modifier>*</modifier></type>
<name>make_agg</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
		 <parameter><decl><type><name>AggStrategy</name></type> <name>aggstrategy</name></decl></parameter>, <parameter><decl><type><name>AggSplit</name></type> <name>aggsplit</name></decl></parameter>,
		 <parameter><decl><type><name>bool</name></type> <name>streaming</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>numGroupCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>grpOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>grpCollations</name></decl></parameter>,
		 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>chain</name></decl></parameter>,
		 <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Agg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>numGroups</name></decl>;</decl_stmt>

	<comment type="block">/* Reduce to long, but 'ware overflow! */</comment>
	<expr_stmt><expr><name>numGroups</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name>dNumGroups</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>LONG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name>aggstrategy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>aggsplit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numGroupCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grpColIdx</name></name> <operator>=</operator> <name>grpColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grpOperators</name></name> <operator>=</operator> <name>grpOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grpCollations</name></name> <operator>=</operator> <name>grpCollations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>=</operator> <name>groupingSets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>aggParams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* SS_finalize_plan() will fill this */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>=</operator> <name>groupingSets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>chain</name></name> <operator>=</operator> <name>chain</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>streaming</name></name> <operator>=</operator> <name>streaming</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TupleSplit</name> <modifier>*</modifier></type>
<name>make_tup_split</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dqa_expr_lst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numGroupCols</name></decl></parameter>,
			   <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleSplit</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TupleSplit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name>    <operator>=</operator> <name>numGroupCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grpColIdx</name></name>  <operator>=</operator> <name>grpColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dqa_expr_lst</name></name> <operator>=</operator> <name>dqa_expr_lst</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type>
<name>make_windowagg</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>winref</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>partNumCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partCollations</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>ordNumCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>ordColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ordOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ordCollations</name></decl></parameter>,
			   <parameter><decl><type><name>AttrNumber</name></type> <name>firstOrderCol</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>firstOrderCmpOperator</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>firstOrderNullsFirst</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>frameOptions</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>startOffset</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>endOffset</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>startInRangeFunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>endInRangeFunc</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>inRangeColl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inRangeAsc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inRangeNullsFirst</name></decl></parameter>,
			   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WindowAgg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>winref</name></name> <operator>=</operator> <name>winref</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name> <operator>=</operator> <name>partNumCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partColIdx</name></name> <operator>=</operator> <name>partColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partOperators</name></name> <operator>=</operator> <name>partOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partCollations</name></name> <operator>=</operator> <name>partCollations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>=</operator> <name>ordNumCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordColIdx</name></name> <operator>=</operator> <name>ordColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordOperators</name></name> <operator>=</operator> <name>ordOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordCollations</name></name> <operator>=</operator> <name>ordCollations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstOrderCol</name></name> <operator>=</operator> <name>firstOrderCol</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstOrderCmpOperator</name></name><operator>=</operator> <name>firstOrderCmpOperator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstOrderNullsFirst</name></name><operator>=</operator> <name>firstOrderNullsFirst</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>=</operator> <name>frameOptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>=</operator> <name>startOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>endOffset</name></name> <operator>=</operator> <name>endOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>startInRangeFunc</name></name> <operator>=</operator> <name>startInRangeFunc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>endInRangeFunc</name></name> <operator>=</operator> <name>endInRangeFunc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>inRangeColl</name></name> <operator>=</operator> <name>inRangeColl</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>inRangeAsc</name></name> <operator>=</operator> <name>inRangeAsc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>inRangeNullsFirst</name></name> <operator>=</operator> <name>inRangeNullsFirst</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* WindowAgg nodes never have a qual clause */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * distinctList is a list of SortGroupClauses, identifying the targetlist items
 * that should be considered by the Unique filter.  The input path must
 * already be sorted accordingly.
 */</comment>
<function><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type>
<name>make_unique_from_sortclauses</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Unique</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>uniqColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>uniqOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>uniqCollations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>slitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * convert SortGroupClause list into arrays of attr indexes and equality
	 * operators, as wanted by executor
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>uniqColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>uniqOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>uniqCollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>slitem</argument>, <argument>distinctList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>slitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>uniqColIdx</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>uniqOperators</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>uniqCollations</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>uniqOperators</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqColIdx</name></name> <operator>=</operator> <name>uniqColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqOperators</name></name> <operator>=</operator> <name>uniqOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqCollations</name></name> <operator>=</operator> <name>uniqCollations</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * as above, but use pathkeys to identify the sort columns and semantics
 */</comment>
<function><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type>
<name>make_unique_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Unique</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>uniqColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>uniqOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>uniqCollations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Convert pathkeys list into arrays of attr indexes and equality
	 * operators, as wanted by executor.  This has a lot in common with
	 * prepare_sort_from_pathkeys ... maybe unify sometime?
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numCols</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numCols</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>uniqColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>uniqOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>uniqCollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_datatype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore pathkeys beyond the specified number of columns */</comment>
		<if_stmt><if>if <condition>(<expr><name>keyno</name> <operator>&gt;=</operator> <name>numCols</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the pathkey's EquivalenceClass is volatile, then it must
			 * have come from an ORDER BY clause, and we have to match it to
			 * that same targetlist entry.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* can't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"volatile EquivalenceClass has no sortref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>em_datatype</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, we can use any non-constant expression listed in the
			 * pathkey's EquivalenceClass.  For now, we take the first tlist
			 * item found in the EC.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_ec_member_for_tle</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>em</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* found expr already in tlist */</comment>
					<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pathkey item to sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Look up the correct equality operator from the PathKey's slightly
		 * abstracted representation.
		 */</comment>
		<expr_stmt><expr><name>eqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
								   <argument><expr><name>pk_datatype</name></expr></argument>,
								   <argument><expr><name>pk_datatype</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
				 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>,
				 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>uniqColIdx</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>uniqOperators</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>uniqCollations</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqColIdx</name></name> <operator>=</operator> <name>uniqColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqOperators</name></name> <operator>=</operator> <name>uniqOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqCollations</name></name> <operator>=</operator> <name>uniqCollations</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type>
<name>make_gather</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
			<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>nworkers</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>rescan_param</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>single_copy</name></decl></parameter>,
			<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Gather</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rescan_param</name></name> <operator>=</operator> <name>rescan_param</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>single_copy</name></name> <operator>=</operator> <name>single_copy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>invisible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>initParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * distinctList is a list of SortGroupClauses, identifying the targetlist
 * items that should be considered by the SetOp filter.  The input path must
 * already be sorted accordingly.
 */</comment>
<function><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type>
<name>make_setop</name><parameter_list>(<parameter><decl><type><name>SetOpCmd</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>SetOpStrategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
		   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>flagColIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>firstFlag</name></decl></parameter>,
		   <parameter><decl><type><name>long</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOp</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dupColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>dupOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>dupCollations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>slitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * convert SortGroupClause list into arrays of attr indexes and equality
	 * operators, as wanted by executor
	 */</comment>
	<expr_stmt><expr><name>dupColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dupOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dupCollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>slitem</argument>, <argument>distinctList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>slitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>dupColIdx</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dupOperators</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dupCollations</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>dupOperators</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupColIdx</name></name> <operator>=</operator> <name>dupColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupOperators</name></name> <operator>=</operator> <name>dupOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupCollations</name></name> <operator>=</operator> <name>dupCollations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flagColIdx</name></name> <operator>=</operator> <name>flagColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstFlag</name></name> <operator>=</operator> <name>firstFlag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_lockrows
 *	  Build a LockRows plan node
 */</comment>
<function><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type>
<name>make_lockrows</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockRows</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>LockRows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>rowMarks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_limit
 *	  Build a Limit plan node
 */</comment>
<function><type><name>Limit</name> <modifier>*</modifier></type>
<name>make_limit</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Limit</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Limit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name>limitOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>limitCount</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_result
 *	  Build a Result plan node
 */</comment>
<function><type><name>Result</name> <modifier>*</modifier></type>
<name>make_result</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
			<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>resconstantqual</name></decl></parameter>,
			<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>resconstantqual</name></name> <operator>=</operator> <name>resconstantqual</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numHashFilterCols</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashFilterColIdx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashFilterFuncs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_project_set
 *	  Build a ProjectSet plan node
 */</comment>
<function><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type>
<name>make_project_set</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
				 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProjectSet</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ProjectSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_modifytable
 *	  Build a ModifyTable plan node
 */</comment>
<function><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type>
<name>make_modifytable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				 <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
				 <parameter><decl><type><name>Index</name></type> <name>nominalRelation</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rootRelation</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>partColsUpdated</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultRelations</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subplans</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subroots</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>withCheckOptionLists</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningLists</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>is_split_updates</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>onconflict</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_private_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>direct_modify_plans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subroots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>withCheckOptionLists</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		   <call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>returningLists</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		   <call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>is_split_updates</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<comment type="block">/* setrefs.c will fill in the targetlist, if needed */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>operation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>canSetTag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nominalRelation</name></name> <operator>=</operator> <name>nominalRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rootRelation</name></name> <operator>=</operator> <name>rootRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partColsUpdated</name></name> <operator>=</operator> <name>partColsUpdated</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name>resultRelations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>resultRelIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* will be set correctly in setrefs.c */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* will be set correctly in setrefs.c */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name> <operator>=</operator> <name>subplans</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>onconflict</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>=</operator> <name>ONCONFLICT_NONE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>arbiterIndexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exclRelRTI</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exclRelTlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>action</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If a set of unique index inference elements was provided (an
		 * INSERT...ON CONFLICT "inference specification"), then infer
		 * appropriate unique indexes (or throw an error if none are
		 * available).
		 */</comment>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>arbiterIndexes</name></name> <operator>=</operator> <call><name>infer_arbiter_indexes</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exclRelRTI</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>exclRelIndex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exclRelTlist</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name> <operator>=</operator> <name>withCheckOptionLists</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name> <operator>=</operator> <name>returningLists</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>rowMarks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>isSplitUpdates</name></name> <operator>=</operator> <name>is_split_updates</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>forceTupleRouting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each result relation that is a foreign table, allow the FDW to
	 * construct private plan data, and accumulate it all into a list.
	 */</comment>
	<expr_stmt><expr><name>fdw_private_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>direct_modify_plans</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>resultRelations</argument>, <argument>lc2</argument>, <argument>subroots</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_private</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>direct_modify</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If possible, we want to get the FdwRoutine from our RelOptInfo for
		 * the table.  But sometimes we don't have a RelOptInfo and must get
		 * it the hard way.  (In INSERT, the target relation is not scanned,
		 * so it's not a baserel; and there are also corner cases for
		 * updatable views where the target rel isn't a baserel.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>rti</name> <operator>&lt;</operator> <name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>&amp;&amp;</operator>
			<name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>resultRel</name> <init>= <expr><name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <name><name>resultRel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineByRelId</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Try to modify the foreign table directly if (1) the FDW provides
		 * callback functions needed for that and (2) there are no local
		 * structures that need to be run for each modified row: row-level
		 * triggers on the foreign table, stored generated columns, WITH CHECK
		 * OPTIONs from parent views.
		 */</comment>
		<expr_stmt><expr><name>direct_modify</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fdwroutine</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanDirectModify</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>fdwroutine</name><operator>-&gt;</operator><name>BeginDirectModify</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>fdwroutine</name><operator>-&gt;</operator><name>IterateDirectModify</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>fdwroutine</name><operator>-&gt;</operator><name>EndDirectModify</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name>withCheckOptionLists</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>has_row_triggers</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>has_stored_generated_columns</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>direct_modify</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanDirectModify</name></name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>direct_modify</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>direct_modify_plans</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>direct_modify_plans</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>direct_modify</name> <operator>&amp;&amp;</operator>
			<name>fdwroutine</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanForeignModify</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanForeignModify</name></name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>fdw_private_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fdw_private_list</name></expr></argument>, <argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdwPrivLists</name></name> <operator>=</operator> <name>fdw_private_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdwDirectModifyPlans</name></name> <operator>=</operator> <name>direct_modify_plans</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_projection_capable_path
 *		Check whether a given Path node is able to do projection.
 */</comment>
<function><type><name>bool</name></type>
<name>is_projection_capable_path</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Most plan types can project, so just list the ones that can't */</comment>
	<switch>switch <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Hash</name></expr>:</case>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<case>case <expr><name>T_Unique</name></expr>:</case>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
		<case>case <expr><name>T_LockRows</name></expr>:</case>
		<case>case <expr><name>T_Limit</name></expr>:</case>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
		<case>case <expr><name>T_Motion</name></expr>:</case>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
		<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>T_Append</name></expr>:</case>

			<comment type="block">/*
			 * Append can't project, but if an AppendPath is being used to
			 * represent a dummy path, what will actually be generated is a
			 * Result which can project.
			 */</comment>
			<return>return <expr><call><name>IS_DUMMY_APPEND</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_ProjectSet</name></expr>:</case>

			<comment type="block">/*
			 * Although ProjectSet certainly projects, say "no" because we
			 * don't want the planner to randomly replace its tlist with
			 * something else; the SRFs have to stay at top level.  This might
			 * get relaxed later.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_projection_capable_plan
 *		Check whether a given Plan node is able to do projection.
 */</comment>
<function><type><name>bool</name></type>
<name>is_projection_capable_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Most plan types can project, so just list the ones that can't */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Hash</name></expr>:</case>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<case>case <expr><name>T_Unique</name></expr>:</case>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
		<case>case <expr><name>T_LockRows</name></expr>:</case>
		<case>case <expr><name>T_Limit</name></expr>:</case>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
		<case>case <expr><name>T_Append</name></expr>:</case>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
		<case>case <expr><name>T_Motion</name></expr>:</case>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
		<case>case <expr><name>T_Sequence</name></expr>:</case>
		<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>T_ProjectSet</name></expr>:</case>

			<comment type="block">/*
			 * Although ProjectSet certainly projects, say "no" because we
			 * don't want the planner to randomly replace its tlist with
			 * something else; the SRFs have to stay at top level.  This might
			 * get relaxed later.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plan_pushdown_tlist
 *
 * If the given Plan node does projection, the same node is returned after
 * replacing its targetlist with the given targetlist.
 *
 * Otherwise, returns a Result node with the given targetlist, inserted atop
 * the given plan.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>plan_pushdown_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>tlist_same_exprs</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>need_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>need_result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_result</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Install the new targetlist. */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name>plan</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Insert a Result node to evaluate the targetlist. */</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>inject_projection_plan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>	<comment type="block">/* plan_pushdown_tlist */</comment>

<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>find_junk_tle</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>junkAttrName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>lct</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lct</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name>	<modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name><operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>junkAttrName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tle</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpathtoplan_create_motion_plan
 */</comment>
<function><type><specifier>static</specifier> <name>Motion</name> <modifier>*</modifier></type>
<name>cdbpathtoplan_create_motion_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
								 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>subpath</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * numHashSegments is only used for hash motion.
	 * It's the module number of the cdb hash, its value
	 * is not necessarily the same as the number of segments
	 * in the parent slice.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numHashSegments</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>numHashSegments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>is_explicit_motion</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>segmentid_tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The junk columns in the subplan need to be labeled as such, otherwise
		 * we won't find the "gp_segment_id" column.
		 *
		 * The target list of a SplitUpdate is correctly labeled already. It has
		 * different layout than normal ModifyTable inputs, because it contains
		 * the DMLActionExpr column, so we cannot apply the
		 * labeling here even if we wanted.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>SplitUpdate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>apply_tlist_labeling</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>segmentid_tle</name> <operator>=</operator> <call><name>find_junk_tle</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><literal type="string">"gp_segment_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>segmentid_tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find gp_segment_id in subplan's targetlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>motion</name> <operator>=</operator> <operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <call><name>make_explicit_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name><name>segmentid_tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>policy</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashExprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashOpfamilies</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>hashExprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>hashExprs</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hashOpfamilies</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>hashOpfamilies</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_hashed_motion</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>,
									<argument><expr><name>hashExprs</name></expr></argument>,
									<argument><expr><name>hashOpfamilies</name></expr></argument>,
									<argument><expr><name>numHashSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_union_motion</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <name>MOTIONTYPE_OUTER_QUERY</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* Send all tuples to a single process? */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>prep</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numSortCols</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name>		<modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Build sort key info to define our Merge Receive keys.
			 */</comment>
			<expr_stmt><expr><name>prep</name> <operator>=</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>,
											  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
											  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>numSortCols</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>prep</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Create a Merge Receive to preserve ordering.
				 *
				 * prepare_sort_from_pathkeys() might return a Result node, if
				 * one would needs to be inserted above the Sort. We don't
				 * create an actual Sort node here, the input is already
				 * ordered, but use the Result node, if any, as the input to
				 * the Motion node. (I'm not sure if that is possible with
				 * Gather Motion nodes. Since the input is already ordered,
				 * presumably the target list already contains the expressions
				 * for the key columns. But better safe than sorry.)
				 */</comment>
				<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name>prep</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_sorted_union_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>numSortCols</name></expr></argument>, <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name>collations</name></expr></argument>,
												  <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Degenerate ordering... build unordered Union Receive */</comment>
				<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_union_motion</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/* Unordered Union Receive */</comment>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_union_motion</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>

	<comment type="block">/* Send all of the tuples to all of the QEs in gang above... */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_broadcast_motion</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/* Hashed redistribution to all QEs in gang above... */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashExprs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashOpfamilies</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cdbpathlocus_get_distkey_exprs</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>,
									   <argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									   <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>hashExprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashOpfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hashExprs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find hash distribution key expressions in target list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_hashed_motion</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>,
									<argument><expr><name>hashExprs</name></expr></argument>,
									<argument><expr><name>hashOpfamilies</name></expr></argument>,
									<argument><expr><name>numHashSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
	<comment type="block">/* Hashed redistribution to all QEs in gang above... */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsStrewn</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_hashed_motion</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name>numHashSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected target locus type %d for Motion node"</literal></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name><operator>.</operator><name>locustype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Remember that this subtree contains a Motion */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>numMotions</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>motion</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpathtoplan_create_motion_plan */</comment>

<comment type="block">/*
 * append_initplan_for_function_scan
 *
 * CDB: gpdb specific function to append an initplan node for function scan.
 *
 * Note that append initplan for function scan node only takes effect when
 * the function location is PROEXECLOCATION_INITPLAN and optimizer is off.
 *
 * Considering functions which include DDLs, they cannot run on QEs.
 * But for query like 'create table t as select * from f();' QD needs to do
 * the CTAS work and function f() will be run on EntryDB, which is also a QE.
 * To support this kind of query in GPDB, we run the function scan on initplan
 * firstly, and store the results into tuplestore, later the function scan
 * on EnrtyDB could fetch tuple from tuplestore instead of executing the real
 * fucntion.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_initplan_for_function_scan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>fsplan</name> <init>= <expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name>exec_location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Param</name>	<modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblFunction</name>	<modifier>*</modifier></type><name>rtfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>	<modifier>*</modifier></type><name>funcexpr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In utility mode (or when planning a local query in QE), ignore EXECUTE
	 * ON markings and run the function the normal way.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If INITPLAN function is executed on QD, there is no 
	 * need to add additional initplan to run this function.
	 * Recall that the reason to introduce INITPLAN function
	 * is that function runing on QE can not do dispatch.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Currently we limit function number to one */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rtfunc</name> <operator>=</operator> <operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* function must be specified EXECUTE ON INITPLAN */</comment>
	<expr_stmt><expr><name>funcexpr</name> <operator>=</operator> <operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>exec_location</name> <operator>=</operator> <call><name>func_exec_location</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>exec_location</name> <operator>!=</operator> <name>PROEXECLOCATION_INITPLAN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* 
	 * create a copied FunctionScan plan as a initplan
	 * Initplan is responsible to run the real function
	 * and store the result into tuplestore.
	 * Original FunctionScan just read the tuple store
	 * (indicated by resultInTupleStore) and return the
	 * result to upper plan node.
	 *
	 * the following param of initplan is a dummy param.
	 * this param is not used by the main plan, since when
	 * function scan is running in initplan, it stores the
	 * result rows in tuplestore instead of a scalar param
	 */</comment>
	<expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>,
											 <argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fsplan</name><operator>-&gt;</operator><name>param</name></name> <operator>=</operator> <name>prm</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsplan</name><operator>-&gt;</operator><name>resultInTupleStore</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We are going to construct what is effectively a sub-SELECT query, so
	 * clone the current query level's state and adjust it to make it look
	 * like a subquery.  Any outer references will now be one level higher
	 * than before.  (This means that when we are done, there will be no Vars
	 * of level 1, which is why the subquery can become an initplan.)
	 */</comment>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>subroot</name> <operator>=</operator> <operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>query_level</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parent_root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<comment type="block">/* reset subplan-related stuff */</comment>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>outer_params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>parse</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parse</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* append_rel_list might contain outer Vars? */</comment>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create initplan for this FunctionScan plan */</comment>
	<decl_stmt><decl><type><name>FunctionScan</name><modifier>*</modifier></type> <name>initplan</name> <init>=<expr><operator>(</operator><name>FunctionScan</name><operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>initplan</name><operator>-&gt;</operator><name>resultInTupleStore</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>SS_make_initplan_from_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>initplan</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curSlice</name></name></expr></argument>, <argument><expr><name>prm</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* record the initplan id which is used to find the right tuplestore */</comment>
	<expr_stmt><expr><name><name>fsplan</name><operator>-&gt;</operator><name>initplanId</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Decorate the top node of the plan with a Flow node. */</comment>
	<expr_stmt><expr><name><name>initplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>flow</name></name> <operator>=</operator> <call><name>cdbpathtoplan_create_flow</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * contain_motion
 * This function walks the joinqual list to  see there is
 * any motion node in it. The only case a qual contains motion
 * is that it is a SubPlan and the SubPlan contains motion.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>contain_motion_walk_context</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>planner_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>seen_subplans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>contain_motion_walk</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ctx</name><operator>.</operator><name>result</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_motion_walk</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>contain_motion_walk_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>node</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>	   <modifier>*</modifier></type><name>spexpr</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>plan_id</name> <init>= <expr><name><name>spexpr</name><operator>-&gt;</operator><name>plan_id</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>plan_id</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>seen_subplans</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>seen_subplans</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>seen_subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>spexpr</name><operator>-&gt;</operator><name>is_initplan</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>contain_motion_walk</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>contain_motion_walk</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
