<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/util/pathnode.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pathnode.c
 *	  Routines to manipulate pathlists and create path nodes
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/pathnode.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/appendinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>        <comment type="block">/* cdb_default_distribution_opfamily_for_type() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmutate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpath.h"</cpp:file></cpp:include>        <comment type="block">/* cdb_create_motion_path() etc */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpathlocus.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>		<comment type="block">/* getgpsegmentCount() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>COSTS_EQUAL</name></decl>,				<comment type="block">/* path costs are fuzzily equal */</comment>
	<decl><name>COSTS_BETTER1</name></decl>,				<comment type="block">/* first path is cheaper than second */</comment>
	<decl><name>COSTS_BETTER2</name></decl>,				<comment type="block">/* second path is cheaper than first */</comment>
	<decl><name>COSTS_DIFFERENT</name></decl>				<comment type="block">/* neither path dominates the other on cost */</comment>
}</block></enum></type> <name>PathCostComparison</name>;</typedef>

<comment type="block">/*
 * STD_FUZZ_FACTOR is the normal fuzz factor for compare_path_costs_fuzzily.
 * XXX is it worth making this user-controllable?  It provides a tradeoff
 * between planner runtime and the accuracy of path cost comparisons.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STD_FUZZ_FACTOR</name></cpp:macro> <cpp:value>1.01</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>translate_sub_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>append_total_cost_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>append_startup_cost_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>reparameterize_pathlist_by_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathlist</name></decl></parameter>,
											  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>set_append_path_locus</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CdbPathLocus</name></type>
<name>adjust_modifytable_subpaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultRelations</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>is_split_updates</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/*****************************************************************************
 *		MISC. PATH UTILITIES
 *****************************************************************************/</comment>

<comment type="block">/*
 * compare_path_costs
 *	  Return -1, 0, or +1 according as path1 is cheaper, the same cost,
 *	  or more expensive than path2 for the specified criterion.
 */</comment>
<function><type><name>int</name></type>
<name>compare_path_costs</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>, <parameter><decl><type><name>CostSelector</name></type> <name>criterion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>criterion</name> <operator>==</operator> <name>STARTUP_COST</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&lt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If paths have the same startup cost (not at all unlikely), order
		 * them by total cost.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If paths have the same total cost, order them by startup cost.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&lt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compare_path_fractional_costs
 *	  Return -1, 0, or +1 according as path1 is cheaper, the same cost,
 *	  or more expensive than path2 for fetching the specified fraction
 *	  of the total tuples.
 *
 * If fraction is &lt;= 0 or &gt; 1, we interpret it as 1, ie, we select the
 * path with the cheaper total_cost.
 */</comment>
<function><type><name>int</name></type>
<name>compare_fractional_path_costs</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>,
							  <parameter><decl><type><name>double</name></type> <name>fraction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cost1</name></decl>,
				<decl><type ref="prev"/><name>cost2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fraction</name> <operator>&lt;=</operator> <literal type="number">0.0</literal> <operator>||</operator> <name>fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>compare_path_costs</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>cost1</name> <operator>=</operator> <name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
		<name>fraction</name> <operator>*</operator> <operator>(</operator><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>cost2</name> <operator>=</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
		<name>fraction</name> <operator>*</operator> <operator>(</operator><name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cost1</name> <operator>&lt;</operator> <name>cost2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cost1</name> <operator>&gt;</operator> <name>cost2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compare_path_costs_fuzzily
 *	  Compare the costs of two paths to see if either can be said to
 *	  dominate the other.
 *
 * We use fuzzy comparisons so that add_path() can avoid keeping both of
 * a pair of paths that really have insignificantly different cost.
 *
 * The fuzz_factor argument must be 1.0 plus delta, where delta is the
 * fraction of the smaller cost that is considered to be a significant
 * difference.  For example, fuzz_factor = 1.01 makes the fuzziness limit
 * be 1% of the smaller cost.
 *
 * The two paths are said to have "equal" costs if both startup and total
 * costs are fuzzily the same.  Path1 is said to be better than path2 if
 * it has fuzzily better startup cost and fuzzily no worse total cost,
 * or if it has fuzzily better total cost and fuzzily no worse startup cost.
 * Path2 is better than path1 if the reverse holds.  Finally, if one path
 * is fuzzily better than the other on startup cost and fuzzily worse on
 * total cost, we just say that their costs are "different", since neither
 * dominates the other across the whole performance spectrum.
 *
 * This function also enforces a policy rule that paths for which the relevant
 * one of parent-&gt;consider_startup and parent-&gt;consider_param_startup is false
 * cannot survive comparisons solely on the grounds of good startup cost, so
 * we never return COSTS_DIFFERENT when that is true for the total-cost loser.
 * (But if total costs are fuzzily equal, we compare startup costs anyway,
 * in hopes of eliminating one path or the other.)
 */</comment>
<function><type><specifier>static</specifier> <name>PathCostComparison</name></type>
<name>compare_path_costs_fuzzily</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>fuzz_factor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSIDER_PATH_STARTUP_COST</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>((p)-&gt;param_info == NULL ? (p)-&gt;parent-&gt;consider_startup : (p)-&gt;parent-&gt;consider_param_startup)</cpp:value></cpp:define>

	<comment type="block">/*
	 * Check total cost first since it's more likely to be different; many
	 * paths have zero startup cost.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* path1 fuzzily worse on total cost */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CONSIDER_PATH_STARTUP_COST</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ... but path2 fuzzily worse on startup, so DIFFERENT */</comment>
			<return>return <expr><name>COSTS_DIFFERENT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* else path2 dominates */</comment>
		<return>return <expr><name>COSTS_BETTER2</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* path2 fuzzily worse on total cost */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CONSIDER_PATH_STARTUP_COST</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ... but path1 fuzzily worse on startup, so DIFFERENT */</comment>
			<return>return <expr><name>COSTS_DIFFERENT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* else path1 dominates */</comment>
		<return>return <expr><name>COSTS_BETTER1</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* fuzzily the same on total cost ... */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ... but path1 fuzzily worse on startup, so path2 wins */</comment>
		<return>return <expr><name>COSTS_BETTER2</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ... but path2 fuzzily worse on startup, so path1 wins */</comment>
		<return>return <expr><name>COSTS_BETTER1</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* fuzzily the same on both costs */</comment>
	<return>return <expr><name>COSTS_EQUAL</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONSIDER_PATH_STARTUP_COST</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/*
 * set_cheapest
 *	  Find the minimum-cost paths from among a relation's paths,
 *	  and save them in the rel's cheapest-path fields.
 *
 * cheapest_total_path is normally the cheapest-total-cost unparameterized
 * path; but if there are no unparameterized paths, we assign it to be the
 * best (cheapest least-parameterized) parameterized path.  However, only
 * unparameterized paths are considered candidates for cheapest_startup_path,
 * so that will be NULL if there are no unparameterized paths.
 *
 * The cheapest_parameterized_paths list collects all parameterized paths
 * that have survived the add_path() tournament for this relation.  (Since
 * add_path ignores pathkeys for a parameterized path, these will be paths
 * that have best cost or best row count for their parameterization.  We
 * may also have both a parallel-safe and a non-parallel-safe path in some
 * cases for the same parameterization in some cases, but this should be
 * relatively rare since, most typically, all paths for the same relation
 * will be parallel-safe or none of them will.)
 *
 * cheapest_parameterized_paths always includes the cheapest-total
 * unparameterized path, too, if there is one; the users of that list find
 * it more convenient if that's included.
 *
 * This is normally called only after we've finished constructing the path
 * list for the rel node.
 */</comment>
<function><type><name>void</name></type>
<name>set_cheapest</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_startup_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_total_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>best_param_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parameterized_paths</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not devise a query plan for the given query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cheapest_startup_path</name> <operator>=</operator> <name>cheapest_total_path</name> <operator>=</operator> <name>best_param_path</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parameterized_paths</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>p</argument>, <argument>parent_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Parameterized path, so add it to parameterized_paths */</comment>
			<expr_stmt><expr><name>parameterized_paths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parameterized_paths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we have an unparameterized cheapest-total, we no longer care
			 * about finding the best parameterized path, so move on.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise, track the best parameterized path, which is the one
			 * with least total cost among those of the minimum
			 * parameterization.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>best_param_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>best_param_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<switch>switch <condition>(<expr><call><name>bms_subset_compare</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>best_param_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>BMS_EQUAL</name></expr>:</case>
						<comment type="block">/* keep the cheaper one */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>compare_path_costs</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>best_param_path</name></expr></argument>,
											   <argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>best_param_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>BMS_SUBSET1</name></expr>:</case>
						<comment type="block">/* new path is less-parameterized */</comment>
						<expr_stmt><expr><name>best_param_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>BMS_SUBSET2</name></expr>:</case>
						<comment type="block">/* old path is less-parameterized, keep it */</comment>
						<break>break;</break>
					<case>case <expr><name>BMS_DIFFERENT</name></expr>:</case>

						<comment type="block">/*
						 * This means that neither path has the least possible
						 * parameterization for the rel.  We'll sit on the old
						 * path until something better comes along.
						 */</comment>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Unparameterized path, so consider it for cheapest slots */</comment>
			<if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cheapest_startup_path</name> <operator>=</operator> <name>cheapest_total_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we find two paths of identical costs, try to keep the
			 * better-sorted one.  The paths might have unrelated sort
			 * orderings, in which case we can only guess which might be
			 * better to keep, but if one is superior then we definitely
			 * should keep that one.
			 */</comment>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>compare_path_costs</name><argument_list>(<argument><expr><name>cheapest_startup_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>STARTUP_COST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name><name>cheapest_startup_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
								  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PATHKEYS_BETTER2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cheapest_startup_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>compare_path_costs</name><argument_list>(<argument><expr><name>cheapest_total_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name><name>cheapest_total_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
								  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PATHKEYS_BETTER2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cheapest_total_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Add cheapest unparameterized path, if any, to parameterized_paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>parameterized_paths</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>cheapest_total_path</name></expr></argument>, <argument><expr><name>parameterized_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there is no unparameterized path, use the best parameterized path as
	 * cheapest_total_path (but not as cheapest_startup_path).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cheapest_total_path</name> <operator>=</operator> <name>best_param_path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cheapest_total_path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>cheapest_startup_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>cheapest_total_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* computed only if needed */</comment>
	<expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_parameterized_paths</name></name> <operator>=</operator> <name>parameterized_paths</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_path
 *	  Consider a potential implementation path for the specified parent rel,
 *	  and add it to the rel's pathlist if it is worthy of consideration.
 *	  A path is worthy if it has a better sort order (better pathkeys) or
 *	  cheaper cost (on either dimension), or generates fewer rows, than any
 *	  existing path that has the same or superset parameterization rels.
 *	  We also consider parallel-safe paths more worthy than others.
 *
 *	  We also remove from the rel's pathlist any old paths that are dominated
 *	  by new_path --- that is, new_path is cheaper, at least as well ordered,
 *	  generates no more rows, requires no outer rels not required by the old
 *	  path, and is no less parallel-safe.
 *
 *	  In most cases, a path with a superset parameterization will generate
 *	  fewer rows (since it has more join clauses to apply), so that those two
 *	  figures of merit move in opposite directions; this means that a path of
 *	  one parameterization can seldom dominate a path of another.  But such
 *	  cases do arise, so we make the full set of checks anyway.
 *
 *	  There are two policy decisions embedded in this function, along with
 *	  its sibling add_path_precheck.  First, we treat all parameterized paths
 *	  as having NIL pathkeys, so that they cannot win comparisons on the
 *	  basis of sort order.  This is to reduce the number of parameterized
 *	  paths that are kept; see discussion in src/backend/optimizer/README.
 *
 *	  Second, we only consider cheap startup cost to be interesting if
 *	  parent_rel-&gt;consider_startup is true for an unparameterized path, or
 *	  parent_rel-&gt;consider_param_startup is true for a parameterized one.
 *	  Again, this allows discarding useless paths sooner.
 *
 *	  The pathlist is kept sorted by total_cost, with cheaper paths
 *	  at the front.  Within this routine, that's simply a speed hack:
 *	  doing it that way makes it more likely that we will reject an inferior
 *	  path after a few comparisons, rather than many comparisons.
 *	  However, add_path_precheck relies on this ordering to exit early
 *	  when possible.
 *
 *	  NOTE: discarded Path objects are immediately pfree'd to reduce planner
 *	  memory consumption.  We dare not try to free the substructure of a Path,
 *	  since much of it may be shared with other Paths or the query tree itself;
 *	  but just recycling discarded Path nodes is a very useful savings in
 *	  a large join tree.  We can recycle the List nodes of pathlist, too.
 *
 *	  NB: The Path that is passed to add_path() must be considered invalid
 *	  upon return, and not touched again by the caller, because we free it
 *	  if we already know of a better path.  Likewise, a Path that is passed
 *	  to add_path() must not be shared as a subpath of any other Path of the
 *	  same join level.
 *
 *	  As noted in optimizer/README, deleting a previously-accepted Path is
 *	  safe because we know that Paths of this rel cannot yet be referenced
 *	  from any other rel, such as a higher-level join.  However, in some cases
 *	  it is possible that a Path is referenced by another Path for its own
 *	  rel; we must not delete such a Path, even if it is dominated by the new
 *	  Path.  Currently this occurs only for IndexPath objects, which may be
 *	  referenced as children of BitmapHeapPaths as well as being paths in
 *	  their own right.  Hence, we don't pfree IndexPaths when rejecting them.
 *
 * 'parent_rel' is the relation entry to which the path corresponds.
 * 'new_path' is a potential path for parent_rel.
 *
 * Returns nothing, but modifies parent_rel-&gt;pathlist.
 */</comment>
<function><type><name>void</name></type>
<name>add_path</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>new_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>accept_new</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* unless we find a superior old path */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>insert_after</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* where to insert new item */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_path_pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1_prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1_next</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is a convenient place to check for query cancel --- no part of the
	 * planner goes very long without calling add_path().
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_path</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * GPDB: Check that the correct locus has been determined for the Path.
	 * This can easily be missing from upstream code that construct Paths
	 * that haven't been modified in GPDB to set the locus correctly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbLocusType_IsValid</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>locustype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"path of type %u is missing distribution locus"</literal></expr></argument>, <argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pretend parameterized paths have no pathkeys, per comment above */</comment>
	<expr_stmt><expr><name>new_path_pathkeys</name> <operator>=</operator> <ternary><condition><expr><name><name>new_path</name><operator>-&gt;</operator><name>param_info</name></name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name><name>new_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop to check proposed new path against old paths.  Note it is possible
	 * for more than one old path to be tossed out because new_path dominates
	 * it.
	 *
	 * We can't use foreach here because the loop body may delete the current
	 * list cell.
	 */</comment>
	<expr_stmt><expr><name>p1_prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p1</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>p1</name> <operator>=</operator> <name>p1_next</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>old_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>remove_old</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* unless new proves superior */</comment>
		<decl_stmt><decl><type><name>PathCostComparison</name></type> <name>costcmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKeysComparison</name></type> <name>keyscmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMS_Comparison</name></type> <name>outercmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>p1_next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do a fuzzy cost comparison with standard fuzziness limit.
		 */</comment>
		<expr_stmt><expr><name>costcmp</name> <operator>=</operator> <call><name>compare_path_costs_fuzzily</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>old_path</name></expr></argument>,
											 <argument><expr><name>STD_FUZZ_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the two paths compare differently for startup and total cost,
		 * then we want to keep both, and we can skip comparing pathkeys and
		 * required_outer rels.  If they compare the same, proceed with the
		 * other comparisons.  Row count is checked last.  (We make the tests
		 * in this order because the cost comparison is most likely to turn
		 * out "different", and the pathkeys comparison next most likely.  As
		 * explained above, row count very seldom makes a difference, so even
		 * though it's cheap to compare there's not much point in checking it
		 * earlier.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>costcmp</name> <operator>!=</operator> <name>COSTS_DIFFERENT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Similarly check to see if either dominates on pathkeys */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>old_path_pathkeys</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>old_path_pathkeys</name> <operator>=</operator> <ternary><condition><expr><name><name>old_path</name><operator>-&gt;</operator><name>param_info</name></name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name><name>old_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>keyscmp</name> <operator>=</operator> <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name>new_path_pathkeys</name></expr></argument>,
									   <argument><expr><name>old_path_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * GPDB: If the new path has different locus than the other path,
			 * keep it, like we keep paths with different pathkeys. We can
			 * avoid the (Gather) Motion at the top of the plan, if we choose
			 * a plan that produces the result at the right locus to begin
			 * with. In particular, if it's a two-stage aggregate plan, it might
			 * be cheaper to perform the Finalize Aggregate stage in the QD than
			 * redistribute it to all segments, if that avoids a Gather Motion
			 * at the top.
			 *
			 * Only do this for the "upper rels". The join planning code hasn't
			 * been updated to consider plans with multiple loci. Keeping extra
			 * paths might be a win, but it might also lead to erratic behavior.
			 * For example, a Hash Join only considers the cheapest input paths,
			 * but a Merge Join would consider all paths with sorted input. A
			 * path with a suitable locus migh therefore win with a Merge Join
			 * but not even be considered a Hash Join, even though the Hash Join
			 * path would be cheaper.
			 *
			 * Parts of the upper planner functions could have similar issues,
			 * but it seems more limited in scope.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_DIFFERENT</name> <operator>&amp;&amp;</operator>
				<name><name>parent_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_UPPER_REL</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>cdbpathlocus_equal</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name><name>old_path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>keyscmp</name> <operator>=</operator> <name>PATHKEYS_DIFFERENT</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_DIFFERENT</name></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name>costcmp</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>COSTS_EQUAL</name></expr>:</case>
						<expr_stmt><expr><name>outercmp</name> <operator>=</operator> <call><name>bms_subset_compare</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name> <operator>||</operator>
								 <name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET1</name><operator>)</operator> <operator>&amp;&amp;</operator>
								<name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
								<name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* new dominates old */</comment>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name> <operator>||</operator>
								 <name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET2</name><operator>)</operator> <operator>&amp;&amp;</operator>
								<name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
								<name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* old dominates new */</comment>
						</block_content>}</block></if>
						<else>else	<comment type="block">/* keyscmp == PATHKEYS_EQUAL */</comment>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/*
								 * Same pathkeys and outer rels, and fuzzily
								 * the same cost, so keep just one; to decide
								 * which, first check parallel-safety, then
								 * rows, then do a fuzzy cost comparison with
								 * very small fuzz limit.  (We used to do an
								 * exact cost comparison, but that results in
								 * annoying platform-specific plan variations
								 * due to roundoff in the cost estimates.)	If
								 * things are still tied, arbitrarily keep
								 * only the old path.  Notice that we will
								 * keep only the old path even if the
								 * less-fuzzy comparison decides the startup
								 * and total costs compare differently.
								 */</comment>
								<if_stmt><if>if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&gt;</operator>
									<name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* new dominates old */</comment>
								<if type="elseif">else if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&lt;</operator>
										 <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* old dominates new */</comment>
								<if type="elseif">else if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* new dominates old */</comment>
								<if type="elseif">else if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* old dominates new */</comment>
								<if type="elseif">else if <condition>(<expr><call><name>compare_path_costs_fuzzily</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>,
																	<argument><expr><name>old_path</name></expr></argument>,
																	<argument><expr><literal type="number">1.0000000001</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>COSTS_BETTER1</name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* new dominates old */</comment>
								<else>else<block type="pseudo"><block_content>
									<expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* old equals or
														 * dominates new */</comment>
							</block_content>}</block></if>
							<if type="elseif">else if <condition>(<expr><name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET1</name> <operator>&amp;&amp;</operator>
									 <name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
									 <name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* new dominates old */</comment>
							<if type="elseif">else if <condition>(<expr><name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET2</name> <operator>&amp;&amp;</operator>
									 <name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
									 <name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* old dominates new */</comment>
							<comment type="block">/* else different parameterizations, keep both */</comment>
						</block_content>}</block></else></if_stmt>
						<break>break;</break>
					<case>case <expr><name>COSTS_BETTER1</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>outercmp</name> <operator>=</operator> <call><name>bms_subset_compare</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name> <operator>||</operator>
								 <name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET1</name><operator>)</operator> <operator>&amp;&amp;</operator>
								<name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
								<name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* new dominates old */</comment>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>COSTS_BETTER2</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>outercmp</name> <operator>=</operator> <call><name>bms_subset_compare</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name> <operator>||</operator>
								 <name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET2</name><operator>)</operator> <operator>&amp;&amp;</operator>
								<name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
								<name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* old dominates new */</comment>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>COSTS_DIFFERENT</name></expr>:</case>

						<comment type="block">/*
						 * can't get here, but keep this case to keep compiler
						 * quiet
						 */</comment>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Remove current element from pathlist if dominated by new.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remove_old</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>,
													<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p1_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Delete the data pointed-to by the deleted cell, if possible
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* p1_prev does not advance */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* new belongs after this old path if it has cost &gt;= old's */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>insert_after</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* p1_prev advances */</comment>
			<expr_stmt><expr><name>p1_prev</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we found an old path that dominates new_path, we can quit
		 * scanning the pathlist; we will not add new_path, and we assume
		 * new_path cannot dominate any other elements of the pathlist.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>accept_new</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>accept_new</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Accept the new path: insert it at proper place in pathlist */</comment>
		<if_stmt><if>if <condition>(<expr><name>insert_after</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>lappend_cell</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>, <argument><expr><name>insert_after</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Reject and recycle the new path */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>                               <comment type="block">/* add_path */</comment>

<comment type="block">/*
 * add_path_precheck
 *	  Check whether a proposed new path could possibly get accepted.
 *	  We assume we know the path's pathkeys and parameterization accurately,
 *	  and have lower bounds for its costs.
 *
 * Note that we do not know the path's rowcount, since getting an estimate for
 * that is too expensive to do before prechecking.  We assume here that paths
 * of a superset parameterization will generate fewer rows; if that holds,
 * then paths with different parameterizations cannot dominate each other
 * and so we can simply ignore existing paths of another parameterization.
 * (In the infrequent cases where that rule of thumb fails, add_path will
 * get rid of the inferior path.)
 *
 * At the time this is called, we haven't actually built a Path structure,
 * so the required information has to be passed piecemeal.
 */</comment>
<function><type><name>bool</name></type>
<name>add_path_precheck</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>,
				  <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_path_pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>consider_startup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

	<comment type="block">/* Pretend parameterized paths have no pathkeys, per add_path policy */</comment>
	<expr_stmt><expr><name>new_path_pathkeys</name> <operator>=</operator> <ternary><condition><expr><name>required_outer</name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name>pathkeys</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Decide whether new path's startup cost is interesting */</comment>
	<expr_stmt><expr><name>consider_startup</name> <operator>=</operator> <ternary><condition><expr><name>required_outer</name></expr> ?</condition><then> <expr><name><name>parent_rel</name><operator>-&gt;</operator><name>consider_param_startup</name></name></expr> </then><else>: <expr><name><name>parent_rel</name><operator>-&gt;</operator><name>consider_startup</name></name></expr></else></ternary></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>p1</argument>, <argument>parent_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>old_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKeysComparison</name></type> <name>keyscmp</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We are looking for an old_path with the same parameterization (and
		 * by assumption the same rowcount) that dominates the new path on
		 * pathkeys as well as both cost metrics.  If we find one, we can
		 * reject the new path.
		 *
		 * Cost comparisons here should match compare_path_costs_fuzzily.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>total_cost</name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* new path can win on startup cost only if consider_startup */</comment>
			<if_stmt><if>if <condition>(<expr><name>startup_cost</name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name> <operator>||</operator>
				<operator>!</operator><name>consider_startup</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* new path loses on cost, so check pathkeys... */</comment>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>old_path_pathkeys</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>old_path_pathkeys</name> <operator>=</operator> <ternary><condition><expr><name><name>old_path</name><operator>-&gt;</operator><name>param_info</name></name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name><name>old_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name>keyscmp</name> <operator>=</operator> <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name>new_path_pathkeys</name></expr></argument>,
										   <argument><expr><name>old_path_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_EQUAL</name> <operator>||</operator>
					<name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* new path does not win on pathkeys... */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Found an old path that dominates the new one */</comment>
						<return>return <expr><name>false</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Since the pathlist is sorted by total_cost, we can stop looking
			 * once we reach a path with a total_cost larger than the new
			 * path's.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_partial_path
 *	  Like add_path, our goal here is to consider whether a path is worthy
 *	  of being kept around, but the considerations here are a bit different.
 *	  A partial path is one which can be executed in any number of workers in
 *	  parallel such that each worker will generate a subset of the path's
 *	  overall result.
 *
 *	  As in add_path, the partial_pathlist is kept sorted with the cheapest
 *	  total path in front.  This is depended on by multiple places, which
 *	  just take the front entry as the cheapest path without searching.
 *
 *	  We don't generate parameterized partial paths for several reasons.  Most
 *	  importantly, they're not safe to execute, because there's nothing to
 *	  make sure that a parallel scan within the parameterized portion of the
 *	  plan is running with the same value in every worker at the same time.
 *	  Fortunately, it seems unlikely to be worthwhile anyway, because having
 *	  each worker scan the entire outer relation and a subset of the inner
 *	  relation will generally be a terrible plan.  The inner (parameterized)
 *	  side of the plan will be small anyway.  There could be rare cases where
 *	  this wins big - e.g. if join order constraints put a 1-row relation on
 *	  the outer side of the topmost join with a parameterized plan on the inner
 *	  side - but we'll have to be content not to handle such cases until
 *	  somebody builds an executor infrastructure that can cope with them.
 *
 *	  Because we don't consider parameterized paths here, we also don't
 *	  need to consider the row counts as a measure of quality: every path will
 *	  produce the same number of rows.  Neither do we need to consider startup
 *	  costs: parallelism is only used for plans that will be run to completion.
 *	  Therefore, this routine is much simpler than add_path: it needs to
 *	  consider only pathkeys and total cost.
 *
 *	  As with add_path, we pfree paths that are found to be dominated by
 *	  another partial path; this requires that there be no other references to
 *	  such paths yet.  Hence, GatherPaths must not be created for a rel until
 *	  we're done creating all partial paths for it.  Unlike add_path, we don't
 *	  take an exception for IndexPaths as partial index paths won't be
 *	  referenced by partial BitmapHeapPaths.
 */</comment>
<function><type><name>void</name></type>
<name>add_partial_path</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>new_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>accept_new</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* unless we find a superior old path */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>insert_after</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* where to insert new item */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1_prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1_next</name></decl>;</decl_stmt>

	<comment type="block">/* Check for query cancel. */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Path to be added must be parallel safe. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Relation should be OK for parallelism, too. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * As in add_path, throw out any paths which are dominated by the new
	 * path, but throw out the new path if some existing path dominates it.
	 */</comment>
	<expr_stmt><expr><name>p1_prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p1</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>p1</name> <operator>=</operator> <name>p1_next</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>old_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>remove_old</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* unless new proves superior */</comment>
		<decl_stmt><decl><type><name>PathKeysComparison</name></type> <name>keyscmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>p1_next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Compare pathkeys. */</comment>
		<expr_stmt><expr><name>keyscmp</name> <operator>=</operator> <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>, <argument><expr><name><name>old_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Unless pathkeys are incompable, keep just one of the two paths. */</comment>
		<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_DIFFERENT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* New path costs more; keep it only if pathkeys are better. */</comment>
				<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name>
					 <operator>*</operator> <name>STD_FUZZ_FACTOR</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Old path costs more; keep it only if pathkeys are better. */</comment>
				<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Costs are about the same, new path has better pathkeys. */</comment>
				<expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Costs are about the same, old path has better pathkeys. */</comment>
				<expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <literal type="number">1.0000000001</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Pathkeys are the same, and the old path costs more. */</comment>
				<expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Pathkeys are the same, and new path isn't materially
				 * cheaper.
				 */</comment>
				<expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Remove current element from partial_pathlist if dominated by new.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remove_old</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator>
				<call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p1_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* p1_prev does not advance */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* new belongs after this old path if it has cost &gt;= old's */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>insert_after</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* p1_prev advances */</comment>
			<expr_stmt><expr><name>p1_prev</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we found an old path that dominates new_path, we can quit
		 * scanning the partial_pathlist; we will not add new_path, and we
		 * assume new_path cannot dominate any later path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>accept_new</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>accept_new</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Accept the new path: insert it at proper place */</comment>
		<if_stmt><if>if <condition>(<expr><name>insert_after</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>lappend_cell</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>, <argument><expr><name>insert_after</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator>
				<call><name>lcons</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Reject and recycle the new path */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_partial_path_precheck
 *	  Check whether a proposed new partial path could possibly get accepted.
 *
 * Unlike add_path_precheck, we can ignore startup cost and parameterization,
 * since they don't matter for partial paths (see add_partial_path).  But
 * we do want to make sure we don't add a partial path if there's already
 * a complete path that dominates it, since in that case the proposed path
 * is surely a loser.
 */</comment>
<function><type><name>bool</name></type>
<name>add_partial_path_precheck</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Our goal here is twofold.  First, we want to find out whether this path
	 * is clearly inferior to some existing partial path.  If so, we want to
	 * reject it immediately.  Second, we want to find out whether this path
	 * is clearly superior to some existing partial path -- at least, modulo
	 * final cost computations.  If so, we definitely want to consider it.
	 *
	 * Unlike add_path(), we always compare pathkeys here.  This is because we
	 * expect partial_pathlist to be very short, and getting a definitive
	 * answer at this stage avoids the need to call add_path_precheck.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>p1</argument>, <argument>parent_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>old_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKeysComparison</name></type> <name>keyscmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>keyscmp</name> <operator>=</operator> <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>old_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_DIFFERENT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>total_cost</name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name> <operator>&amp;&amp;</operator>
				<name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name>total_cost</name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name> <operator>&amp;&amp;</operator>
				<name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * This path is neither clearly inferior to an existing partial path nor
	 * clearly good enough that it might replace one.  Compare it to
	 * non-parallel plans.  If it loses even before accounting for the cost of
	 * the Gather node, we should definitely reject it.
	 *
	 * Note that we pass the total_cost to add_path_precheck twice.  This is
	 * because it's never advantageous to consider the startup cost of a
	 * partial path; the resulting plans, if run in parallel, will be run to
	 * completion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_path_precheck</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>total_cost</name></expr></argument>, <argument><expr><name>total_cost</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *		PATH NODE CREATION ROUTINES
 *****************************************************************************/</comment>

<comment type="block">/*
 * create_seqscan_path
 *	  Creates a path corresponding to a sequential scan, returning the
 *	  pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_seqscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					<parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_SeqScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <ternary><condition><expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <name>parallel_workers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* seqscan has unordered result */</comment>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <call><name>cdbpathlocus_from_baserel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>sameslice_relids</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_seqscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_samplescan_path
 *	  Creates a path node for a sampled table scan.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_samplescan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_SampleScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* samplescan has unordered result */</comment>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <call><name>cdbpathlocus_from_baserel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>sameslice_relids</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_samplescan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_index_path
 *	  Creates a path node for an index scan.
 *
 * 'index' is a usable index.
 * 'indexclauses' is a list of IndexClause nodes representing clauses
 *			to be enforced as qual conditions in the scan.
 * 'indexorderbys' is a list of bare expressions (no RestrictInfos)
 *			to be used as index ordering operators in the scan.
 * 'indexorderbycols' is an integer list of index column numbers (zero based)
 *			the ordering operators can be used with.
 * 'pathkeys' describes the ordering of the path.
 * 'indexscandir' is ForwardScanDirection or BackwardScanDirection
 *			for an ordered index, or NoMovementScanDirection for
 *			an unordered index.
 * 'indexonly' is true if an index-only scan is wanted.
 * 'required_outer' is the set of outer relids for a parameterized path.
 * 'loop_count' is the number of repetitions of the indexscan to factor into
 *		estimates of caching behavior.
 * 'partial_path' is true if constructing a parallel index scan path.
 *
 * Returns the new path node.
 */</comment>
<function><type><name>IndexPath</name> <modifier>*</modifier></type>
<name>create_index_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexclauses</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbys</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbycols</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
				  <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>indexonly</name></decl></parameter>,
				  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
				  <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>partial_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <ternary><condition><expr><name>indexonly</name></expr> ?</condition><then> <expr><name>T_IndexOnlyScan</name></expr> </then><else>: <expr><name>T_IndexScan</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexinfo</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexclauses</name></name> <operator>=</operator> <name>indexclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexorderbys</name></name> <operator>=</operator> <name>indexorderbys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexorderbycols</name></name> <operator>=</operator> <name>indexorderbycols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexscandir</name></name> <operator>=</operator> <name>indexscandir</name></expr>;</expr_stmt>

	<comment type="block">/* Distribution is same as the base table. */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <call><name>cdbpathlocus_from_baserel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_index</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><name>partial_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_bitmap_heap_path
 *	  Creates a path node for a bitmap scan.
 *
 * 'bitmapqual' is a tree of IndexPath, BitmapAndPath, and BitmapOrPath nodes.
 * 'required_outer' is the set of outer relids for a parameterized path.
 * 'loop_count' is the number of repetitions of the indexscan to factor into
 *		estimates of caching behavior.
 *
 * loop_count should match the value used when creating the component
 * IndexPaths.
 */</comment>
<function><type><name>BitmapHeapPath</name> <modifier>*</modifier></type>
<name>create_bitmap_heap_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
						<parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>parallel_degree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapHeapPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_BitmapHeapScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <ternary><condition><expr><name>parallel_degree</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name>parallel_degree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* always unordered */</comment>

	<comment type="block">/* Distribution is same as the base table. */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <call><name>cdbpathlocus_from_baserel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>bitmapqual</name></name> <operator>=</operator> <name>bitmapqual</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_bitmap_heap_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
						  <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>,
						  <argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_bitmap_and_path
 *	  Creates a path node representing a BitmapAnd.
 */</comment>
<function><type><name>BitmapAndPath</name> <modifier>*</modifier></type>
<name>create_bitmap_and_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapquals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BitmapAndPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapAndPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_BitmapAnd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* not used in bitmap trees */</comment>

	<comment type="block">/*
	 * Currently, a BitmapHeapPath, BitmapAndPath, or BitmapOrPath will be
	 * parallel-safe if and only if rel-&gt;consider_parallel is set.  So, we can
	 * set the flag for this path based only on the relation-level flag,
	 * without actually iterating over the list of children.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* always unordered */</comment>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>bitmapquals</name></name> <operator>=</operator> <name>bitmapquals</name></expr>;</expr_stmt>

	<comment type="block">/* this sets bitmapselectivity as well as the regular cost fields: */</comment>
	<expr_stmt><expr><call><name>cost_bitmap_and_node</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_bitmap_or_path
 *	  Creates a path node representing a BitmapOr.
 */</comment>
<function><type><name>BitmapOrPath</name> <modifier>*</modifier></type>
<name>create_bitmap_or_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapquals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BitmapOrPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapOrPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_BitmapOr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* not used in bitmap trees */</comment>

	<comment type="block">/*
	 * Currently, a BitmapHeapPath, BitmapAndPath, or BitmapOrPath will be
	 * parallel-safe if and only if rel-&gt;consider_parallel is set.  So, we can
	 * set the flag for this path based only on the relation-level flag,
	 * without actually iterating over the list of children.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* always unordered */</comment>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>bitmapquals</name></name> <operator>=</operator> <name>bitmapquals</name></expr>;</expr_stmt>

	<comment type="block">/* this sets bitmapselectivity as well as the regular cost fields: */</comment>
	<expr_stmt><expr><call><name>cost_bitmap_or_node</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tidscan_path
 *	  Creates a path corresponding to a scan by TID, returning the pathnode.
 */</comment>
<function><type><name>TidPath</name> <modifier>*</modifier></type>
<name>create_tidscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tidquals</name></decl></parameter>,
					<parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>REL_SUPPORTS_TID_SCAN</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>TidPath</name>    <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TidPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_TidScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* always unordered */</comment>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>tidquals</name></name> <operator>=</operator> <name>tidquals</name></expr>;</expr_stmt>

	<comment type="block">/* Distribution is same as the base table. */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <call><name>cdbpathlocus_from_baserel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_tidscan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tidquals</name></expr></argument>,
				 <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_append_path
 *	  Creates a path corresponding to an Append plan, returning the
 *	  pathnode.
 *
 * Note that we must handle subpaths = NIL, representing a dummy access path.
 * Also, there are callers that pass root = NULL.
 */</comment>
<function><type><name>AppendPath</name> <modifier>*</modifier></type>
<name>create_append_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partial_subpaths</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parallel_aware</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>parallel_aware</name> <operator>||</operator> <name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Append</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * When generating an Append path for a partitioned table, there may be
	 * parameters that are useful so we can eliminate certain partitions
	 * during execution.  Here we'll go all the way and fully populate the
	 * parameter info data as we do for normal base relations.  However, we
	 * need only bother doing this for RELOPT_BASEREL rels, as
	 * RELOPT_OTHER_MEMBER_REL's Append paths are merged into the base rel's
	 * Append subpaths.  It would do no harm to do this, we just avoid it to
	 * save wasting effort.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitioned_rels</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>root</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>rel</name></expr></argument>,
															  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_appendrel_parampathinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
																<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>parallel_aware</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name>parallel_workers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For parallel append, non-partial paths are sorted by descending total
	 * costs. That way, the total time to finish all non-partial paths is
	 * minimized.  Also, the partial paths are sorted by descending startup
	 * costs.  There may be some paths that require to do startup work by a
	 * single worker.  In such case, it's better for workers to choose the
	 * expensive ones first, whereas the leader should choose the cheapest
	 * startup plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We mustn't fiddle with the order of subpaths when the Append has
		 * pathkeys.  The order they're listed in is critical to keeping the
		 * pathkeys valid.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathkeys</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>subpaths</name> <operator>=</operator> <call><name>list_qsort</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>, <argument><expr><name>append_total_cost_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partial_subpaths</name> <operator>=</operator> <call><name>list_qsort</name><argument_list>(<argument><expr><name>partial_subpaths</name></expr></argument>,
									  <argument><expr><name>append_startup_cost_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>first_partial_path</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>, <argument><expr><name>partial_subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply query-wide LIMIT if known and path is for sole base relation.
	 * (Handling this at this low level is a bit klugy.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>root</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_append_path_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pathnode-&gt;subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
			<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

		<comment type="block">/* All child paths must have same parameterization */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>parallel_aware</name> <operator>||</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's exactly one child path, the Append is a no-op and will be
	 * discarded later (in setrefs.c); therefore, we can inherit the child's
	 * size and cost, as well as its pathkeys if any (overriding whatever the
	 * caller might've said).  Otherwise, we must do the normal costsize
	 * calculation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>child</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cost_append</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* If the caller provided a row estimate, override the computed value. */</comment>
	<if_stmt><if>if <condition>(<expr><name>rows</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * append_total_cost_compare
 *	  qsort comparator for sorting append child paths by total_cost descending
 *
 * For equal total costs, we fall back to comparing startup costs; if those
 * are equal too, break ties using bms_compare on the paths' relids.
 * (This is to avoid getting unpredictable results from qsort.)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>append_total_cost_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path1</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ListCell</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path2</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ListCell</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>compare_path_costs</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>bms_compare</name><argument_list>(<argument><expr><name><name>path1</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>path2</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * append_startup_cost_compare
 *	  qsort comparator for sorting append child paths by startup_cost descending
 *
 * For equal startup costs, we fall back to comparing total costs; if those
 * are equal too, break ties using bms_compare on the paths' relids.
 * (This is to avoid getting unpredictable results from qsort.)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>append_startup_cost_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path1</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ListCell</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path2</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ListCell</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>compare_path_costs</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>STARTUP_COST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>bms_compare</name><argument_list>(<argument><expr><name><name>path1</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>path2</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_merge_append_path
 *	  Creates a path corresponding to a MergeAppend plan, returning the
 *	  pathnode.
 */</comment>
<function><type><name>MergeAppendPath</name> <modifier>*</modifier></type>
<name>create_merge_append_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>input_startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>input_total_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_MergeAppend</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_appendrel_parampathinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
															<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>=</operator> <name>subpaths</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply query-wide LIMIT if known and path is for sole base relation.
	 * (Handling this at this low level is a bit klugy.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Add Motions to the child nodes as needed, and determine the locus
	 * of the MergeAppend itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_append_path_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add up the sizes and costs of the input paths.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>input_startup_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>input_total_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
			<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Subpath is adequately ordered, we won't need to sort it */</comment>
			<expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We'll need to insert a Sort node, so include cost for that */</comment>
			<decl_stmt><decl><type><name>Path</name></type>		<name>sort_path</name></decl>;</decl_stmt>	<comment type="block">/* dummy for result of cost_sort */</comment>

			<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>,
					  <argument><expr><name>root</name></expr></argument>,
					  <argument><expr><name>pathkeys</name></expr></argument>,
					  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
					  <comment type="block">/* GPDB: pass subpath-&gt;rows because it's been adjusted for # of segments */</comment>
					  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
					  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
					  <argument><expr><literal type="number">0.0</literal></expr></argument>,
					  <argument><expr><name>work_mem</name></expr></argument>,
					  <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* All child paths must have same parameterization */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now we can compute total costs of the MergeAppend.  If there's exactly
	 * one child path, the MergeAppend is a no-op and will be discarded later
	 * (in setrefs.c); otherwise we do the normal cost calculation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>input_startup_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>input_total_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cost_merge_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
						  <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>input_startup_cost</name></expr></argument>, <argument><expr><name>input_total_cost</name></expr></argument>,
						  <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the locus of an Append or MergeAppend path.
 *
 * This modifies the 'subpaths', costs fields, and locus of 'pathnode'.
 * It will return false if fails to create motion for parameterized path.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>set_append_path_locus</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbLocusType</name></type> <name>targetlocustype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>targetlocus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subpaths</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>subpaths_out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_subpaths</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Init max_numsegments to slient compiler.
	 * This variable is only used when result
	 * locus is partitioned.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> 	    <name>max_numsegments</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>subpaths_out</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>AppendPath</name> <operator>*</operator><operator>)</operator> <name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>subpaths</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>subpaths_out</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MergeAppendPath</name> <operator>*</operator><operator>)</operator> <name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>subpaths</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected append path type: %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>subpaths</name> <operator>=</operator> <operator>*</operator><name>subpaths_out</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>subpaths_out</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* If no subpath, any worker can execute this Append.  Result has 0 rows. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subpaths</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do a first pass over the children to determine what locus the result
	 * should have, based on the loci of the children.
	 *
	 * We only determine the target locus type here, the number of segments is
	 * figured out later. We treat also all partitioned types the same for now,
	 * using Strewn to represent them all, and figure out later if we can mark
	 * it hashed, or if have to leave it strewn.
	 *
	 * We will record the max number of segments of each subpath here for later
	 * use.
	 */</comment>
	<struct><specifier>static</specifier> <specifier>const</specifier> struct
	<block>{
		<decl_stmt><decl><type><name>CdbLocusType</name></type> <name>a</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbLocusType</name></type> <name>b</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbLocusType</name></type> <name>result</name></decl>;</decl_stmt>
	}</block> <decl><name><name>append_locus_compatibility_table</name><index>[]</index></name> <init>=
	<expr><block>{
		<comment type="block">/*
		 * If any of the children have 'outerquery' locus, bring all the subpaths
		 * to the outer query's locus.
		 */</comment>
		<expr><block>{ <expr><name>CdbLocusType_OuterQuery</name></expr>, <expr><name>CdbLocusType_OuterQuery</name></expr>,     <expr><name>CdbLocusType_OuterQuery</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_OuterQuery</name></expr>, <expr><name>CdbLocusType_Entry</name></expr>,          <expr><name>CdbLocusType_OuterQuery</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_OuterQuery</name></expr>, <expr><name>CdbLocusType_SingleQE</name></expr>,       <expr><name>CdbLocusType_OuterQuery</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_OuterQuery</name></expr>, <expr><name>CdbLocusType_Strewn</name></expr>,         <expr><name>CdbLocusType_OuterQuery</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_OuterQuery</name></expr>, <expr><name>CdbLocusType_Replicated</name></expr>,     <expr><name>CdbLocusType_OuterQuery</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_OuterQuery</name></expr>, <expr><name>CdbLocusType_SegmentGeneral</name></expr>, <expr><name>CdbLocusType_OuterQuery</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_OuterQuery</name></expr>, <expr><name>CdbLocusType_General</name></expr>,        <expr><name>CdbLocusType_OuterQuery</name></expr> }</block></expr>,
		
		<comment type="block">/*
		 * Similarly, if any of the children have 'entry' locus, bring all the subpaths
		 * to the entry db.
		 */</comment>
		<expr><block>{ <expr><name>CdbLocusType_Entry</name></expr>, <expr><name>CdbLocusType_Entry</name></expr>,          <expr><name>CdbLocusType_Entry</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Entry</name></expr>, <expr><name>CdbLocusType_SingleQE</name></expr>,       <expr><name>CdbLocusType_Entry</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Entry</name></expr>, <expr><name>CdbLocusType_Strewn</name></expr>,         <expr><name>CdbLocusType_Entry</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Entry</name></expr>, <expr><name>CdbLocusType_Replicated</name></expr>,     <expr><name>CdbLocusType_Entry</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Entry</name></expr>, <expr><name>CdbLocusType_SegmentGeneral</name></expr>, <expr><name>CdbLocusType_Entry</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Entry</name></expr>, <expr><name>CdbLocusType_General</name></expr>,        <expr><name>CdbLocusType_Entry</name></expr> }</block></expr>,

		<comment type="block">/* similarly, if there are single QE children, bring everything to a single QE */</comment>
		<expr><block>{ <expr><name>CdbLocusType_SingleQE</name></expr>, <expr><name>CdbLocusType_SingleQE</name></expr>,       <expr><name>CdbLocusType_SingleQE</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_SingleQE</name></expr>, <expr><name>CdbLocusType_Strewn</name></expr>,         <expr><name>CdbLocusType_SingleQE</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_SingleQE</name></expr>, <expr><name>CdbLocusType_Replicated</name></expr>,     <expr><name>CdbLocusType_SingleQE</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_SingleQE</name></expr>, <expr><name>CdbLocusType_SegmentGeneral</name></expr>, <expr><name>CdbLocusType_SingleQE</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_SingleQE</name></expr>, <expr><name>CdbLocusType_General</name></expr>,        <expr><name>CdbLocusType_SingleQE</name></expr> }</block></expr>,

		<comment type="block">/*
		 * If everything is partitioned, then the result can be partitioned, too.
		 * But if it's a mix of partitioned and replicated, then we have to bring
		 * everything to a single QE. Otherwise, the replicated children
		 * will contribute rows on every QE.
		 * If it's a mix of partitioned and general, we still consider the
		 * result as partitioned. But the general part will be restricted to
		 * only produce rows on a single QE.
		 */</comment>
		<expr><block>{ <expr><name>CdbLocusType_Strewn</name></expr>, <expr><name>CdbLocusType_Strewn</name></expr>,         <expr><name>CdbLocusType_Strewn</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Strewn</name></expr>, <expr><name>CdbLocusType_Replicated</name></expr>,     <expr><name>CdbLocusType_SingleQE</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Strewn</name></expr>, <expr><name>CdbLocusType_SegmentGeneral</name></expr>, <expr><name>CdbLocusType_Strewn</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Strewn</name></expr>, <expr><name>CdbLocusType_General</name></expr>,        <expr><name>CdbLocusType_Strewn</name></expr> }</block></expr>,

		<expr><block>{ <expr><name>CdbLocusType_Replicated</name></expr>, <expr><name>CdbLocusType_Replicated</name></expr>, <expr><name>CdbLocusType_Replicated</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Replicated</name></expr>, <expr><name>CdbLocusType_SegmentGeneral</name></expr>, <expr><name>CdbLocusType_Replicated</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_Replicated</name></expr>, <expr><name>CdbLocusType_General</name></expr>,        <expr><name>CdbLocusType_Replicated</name></expr> }</block></expr>,

		<expr><block>{ <expr><name>CdbLocusType_SegmentGeneral</name></expr>, <expr><name>CdbLocusType_SegmentGeneral</name></expr>, <expr><name>CdbLocusType_SegmentGeneral</name></expr> }</block></expr>,
		<expr><block>{ <expr><name>CdbLocusType_SegmentGeneral</name></expr>, <expr><name>CdbLocusType_General</name></expr>,        <expr><name>CdbLocusType_SegmentGeneral</name></expr> }</block></expr>,

		<expr><block>{ <expr><name>CdbLocusType_General</name></expr>, <expr><name>CdbLocusType_General</name></expr>,        <expr><name>CdbLocusType_General</name></expr> }</block></expr>,
	}</block></expr></init></decl>;</struct>
	<expr_stmt><expr><name>targetlocustype</name> <operator>=</operator> <name>CdbLocusType_General</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbLocusType</name></type> <name>subtype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <name>CdbLocusType_Strewn</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>locustype</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>targetlocustype</name> <operator>=</operator> <name>subtype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>max_numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>max_numsegments</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>max_numsegments</name></expr></argument>,
							  <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>append_locus_compatibility_table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>append_locus_compatibility_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>a</name> <operator>==</operator> <name>targetlocustype</name> <operator>&amp;&amp;</operator>
				 <name><name>append_locus_compatibility_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>b</name> <operator>==</operator> <name>subtype</name><operator>)</operator> <operator>||</operator>
				<operator>(</operator><name><name>append_locus_compatibility_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>a</name> <operator>==</operator> <name>subtype</name> <operator>&amp;&amp;</operator>
				 <name><name>append_locus_compatibility_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>b</name> <operator>==</operator> <name>targetlocustype</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>targetlocustype</name> <operator>=</operator> <name><name>append_locus_compatibility_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>result</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>append_locus_compatibility_table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine target locus for Append"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now compute the 'numsegments', and the hash keys if it's a partitioned
	 * type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetlocustype</name> <operator>==</operator> <name>CdbLocusType_Entry</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing more to do */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetlocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>targetlocustype</name> <operator>==</operator> <name>CdbLocusType_OuterQuery</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing more to do */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeOuterQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetlocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>targetlocustype</name> <operator>==</operator> <name>CdbLocusType_General</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing more to do */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetlocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>targetlocustype</name> <operator>==</operator> <name>CdbLocusType_SingleQE</name> <operator>||</operator>
			 <name>targetlocustype</name> <operator>==</operator> <name>CdbLocusType_Replicated</name> <operator>||</operator>
			 <name>targetlocustype</name> <operator>==</operator> <name>CdbLocusType_SegmentGeneral</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* By default put Append node on all the segments */</comment>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subpaths</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Align numsegments to be the common segments among the children.
			 * Partitioned children will need to be motioned, so ignore them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>,
								  <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeSimple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetlocus</name></expr></argument>, <argument><expr><name>targetlocustype</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>targetlocustype</name> <operator>==</operator> <name>CdbLocusType_Strewn</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isfirst</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* By default put Append node on all the segments */</comment>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetlocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subpaths</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>projectedlocus</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Afterwards, General/SegmentGeneral will be projected as Strewn */</comment>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>projectedlocus</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>projectedlocus</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

				<comment type="block">/* Transform subpath locus into the appendrel's space for comparison. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name> <operator>&amp;&amp;</operator>
					<name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>rel</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>l</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>cdbpathlocus_pull_above_projection</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						                                   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>,
						                                   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
						                                   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
						                                   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
						                                   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>projectedlocus</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * CDB: If all the scans are distributed alike, set
			 * the result locus to match.  Otherwise, if all are partitioned,
			 * set it to strewn.  A mixture of partitioned and non-partitioned
			 * scans should not occur after above correction;
			 *
			 * CDB TODO: When the scans are not all partitioned alike, and the
			 * result is joined with another rel, consider pushing the join
			 * below the Append so that child tables that are properly
			 * distributed can be joined in place.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>isfirst</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>targetlocus</name> <operator>=</operator> <name>projectedlocus</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>isfirst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>cdbpathlocus_equal</name><argument_list>(<argument><expr><name>targetlocus</name></expr></argument>, <argument><expr><name>projectedlocus</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* compatible */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * subpaths have different distributed policy, mark it as random
				 * distributed and set the numsegments to the maximum of all
				 * subpaths to not missing any tuples.
				 *
				 * max_numsegments is computed in the first deduction loop,
				 * even here we use projectdlocus, the numsegments never change.
				 */</comment>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetlocus</name></expr></argument>, <argument><expr><name>max_numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected Append target locus type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Ok, we now know the target locus. Add Motions/Projections to any subpaths that need it */</comment>
	<expr_stmt><expr><name>new_subpaths</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>targetlocus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If a General/SegmentGeneral is mixed with other Strewn's,
				 * add a projection path with cdb_restrict_clauses, so that only
				 * a single QE will actually produce rows.
				 */</comment>
				<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrict_info</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <name><name>targetlocus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>restrict_info</name> <operator>=</operator> <call><name>make_restrictinfo</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeSegmentFilterExpr</name><argument_list>(
													  <argument><expr><name>gp_session_id</name> <operator>%</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>,		<comment type="block">/* is_pushed_down */</comment>
												  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* outerjoin_delayed */</comment>
												  <argument><expr><name>true</name></expr></argument>,		<comment type="block">/* pseudoconstant */</comment>
												  <argument><expr><literal type="number">0</literal></expr></argument>,		<comment type="block">/* security_level */</comment>
												  <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* required_relids */</comment>
												  <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* outer_relids */</comment>
												  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* nullable_relids */</comment>

				<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path_with_quals</name><argument_list>(
					<argument><expr><name>root</name></expr></argument>,
					<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
					<argument><expr><name>subpath</name></expr></argument>,
					<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>,
					<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>restrict_info</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We use the skill of Result plannode with one time filter
				 * gp_execution_segment() = &lt;segid&gt; here, so we should update
				 * direct dispatch info when creating plan.
				 */</comment>
				<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ProjectionPath</name> <operator>*</operator><operator>)</operator> <name>subpath</name><operator>)</operator><operator>-&gt;</operator><name>direct_dispath_contentIds</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>gp_session_id</name> <operator>%</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name><operator>)</operator></expr></argument>,
				                        <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* we already determined that all the loci are compatible */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetlocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetlocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>sameslice_relids</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subpath</name><operator>-&gt;</operator><name>rescannable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>new_subpaths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_subpaths</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name>targetlocus</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>subpaths_out</name> <operator>=</operator> <name>new_subpaths</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_group_result_path
 *	  Creates a path representing a Result-and-nothing-else plan.
 *
 * This is only used for degenerate grouping cases, in which we know we
 * need to produce one result row, possibly filtered by a HAVING qual.
 */</comment>
<function><type><name>GroupResultPath</name> <modifier>*</modifier></type>
<name>create_group_result_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>havingqual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GroupResultPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupResultPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Result</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* there are no other rels... */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>havingqual</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can't quite use cost_resultscan() because the quals we want to
	 * account for are not baserestrict quals of the rel.  Might as well just
	 * hack it here.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
		<name>cpu_tuple_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add cost of qual, if any --- but we ignore its selectivity, since our
	 * rowcount estimate should be 1 no matter what the qual is.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>havingqual</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>qual_cost</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qual_cost</name></expr></argument>, <argument><expr><name>havingqual</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* havingqual is evaluated once at startup */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Result can be on any segments */</comment>
	<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_material_path
 *	  Creates a path corresponding to a Material plan, returning the
 *	  pathnode.
 */</comment>
<function><type><name>MaterialPath</name> <modifier>*</modifier></type>
<name>create_material_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MaterialPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Material</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>cdb_strict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* Independent of sub-path */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_material</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
				  <argument><expr><name>root</name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_unique_path
 *	  Creates a path representing elimination of distinct rows from the
 *	  input data.  Distinct-ness is defined according to the needs of the
 *	  semijoin represented by sjinfo.  If it is not possible to identify
 *	  how to make the data unique, NULL is returned.
 *
 * If used at all, this is likely to be called repeatedly on the same rel;
 * and the input subpath should always be the same (the cheapest_total path
 * for the rel).  So we cache the result.
 */</comment>
<function><type><name>UniquePath</name> <modifier>*</modifier></type>
<name>create_unique_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
				   <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>sort_path</name></decl>;</decl_stmt>		<comment type="block">/* dummy for result of cost_sort */</comment>
	<decl_stmt><decl><type><name>Path</name></type>		<name>agg_path</name></decl>;</decl_stmt>		<comment type="block">/* dummy for result of cost_agg */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>add_motion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numsegments</name></decl>;</decl_stmt>

	<comment type="block">/* Caller made a mistake if subpath isn't cheapest_total ... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subpath</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... or if SpecialJoinInfo is the wrong one */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If result already cached, return it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>UniquePath</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If it's not possible to unique-ify, return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>||</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * When called during GEQO join planning, we are in a short-lived memory
	 * context.  We must make sure that the path and any subsidiary data
	 * structures created for a baserel survive the GEQO cycle, else the
	 * baserel is trashed for future GEQO cycles.  On the other hand, when we
	 * are creating those for a joinrel during GEQO, we don't want them to
	 * clutter the main planning context.  Upshot is that the best solution is
	 * to explicitly allocate memory in the same context the given RelOptInfo
	 * is in.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Repartition first if duplicates might be on different QEs. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>cdbpathlocus_is_hashed_on_exprs</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name> <init>= <expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opfamilies</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortrefs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sjinfo-&gt;semi_rhs_exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <call><name>cdb_default_distribution_opfamily_for_type</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opfamilies</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortrefs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>sortrefs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>locus</name> <operator>=</operator> <call><name>cdbpathlocus_from_exprs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
										<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>, <argument><expr><name>opfamilies</name></expr></argument>, <argument><expr><name>sortrefs</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * We probably add agg/sort node above the added motion node, but it is
		 * possible to add an agg/sort node below this motion node also,
		 * which might be optimal in some cases?
		 */</comment>
		<expr_stmt><expr><name>add_motion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create motion path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>locus</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If we get here, we can unique-ify using at least one of sorting and
	 * hashing.  Start building the result Path object.
	 */</comment>
	<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Unique</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assume the output is unsorted, since we don't necessarily have pathkeys
	 * to represent it.  (This might get overridden below.)
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>in_operators</name></name> <operator>=</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>uniq_exprs</name></name> <operator>=</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input is a relation and it has a unique index that proves the
	 * semi_rhs_exprs are unique, then we don't need to do anything.  Note
	 * that relation_has_unique_index_for automatically considers restriction
	 * clauses for the rel, as well.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>&amp;&amp;</operator>
		<call><name>relation_has_unique_index_for</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									  <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>,
									  <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For UNIQUE_PATH_NOOP, it is possible that subpath could be a
		 * motion node. It is not allowed to add a motion node above a
		 * motion node so we simply disallow this unique path although
		 * in theory we could improve this.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>add_motion</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_NOOP</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>pathnode</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the input is a subquery whose output must be unique already, then we
	 * don't need to do anything.  The test for uniqueness has to consider
	 * exactly which columns we are extracting; for example "SELECT DISTINCT
	 * x,y" doesn't guarantee that x alone is distinct. So we cannot check for
	 * this optimization unless semi_rhs_exprs consists only of simple Vars
	 * referencing subquery outputs.  (Possibly we could do something with
	 * expressions in the subquery outputs, too, but for now keep it simple.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>query_supports_distinctness</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_tlist_colnos</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sub_tlist_colnos</name> <operator>=</operator> <call><name>translate_sub_tlist</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>,
												   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>sub_tlist_colnos</name> <operator>&amp;&amp;</operator>
				<call><name>query_is_distinct_for</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
									  <argument><expr><name>sub_tlist_colnos</name></expr></argument>,
									  <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Subpath node could be a motion. See previous comment for details. */</comment>
				<if_stmt><if>if <condition>(<expr><name>add_motion</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_NOOP</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>pathnode</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Estimate number of output rows */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>,
											  <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Estimate cost for sort+unique implementation
		 */</comment>
		<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
				  <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
				  <argument><expr><literal type="number">0.0</literal></expr></argument>,
				  <argument><expr><name>work_mem</name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Charge one cpu_operator_cost per comparison per input tuple. We
		 * assume all columns get compared at most of the tuples. (XXX
		 * probably this is an overestimate.)  This should agree with
		 * create_upper_unique_path.
		 */</comment>
		<expr_stmt><expr><name><name>sort_path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name><operator>)</operator> <operator>*</operator> <name>numCols</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Estimate the overhead per hashtable entry at 64 bytes (same as in
		 * planner.c).
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>hashentrysize</name> <init>= <expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name> <operator>+</operator> <literal type="number">64</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hashentrysize</name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>&gt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We should not try to hash.  Hack the SpecialJoinInfo to
			 * remember this, in case we come through here again.
			 */</comment>
			<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
					 <argument><expr><name>AGG_HASHED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>/</operator> <call><name>planner_segment_count</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>NIL</name></expr></argument>,
					 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
					 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name><operator>)</operator></expr></argument>,
					 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>&amp;&amp;</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>agg_path</name><operator>.</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_HASH</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_SORT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_SORT</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_HASH</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* we can get here only if we abandoned hashing above */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_HASH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>agg_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>agg_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* see MPP-1140 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_HASH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* hybrid hash agg is not rescannable, and may present a motion hazard */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* sort or plain implies materialization and breaks deadlock cycle.
		 *  (NB: Must not reset motionHazard when sort is eliminated due to
		 *  existing ordering; but Unique sort is never optimized away at present.)
		 */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>

		<comment type="block">/* Same reasoning applies to rescanablilty.  If no actual sort is placed
		 * in the plan, then rescannable is set correctly to the subpath value.
		 * If sort intervenes, it should be set to true.  We depend
		 * on the above claim that sort will always intervene.
		 */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_unique_rowid_path (GPDB)
 *
 * Create a UniquePath to deduplicate based on a RowIdExp column. This is
 * used as part of implementing semi-joins (such as "x IN (SELECT ...)").
 *
 * In PostgreSQL, semi-joins are implemented with JOIN_SEMI join types, or
 * by first eliminating duplicates from the inner side, and then performing
 * normal inner join (that's JOIN_UNIQUE_OUTER and JOIN_UNIQUE_INNER). GPDB
 * has a third way to implement them: Perform an inner join first, and then
 * eliminate duplicates from the result. The JOIN_DEDUP_SEMI and
 * JOIN_DEDUP_SEMI_REVERSE join types indicate such plans.
 *
 * The JOIN_DEDUP_SEMI plan will look something like this:
 *
 * postgres=# explain select * from s where exists (select 1 from r where s.a = r.b);
 *                                                   QUERY PLAN                                                   
 * ---------------------------------------------------------------------------------------------------------------
 *  Gather Motion 3:1  (slice1; segments: 3)  (cost=153.50..155.83 rows=100 width=8)
 *    -&gt;  HashAggregate  (cost=153.50..153.83 rows=34 width=8)
 *          Group Key: (RowIdExpr)
 *          -&gt;  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=11.75..153.00 rows=34 width=8)
 *                Hash Key: (RowIdExpr)
 *                -&gt;  Hash Join  (cost=11.75..151.00 rows=34 width=8)
 *                      Hash Cond: (r.b = s.a)
 *                      -&gt;  Seq Scan on r  (cost=0.00..112.00 rows=3334 width=4)
 *                      -&gt;  Hash  (cost=8.00..8.00 rows=100 width=8)
 *                            -&gt;  Broadcast Motion 3:3  (slice3; segments: 3)  (cost=0.00..8.00 rows=100 width=8)
 *                                  -&gt;  Seq Scan on s  (cost=0.00..4.00 rows=34 width=8)
 *  Optimizer: Postgres query optimizer
 * (12 rows)
 *
 * In PostgreSQL, this is never better than doing a JOIN_SEMI directly.
 * But it can be a win in GPDB, if the distribution of the outer and inner
 * relations don't match, and the outer relation is much larger than the
 * inner relation. In the above example, a normal semi-join would have to
 * have 's' on the outer side, and 'r' on the inner side. A hash semi-join
 * can't be performed the other way 'round, because the duplicate
 * elimination in a semi-join is done when building the hash table.
 * Furthermore, you can't have a Broadcast motion on the outer side of
 * a semi-join, because that could also generate duplicates. That leaves
 * the planner no choice, but to redistribute the larger 'r' relation,
 * in a JOIN_SEMI plan.
 *
 * So in GPDB, we try to implement semi-joins as a inner joins, followed
 * by an explicit UniquePath to eliminate the duplicates. That allows the
 * above plan, where the smaller 's' relation is Broadcast to all the
 * segments, and the duplicates that can arise from doing that are eliminated
 * above the join. You get one more Motion than with a JOIN_SEMI plan, but
 * each Motion has to move much fewer rows.
 *
 * The role of this function is to insert the UniquePath to represent
 * the deduplication above the join. Returns a UniquePath node representing
 * a "DISTINCT ON (RowIdExpr)" operator, where (r1,...,rn) represents a unique
 * identifier for each row of the cross product of the tables specified by
 * the 'distinct_relids' parameter.
 *
 * NB: The returned node shares the given 'distinct_relids' bitmapset object;
 * so the caller must not free or modify it during the node's lifetime.
 *
 * If a row's duplicates might occur in more than one partition, a Motion
 * operator will be needed to bring them together.  Since this path might
 * not be chosen, we won't take the time to create a CdbMotionPath node here.
 * Just estimate what the cost would be, and assign a dummy locus; leave
 * the real work for create_plan().
 */</comment>
<function><type><name>UniquePath</name> <modifier>*</modifier></type>
<name>create_unique_rowid_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>Path</name>        <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type>       <name>required_outer</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type>          <name>rowidexpr_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>sort_path</name></decl>;</decl_stmt>		<comment type="block">/* dummy for result of cost_sort */</comment>
	<decl_stmt><decl><type><name>Path</name></type>		<name>agg_path</name></decl>;</decl_stmt>		<comment type="block">/* dummy for result of cost_agg */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_btree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numsegments</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rowidexpr_id</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For easier merging (albeit it's going to manual), keep this function
	 * similar to create_unique_path(). In this function, we deduplicate based
	 * on RowIdExpr that we generate on the fly. Sorting and hashing are both
	 * possible, but we keep these as variables to resemble
	 * create_unique_path().
	 */</comment>
	<expr_stmt><expr><name>all_btree</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>all_hash</name> <operator>=</operator> <name>enable_hashagg</name></expr>;</expr_stmt>	<comment type="block">/* don't consider hash if not enabled */</comment>

	<decl_stmt><decl><type><name>RowIdExpr</name> <modifier>*</modifier></type><name>rowidexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RowIdExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rowidexpr</name><operator>-&gt;</operator><name>rowidexpr_id</name></name> <operator>=</operator> <name>rowidexpr_id</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rowidexpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Repartition first if duplicates might be on different QEs. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name> <init>= <expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>locus</name> <operator>=</operator> <call><name>cdbpathlocus_from_exprs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
										<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rowidexpr</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><call><name>cdb_default_distribution_opfamily_for_type</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>list_make1_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subpath</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The motion path has been created correctly, but there's a little
		 * problem with the locus. The locus has RowIdExpr as the distribution
		 * key, but because there are no Vars in it, the EC machinery will
		 * consider it a pseudo-constant. We don't want that, as it would
		 * mean that all rows were considered to live on the same segment,
		 * which is not how this works. Therefore set the locus of the Unique
		 * path to Strewn, which doesn't have that problem. No node above the
		 * Unique will care about the row id expresssion, so it's OK to forget
		 * that the rows are currently hashed by the row id.
		 */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* XXX If the join result is on a single node, a DEDUP plan probably doesn't
		 * make sense.
		 */</comment>
		<expr_stmt><expr><name>locus</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Start building the result Path object.
	 */</comment>
	<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Unique</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Treat the output as always unsorted, since we don't necessarily have
	 * pathkeys to represent it.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>in_operators</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>Int8EqualOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>uniq_exprs</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rowidexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This just removes duplicates generated by broadcasting rows earlier.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numCols</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* the RowIdExpr */</comment>

	<if_stmt><if>if <condition>(<expr><name>all_btree</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Estimate cost for sort+unique implementation
		 */</comment>
		<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
				  <argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name><operator>)</operator></expr></argument>,
				  <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
				  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Charge one cpu_operator_cost per comparison per input tuple. We
		 * assume all columns get compared at most of the tuples. (XXX
		 * probably this is an overestimate.)  This should agree with
		 * make_unique.
		 */</comment>
		<expr_stmt><expr><name><name>sort_path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name><operator>)</operator> <operator>*</operator> <name>numCols</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>all_hash</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Estimate the overhead per hashtable entry at 64 bytes (same as in
		 * planner.c).
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>hashentrysize</name> <init>= <expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name> <operator>+</operator> <literal type="number">64</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hashentrysize</name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>&gt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>all_hash</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* don't try to hash */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
					 <argument><expr><name>AGG_HASHED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>numCols</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>rows</name></expr></argument>,
					 <argument><expr><name>NIL</name></expr></argument>, <comment type="block">/* no quals */</comment>
					 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
					 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name><operator>)</operator></expr></argument>,
					 <argument><expr><name>false</name></expr></argument> <comment type="block">/* streaming */</comment>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>all_btree</name> <operator>&amp;&amp;</operator> <name>all_hash</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>agg_path</name><operator>.</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_HASH</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_SORT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>all_btree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_SORT</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>all_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_HASH</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_HASH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>agg_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>agg_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* see MPP-1140 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_HASH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* hybrid hash agg is not rescannable, and may present a motion hazard */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* sort or plain implies materialization and breaks deadlock cycle.
		 *  (NB: Must not reset motionHazard when sort is eliminated due to
		 *  existing ordering; but Unique sort is never optimized away at present.)
		 */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>

		<comment type="block">/* Same reasoning applies to rescanablilty.  If no actual sort is placed
		 * in the plan, then rescannable is set correctly to the subpath value.
		 * If sort intervenes, it should be set to true.  We depend
		 * on the above claim that sort will always intervene.
		 */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>                               <comment type="block">/* create_unique_rowid_path */</comment>

<comment type="block">/*
 * create_gather_merge_path
 *
 *	  Creates a path corresponding to a gather merge scan, returning
 *	  the pathnode.
 */</comment>
<function><type><name>GatherMergePath</name> <modifier>*</modifier></type>
<name>create_gather_merge_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
						 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GatherMergePath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>input_startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>input_total_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_GatherMerge</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <ternary><condition><expr><name>target</name></expr> ?</condition><then> <expr><name>target</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Subpath is adequately ordered, we won't need to sort it */</comment>
		<expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We'll need to insert a Sort node, so include cost for that */</comment>
		<decl_stmt><decl><type><name>Path</name></type>		<name>sort_path</name></decl>;</decl_stmt>	<comment type="block">/* dummy for result of cost_sort */</comment>

		<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>,
				  <argument><expr><name>root</name></expr></argument>,
				  <argument><expr><name>pathkeys</name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
				  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
				  <argument><expr><literal type="number">0.0</literal></expr></argument>,
				  <argument><expr><name>work_mem</name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>cost_gather_merge</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>,
					  <argument><expr><name>input_startup_cost</name></expr></argument>, <argument><expr><name>input_total_cost</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * translate_sub_tlist - get subquery column numbers represented by tlist
 *
 * The given targetlist usually contains only Vars referencing the given relid.
 * Extract their varattnos (ie, the column numbers of the subquery) and return
 * as an integer List.
 *
 * If any of the tlist items is not a simple Var, we cannot determine whether
 * the subquery's uniqueness condition (if any) matches ours, so punt and
 * return NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>translate_sub_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* punt */</comment>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_gather_path
 *	  Creates a path corresponding to a gather scan, returning the
 *	  pathnode.
 *
 * 'rows' may optionally be set to override row estimates from other sources.
 */</comment>
<function><type><name>GatherPath</name> <modifier>*</modifier></type>
<name>create_gather_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
				   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GatherPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Gather</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* Gather has unordered result */</comment>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>single_copy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>single_copy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>cost_gather</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* GPDB_96_MERGE_FIXME: how do data distribution locus and parallelism work together? */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_subqueryscan_path
 *	  Creates a path corresponding to a scan of a subquery,
 *	  returning the pathnode.
 */</comment>
<function><type><name>SubqueryScanPath</name> <modifier>*</modifier></type>
<name>create_subqueryscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SubqueryScanPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_SubqueryScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>required_outer</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cost_subqueryscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_functionscan_path
 *	  Creates a path corresponding to a sequential scan of a function,
 *	  returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_functionscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_FunctionScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decide where to execute the FunctionScan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>exec_location</name> <init>= <expr><name>PROEXECLOCATION_ANY</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>contain_mutables</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>contain_outer_params</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the function desires to run on segments, mark randomly-distributed.
		 * If expression contains mutable functions, evaluate it on entry db.
		 * Otherwise let it be evaluated in the same slice as its parent operator.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>contain_outer_query_references</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>contain_outer_params</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name>this_exec_location</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>this_exec_location</name> <operator>=</operator> <call><name>func_exec_location</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<switch>switch <condition>(<expr><name>this_exec_location</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>PROEXECLOCATION_ANY</name></expr>:</case>
						<comment type="block">/*
						 * This can be executed anywhere. Remember if it was
						 * mutable (or contained any mutable arguments), that
						 * will affect the decision after this loop on where
						 * to actually execute it.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>contain_mutables</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>contain_mutables</name> <operator>=</operator> <call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>PROEXECLOCATION_COORDINATOR</name></expr>:</case>
						<comment type="block">/*
						 * This function forces the execution to master.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>exec_location</name> <operator>==</operator> <name>PROEXECLOCATION_ALL_SEGMENTS</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot mix EXECUTE ON MASTER and ALL SEGMENTS functions in same function scan"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>exec_location</name> <operator>=</operator> <name>PROEXECLOCATION_COORDINATOR</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>PROEXECLOCATION_INITPLAN</name></expr>:</case>
						<comment type="block">/*
						 * This function forces the execution to master.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>exec_location</name> <operator>==</operator> <name>PROEXECLOCATION_ALL_SEGMENTS</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot mix EXECUTE ON INITPLAN and ALL SEGMENTS functions in same function scan"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>exec_location</name> <operator>=</operator> <name>PROEXECLOCATION_INITPLAN</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>PROEXECLOCATION_ALL_SEGMENTS</name></expr>:</case>
						<comment type="block">/*
						 * This function forces the execution to segments.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>exec_location</name> <operator>==</operator> <name>PROEXECLOCATION_COORDINATOR</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot mix EXECUTE ON MASTER and ALL SEGMENTS functions in same function scan"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>exec_location</name> <operator>=</operator> <name>PROEXECLOCATION_ALL_SEGMENTS</name></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized proexeclocation '%c'"</literal></expr></argument>, <argument><expr><name>exec_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The expression might've been simplified into a Const. Which can
				 * be executed anywhere.
				 */</comment>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>contain_outer_params</name> <operator>&amp;&amp;</operator>
				<call><name>contains_outer_params</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>contain_outer_params</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<switch>switch <condition>(<expr><name>exec_location</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PROEXECLOCATION_ANY</name></expr>:</case>
				<comment type="block">/*
				 * If all the functions are ON ANY, we presumably could execute
				 * the function scan anywhere. However, historically, before the
				 * EXECUTE ON syntax was introduced, we always executed
				 * non-IMMUTABLE functions on the master. Keep that behavior
				 * for backwards compatibility.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>contain_outer_params</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CdbPathLocus_MakeOuterQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>contain_mutables</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>PROEXECLOCATION_COORDINATOR</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>contain_outer_params</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot execute EXECUTE ON MASTER function in a subquery with arguments from outer query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PROEXECLOCATION_INITPLAN</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>contain_outer_params</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot execute EXECUTE ON INITPLAN function in a subquery with arguments from outer query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PROEXECLOCATION_ALL_SEGMENTS</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>contain_outer_params</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot execute EXECUTE ON ALL SEGMENTS function in a subquery with arguments from outer query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>,
										<argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized proexeclocation '%c'"</literal></expr></argument>, <argument><expr><name>exec_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * FunctionScan is always rescannable. It uses a tuplestore to
	 * materialize the results all by itself.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>sameslice_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_functionscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tablefunction_path
 *	  Creates a path corresponding to a sequential scan of a table function,
 *	  returning the pathnode.
 *
 * NB: This is a GPDB specific thing, to support this syntax:
 *
 *   SELECT * FROM multiset_5( TABLE( SELECT * from example) ) order by a, b;
 *
 * Despite the similar name, this is completely different from the upstream
 * create_tablefuncscan_path() function below! The other function deals with
 * XMLTABLE and similar functions.
 */</comment>
<function><type><name>TableFunctionScanPath</name> <modifier>*</modifier></type>
<name>create_tablefunction_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableFunctionScanPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TableFunctionScanPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Setup the basics of the TableFunction path */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_TableFunctionScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name>	   <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>		<comment type="block">/* no way to specify output ordering */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>      <comment type="block">/* better safe than sorry */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>     <comment type="block">/* better safe than sorry */</comment>

	<comment type="block">/*
	 * Inherit the locus of the input subquery's path.  This is necessary to handle the
	 * case of a General locus, e.g. if all the data has been concentrated to a
	 * single segment then the output will all be on that segment, otherwise the
	 * output must be declared as randomly distributed because we do not know
	 * what relationship, if any, there is between the input data and the output
	 * data.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

	<comment type="block">/* Mark the output as random if the input is partitioned */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>,
								<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_tablefunction</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tablefuncscan_path
 *	  Creates a path corresponding to a sequential scan of a table function,
 *	  returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_tablefuncscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_TableFuncScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* result is always unordered */</comment>
	<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_tablefuncscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_valuesscan_path
 *	  Creates a path corresponding to a scan of a VALUES list,
 *	  returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_valuesscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ValuesScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* result is always unordered */</comment>

	<comment type="block">/*
	 * CDB: If VALUES list contains mutable functions, evaluate it on entry db.
	 * Otherwise let it be evaluated in the same slice as its parent operator.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * ValuesScan can be on any segment.
		 */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>sameslice_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_valuesscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_ctescan_path
 *	  Creates a path corresponding to a scan of a non-self-reference CTE,
 *	  returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_ctescan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
					<parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CtePath</name>	   <modifier>*</modifier></type><name>ctepath</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CtePath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>&amp;</operator><name><name>ctepath</name><operator>-&gt;</operator><name>path</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CteScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="line">// GPDB_96_MERGE_FIXME: Why do we set pathkeys in GPDB, but not in Postgres?</comment>
	<comment type="line">// pathnode-&gt;pathkeys = NIL;	/* XXX for now, result is always unordered */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can't extract these two values from the subplan, so we simple set
	 * them to their worst case here.
	 *
	 * GPDB_96_MERGE_FIXME: we do have the subpath, at least if it's not a
	 * shared cte
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>sameslice_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>subpath</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* copy the cost estimates from the subpath */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>numsegments</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ctepath</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Shared scan. We'll use the cost estimates from the CTE rel. */</comment>
		<expr_stmt><expr><call><name>cost_ctescan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_namedtuplestorescan_path
 *	  Creates a path corresponding to a scan of a named tuplestore, returning
 *	  the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_namedtuplestorescan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								<parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_NamedTuplestoreScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* result is always unordered */</comment>

	<expr_stmt><expr><call><name>cost_namedtuplestorescan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When this is used in triggers that run on QEs, the locus is ignored
	 * and the scan is executed locally on the QE anyway. On QD, it's not
	 * clear if named tuplestores are populated correctly in triggers, but if
	 * it does work t all, Entry seems most appropriate.
	 */</comment>
	<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_resultscan_path
 *	  Creates a path corresponding to a scan of an RTE_RESULT relation,
 *	  returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_resultscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Result</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* result is always unordered */</comment>

	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>exec_location</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>exec_location</name> <operator>=</operator> <call><name>check_execute_on_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * A function with EXECUTE ON { COORDINATOR | ALL SEGMENTS } attribute
		 * must be a set-returning function, a subquery has set-returning 
		 * functions in tlist can't be pulled up as RTE_RESULT relation.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>exec_location</name> <operator>==</operator> <name>PROEXECLOCATION_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>cost_resultscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_worktablescan_path
 *	  Creates a path corresponding to a scan of a self-reference CTE,
 *	  returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_worktablescan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>CdbPathLocus</name></type> <name>ctelocus</name></decl></parameter>,
						  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_WorkTableScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* result is always unordered */</comment>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name>ctelocus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>sameslice_relids</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>

	<comment type="block">/* Cost is the same as for a regular CTE scan */</comment>
	<expr_stmt><expr><call><name>cost_ctescan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>path_contains_inner_index</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapHeapPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* MPP-2377: Append paths may conceal inner-index scans, if
		 * any of the subpaths are indexpaths or bitmapheap-paths we
		 * have to do more checking */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* scan the subpaths of the Append */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((AppendPath *)path)-&gt;subpaths</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>path_contains_inner_index</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_foreignscan_path
 *	  Creates a path corresponding to a scan of a foreign base table,
 *	  returning the pathnode.
 *
 * This function is never called from core Postgres; rather, it's expected
 * to be called by the GetForeignPaths function of a foreign data wrapper.
 * We make the FDW supply all fields of the path, since we do not have any way
 * to calculate them in core.  However, there is a usually-sane default for
 * the pathtarget (rel-&gt;reltarget), so we let a NULL for "target" select that.
 */</comment>
<function><type><name>ForeignPath</name> <modifier>*</modifier></type>
<name>create_foreignscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
						<parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
						<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>fdw_outerpath</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Historically some FDWs were confused about when to use this */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <ternary><condition><expr><name>target</name></expr> ?</condition><then> <expr><name>target</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>exec_location</name></name></expr>)</condition>
		<block>{<block_content>
		<case>case <expr><name>FTEXECLOCATION_ANY</name></expr>:</case>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTEXECLOCATION_ALL_SEGMENTS</name></expr>:</case>
			<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>server</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>num_segments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>FTEXECLOCATION_COORDINATOR</name></expr>:</case>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized exec_location '%c'"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>exec_location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* make entry locus for utility role */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>fdw_outerpath</name></name> <operator>=</operator> <name>fdw_outerpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>fdw_private</name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_foreign_join_path
 *	  Creates a path corresponding to a scan of a foreign join,
 *	  returning the pathnode.
 *
 * This function is never called from core Postgres; rather, it's expected
 * to be called by the GetForeignJoinPaths function of a foreign data wrapper.
 * We make the FDW supply all fields of the path, since we do not have any way
 * to calculate them in core.  However, there is a usually-sane default for
 * the pathtarget (rel-&gt;reltarget), so we let a NULL for "target" select that.
 */</comment>
<function><type><name>ForeignPath</name> <modifier>*</modifier></type>
<name>create_foreign_join_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
						 <parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
						 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>fdw_outerpath</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should use get_joinrel_parampathinfo to handle parameterized paths,
	 * but the API of this function doesn't support it, and existing
	 * extensions aren't yet trying to build such paths anyway.  For the
	 * moment just throw an error if someone tries it; eventually we should
	 * revisit this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parameterized foreign joins are not supported yet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <ternary><condition><expr><name>target</name></expr> ?</condition><then> <expr><name>target</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* XXX see above */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>exec_location</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FTEXECLOCATION_ANY</name></expr>:</case>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTEXECLOCATION_ALL_SEGMENTS</name></expr>:</case>
			<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>server</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>num_segments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>FTEXECLOCATION_COORDINATOR</name></expr>:</case>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized exec_location '%c'"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>exec_location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>fdw_outerpath</name></name> <operator>=</operator> <name>fdw_outerpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>fdw_private</name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_foreign_upper_path
 *	  Creates a path corresponding to an upper relation that's computed
 *	  directly by an FDW, returning the pathnode.
 *
 * This function is never called from core Postgres; rather, it's expected to
 * be called by the GetForeignUpperPaths function of a foreign data wrapper.
 * We make the FDW supply all fields of the path, since we do not have any way
 * to calculate them in core.  However, there is a usually-sane default for
 * the pathtarget (rel-&gt;reltarget), so we let a NULL for "target" select that.
 */</comment>
<function><type><name>ForeignPath</name> <modifier>*</modifier></type>
<name>create_foreign_upper_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
						  <parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>fdw_outerpath</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Upper relations should never have any lateral references, since joining
	 * is complete.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <ternary><condition><expr><name>target</name></expr> ?</condition><then> <expr><name>target</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>exec_location</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FTEXECLOCATION_ANY</name></expr>:</case>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTEXECLOCATION_ALL_SEGMENTS</name></expr>:</case>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTEXECLOCATION_COORDINATOR</name></expr>:</case>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized exec_location '%c'"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>exec_location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>fdw_outerpath</name></name> <operator>=</operator> <name>fdw_outerpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>fdw_private</name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * calc_nestloop_required_outer
 *	  Compute the required_outer set for a nestloop join path
 *
 * Note: result must not share storage with either input
 */</comment>
<function><type><name>Relids</name></type>
<name>calc_nestloop_required_outer</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>,
							 <parameter><decl><type><name>Relids</name></type> <name>outer_paramrels</name></decl></parameter>,
							 <parameter><decl><type><name>Relids</name></type> <name>innerrelids</name></decl></parameter>,
							 <parameter><decl><type><name>Relids</name></type> <name>inner_paramrels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/* inner_path can require rels from outer path, but not vice versa */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>, <argument><expr><name>innerrelids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* easy case if inner path is not parameterized */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inner_paramrels</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* else, form the union ... */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>, <argument><expr><name>inner_paramrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... and remove any mention of now-satisfied outer rels */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>,
									 <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* maintain invariant that required_outer is exactly NULL if empty */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>required_outer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * calc_non_nestloop_required_outer
 *	  Compute the required_outer set for a merge or hash join path
 *
 * Note: result must not share storage with either input
 */</comment>
<function><type><name>Relids</name></type>
<name>calc_non_nestloop_required_outer</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>outer_paramrels</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_paramrels</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/* neither path can require rels from the other */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>, <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>inner_paramrels</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* form the union ... */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>, <argument><expr><name>inner_paramrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we do not need an explicit test for empty; bms_union gets it right */</comment>
	<return>return <expr><name>required_outer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_nestloop_path
 *	  Creates a pathnode corresponding to a nestloop join between two
 *	  relations.
 *
 * 'joinrel' is the join relation.
 * 'jointype' is the type of join required
 * 'workspace' is the result from initial_cost_nestloop
 * 'extra' contains various information about the join
 * 'outer_path' is the outer path
 * 'inner_path' is the inner path
 * 'restrict_clauses' are the RestrictInfo nodes to apply at the join
 * 'pathkeys' are the path keys of the new join path
 * 'required_outer' is the set of required outer rels
 *
 * Returns the resulting path node.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_nestloop_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>orig_jointype</name></decl></parameter>,		<comment type="block">/* CDB */</comment>
					 <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
					 <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
					 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
					 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>redistribution_clauses</name></decl></parameter>,	<comment type="block">/* CDB */</comment>
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
					 <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NestPath</name>   <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>join_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>outer_req_outer</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>outer_must_be_local</name> <init>= <expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>outer_req_outer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_req_outer</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inner_must_be_local</name> <init>= <expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>inner_req_outer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowidexpr_id</name></decl>;</decl_stmt>

	<comment type="block">/* Add motion nodes above subpaths and decide where to join. */</comment>
	<expr_stmt><expr><name>join_locus</name> <operator>=</operator> <call><name>cdbpath_motion_for_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>orig_jointype</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>outer_path</name></expr></argument>,       <comment type="block">/* INOUT */</comment>
										 <argument><expr><operator>&amp;</operator><name>inner_path</name></expr></argument>,       <comment type="block">/* INOUT */</comment>
										 <argument><expr><operator>&amp;</operator><name>rowidexpr_id</name></expr></argument>,		<comment type="block">/* OUT */</comment>
										 <argument><expr><name>redistribution_clauses</name></expr></argument>,
										 <argument><expr><name>restrict_clauses</name></expr></argument>,
										 <argument><expr><name>pathkeys</name></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>,
										 <argument><expr><name>outer_must_be_local</name></expr></argument>,
										 <argument><expr><name>inner_must_be_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsNull</name><argument_list>(<argument><expr><name>join_locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Outer might not be ordered anymore after motion. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>outer_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this join path is parameterized by a parameter above this path, then
	 * this path needs to be rescannable. A NestLoop is rescannable, when both
	 * outer and inner paths rescannable, so make them both rescannable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>outer_path</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>matouter</name> <init>= <expr><call><name>create_material_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>outer_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>matouter</name><operator>-&gt;</operator><name>cdb_shield_child_from_rescans</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>outer_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>matouter</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If outer has at most one row, NJ will make at most one pass over inner.
	 * Else materialize inner rel after motion so NJ can loop over results.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>inner_path</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * NLs potentially rescan the inner; if our inner path
		 * isn't rescannable we have to add a materialize node
		 */</comment>
		<decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>matinner</name> <init>= <expr><call><name>create_material_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>matinner</name><operator>-&gt;</operator><name>cdb_shield_child_from_rescans</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have motion on the outer, to avoid a deadlock; we
		 * need to set cdb_strict. In order for materialize to
		 * fully fetch the underlying (required to avoid our
		 * deadlock hazard) we must set cdb_strict!
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>inner_path</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>&amp;&amp;</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>matinner</name><operator>-&gt;</operator><name>cdb_strict</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>matinner</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>inner_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>matinner</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the inner path is parameterized by the outer, we must drop any
	 * restrict_clauses that are due to be moved into the inner path.  We have
	 * to do this now, rather than postpone the work till createplan time,
	 * because the restrict_clauses list can affect the size and cost
	 * estimates for this path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>inner_req_outer</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_and_outer</name> <init>= <expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
												<argument><expr><name>inner_req_outer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>jclauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>restrict_clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
											 <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											 <argument><expr><name>inner_and_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>jclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>jclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>restrict_clauses</name> <operator>=</operator> <name>jclauses</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NestPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_NestLoop</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>joinrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator>
		<call><name>get_joinrel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name>joinrel</name></expr></argument>,
								  <argument><expr><name>outer_path</name></expr></argument>,
								  <argument><expr><name>inner_path</name></expr></argument>,
								  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>,
								  <argument><expr><name>required_outer</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>restrict_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>outer_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<comment type="block">/* This is a foolish way to estimate parallel_workers, but for now... */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name> <operator>=</operator> <name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name> <operator>=</operator> <name>outer_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name> <operator>=</operator> <name>inner_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name> <operator>=</operator> <name>restrict_clauses</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>join_locus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>||</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>

	<comment type="block">/* we're only as rescannable as our child plans */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>&amp;&amp;</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>rescannable</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * inner_path &amp; outer_path are possibly modified above. Let's recalculate
	 * the initial cost.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_nestloop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
						  <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>,
						  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>final_cost_nestloop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>orig_jointype</name> <operator>==</operator> <name>JOIN_DEDUP_SEMI</name> <operator>||</operator>
		<name>orig_jointype</name> <operator>==</operator> <name>JOIN_DEDUP_SEMI_REVERSE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_unique_rowid_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>joinrel</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>,
												 <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
												 <argument><expr><name>rowidexpr_id</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Greenplum specific behavior:
	 * If we find the join locus is general or segmentgeneral,
	 * we should check the joinqual, if it contains volatile functions
	 * we have to turn the join path to singleQE.
	 *
	 * NB: we do not add this logic in the above create_unique_rowid_path
	 * code block, the reason is:
	 *   create_unique_rowid_path is a technique to implement semi join
	 *   using normal join, it can only happens for sublink query:
	 *   1. if the sublink query contains volatile target list or havingQual
	 *      it cannot be pulled up in pull_up_subquery, so it will be a
	 *      subselect and be handled in the function set_subquery_pathlist
	 *   2. if the sublink query contains volatile functions in joinqual
	 *      or where clause, it will be handled in set_rel_pathlist and
	 *      here.
	 */</comment>
	<return>return <expr><call><name>turn_volatile_seggen_to_singleqe</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_mergejoin_path
 *	  Creates a pathnode corresponding to a mergejoin join between
 *	  two relations
 *
 * 'joinrel' is the join relation
 * 'jointype' is the type of join required
 * 'workspace' is the result from initial_cost_mergejoin
 * 'extra' contains various information about the join
 * 'outer_path' is the outer path
 * 'inner_path' is the inner path
 * 'restrict_clauses' are the RestrictInfo nodes to apply at the join
 * 'pathkeys' are the path keys of the new join path
 * 'required_outer' is the set of required outer rels
 * 'mergeclauses' are the RestrictInfo nodes to use as merge clauses
 *		(this should be a subset of the restrict_clauses list)
 * 'allmergeclauses' are the RestrictInfo nodes that are of the form
 *      required of merge clauses (equijoin between outer and inner rel).
 *      Consists of the ones to be used for merging ('mergeclauses') plus
 *      any others in 'restrict_clauses' that are to be applied after the
 *      merge.  We use them for motion planning.  (CDB)

 * 'outersortkeys' are the sort varkeys for the outer relation
 *      or NIL to use existing ordering
 * 'innersortkeys' are the sort varkeys for the inner relation
 *      or NIL to use existing ordering
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_mergejoin_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					  <parameter><decl><type><name>JoinType</name></type> <name>orig_jointype</name></decl></parameter>,		<comment type="block">/* CDB */</comment>
					  <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
					  <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
					  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>redistribution_clauses</name></decl></parameter>,	<comment type="block">/* CDB */</comment>
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outersortkeys</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>innersortkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergePath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>join_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outermotionkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>innermotionkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>preserve_outer_ordering</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>preserve_inner_ordering</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowidexpr_id</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * GPDB_92_MERGE_FIXME: Should we keep the pathkeys_contained_in calls?
	 */</comment>
	<comment type="block">/*
	 * Do subpaths have useful ordering?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outersortkeys</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>           <comment type="block">/* must preserve existing ordering */</comment>
		<expr_stmt><expr><name>outermotionkeys</name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>outersortkeys</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outermotionkeys</name> <operator>=</operator> <name>outersortkeys</name></expr>;</expr_stmt></block_content></block></if><comment type="block">/* lucky coincidence, already ordered */</comment>
	<else>else<block type="pseudo"><block_content>                                <comment type="block">/* existing order useless; must sort */</comment>
		<expr_stmt><expr><name>outermotionkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>innersortkeys</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>innermotionkeys</name> <operator>=</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>innersortkeys</name></expr></argument>, <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>innermotionkeys</name> <operator>=</operator> <name>innersortkeys</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>innermotionkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Add motion nodes above subpaths and decide where to join.
	 *
	 * If we're explicitly sorting one or both sides of the join, don't choose
	 * a Motion that would break that ordering again. But as a special case,
	 * if there are no merge clauses, then there is no join order that would need
	 * preserving. That case can occur with a query like "a FULL JOIN b ON true"
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mergeclauses</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preserve_outer_ordering</name> <operator>=</operator> <operator>(</operator><name>outersortkeys</name> <operator>==</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>preserve_inner_ordering</name> <operator>=</operator> <operator>(</operator><name>innersortkeys</name> <operator>==</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>preserve_outer_ordering</name> <operator>=</operator> <name>preserve_inner_ordering</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>preserve_outer_ordering</name> <operator>=</operator> <name>preserve_outer_ordering</name> <operator>||</operator> <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>preserve_inner_ordering</name> <operator>=</operator> <name>preserve_inner_ordering</name> <operator>||</operator> <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>join_locus</name> <operator>=</operator> <call><name>cdbpath_motion_for_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>orig_jointype</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>outer_path</name></expr></argument>,       <comment type="block">/* INOUT */</comment>
										 <argument><expr><operator>&amp;</operator><name>inner_path</name></expr></argument>,       <comment type="block">/* INOUT */</comment>
										 <argument><expr><operator>&amp;</operator><name>rowidexpr_id</name></expr></argument>,
										 <argument><expr><name>redistribution_clauses</name></expr></argument>,
										 <argument><expr><name>restrict_clauses</name></expr></argument>,
										 <argument><expr><name>outermotionkeys</name></expr></argument>,
										 <argument><expr><name>innermotionkeys</name></expr></argument>,
										 <argument><expr><name>preserve_outer_ordering</name></expr></argument>,
										 <argument><expr><name>preserve_inner_ordering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsNull</name><argument_list>(<argument><expr><name>join_locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Sort is not needed if subpath is already well enough ordered and a
	 * disordering motion node (with pathkeys == NIL) hasn't been added.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outermotionkeys</name> <operator>&amp;&amp;</operator>
		<name><name>outer_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>innermotionkeys</name> <operator>&amp;&amp;</operator>
		<name><name>inner_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>innersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_MergeJoin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>joinrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator>
		<call><name>get_joinrel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name>joinrel</name></expr></argument>,
								  <argument><expr><name>outer_path</name></expr></argument>,
								  <argument><expr><name>inner_path</name></expr></argument>,
								  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>,
								  <argument><expr><name>required_outer</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>restrict_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>outer_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<comment type="block">/* This is a foolish way to estimate parallel_workers, but for now... */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>join_locus</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>||</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>&amp;&amp;</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>rescannable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name> <operator>=</operator> <name>outer_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name> <operator>=</operator> <name>inner_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name> <operator>=</operator> <name>restrict_clauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path_mergeclauses</name></name> <operator>=</operator> <name>mergeclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outersortkeys</name></name> <operator>=</operator> <name>outersortkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innersortkeys</name></name> <operator>=</operator> <name>innersortkeys</name></expr>;</expr_stmt>
	<comment type="block">/* pathnode-&gt;skip_mark_restore will be set by final_cost_mergejoin */</comment>
	<comment type="block">/* pathnode-&gt;materialize_inner will be set by final_cost_mergejoin */</comment>

	<comment type="block">/*
	 * inner_path &amp; outer_path are possibly modified above. Let's recalculate
	 * the initial cost.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_mergejoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>mergeclauses</name></expr></argument>,
						   <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>,
						   <argument><expr><name>outersortkeys</name></expr></argument>, <argument><expr><name>innersortkeys</name></expr></argument>,
						   <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>final_cost_mergejoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>orig_jointype</name> <operator>==</operator> <name>JOIN_DEDUP_SEMI</name> <operator>||</operator>
		<name>orig_jointype</name> <operator>==</operator> <name>JOIN_DEDUP_SEMI_REVERSE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_unique_rowid_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>joinrel</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>,
												 <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
												 <argument><expr><name>rowidexpr_id</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * See the comments at the end of create_nestloop_path.
	 */</comment>
	<return>return <expr><call><name>turn_volatile_seggen_to_singleqe</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_hashjoin_path
 *	  Creates a pathnode corresponding to a hash join between two relations.
 *
 * 'joinrel' is the join relation
 * 'jointype' is the type of join required
 * 'workspace' is the result from initial_cost_hashjoin
 * 'extra' contains various information about the join
 * 'outer_path' is the cheapest outer path
 * 'inner_path' is the cheapest inner path
 * 'parallel_hash' to select Parallel Hash of inner path (shared hash table)
 * 'restrict_clauses' are the RestrictInfo nodes to apply at the join
 * 'required_outer' is the set of required outer rels
 * 'hashclauses' are the RestrictInfo nodes to use as hash clauses
 *		(this should be a subset of the restrict_clauses list)
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_hashjoin_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>orig_jointype</name></decl></parameter>,		<comment type="block">/* CDB */</comment>
					 <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
					 <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
					 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
					 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>parallel_hash</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>,
					 <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>redistribution_clauses</name></decl></parameter>,	<comment type="block">/* CDB */</comment>
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashclauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashPath</name>   <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>join_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>outer_must_be_local</name> <init>= <expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inner_must_be_local</name> <init>= <expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowidexpr_id</name></decl>;</decl_stmt>

	<comment type="block">/* Add motion nodes above subpaths and decide where to join. */</comment>
	<expr_stmt><expr><name>join_locus</name> <operator>=</operator> <call><name>cdbpath_motion_for_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>orig_jointype</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>outer_path</name></expr></argument>,       <comment type="block">/* INOUT */</comment>
										 <argument><expr><operator>&amp;</operator><name>inner_path</name></expr></argument>,       <comment type="block">/* INOUT */</comment>
										 <argument><expr><operator>&amp;</operator><name>rowidexpr_id</name></expr></argument>,
										 <argument><expr><name>redistribution_clauses</name></expr></argument>,
										 <argument><expr><name>restrict_clauses</name></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>,   <comment type="block">/* don't care about ordering */</comment>
										 <argument><expr><name>NIL</name></expr></argument>,
										 <argument><expr><name>outer_must_be_local</name></expr></argument>,
										 <argument><expr><name>inner_must_be_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsNull</name><argument_list>(<argument><expr><name>join_locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * CDB: If gp_enable_hashjoin_size_heuristic is set, disallow inner
	 * joins where the inner rel is the larger of the two inputs.
	 *
	 * Note cdbpath_motion_for_join() has to precede this so we can get
	 * the right row count, in case Broadcast Motion is inserted above an
	 * input path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name> <operator>&amp;&amp;</operator> <name>gp_enable_hashjoin_size_heuristic</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>outersize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>innersize</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>outersize</name> <operator>=</operator> <call><name>ExecHashRowSize</name><argument_list>(<argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>*</operator>
			<name><name>outer_path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>innersize</name> <operator>=</operator> <call><name>ExecHashRowSize</name><argument_list>(<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>*</operator>
			<name><name>inner_path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>innersize</name> <operator>&gt;</operator> <name>outersize</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>HashPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_HashJoin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>joinrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator>
		<call><name>get_joinrel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name>joinrel</name></expr></argument>,
								  <argument><expr><name>outer_path</name></expr></argument>,
								  <argument><expr><name>inner_path</name></expr></argument>,
								  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>,
								  <argument><expr><name>required_outer</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>restrict_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator>
		<name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name>parallel_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>outer_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<comment type="block">/* This is a foolish way to estimate parallel_workers, but for now... */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * A hashjoin never has pathkeys, since its output ordering is
	 * unpredictable due to possible batching.  XXX If the inner relation is
	 * small enough, we could instruct the executor that it must not batch,
	 * and then we could assume that the output inherits the outer relation's
	 * ordering, which might save a sort step.  However there is considerable
	 * downside if our estimate of the inner relation size is badly off. For
	 * the moment we don't risk it.  (Note also that if we wanted to take this
	 * seriously, joinpath.c would have to consider many more paths for the
	 * outer rel than it does now.)
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>join_locus</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name> <operator>=</operator> <name>outer_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name> <operator>=</operator> <name>inner_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name> <operator>=</operator> <name>restrict_clauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path_hashclauses</name></name> <operator>=</operator> <name>hashclauses</name></expr>;</expr_stmt>
	<comment type="block">/* final_cost_hashjoin will fill in pathnode-&gt;num_batches */</comment>

	<comment type="block">/*
	 * If hash table overflows to disk, and an ancestor node requests rescan
	 * (e.g. because the HJ is in the inner subtree of a NJ), then the HJ has
	 * to be redone, including rescanning the inner rel in order to rebuild
	 * the hash table.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>rescannable</name></name> <operator>&amp;&amp;</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>rescannable</name></name></expr>;</expr_stmt>

	<comment type="block">/* see the comment above; we may have a motion hazard on our inner ?! */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rescannable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>motionHazard</name></name> <operator>||</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * inner_path &amp; outer_path are possibly modified above. Let's recalculate
	 * the initial cost.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_hashjoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>hashclauses</name></expr></argument>,
						  <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>,
						  <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>parallel_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>final_cost_hashjoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>orig_jointype</name> <operator>==</operator> <name>JOIN_DEDUP_SEMI</name> <operator>||</operator>
		<name>orig_jointype</name> <operator>==</operator> <name>JOIN_DEDUP_SEMI_REVERSE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_unique_rowid_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>joinrel</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>,
												 <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
												 <argument><expr><name>rowidexpr_id</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * See the comments at the end of create_nestloop_path.
	 */</comment>
	<return>return <expr><call><name>turn_volatile_seggen_to_singleqe</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_projection_path
 *	  Creates a pathnode that represents performing a projection.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 */</comment>
<function><type><name>ProjectionPath</name> <modifier>*</modifier></type>
<name>create_projection_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>create_projection_path_with_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
											 <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
											 <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ProjectionPath</name> <modifier>*</modifier></type>
<name>create_projection_path_with_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
								  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>need_param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProjectionPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>oldtarget</name> <init>= <expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Result</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <ternary><condition><expr><name>need_param</name></expr> ?</condition><then> <expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<comment type="block">/* Projection does not change the sort order */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>sameslice_relids</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We might not need a separate Result node.  If the input plan node type
	 * can project, we can just tell it to project something else.  Or, if it
	 * can't project but the desired target has the same expression list as
	 * what the input will produce anyway, we can still give it the desired
	 * tlist (possibly changing its ressortgroupref labels, but nothing else).
	 * Note: in the latter case, create_projection_plan has to recheck our
	 * conclusion; see comments therein.
	 *
	 * GPDB: The 'restrict_clauses' is a GPDB addition. If the subpath supports
	 * Filters, we could push them down too. But currently this is only used on
	 * top of Material paths, which don't support it, so it doesn't matter.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>restrict_clauses</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>is_projection_capable_path</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>equal</name><argument_list>(<argument><expr><name><name>oldtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No separate Result node needed */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>dummypp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set cost of plan as subpath's cost, adjusted for tlist replacement.
		 */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
			<operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>-</operator> <name><name>oldtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
			<operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>-</operator> <name><name>oldtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name><operator>)</operator> <operator>+</operator>
			<operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>-</operator> <name><name>oldtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We really do need the Result node */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>dummypp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The Result node's cost is cpu_tuple_cost per row, plus the cost of
		 * evaluating the tlist.  There is no qual to worry about.
		 */</comment>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
			<name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
			<name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
			<operator>(</operator><name>cpu_tuple_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>cdb_restrict_clauses</name></name> <operator>=</operator> <name>restrict_clauses</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * apply_projection_to_path
 *	  Add a projection step, or just apply the target directly to given path.
 *
 * This has the same net effect as create_projection_path(), except that if
 * a separate Result plan node isn't needed, we just replace the given path's
 * pathtarget with the desired one.  This must be used only when the caller
 * knows that the given path isn't referenced elsewhere and so can be modified
 * in-place.
 *
 * If the input path is a GatherPath or GatherMergePath, we try to push the
 * new target down to its input as well; this is a yet more invasive
 * modification of the input path, which create_projection_path() can't do.
 *
 * Note that we mustn't change the source path's parent link; so when it is
 * add_path'd to "rel" things will be a bit inconsistent.  So far that has
 * not caused any trouble.
 *
 * 'rel' is the parent relation associated with the result
 * 'path' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>apply_projection_to_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
						 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>oldcost</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If given path can't project, we might need a Result node, so make a
	 * separate ProjectionPath.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_projection_capable_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can just jam the desired tlist into the existing path, being sure to
	 * update its cost estimates appropriately.
	 */</comment>
	<expr_stmt><expr><name>oldcost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>-</operator> <name><name>oldcost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>-</operator> <name><name>oldcost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
		<operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>-</operator> <name><name>oldcost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the path happens to be a Gather or GatherMerge path, we'd like to
	 * arrange for the subpath to return the required target list so that
	 * workers can help project.  But if there is something that is not
	 * parallel-safe in the target expressions, then we can't.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>GatherPath</name></expr></argument>)</argument_list></call> <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>GatherMergePath</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We always use create_projection_path here, even if the subpath is
		 * projection-capable, so as to avoid modifying the subpath in place.
		 * It seems unlikely at present that there could be any other
		 * references to the subpath, but better safe than sorry.
		 *
		 * Note that we don't change the parallel path's cost estimates; it
		 * might be appropriate to do so, to reflect the fact that the bulk of
		 * the target evaluation will happen in workers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>GatherPath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>gpath</name> <init>= <expr><operator>(</operator><name>GatherPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>gpath</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name><name>gpath</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
									   <argument><expr><name><name>gpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
									   <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>gmpath</name> <init>= <expr><operator>(</operator><name>GatherMergePath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>gmpath</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name><name>gmpath</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
									   <argument><expr><name><name>gmpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
									   <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're inserting a parallel-restricted target list into a path
		 * currently marked parallel-safe, so we have to mark it as no longer
		 * safe.
		 */</comment>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_set_projection_path
 *	  Creates a pathnode that represents performing a projection that
 *	  includes set-returning functions.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 */</comment>
<function><type><name>ProjectSetPath</name> <modifier>*</modifier></type>
<name>create_set_projection_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
						   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProjectSetPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ProjectSetPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tlist_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ProjectSet</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<comment type="block">/* Projection does not change the sort order XXX? */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of rows produced by SRFs for each row of input; if
	 * there's more than one in this node, use the maximum.
	 */</comment>
	<expr_stmt><expr><name>tlist_rows</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>itemrows</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemrows</name> <operator>=</operator> <call><name>expression_returns_set_rows</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tlist_rows</name> <operator>&lt;</operator> <name>itemrows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tlist_rows</name> <operator>=</operator> <name>itemrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * In addition to the cost of evaluating the tlist, charge cpu_tuple_cost
	 * per input row, and half of cpu_tuple_cost for each added output row.
	 * This is slightly bizarre maybe, but it's what 9.6 did; we may revisit
	 * this estimate later.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>tlist_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
		<name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
		<name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
		<operator>(</operator><name>cpu_tuple_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>+</operator>
		<operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>-</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name><operator>)</operator> <operator>*</operator> <name>cpu_tuple_cost</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_sort_path
 *	  Creates a pathnode that represents performing an explicit sort.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'pathkeys' represents the desired sort order
 * 'limit_tuples' is the estimated bound on the number of output tuples,
 *		or -1 if no LIMIT or couldn't estimate
 */</comment>
<function><type><name>SortPath</name> <modifier>*</modifier></type>
<name>create_sort_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortPath</name>   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SortPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathkeys</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Sort</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<comment type="block">/* Sort doesn't project, so use source path's pathtarget */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
			  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
			  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
			  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
			  <argument><expr><literal type="number">0.0</literal></expr></argument>,				<comment type="block">/* XXX comparison_cost shouldn't be 0? */</comment>
			  <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>limit_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef> <comment type="block">/* Group nodes are not used in GPDB */</comment>
<comment type="block">/*
 * create_group_path
 *	  Creates a pathnode that represents performing grouping of presorted input
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 * 'groupClause' is a list of SortGroupClause's representing the grouping
 * 'qual' is the HAVING quals if any
 * 'numGroups' is the estimated number of groups
 */</comment>
<function><type><name>GroupPath</name> <modifier>*</modifier></type>
<name>create_group_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
				  <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GroupPath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Group</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<comment type="block">/* Group doesn't change sort ordering */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>groupClause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_group</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
			   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>numGroups</name></expr></argument>,
			   <argument><expr><name>qual</name></expr></argument>,
			   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
			   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add tlist eval cost for each output row */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
		<name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * create_upper_unique_path
 *	  Creates a pathnode that represents performing an explicit Unique step
 *	  on presorted input.
 *
 * This produces a Unique plan node, but the use-case is so different from
 * create_unique_path that it doesn't seem worth trying to merge the two.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'numCols' is the number of grouping columns
 * 'numGroups' is the estimated number of groups
 *
 * The input path must be sorted on the grouping columns, plus possibly
 * additional columns; so the first numCols pathkeys are the grouping columns
 */</comment>
<function><type><name>UpperUniquePath</name> <modifier>*</modifier></type>
<name>create_upper_unique_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>,
						 <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UpperUniquePath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>UpperUniquePath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Unique</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<comment type="block">/* Unique doesn't project, so use source path's pathtarget */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<comment type="block">/* Unique doesn't change the input ordering */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>numkeys</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Charge one cpu_operator_cost per comparison per input tuple. We assume
	 * all columns get compared at most of the tuples.  (XXX probably this is
	 * an overestimate.)
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
		<name>cpu_operator_cost</name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>numCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_agg_path
 *	  Creates a pathnode that represents performing aggregation/grouping
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 * 'aggstrategy' is the Agg node's basic implementation strategy
 * 'aggsplit' is the Agg node's aggregate-splitting mode
 * 'groupClause' is a list of SortGroupClause's representing the grouping
 * 'qual' is the HAVING quals if any
 * 'aggcosts' contains cost info about the aggregate functions to be computed
 * 'numGroups' is the estimated number of groups (1 if not grouping)
 */</comment>
<function><type><name>AggPath</name> <modifier>*</modifier></type>
<name>create_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
				<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
				<parameter><decl><type><name>AggStrategy</name></type> <name>aggstrategy</name></decl></parameter>,
				<parameter><decl><type><name>AggSplit</name></type> <name>aggsplit</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>streaming</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>aggcosts</name></decl></parameter>,
				<parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AggPath</name>    <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AggPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Agg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_SORTED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* preserves order */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* output is unordered */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>streaming</name></name> <operator>=</operator> <name>streaming</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name>aggstrategy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>aggsplit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>groupClause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
			 <argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>aggcosts</name></expr></argument>,
			 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>numGroups</name></expr></argument>,
			 <argument><expr><name>qual</name></expr></argument>,
			 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
			 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add tlist eval cost for each output row */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
		<name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tup_split_path
 *	  Creates a pathnode that represents performing TupleSplit
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 * 'groupClause' is a list of SortGroupClause's representing the grouping
 * 'numGroups' is the estimated number of groups (1 if not grouping)
 * 'bitmapset' is the bitmap of DQA expr Index in PathTarget
 * 'numDisDQAs' is the number of bitmapset size
 */</comment>
<function><type><name>TupleSplitPath</name> <modifier>*</modifier></type>
<name>create_tup_split_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
					  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dqa_expr_lst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleSplitPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TupleSplitPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_TupleSplit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>groupClause</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>dqa_expr_lst</name></name> <operator>=</operator> <name>dqa_expr_lst</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_tup_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>dqa_expr_lst</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
				   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>,
							<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_groupingsets_path
 *	  Creates a pathnode that represents performing GROUPING SETS aggregation
 *
 * GroupingSetsPath represents sorted grouping with one or more grouping sets.
 * The input path's result must be sorted to match the last entry in
 * rollup_groupclauses.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 * 'having_qual' is the HAVING quals if any
 * 'rollups' is a list of RollupData nodes
 * 'agg_costs' contains cost info about the aggregate functions to be computed
 */</comment>
<function><type><name>GroupingSetsPath</name> <modifier>*</modifier></type>
<name>create_groupingsets_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
						 <parameter><decl><type><name>AggSplit</name></type> <name>aggsplit</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>having_qual</name></decl></parameter>,
						 <parameter><decl><type><name>AggStrategy</name></type> <name>aggstrategy</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rollups</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GroupingSetsPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingSetsPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_first_sort</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* The topmost generated Plan node will be an Agg */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Agg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Simplify callers by downgrading AGG_SORTED to AGG_PLAIN, and AGG_MIXED
	 * to AGG_HASHED, here if possible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_SORTED</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>RollupData</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>groupClause</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aggstrategy</name> <operator>=</operator> <name>AGG_PLAIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_MIXED</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aggstrategy</name> <operator>=</operator> <name>AGG_HASHED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Output will be in sorted order by group_pathkeys if, and only if, there
	 * is a single rollup operation on a non-empty list of grouping
	 * expressions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_SORTED</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>aggsplit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name>aggstrategy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rollups</name></name> <operator>=</operator> <name>rollups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>having_qual</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rollups</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aggstrategy</name> <operator>!=</operator> <name>AGG_PLAIN</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aggstrategy</name> <operator>!=</operator> <name>AGG_MIXED</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rollups</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gsets</name> <init>= <expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numGroupCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In AGG_SORTED or AGG_PLAIN mode, the first rollup takes the
		 * (already-sorted) input, and following ones do their own sort.
		 *
		 * In AGG_HASHED mode, there is one rollup for each grouping set.
		 *
		 * In AGG_MIXED mode, the first rollups are hashed, the first
		 * non-hashed one takes the (already-sorted) input, and following ones
		 * do their own sort.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
					 <argument><expr><name>aggstrategy</name></expr></argument>,
					 <argument><expr><name>agg_costs</name></expr></argument>,
					 <argument><expr><name>numGroupCols</name></expr></argument>,
					 <argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
													<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
													<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>having_qual</name></expr></argument>,
					 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
					 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
					 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
					 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_first_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name></type>		<name>sort_path</name></decl>;</decl_stmt>	<comment type="block">/* dummy for result of cost_sort */</comment>
			<decl_stmt><decl><type><name>Path</name></type>		<name>agg_path</name></decl>;</decl_stmt>	<comment type="block">/* dummy for result of cost_agg */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>||</operator> <name>is_first_sort</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Account for cost of aggregation, but don't charge input
				 * cost again
				 */</comment>
				<expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr> ?</condition><then> <expr><name>AGG_HASHED</name></expr> </then><else>: <expr><name>AGG_SORTED</name></expr></else></ternary></expr></argument>,
						 <argument><expr><name>agg_costs</name></expr></argument>,
						 <argument><expr><name>numGroupCols</name></expr></argument>,
						 <argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
														<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
														<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>having_qual</name></expr></argument>,
						 <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>,
						 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
						 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>is_first_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Account for cost of sort, but don't charge input cost again */</comment>
				<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
						  <argument><expr><literal type="number">0.0</literal></expr></argument>,
						  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
						  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
						  <argument><expr><literal type="number">0.0</literal></expr></argument>,
						  <argument><expr><name>work_mem</name></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Account for cost of aggregation */</comment>

				<expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
						 <argument><expr><name>AGG_SORTED</name></expr></argument>,
						 <argument><expr><name>agg_costs</name></expr></argument>,
						 <argument><expr><name>numGroupCols</name></expr></argument>,
						 <argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
														<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
														<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>having_qual</name></expr></argument>,
						 <argument><expr><name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr></argument>,
						 <argument><expr><name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
						 <argument><expr><name><name>sort_path</name><operator>.</operator><name>rows</name></name></expr></argument>,
						 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>agg_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>agg_path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* add tlist eval cost for each output row */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
		<name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is a one-stage aggregate, the caller should already have
	 * ensured that the data is distributed so that a one-stage aggregate
	 * works, and the distribution is preserved. But if this is the first
	 * stage of a multi-stage aggregate, if any distribution key columns
	 * are part of rollups, they will be set to NULLs for the rolled up
	 * rows. That breaks the distribution.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>,
								<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_minmaxagg_path
 *	  Creates a pathnode that represents computation of MIN/MAX aggregates
 *
 * 'rel' is the parent relation associated with the result
 * 'target' is the PathTarget to be computed
 * 'mmaggregates' is a list of MinMaxAggInfo structs
 * 'quals' is the HAVING quals if any
 */</comment>
<function><type><name>MinMaxAggPath</name> <modifier>*</modifier></type>
<name>create_minmaxagg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mmaggregates</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinMaxAggPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MinMaxAggPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>initplan_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbLocusType</name></type> <name>locustype</name> <init>= <expr><name>CdbLocusType_Null</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* The topmost generated Plan node will be a Result */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Result</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* A MinMaxAggPath implies use of subplans, so cannot be parallel-safe */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Result is one unordered row */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>mmaggregates</name></name> <operator>=</operator> <name>mmaggregates</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt>

	<comment type="block">/* Calculate cost of all the initplans ... */</comment>
	<expr_stmt><expr><name>initplan_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mmaggregates</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>mminfo</name> <init>= <expr><operator>(</operator><name>MinMaxAggInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>initplan_cost</name> <operator>+=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>pathcost</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * All the subpaths should have SingleQE locus, if the underlying
		 * table is partitioned, build_minmax_path() ensures that. But
		 * double-check here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>locustype</name> <operator>==</operator> <name>CdbLocusType_Null</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>locustype</name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>locustype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"minmax path has unexpected path locus of type %d"</literal></expr></argument>,
					 <argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>locustype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>locustype</name> <operator>!=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>locustype</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"minmax paths have different loci"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>mmaggregates</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>locustype</name> <operator>=</operator> <name>CdbLocusType_General</name></expr>;</expr_stmt>
		<comment type="block">/* numsegments is useless for general locus, so should be -1 */</comment>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we checked that all the child paths have compatible loci */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeSimple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>, <argument><expr><name>locustype</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* add tlist eval cost for each output row, plus cpu_tuple_cost */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>initplan_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>initplan_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
		<name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+</operator> <name>cpu_tuple_cost</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add cost of qual, if any --- but we ignore its selectivity, since our
	 * rowcount estimate should be 1 no matter what the qual is.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>quals</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>qual_cost</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qual_cost</name></expr></argument>, <argument><expr><name>quals</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_windowagg_path
 *	  Creates a pathnode that represents computation of window functions
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 * 'windowFuncs' is a list of WindowFunc structs
 * 'winclause' is a WindowClause that is common to all the WindowFuncs
 *
 * The input must be sorted according to the WindowClause's PARTITION keys
 * plus ORDER BY keys.
 */</comment>
<function><type><name>WindowAggPath</name> <modifier>*</modifier></type>
<name>create_windowagg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
					  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>windowFuncs</name></decl></parameter>,
					  <parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>winclause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAggPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WindowAggPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_WindowAgg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<comment type="block">/* WindowAgg preserves the input sort order */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>winclause</name></name> <operator>=</operator> <name>winclause</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For costing purposes, assume that there are no redundant partitioning
	 * or ordering columns; it's not worth the trouble to deal with that
	 * corner case here.  So we just pass the unmodified list lengths to
	 * cost_windowagg.
	 */</comment>
	<expr_stmt><expr><call><name>cost_windowagg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
				   <argument><expr><name>windowFuncs</name></expr></argument>,
				   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>winclause</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>winclause</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
				   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
				   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add tlist eval cost for each output row */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
		<name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_setop_path
 *	  Creates a pathnode that represents computation of INTERSECT or EXCEPT
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'cmd' is the specific semantics (INTERSECT or EXCEPT, with/without ALL)
 * 'strategy' is the implementation strategy (sorted or hashed)
 * 'distinctList' is a list of SortGroupClause's representing the grouping
 * 'flagColIdx' is the column number where the flag column will be, if any
 * 'firstFlag' is the flag value for the first input relation when hashing;
 *		or -1 when sorting
 * 'numGroups' is the estimated number of distinct groups
 * 'outputRows' is the estimated number of output rows
 */</comment>
<function><type><name>SetOpPath</name> <modifier>*</modifier></type>
<name>create_setop_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
				  <parameter><decl><type><name>SetOpCmd</name></type> <name>cmd</name></decl></parameter>,
				  <parameter><decl><type><name>SetOpStrategy</name></type> <name>strategy</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>,
				  <parameter><decl><type><name>AttrNumber</name></type> <name>flagColIdx</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>firstFlag</name></decl></parameter>,
				  <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>,
				  <parameter><decl><type><name>double</name></type> <name>outputRows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOpPath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetOpPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_SetOp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<comment type="block">/* SetOp doesn't project, so use source path's pathtarget */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<comment type="block">/* SetOp preserves the input sort order if in sort mode */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator>
		<ternary><condition><expr><operator>(</operator><name>strategy</name> <operator>==</operator> <name>SETOP_SORTED</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>distinctList</name></name> <operator>=</operator> <name>distinctList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>flagColIdx</name></name> <operator>=</operator> <name>flagColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>firstFlag</name></name> <operator>=</operator> <name>firstFlag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Charge one cpu_operator_cost per comparison per input tuple. We assume
	 * all columns get compared at most of the tuples.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
		<name>cpu_operator_cost</name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>outputRows</name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_recursiveunion_path
 *	  Creates a pathnode that represents a recursive UNION node
 *
 * 'rel' is the parent relation associated with the result
 * 'leftpath' is the source of data for the non-recursive term
 * 'rightpath' is the source of data for the recursive term
 * 'target' is the PathTarget to be computed
 * 'distinctList' is a list of SortGroupClause's representing the grouping
 * 'wtParam' is the ID of Param representing work table
 * 'numGroups' is the estimated number of groups
 *
 * For recursive UNION ALL, distinctList is empty and numGroups is zero
 */</comment>
<function><type><name>RecursiveUnionPath</name> <modifier>*</modifier></type>
<name>create_recursiveunion_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>leftpath</name></decl></parameter>,
						   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>rightpath</name></decl></parameter>,
						   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>,
						   <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecursiveUnionPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RecursiveUnionPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_RecursiveUnion</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>leftpath</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator> <name><name>rightpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<comment type="block">/* Foolish, but we'll do it like joins for now: */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>leftpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<comment type="block">/* RecursiveUnion result is always unsorted */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>leftpath</name></name> <operator>=</operator> <name>leftpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rightpath</name></name> <operator>=</operator> <name>rightpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>distinctList</name></name> <operator>=</operator> <name>distinctList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>wtParam</name></name> <operator>=</operator> <name>wtParam</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_recursive_union</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>leftpath</name></expr></argument>, <argument><expr><name>rightpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_lockrows_path
 *	  Creates a pathnode that represents acquiring row locks
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'rowMarks' is a list of PlanRowMark's
 * 'epqParam' is the ID of Param for EvalPlanQual re-eval
 */</comment>
<function><type><name>LockRowsPath</name> <modifier>*</modifier></type>
<name>create_lockrows_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockRowsPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>LockRowsPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_LockRows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<comment type="block">/* LockRows doesn't project, so use source path's pathtarget */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The result cannot be assumed sorted, since locking might cause the sort
	 * key columns to be replaced with new values.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>rowMarks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should charge something extra for the costs of row locking and
	 * possible refetches, but it's hard to say how much.  For now, use
	 * cpu_tuple_cost per row.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
		<name>cpu_tuple_cost</name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_modifytable_path
 *	  Creates a pathnode that represents performing INSERT/UPDATE/DELETE mods
 *
 * 'rel' is the parent relation associated with the result
 * 'operation' is the operation type
 * 'canSetTag' is true if we set the command tag/es_processed
 * 'nominalRelation' is the parent RT index for use of EXPLAIN
 * 'rootRelation' is the partitioned table root RT index, or 0 if none
 * 'partColsUpdated' is true if any partitioning columns are being updated,
 *		either from the target relation or a descendent partitioned table.
 * 'resultRelations' is an integer list of actual RT indexes of target rel(s)
 * 'subpaths' is a list of Path(s) producing source data (one per rel)
 * 'subroots' is a list of PlannerInfo structs (one per rel)
 * 'withCheckOptionLists' is a list of WCO lists (one per rel)
 * 'returningLists' is a list of RETURNING tlists (one per rel)
 * 'rowMarks' is a list of PlanRowMarks (non-locking only)
 * 'onconflict' is the ON CONFLICT clause, or NULL
 * 'epqParam' is the ID of Param for EvalPlanQual re-eval
 */</comment>
<function><type><name>ModifyTablePath</name> <modifier>*</modifier></type>
<name>create_modifytable_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						<parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
						<parameter><decl><type><name>Index</name></type> <name>nominalRelation</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rootRelation</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>partColsUpdated</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultRelations</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subroots</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>withCheckOptionLists</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningLists</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>is_split_updates</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>onconflict</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ModifyTablePath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subroots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>withCheckOptionLists</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		   <call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>returningLists</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		   <call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>is_split_updates</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ModifyTable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<comment type="block">/* pathtarget is not interesting, just make it minimally valid */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Put Motions on top of the subpaths as needed, and set the locus of the
	 * ModifyTable path itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator>
			<call><name>adjust_modifytable_subpaths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>,
										<argument><expr><name>resultRelations</name></expr></argument>, <argument><expr><name>subpaths</name></expr></argument>,
										<argument><expr><name>is_split_updates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* don't allow split updates in utility mode. */</comment>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name> <operator>&amp;&amp;</operator> <name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
			<call><name>list_member_int</name><argument_list>(<argument><expr><name>is_split_updates</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update distribution key columns in utility mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Compute cost &amp; rowcount as sum of subpath costs &amp; rowcounts.
	 *
	 * Currently, we don't charge anything extra for the actual table
	 * modification work, nor for the WITH CHECK OPTIONS or RETURNING
	 * expressions if any.  It would only be window dressing, since
	 * ModifyTable is always a top-level node and there is no way for the
	 * costs to change any higher-level planning choices.  But we might want
	 * to make it look better sometime.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* first node? */</comment>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_size</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Set width to the average width of the subpath outputs.  XXX this is
	 * totally wrong: we should report zero if no RETURNING, else an average
	 * of the RETURNING tlist widths.  But it's what happened historically,
	 * and improving it is a task for another day.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>total_size</name> <operator>/=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>operation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>canSetTag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>nominalRelation</name></name> <operator>=</operator> <name>nominalRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rootRelation</name></name> <operator>=</operator> <name>rootRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>partColsUpdated</name></name> <operator>=</operator> <name>partColsUpdated</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name>resultRelations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>is_split_updates</name></name> <operator>=</operator> <name>is_split_updates</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>=</operator> <name>subpaths</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <name>subroots</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name> <operator>=</operator> <name>withCheckOptionLists</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>returningLists</name></name> <operator>=</operator> <name>returningLists</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>rowMarks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>onconflict</name></name> <operator>=</operator> <name>onconflict</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Add Motions to children of a ModifyTable path, so that data
 * is modified on the correct segments.
 *
 * The input to a ModifyTable node must be distributed according to the
 * DISTRIBUTED BY of the target table. Add Motion paths to the child
 * plans for that. Returns a locus to represent the distribution of the
 * ModifyTable node itself.
 */</comment>
<function><type><specifier>static</specifier> <name>CdbPathLocus</name></type>
<name>adjust_modifytable_subpaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultRelations</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>is_split_updates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The input plans must be distributed correctly.
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lcp</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lci</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_subplans_entry</name> <init>= <expr><name>true</name></expr></init></decl>,
				<decl><type ref="prev"/><name>all_subplans_replicated</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lci</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>is_split_updates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>forboth</name><argument_list>(<argument>lcr</argument>, <argument>resultRelations</argument>, <argument>lcp</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rti</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>targetPolicy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpPolicyType</name></type> <name>targetPolicyType</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>targetPolicy</name> <operator>=</operator> <call><name>GpPolicyFetch</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetPolicyType</name> <operator>=</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>ptype</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>targetPolicyType</name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>all_subplans_entry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>all_subplans_replicated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>targetPolicyType</name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Master-only table */</comment>
			<expr_stmt><expr><name>all_subplans_replicated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>targetPolicyType</name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>all_subplans_entry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized policy type %u"</literal></expr></argument>, <argument><expr><name>targetPolicyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>create_motion_path_for_insert</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>targetPolicy</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>create_motion_path_for_upddel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>targetPolicy</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_split_update</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>is_split_update</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>is_split_update</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>create_split_update_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>targetPolicy</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>create_motion_path_for_upddel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>targetPolicy</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>lci</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Set the distribution of the ModifyTable node itself. If there is only
	 * one subplan, or all the subplans have a compatible distribution, then
	 * we could mark the ModifyTable with the same distribution key. However,
	 * currently, because a ModifyTable node can only be at the top of the
	 * plan, it won't make any difference to the overall plan.
	 *
	 * GPDB_96_MERGE_FIXME: it might with e.g. a INSERT RETURNING in a CTE
	 * I tried here, the locus setting is quite simple, but failed if it's not
	 * in a CTE and the locus is General. Haven't figured out how to create
	 * flow in that case.
	 * Example:
	 * CREATE TABLE cte_returning_locus(c1 int) DISTRIBUTED BY (c1);
	 * COPY cte_returning_locus FROM PROGRAM 'seq 1 100';
	 * EXPLAIN WITH aa AS (
	 *        INSERT INTO cte_returning_locus SELECT generate_series(3,300) RETURNING c1
	 * )
	 * SELECT count(*) FROM aa,cte_returning_locus WHERE aa.c1 = cte_returning_locus.c1;
	 *
	 * The returning doesn't need a motion to be hash joined, works fine. But
	 * without the WITH, what is the proper flow? FLOW_SINGLETON returns
	 * nothing, FLOW_PARTITIONED without hashExprs(General locus has no
	 * distkeys) returns duplication.
	 *
	 * GPDB_90_MERGE_FIXME: I've hacked a basic implementation of the above for
	 * the case where all the subplans are POLICYTYPE_ENTRY, but it seems like
	 * there should be a more general way to do this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>all_subplans_entry</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>resultLocus</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resultLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>resultLocus</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>all_subplans_replicated</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>resultLocus</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numsegments</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resultLocus</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>resultLocus</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>resultLocus</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numsegments</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resultLocus</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>resultLocus</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_limit_path
 *	  Creates a pathnode that represents performing LIMIT/OFFSET
 *
 * In addition to providing the actual OFFSET and LIMIT expressions,
 * the caller must provide estimates of their values for costing purposes.
 * The estimates are as computed by preprocess_limit(), ie, 0 represents
 * the clause not being present, and -1 means it's present but we could
 * not estimate its value.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'limitOffset' is the actual OFFSET expression, or NULL
 * 'limitCount' is the actual LIMIT expression, or NULL
 * 'offset_est' is the estimated value of the OFFSET expression
 * 'count_est' is the estimated value of the LIMIT expression
 *
 * Greenplum specific change: the return type is changed to Path
 * because at the end of function, we need to check if it is
 * segment general locus and may create other kind of path.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_limit_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name></decl></parameter>,
				  <parameter><decl><type><name>int64</name></type> <name>offset_est</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>count_est</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LimitPath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>LimitPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Limit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<comment type="block">/* Limit doesn't project, so use source path's pathtarget */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name>limitOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>limitCount</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust the output rows count and costs according to the offset/limit.
	 */</comment>
	<expr_stmt><expr><call><name>adjust_limit_rows_costs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
							<argument><expr><name>offset_est</name></expr></argument>, <argument><expr><name>count_est</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Greenplum specific behavior:
	 * If the limit path's locus is general or segmentgeneral
	 * we have to make it singleQE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>turn_volatile_seggen_to_singleqe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>pathnode</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_limit_rows_costs
 *	  Adjust the size and cost estimates for a LimitPath node according to the
 *	  offset/limit.
 *
 * This is only a cosmetic issue if we are at top level, but if we are
 * building a subquery then it's important to report correct info to the outer
 * planner.
 *
 * When the offset or count couldn't be estimated, use 10% of the estimated
 * number of rows emitted from the subpath.
 *
 * XXX we don't bother to add eval costs of the offset/limit expressions
 * themselves to the path costs.  In theory we should, but in most cases those
 * expressions are trivial and it's just not worth the trouble.
 */</comment>
<function><type><name>void</name></type>
<name>adjust_limit_rows_costs</name><parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>,	<comment type="block">/* in/out parameter */</comment>
						<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>startup_cost</name></decl></parameter>, <comment type="block">/* in/out parameter */</comment>
						<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>total_cost</name></decl></parameter>,	<comment type="block">/* in/out parameter */</comment>
						<parameter><decl><type><name>int64</name></type> <name>offset_est</name></decl></parameter>,
						<parameter><decl><type><name>int64</name></type> <name>count_est</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>input_rows</name> <init>= <expr><operator>*</operator><name>rows</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>input_startup_cost</name> <init>= <expr><operator>*</operator><name>startup_cost</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>input_total_cost</name> <init>= <expr><operator>*</operator><name>total_cost</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset_est</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>offset_rows</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>offset_est</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>offset_rows</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>offset_est</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>offset_rows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>input_rows</name> <operator>*</operator> <literal type="number">0.10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>offset_rows</name> <operator>&gt;</operator> <operator>*</operator><name>rows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>offset_rows</name> <operator>=</operator> <operator>*</operator><name>rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>input_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>startup_cost</name> <operator>+=</operator>
				<operator>(</operator><name>input_total_cost</name> <operator>-</operator> <name>input_startup_cost</name><operator>)</operator>
				<operator>*</operator> <name>offset_rows</name> <operator>/</operator> <name>input_rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>rows</name> <operator>-=</operator> <name>offset_rows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rows</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>rows</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>count_est</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>count_rows</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>count_est</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>count_rows</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>count_est</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>count_rows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>input_rows</name> <operator>*</operator> <literal type="number">0.10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>count_rows</name> <operator>&gt;</operator> <operator>*</operator><name>rows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>count_rows</name> <operator>=</operator> <operator>*</operator><name>rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>input_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>total_cost</name> <operator>=</operator> <operator>*</operator><name>startup_cost</name> <operator>+</operator>
				<operator>(</operator><name>input_total_cost</name> <operator>-</operator> <name>input_startup_cost</name><operator>)</operator>
				<operator>*</operator> <name>count_rows</name> <operator>/</operator> <name>input_rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>rows</name> <operator>=</operator> <name>count_rows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rows</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>rows</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * reparameterize_path
 *		Attempt to modify a Path to have greater parameterization
 *
 * We use this to attempt to bring all child paths of an appendrel to the
 * same parameterization level, ensuring that they all enforce the same set
 * of join quals (and thus that that parameterization can be attributed to
 * an append path built from such paths).  Currently, only a few path types
 * are supported here, though more could be added at need.  We return NULL
 * if we can't reparameterize the given path.
 *
 * Note: we intentionally do not pass created paths to add_path(); it would
 * possibly try to delete them on the grounds of being cost-inferior to the
 * paths they were made from, and we don't want that.  Paths made here are
 * not necessarily of general-purpose usefulness, but they can be useful
 * as members of an append path.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>reparameterize_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					<parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
					<parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Can only increase, not decrease, path's parameterization */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<return>return <expr><call><name>create_seqscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_samplescan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>ipath</name> <init>= <expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>newpath</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * We can't use create_index_path directly, and would not want
				 * to because it would re-compute the indexqual conditions
				 * which is wasted effort.  Instead we hack things a bit:
				 * flat-copy the path node, revise its param_info, and redo
				 * the cost estimate.
				 */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>ipath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator>
					<call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cost_index</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>newpath</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>bpath</name> <init>= <expr><operator>(</operator><name>BitmapHeapPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_bitmap_heap_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><name>rel</name></expr></argument>,
														<argument><expr><name><name>bpath</name><operator>-&gt;</operator><name>bitmapqual</name></name></expr></argument>,
														<argument><expr><name>required_outer</name></expr></argument>,
														<argument><expr><name>loop_count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>spath</name> <init>= <expr><operator>(</operator><name>SubqueryScanPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name>rel</name></expr></argument>,
														 <argument><expr><name><name>spath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
														 <argument><expr><name><name>spath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
														 <argument><expr><name><name>spath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>,
														 <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<comment type="block">/* Supported only for RTE_RESULT scan paths */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>create_resultscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Append</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>apath</name> <init>= <expr><operator>(</operator><name>AppendPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>childpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partialpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/* Reparameterize the children */</comment>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>apath-&gt;subpaths</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>spath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>spath</name> <operator>=</operator> <call><name>reparameterize_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>spath</name></expr></argument>,
												<argument><expr><name>required_outer</name></expr></argument>,
												<argument><expr><name>loop_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>spath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
					<comment type="block">/* We have to re-split the regular and partial paths */</comment>
					<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>apath</name><operator>-&gt;</operator><name>first_partial_path</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>childpaths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>childpaths</name></expr></argument>, <argument><expr><name>spath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>partialpaths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>partialpaths</name></expr></argument>, <argument><expr><name>spath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>
				<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
					<call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>childpaths</name></expr></argument>, <argument><expr><name>partialpaths</name></expr></argument>,
									   <argument><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>,
									   <argument><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name></expr></argument>,
									   <argument><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name></expr></argument>,
									   <argument><expr><name><name>apath</name><operator>-&gt;</operator><name>partitioned_rels</name></name></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * reparameterize_path_by_child
 * 		Given a path parameterized by the parent of the given child relation,
 * 		translate the path to be parameterized by the given child relation.
 *
 * The function creates a new path of the same type as the given path, but
 * parameterized by the given child relation.  Most fields from the original
 * path can simply be flat-copied, but any expressions must be adjusted to
 * refer to the correct varnos, and any paths must be recursively
 * reparameterized.  Other fields that refer to specific relids also need
 * adjustment.
 *
 * The cost, number of rows, width and parallel path properties depend upon
 * path-&gt;parent, which does not change during the translation. Hence those
 * members are copied as they are.
 *
 * If the given path can not be reparameterized, the function returns NULL.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>reparameterize_path_by_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAT_COPY_PATH</name><parameter_list>(<parameter><type><name>newnode</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>nodetype</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>( (newnode) = makeNode(nodetype), \
	  memcpy((newnode), (node), sizeof(nodetype)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADJUST_CHILD_ATTRS</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((node) = \
	 (List *) adjust_appendrel_attrs_multilevel(root, (Node *) (node), \
												child_rel-&gt;relids, \
												child_rel-&gt;top_parent_relids))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPARAMETERIZE_CHILD_PATH</name><parameter_list>(<parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	(path) = reparameterize_path_by_child(root, (path), child_rel); \
	if ((path) == NULL) \
		return NULL; \
} while(0);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPARAMETERIZE_CHILD_PATH_LIST</name><parameter_list>(<parameter><type><name>pathlist</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if ((pathlist) != NIL) \
	{ \
		(pathlist) = reparameterize_pathlist_by_child(root, (pathlist), \
													  child_rel); \
		if ((pathlist) == NIL) \
			return NULL; \
	} \
} while(0);</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>new_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>new_ppi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>old_ppi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the path is not parameterized by parent of the given relation, it
	 * doesn't need reparameterization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>||</operator>
		<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reparameterize a copy of given path. */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Path</name></expr>:</case>
			<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>ipath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>ipath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>ipath</name><operator>-&gt;</operator><name>indexclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>ipath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>bhpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>bhpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapHeapPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>bhpath</name><operator>-&gt;</operator><name>bitmapqual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>bhpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAndPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapAndPath</name> <modifier>*</modifier></type><name>bapath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>bapath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapAndPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>bapath</name><operator>-&gt;</operator><name>bitmapquals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>bapath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOrPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapOrPath</name> <modifier>*</modifier></type><name>bopath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>bopath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapOrPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>bopath</name><operator>-&gt;</operator><name>bitmapquals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>bopath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_TidPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TidPath</name>    <modifier>*</modifier></type><name>tpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>tpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TidPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>tpath</name><operator>-&gt;</operator><name>tidquals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>tpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ForeignPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>fpath</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ReparameterizeForeignPathByChild_function</name></type> <name>rfpc_func</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ForeignPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>fpath</name><operator>-&gt;</operator><name>fdw_outerpath</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>fpath</name><operator>-&gt;</operator><name>fdw_outerpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Hand over to FDW if needed. */</comment>
				<expr_stmt><expr><name>rfpc_func</name> <operator>=</operator>
					<name><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>ReparameterizeForeignPathByChild</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>rfpc_func</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>fpath</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <call><name>rfpc_func</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fpath</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
												   <argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>fpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CustomPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>cpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>CustomPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>custom_paths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>cpath</name><operator>-&gt;</operator><name>methods</name></name> <operator>&amp;&amp;</operator>
					<name><name>cpath</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>ReparameterizeCustomPathByChild</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>cpath</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator>
						<call><name><name>cpath</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>ReparameterizeCustomPathByChild</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																		<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>,
																		<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>cpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NestPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinPath</name>   <modifier>*</modifier></type><name>jpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>jpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NestPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>jpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MergePath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinPath</name>   <modifier>*</modifier></type><name>jpath</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MergePath</name>  <modifier>*</modifier></type><name>mpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>mpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>jpath</name> <operator>=</operator> <operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>mpath</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>mpath</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>mpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_HashPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinPath</name>   <modifier>*</modifier></type><name>jpath</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HashPath</name>   <modifier>*</modifier></type><name>hpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>hpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>HashPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>jpath</name> <operator>=</operator> <operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>hpath</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>hpath</name><operator>-&gt;</operator><name>path_hashclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>hpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AppendPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>apath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>apath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>apath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>mapath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>mapath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>mapath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>mapath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MaterialPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>mpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>mpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MaterialPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>mpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>mpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_UniquePath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>upath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>upath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>upath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>upath</name><operator>-&gt;</operator><name>uniq_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>upath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_GatherPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>gpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>gpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>GatherPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>gpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>gpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_GatherMergePath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>gmpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>gmpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>GatherMergePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>gmpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>gmpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>

			<comment type="block">/* We don't know how to reparameterize this path. */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Adjust the parameterization information, which refers to the topmost
	 * parent. The topmost parent can be multiple levels away from the given
	 * child, hence use multi-level expression adjustment routines.
	 */</comment>
	<expr_stmt><expr><name>old_ppi</name> <operator>=</operator> <name><name>new_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator>
		<call><name>adjust_child_relids_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>old_ppi</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>,
									   <argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									   <argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we already have a PPI for this parameterization, just return it */</comment>
	<expr_stmt><expr><name>new_ppi</name> <operator>=</operator> <call><name>find_param_path_info</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If not, build a new one and link it to the list of PPIs. For the same
	 * reason as explained in mark_dummy_rel(), allocate new PPI in the same
	 * context the given RelOptInfo is in.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_ppi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_ppi</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ParamPathInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_ppi</name><operator>-&gt;</operator><name>ppi_req_outer</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_ppi</name><operator>-&gt;</operator><name>ppi_rows</name></name> <operator>=</operator> <name><name>old_ppi</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_ppi</name><operator>-&gt;</operator><name>ppi_clauses</name></name> <operator>=</operator> <name><name>old_ppi</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>new_ppi</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>ppilist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>ppilist</name></name></expr></argument>, <argument><expr><name>new_ppi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <name>new_ppi</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust the path target if the parent of the outer relation is
	 * referenced in the targetlist. This can happen when only the parent of
	 * outer relation is laterally referenced in this relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
					<argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>new_path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>new_path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * reparameterize_pathlist_by_child
 * 		Helper function to reparameterize a list of paths by given child rel.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>reparameterize_pathlist_by_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathlist</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>reparameterize_path_by_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
