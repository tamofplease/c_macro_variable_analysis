<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/util/appendinfo.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * appendinfo.c
 *	  Routines for mapping between append parent(s) and children
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/path/appendinfo.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/appendinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
}</block></struct></type> <name>adjust_appendrel_attrs_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_inh_translation_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>oldrelation</name></decl></parameter>,
									  <parameter><decl><type><name>Relation</name></type> <name>newrelation</name></decl></parameter>,
									  <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
									  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>adjust_appendrel_attrs_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
											<parameter><decl><type><name>adjust_appendrel_attrs_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>adjust_inherited_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
									<parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * make_append_rel_info
 *	  Build an AppendRelInfo for the parent-child pair
 */</comment>
<function><type><name>AppendRelInfo</name> <modifier>*</modifier></type>
<name>make_append_rel_info</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>childrel</name></decl></parameter>,
					 <parameter><decl><type><name>Index</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>childRTindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <name>parentRTindex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>=</operator> <name>childRTindex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name> <operator>=</operator> <name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_inh_translation_list</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reloid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>appinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_inh_translation_list
 *	  Build the list of translations from parent Vars to child Vars for
 *	  an inheritance child.
 *
 * For paranoia's sake, we match type/collation as well as attribute name.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_inh_translation_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>oldrelation</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>newrelation</name></decl></parameter>,
						  <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>old_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>oldrelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>new_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>new_relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldnatts</name> <init>= <expr><name><name>old_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newnatts</name> <init>= <expr><name><name>new_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>old_attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>old_attno</name> <operator>&lt;</operator> <name>oldnatts</name></expr>;</condition> <incr><expr><name>old_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttypid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>atttypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>old_tupdesc</name></expr></argument>, <argument><expr><name>old_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Just put NULL into this list entry */</comment>
			<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>atttypid</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>atttypmod</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When we are generating the "translation list" for the parent table
		 * of an inheritance set, no need to search for matches.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldrelation</name> <operator>==</operator> <name>newrelation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><call><name>makeVar</name><argument_list>(<argument><expr><name>newvarno</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>(</operator><name>old_attno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
										 <argument><expr><name>atttypid</name></expr></argument>,
										 <argument><expr><name>atttypmod</name></expr></argument>,
										 <argument><expr><name>attcollation</name></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise we have to search for the matching column by name.
		 * There's no guarantee it'll have the same column position, because
		 * of cases like ALTER TABLE ADD COLUMN and multiple inheritance.
		 * However, in simple cases, the relative order of columns is mostly
		 * the same in both relations, so try the column of newrelation that
		 * follows immediately after the one that we just found, and if that
		 * fails, let syscache handle it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_attno</name> <operator>&gt;=</operator> <name>newnatts</name> <operator>||</operator>
			<operator>(</operator><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>new_tupdesc</name></expr></argument>, <argument><expr><name>new_attno</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attisdropped</name> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>new_relid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find inherited attribute \"%s\" of relation \"%s\""</literal></expr></argument>,
					 <argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>new_attno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>new_tupdesc</name></expr></argument>, <argument><expr><name>new_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Found it, check type and collation match */</comment>
		<if_stmt><if>if <condition>(<expr><name>atttypid</name> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator> <name>atttypmod</name> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute \"%s\" of relation \"%s\" does not match parent's type"</literal></expr></argument>,
				 <argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attcollation</name> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute \"%s\" of relation \"%s\" does not match parent's collation"</literal></expr></argument>,
				 <argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><call><name>makeVar</name><argument_list>(<argument><expr><name>newvarno</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>(</operator><name>new_attno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
									 <argument><expr><name>atttypid</name></expr></argument>,
									 <argument><expr><name>atttypmod</name></expr></argument>,
									 <argument><expr><name>attcollation</name></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_attno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>translated_vars</name> <operator>=</operator> <name>vars</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_appendrel_attrs
 *	  Copy the specified query or expression and translate Vars referring to a
 *	  parent rel to refer to the corresponding child rel instead.  We also
 *	  update rtindexes appearing outside Vars, such as resultRelation and
 *	  jointree relids.
 *
 * Note: this is only applied after conversion of sublinks to subplans,
 * so we don't need to cope with recursion into sub-queries.
 *
 * Note: this is not hugely different from what pullup_replace_vars() does;
 * maybe we should try to fold the two routines together.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>adjust_appendrel_attrs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nappinfos</name></decl></parameter>,
					   <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>adjust_appendrel_attrs_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nappinfos</name></name> <operator>=</operator> <name>nappinfos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>appinfos</name></name> <operator>=</operator> <name>appinfos</name></expr>;</expr_stmt>

	<comment type="block">/* If there's nothing to adjust, don't call this function. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nappinfos</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>appinfos</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
									 <argument><expr><name>adjust_appendrel_attrs_mutator</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
									 <argument><expr><name>QTW_IGNORE_RC_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>newnode</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
				<comment type="block">/* Fix tlist resnos too, if it's inherited UPDATE */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>newnode</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator>
						<call><name>adjust_inherited_tlist</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
											   <argument><expr><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>adjust_appendrel_attrs_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>adjust_appendrel_attrs_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>adjust_appendrel_attrs_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name><operator>-&gt;</operator><name>parent_relid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>appinfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d of relation \"%s\" does not exist"</literal></expr></argument>,
						 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>,
											  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>newnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d of relation \"%s\" does not exist"</literal></expr></argument>,
						 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>newnode</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Whole-row Var: if we are dealing with named rowtypes, we
				 * can use a whole-row Var for the child table plus a coercion
				 * step to convert the tuple layout to the parent's rowtype.
				 * Otherwise we have to generate a RowExpr.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name> <operator>!=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
						<comment type="block">/* Make sure the Var node has the right type ID, too */</comment>
						<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name></expr>;</expr_stmt>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Build a RowExpr containing the translated variables.
					 *
					 * In practice var-&gt;vartype will always be RECORDOID here,
					 * so we need to come up with some suitable column names.
					 * We use the parent RTE's column names.
					 *
					 * Note: we can't get here for inheritance cases, so there
					 * is no need to worry that translated_vars might contain
					 * some dummy NULLs.
					 */</comment>
					<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fields</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>,
								   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>fields</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>rowexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>fields</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rowexpr</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* system attributes don't need any other translation */</comment>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Copy the JoinExpr node with correct mutation of subnodes */</comment>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
												 <argument><expr><name>adjust_appendrel_attrs_mutator</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* now fix JoinExpr's rtindex (probably never happens) */</comment>
		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Copy the PlaceHolderVar node with correct mutation of subnodes */</comment>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>phv</name> <operator>=</operator> <operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
														 <argument><expr><name>adjust_appendrel_attrs_mutator</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* now fix PlaceHolderVar's relid sets */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Shouldn't need to handle planner auxiliary nodes here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MinMaxAggInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to process RestrictInfo nodes specially.  (Note: although
	 * set_append_rel_pathlist will hide RestrictInfos in the parent's
	 * baserestrictinfo list from us, it doesn't hide those in joininfo.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>oldinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>newinfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Copy all flat-copiable fields */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newinfo</name></expr></argument>, <argument><expr><name>oldinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recursively fix the clause itself */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oldinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and the modified version, if an OR clause */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>orclause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oldinfo</name><operator>-&gt;</operator><name>orclause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* adjust relid sets too */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>clause_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>,
													 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>required_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>,
													   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>outer_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>outer_relids</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>,
													   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>,
												   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
												   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset cached derivative fields, since these might need to have
		 * different values when considering the child relation.  Note we
		 * don't reset left_ec/right_ec: each child variable is implicitly
		 * equivalent to its parent, so still a member of the same EC if any.
		 */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>norm_selec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>outer_selec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>scansel_cache</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_bucketsize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_bucketsize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_mcvfreq</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_mcvfreq</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newinfo</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * NOTE: we do not need to recurse into sublinks, because they should
	 * already have been converted to subplans before we see them.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>adjust_appendrel_attrs_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In GPDB, if you have two SubPlans referring to the same initplan, we
	 * require two separate copies of the subplan, one for each SubPlan
	 * reference. That's because even if a plan is otherwise the same, we
	 * may want to later apply different flow to different SubPlans
	 * referring it. Any subplan that is left unused, because we created
	 * the new copy here, will be removed by remove_unused_subplans().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>	   <modifier>*</modifier></type><name>sp</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sp</name><operator>-&gt;</operator><name>is_initplan</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>newsubplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>planner_subplan_get_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>newsubroot</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newsubroot</name></expr></argument>, <argument><expr><call><name>planner_subplan_get_root</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Add the subplan and its subroot to the global lists.
			 */</comment>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>newsubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>, <argument><expr><name>newsubroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * expression_tree_mutator made a copy of the SubPlan already, so
			 * we can modify it directly.
			 */</comment>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>plan_name</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s (copy %d)"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_appendrel_attrs_multilevel
 *	  Apply Var translations from a toplevel appendrel parent down to a child.
 *
 * In some cases we need to translate expressions referencing a parent relation
 * to reference an appendrel child that's multiple levels removed from it.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>adjust_appendrel_attrs_multilevel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								  <parameter><decl><type><name>Relids</name></type> <name>child_relids</name></decl></parameter>,
								  <parameter><decl><type><name>Relids</name></type> <name>top_parent_relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>parent_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>child_relids</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_relids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct relids set for the immediate parent of given child. */</comment>
	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Recurse if immediate parent is not the top parent. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>adjust_appendrel_attrs_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>parent_relids</name></expr></argument>,
												 <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now translate for this child */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Substitute child relids for parent relids in a Relid set.  The array of
 * appinfos specifies the substitutions to be performed.
 */</comment>
<function><type><name>Relids</name></type>
<name>adjust_child_relids</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nappinfos</name></decl></parameter>, <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Remove parent, add child */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Make a copy if we are changing the set. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If we made any changes, return the modified copy. */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise, return the original set without modification. */</comment>
	<return>return <expr><name>relids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replace any relid present in top_parent_relids with its child in
 * child_relids. Members of child_relids can be multiple levels below top
 * parent in the partition hierarchy.
 */</comment>
<function><type><name>Relids</name></type>
<name>adjust_child_relids_multilevel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
							   <parameter><decl><type><name>Relids</name></type> <name>child_relids</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>top_parent_relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>parent_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>tmp_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the given relids set doesn't contain any of the top parent relids,
	 * it will remain unchanged.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>relids</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_relids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct relids set for the immediate parent of the given child. */</comment>
	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Recurse if immediate parent is not the top parent. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmp_result</name> <operator>=</operator> <call><name>adjust_child_relids_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>,
													<argument><expr><name>parent_relids</name></expr></argument>,
													<argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <name>tmp_result</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Free memory consumed by any intermediate result. */</comment>
	<if_stmt><if>if <condition>(<expr><name>tmp_result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmp_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the targetlist entries of an inherited UPDATE operation
 *
 * The expressions have already been fixed, but we have to make sure that
 * the target resnos match the child table (they may not, in the case of
 * a column that was added after-the-fact by ALTER TABLE).  In some cases
 * this can force us to re-order the tlist to preserve resno ordering.
 * (We do all this work in special cases so that preptlist.c is fast for
 * the typical case.)
 *
 * The given tlist has already been through expression_tree_mutator;
 * therefore the TargetEntry nodes are fresh copies that it's okay to
 * scribble on.
 *
 * Note that this is not needed for INSERT because INSERT isn't inheritable.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>adjust_inherited_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed_it</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>more</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>;</decl_stmt>

	<comment type="block">/* This should only happen for an inheritance case, not UNION ALL */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan tlist and update resnos to match attnums of child rel */</comment>
	<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>childvar</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk items */</comment>

		<comment type="block">/* Look up the translation of this column: it must be a Var */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d of relation \"%s\" does not exist"</literal></expr></argument>,
				 <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>childvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>childvar</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>childvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d of relation \"%s\" does not exist"</literal></expr></argument>,
				 <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>!=</operator> <name><name>childvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name><name>childvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>changed_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we changed anything, re-sort the tlist by resno, and make sure
	 * resjunk entries have resnos above the last real resno.  The sort
	 * algorithm is a bit stupid, but for such a seldom-taken path, small is
	 * probably better than fast.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_it</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tlist</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>more</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>more</name></expr>;</condition> <incr><expr><name>attrno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>more</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>tlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore junk items */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>attrno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <name>attrno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>more</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* here, ignore non-junk items */</comment>

		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>attrno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attrno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_appinfos_by_relids
 * 		Find AppendRelInfo structures for all relations specified by relids.
 *
 * The AppendRelInfos are returned in an array, which can be pfree'd by the
 * caller. *nappinfos is set to the number of entries in the array.
 */</comment>
<function><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>find_appinfos_by_relids</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nappinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>nappinfos</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendRelInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>appinfo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"child rel %d not found in append_rel_array"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>appinfos</name><index>[<expr><name>cnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>appinfo</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>appinfos</name></expr>;</return>
</block_content>}</block></function>
</unit>
