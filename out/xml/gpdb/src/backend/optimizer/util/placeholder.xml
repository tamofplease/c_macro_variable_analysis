<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/util/placeholder.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * placeholder.c
 *	  PlaceHolderVar and PlaceHolderInfo manipulation routines
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/placeholder.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/placeholder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<comment type="block">/* Local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>find_placeholders_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>find_placeholders_in_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * make_placeholder_expr
 *		Make a PlaceHolderVar for the given expression.
 *
 * phrels is the syntactic location (as a set of baserels) to attribute
 * to the expression.
 */</comment>
<function><type><name>PlaceHolderVar</name> <modifier>*</modifier></type>
<name>make_placeholder_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>phrels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name> <operator>=</operator> <name>phrels</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phid</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>lastPHId</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>phv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_placeholder_info
 *		Fetch the PlaceHolderInfo for the given PHV
 *
 * If the PlaceHolderInfo doesn't exist yet, create it if create_new_ph is
 * true, else throw an error.
 *
 * This is separate from make_placeholder_expr because subquery pullup has
 * to make PlaceHolderVars for expressions that might not be used at all in
 * the upper query, or might not remain after const-expression simplification.
 * We build PlaceHolderInfos only for PHVs that are still present in the
 * simplified query passed to query_planner().
 *
 * Note: this should only be called after query_planner() has started.  Also,
 * create_new_ph must not be true after deconstruct_jointree begins, because
 * make_outerjoininfo assumes that we already know about all placeholders.
 */</comment>
<function><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type>
<name>find_placeholder_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>create_new_ph</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>rels_used</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* if this ever isn't true, we'd need to be able to look in parent lists */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>phinfo</name> <operator>=</operator> <operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>phinfo</name><operator>-&gt;</operator><name>phid</name></name> <operator>==</operator> <name><name>phv</name><operator>-&gt;</operator><name>phid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>phinfo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Not found, so create it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>create_new_ph</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too late to create a new PlaceHolderInfo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>phinfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>phid</name></name> <operator>=</operator> <name><name>phv</name><operator>-&gt;</operator><name>phid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Any referenced rels that are outside the PHV's syntactic scope are
	 * LATERAL references, which should be included in ph_lateral but not in
	 * ph_eval_at.  If no referenced rels are within the syntactic scope,
	 * force evaluation at the syntactic location.
	 */</comment>
	<expr_stmt><expr><name>rels_used</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name>rels_used</name></expr></argument>, <argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* make it exactly NULL if empty */</comment>
	<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name> <operator>=</operator> <call><name>bms_int_members</name><argument_list>(<argument><expr><name>rels_used</name></expr></argument>, <argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If no contained vars, force evaluation at syntactic location */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* ph_eval_at may change later, see update_placeholder_eval_levels */</comment>
	<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* initially it's unused */</comment>
	<comment type="block">/* for the moment, estimate width using just the datatype info */</comment>
	<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_width</name></name> <operator>=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>placeholder_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>placeholder_list</name></name></expr></argument>, <argument><expr><name>phinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The PHV's contained expression may contain other, lower-level PHVs.  We
	 * now know we need to get those into the PlaceHolderInfo list, too, so we
	 * may as well do that immediately.
	 */</comment>
	<expr_stmt><expr><call><name>find_placeholders_in_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>phinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_placeholders_in_jointree
 *		Search the jointree for PlaceHolderVars, and build PlaceHolderInfos
 *
 * We don't need to look at the targetlist because build_base_rel_tlists()
 * will already have made entries for any PHVs in the tlist.
 *
 * This is called before we begin deconstruct_jointree.  Once we begin
 * deconstruct_jointree, all active placeholders must be present in
 * root-&gt;placeholder_list, because make_outerjoininfo and
 * update_placeholder_eval_levels require this info to be available
 * while we crawl up the join tree.
 */</comment>
<function><type><name>void</name></type>
<name>find_placeholders_in_jointree</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We need do nothing if the query contains no PlaceHolderVars */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>lastPHId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Start recursion at top of jointree */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			   <call><name>IsA</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>find_placeholders_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * find_placeholders_recurse
 *	  One recursion level of find_placeholders_in_jointree.
 *
 * jtnode is the current jointree node to examine.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_placeholders_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No quals to deal with here */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First, recurse to handle child joins.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>find_placeholders_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Now process the top-level quals.
		 */</comment>
		<expr_stmt><expr><call><name>find_placeholders_in_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * First, recurse to handle child joins.
		 */</comment>
		<expr_stmt><expr><call><name>find_placeholders_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>find_placeholders_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process the qual clauses */</comment>
		<expr_stmt><expr><call><name>find_placeholders_in_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * find_placeholders_in_expr
 *		Find all PlaceHolderVars in the given expression, and create
 *		PlaceHolderInfo entries for them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_placeholders_in_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>vl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * pull_var_clause does more than we need here, but it'll do and it's
	 * convenient to use.
	 */</comment>
	<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
						   <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
						   <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
						   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>vl</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>vl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore any plain Vars */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>phv</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Create a PlaceHolderInfo entry if there's not one already */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * update_placeholder_eval_levels
 *		Adjust the target evaluation levels for placeholders
 *
 * The initial eval_at level set by find_placeholder_info was the set of
 * rels used in the placeholder's expression (or the whole subselect below
 * the placeholder's syntactic location, if the expr is variable-free).
 * If the query contains any outer joins that can null any of those rels,
 * we must delay evaluation to above those joins.
 *
 * We repeat this operation each time we add another outer join to
 * root-&gt;join_info_list.  It's somewhat annoying to have to do that, but
 * since we don't have very much information on the placeholders' locations,
 * it's hard to avoid.  Each placeholder's eval_at level must be correct
 * by the time it starts to figure in outer-join delay decisions for higher
 * outer joins.
 *
 * In future we might want to put additional policy/heuristics here to
 * try to determine an optimal evaluation level.  The current rules will
 * result in evaluation at the lowest possible level.  However, pushing a
 * placeholder eval up the tree is likely to further constrain evaluation
 * order for outer joins, so it could easily be counterproductive; and we
 * don't have enough information at this point to make an intelligent choice.
 */</comment>
<function><type><name>void</name></type>
<name>update_placeholder_eval_levels</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>new_sjinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>syn_level</name> <init>= <expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name><operator>-&gt;</operator><name>phrels</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>eval_at</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_some</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We don't need to do any work on this placeholder unless the
		 * newly-added outer join is syntactically beneath its location.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>new_sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>, <argument><expr><name>syn_level</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>new_sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name>syn_level</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check for delays due to lower outer joins.  This is the same logic
		 * as in check_outerjoin_delay in initsplan.c, except that we don't
		 * have anything to do with the delay_upper_joins flags; delay of
		 * upper outer joins will be handled later, based on the eval_at
		 * values we compute now.
		 */</comment>
		<expr_stmt><expr><name>eval_at</name> <operator>=</operator> <name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr>;</expr_stmt>

		<do>do
		<block>{<block_content>
			<expr_stmt><expr><name>found_some</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* disregard joins not within the PHV's sub-select */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>, <argument><expr><name>syn_level</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name>syn_level</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* do we reference any nullable rels of this OJ? */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>eval_at</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>(</operator><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
					 <call><name>bms_overlap</name><argument_list>(<argument><expr><name>eval_at</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* yes; have we included all its rels in eval_at? */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name>eval_at</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name>eval_at</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* no, so add them in */</comment>
						<expr_stmt><expr><name>eval_at</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>eval_at</name></expr></argument>,
												  <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>eval_at</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>eval_at</name></expr></argument>,
												  <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* we'll need another iteration */</comment>
						<expr_stmt><expr><name>found_some</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block> while <condition>(<expr><name>found_some</name></expr>)</condition>;</do>

		<comment type="block">/* Can't move the PHV's eval_at level to above its syntactic level */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>eval_at</name></expr></argument>, <argument><expr><name>syn_level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name> <operator>=</operator> <name>eval_at</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * fix_placeholder_input_needed_levels
 *		Adjust the "needed at" levels for placeholder inputs
 *
 * This is called after we've finished determining the eval_at levels for
 * all placeholders.  We need to make sure that all vars and placeholders
 * needed to evaluate each placeholder will be available at the scan or join
 * level where the evaluation will be done.  (It might seem that scan-level
 * evaluations aren't interesting, but that's not so: a LATERAL reference
 * within a placeholder's expression needs to cause the referenced var or
 * placeholder to be marked as needed in the scan where it's evaluated.)
 * Note that this loop can have side-effects on the ph_needed sets of other
 * PlaceHolderInfos; that's okay because we don't examine ph_needed here, so
 * there are no ordering issues to worry about.
 */</comment>
<function><type><name>void</name></type>
<name>fix_placeholder_input_needed_levels</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>,
										   <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
										   <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
										   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>add_vars_to_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * add_placeholders_to_base_rels
 *		Add any required PlaceHolderVars to base rels' targetlists.
 *
 * If any placeholder can be computed at a base rel and is needed above it,
 * add it to that rel's targetlist.  This might look like it could be merged
 * with fix_placeholder_input_needed_levels, but it must be separate because
 * join removal happens in between, and can change the ph_eval_at sets.  There
 * is essentially the same logic in add_placeholders_to_joinrel, but we can't
 * do that part until joinrels are formed.
 */</comment>
<function><type><name>void</name></type>
<name>add_placeholders_to_base_rels</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>eval_at</name> <init>= <expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_get_singleton_member</name><argument_list>(<argument><expr><name>eval_at</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varno</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_nonempty_difference</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name></expr></argument>, <argument><expr><name>eval_at</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
											<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* reltarget's cost and width fields will be updated later */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * add_placeholders_to_joinrel
 *		Add any required PlaceHolderVars to a join rel's targetlist;
 *		and if they contain lateral references, add those references to the
 *		joinrel's direct_lateral_relids.
 *
 * A join rel should emit a PlaceHolderVar if (a) the PHV is needed above
 * this join level and (b) the PHV can be computed at or below this level.
 */</comment>
<function><type><name>void</name></type>
<name>add_placeholders_to_joinrel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name> <init>= <expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Is it still needed above this joinrel? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_nonempty_difference</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Is it computable here? */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yup, add it to the output */</comment>
				<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
													<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>+=</operator> <name><name>phinfo</name><operator>-&gt;</operator><name>ph_width</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Charge the cost of evaluating the contained expression if
				 * the PHV can be computed here but not in either input.  This
				 * is a bit bogus because we make the decision based on the
				 * first pair of possible input relations considered for the
				 * joinrel.  With other pairs, it might be possible to compute
				 * the PHV in one input or the other, and then we'd be double
				 * charging the PHV's cost for some join paths.  For now, live
				 * with that; but we might want to improve it later by
				 * refiguring the reltarget costs for each pair of inputs.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>QualCost</name></type>	<name>cost</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cost</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>,
										<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Adjust joinrel's direct_lateral_relids as needed */</comment>
				<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator>
					<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>,
									<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * In GPDB, SubPlans expressions pose a problem, if they're moved or
 * duplicated in the plan tree. If the SubPlan contains any Motions, it can
 * only be evaluated at a particular slice, because the Motion nodes in the
 * SubPlan are set up to send the result to the parent slice. To prevent
 * multiple evaluation of SubPlans, we wrap all SubPlan references in
 * PlaceHolderVars. When wrapped in a PlaceHolderVar, the SubPlan gets
 * evaluated once, at the lowest level in the join tree where possible, and
 * if it's needed elsewhere, its value is propagated up the plan tree, in
 * the target lists of all the nodes.
 *
 * This is more conservative than necessary. It would be OK to evaluate a
 * SubPlan multiple times, as long as all the evaluations happen in the same
 * slice. However, we don't divide the plan into slices until much later in
 * planning, so we don't know that yet. It's quite possibly cheaper to avoid
 * multiple evaluation anyway, since subqueries tend be pretty expensive.
 * (On the other hand, PlaceHolderVars can constrain the join order if there
 * are outer joins in the query.)
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>phrels</name></decl>;</decl_stmt>		<comment type="block">/* current syntactic location (as a set of baserels)
							 * in the join tree. */</comment>
}</block></struct></type> <name>make_placeholders_for_subplans_in_expr_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>subplan_needs_placeholder</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>spexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<comment type="block">/* InitPlans should be converted to Params by now. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>spexpr</name><operator>-&gt;</operator><name>is_initplan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected Init Plan in plan tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't need PlaceHolderVars for plans that are readily executable
	 * anywhere.
	 *
	 * XXX: This isn't exactly what we are worried about here. It's
	 * theoretically possible that the Plan tree contains branches with
	 * Motions, but the topmost node is General. I don't think the planner
	 * can produce such plans at the moment, though.
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>planner_subplan_get_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>spexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>locustype</name></name> <operator>==</operator> <name>CdbLocusType_General</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_placeholders_for_subplans_in_expr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>make_placeholders_for_subplans_in_expr_context</name> <modifier>*</modifier></type><name>cxt</name> <init>=
		<expr><operator>(</operator><name>make_placeholders_for_subplans_in_expr_context</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>placeholder_needed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>	   <modifier>*</modifier></type><name>spexpr</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>subplan_needs_placeholder</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>spexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>placeholder_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/*
	 * An AlternativeSubPlan is wrapped in a PlaceHolder, if any of the
	 * alternative SubPlans need it. (It's probably not possible for only
	 * some of them to need it, but this seems like the right thing to do,
	 * if it was.)
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asp</name> <init>= <expr><operator>(</operator><name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>asp-&gt;subplans</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlan</name>	   <modifier>*</modifier></type><name>spexpr</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>spexpr</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>subplan_needs_placeholder</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>spexpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>placeholder_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>placeholder_needed</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_placeholder_expr</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>make_placeholders_for_subplans_in_expr_mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_placeholders_for_subplans_in_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>phrels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>make_placeholders_for_subplans_in_expr_context</name></type> <name>cxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>phrels</name></name> <operator>=</operator> <name>phrels</name></expr>;</expr_stmt>

	<return>return <expr><call><name>make_placeholders_for_subplans_in_expr_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The logic to track 'scope' is copied from deconstruct_jointree. We cannot
 * do this in deconstruct_jointree(), because it's too late to assign new
 * placeholders there.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_placeholders_for_subplans_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>qualscope</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* No quals to deal with here */</comment>
		<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First, recurse to handle child joins.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relids</name></type>		<name>sub_qualscope</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>make_placeholders_for_subplans_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub_qualscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><operator>*</operator><name>qualscope</name></expr></argument>, <argument><expr><name>sub_qualscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Now process the top-level quals.
		 */</comment>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>make_placeholders_for_subplans_in_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><operator>*</operator><name>qualscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>leftids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>rightids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * First, recurse to handle child joins.
		 */</comment>
		<expr_stmt><expr><call><name>make_placeholders_for_subplans_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>make_placeholders_for_subplans_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>leftids</name></expr></argument>, <argument><expr><name>rightids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process the qual clauses */</comment>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>make_placeholders_for_subplans_in_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><operator>*</operator><name>qualscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>make_placeholders_for_subplans</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>scope</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>make_placeholders_for_subplans_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
