<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/util/walkers.c"><comment type="block">/*
 * walkers.c
 *
 *  Created on: Feb 8, 2011
 *      Author: siva
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/walkers.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/**
 * Plan node walker related methods.
 */</comment>

<comment type="block">/* Initialize a plan_tree_base_prefix during planning. */</comment>
<function><type><name>void</name></type> <name>planner_init_plan_tree_base</name><parameter_list>(<parameter><decl><type><name>plan_tree_base_prefix</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>base</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>root</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize a plan_tree_base_prefix after planning. */</comment>
<function><type><name>void</name></type> <name>exec_init_plan_tree_base</name><parameter_list>(<parameter><decl><type><name>plan_tree_base_prefix</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>base</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>stmt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>walk_scan_node_fields</name><parameter_list>(<parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>walk_join_node_fields</name><parameter_list>(<parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>join</name></decl></parameter>, <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------------- *
 * Plan Tree Walker Framework
 * ----------------------------------------------------------------------- *
 */</comment>

<comment type="block">/* Function walk_plan_node_fields is a subroutine used by plan_tree_walker()
 * to walk the fields of Plan nodes.  Plan is actually an abstract superclass
 * of all plan nodes and this function encapsulates the common structure.
 *
 * Most specific walkers won't need to call this function, but complicated
 * ones may find it a useful utility.
 *
 * Caution: walk_scan_node_fields and walk_join_node_fields call this
 * function.  Use only the most specific function.
 */</comment>
<function><type><name>bool</name></type>
<name>walk_plan_node_fields</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
					  <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* target list to be computed at this node */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name><operator>)</operator></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* implicitly ANDed qual conditions */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name><operator>)</operator></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* input plan tree(s) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name><operator>)</operator></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* target list to be computed at this node */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name><operator>)</operator></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Init Plan nodes (uncorrelated expr subselects */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name><operator>)</operator></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Greenplum Database Flow node */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plan</name><operator>-&gt;</operator><name>flow</name></name><operator>)</operator></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Function walk_scan_node_fields is a subroutine used by plan_tree_walker()
 * to walk the fields of Scan nodes.  Scan is actually an abstract superclass
 * of all scan nodes and a subclass of Plan.  This function encapsulates the
 * common structure.
 *
 * Most specific walkers won't need to call this function, but complicated
 * ones may find it a useful utility.
 *
 * Caution: This function calls walk_plan_node_fields so callers shouldn't,
 * else they will walk common plan fields twice.
 */</comment>
<function><type><name>bool</name></type>
<name>walk_scan_node_fields</name><parameter_list>(<parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>,
					  <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* A Scan node is a kind of Plan node. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>scan</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* The only additional field is an Index so no extra walking. */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Function walk_join_node_fields is a subroutine used by plan_tree_walker()
 * to walk the fields of Join nodes.  Join is actually an abstract superclass
 * of all join nodes and a subclass of Plan.  This function encapsulates the
 * common structure.
 *
 * Most specific walkers won't need to call this function, but complicated
 * ones may find it a useful utility.
 *
 * Caution: This function calls walk_plan_node_fields so callers shouldn't,
 * else they will walk common plan fields twice.
 */</comment>
<function><type><name>bool</name></type>
<name>walk_join_node_fields</name><parameter_list>(<parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>join</name></decl></parameter>,
					  <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* A Join node is a kind of Plan node. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>join</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>join</name><operator>-&gt;</operator><name>joinqual</name></name><operator>)</operator></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Function plan_tree_walker is a general walker for Plan trees.
 *
 * It is based on (and uses) the expression_tree_walker() framework from
 * src/backend/optimizer/util/clauses.c.  See the comments there for more
 * insight into how this function works.
 *
 * The basic idea is that this function (and its helpers) walk plan-specific
 * nodes and delegate other nodes to expression_tree_walker().	The caller
 * may supply a specialized walker
 */</comment>
<function><type><name>bool</name></type>
<name>plan_tree_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				 <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
				 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>recurse_into_subplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The walker has already visited the current node, and so we need
	 * only recurse into any sub-nodes it has.
	 *
	 * We assume that the walker is not interested in List nodes per se, so
	 * when we expect a List we just recurse directly to self without
	 * bothering to call the walker.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Plan nodes aren't handled by expression_tree_walker, so we need
			 * to do them here.
			 */</comment>
		<case>case <expr><name>T_Plan</name></expr>:</case>
			<comment type="block">/* Abstract: really should see only subclasses. */</comment>
			<return>return <expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_Result</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>resconstantqual</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ProjectSet</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Append</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>appendplans</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>mergeplans</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Sequence</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Sequence</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>subplans</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>T_BitmapOr</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

		<case>case <expr><name>T_Scan</name></expr>:</case>
			<comment type="block">/* Abstract: really should see only subclasses. */</comment>
			<return>return <expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
		<case>case <expr><name>T_DynamicSeqScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
		<case>case <expr><name>T_DynamicBitmapHeapScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>fdw_exprs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>custom_plans</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>custom_exprs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>custom_private</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>custom_scan_tlist</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>values_lists</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>tablefunc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
			
		<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TableFunctionScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>function</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>functions</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>param</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_DynamicIndexScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other fields are lists of basic items, nothing to walk. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
		<case>case <expr><name>T_DynamicBitmapIndexScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other fields are lists of basic items, nothing to walk. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>tidquals</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_scan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Join</name></expr>:</case>
			<comment type="block">/* Abstract: really should see only subclasses. */</comment>
			<return>return <expr><call><name>walk_join_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_NestLoop</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_join_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_join_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>mergeclauses</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_join_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>hashclauses</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>hashqualclauses</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Material</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Sort</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other fields are simple counts and lists of indexes and oids. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_Agg</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other fields are simple items and lists of simple items. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_TupleSplit</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>TupleSplit</name> <operator>*</operator><operator>)</operator><name>node</name><operator>)</operator><operator>-&gt;</operator><name>dqa_expr_lst</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other fields are simple items and lists of simple items. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_DQAExpr</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>DQAExpr</name> <operator>*</operator><operator>)</operator><name>node</name><operator>)</operator><operator>-&gt;</operator><name>agg_filter</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other fields are simple items and lists of simple items. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>startOffset</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>endOffset</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Unique</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other fields are simple items and lists of simple items. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_Gather</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other fields are simple items. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_Hash</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other info is in parent HashJoin node. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_SetOp</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Other fields are simple items and lists of simple items. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_Limit</name></expr>:</case>

			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* Greenplum Database Limit Count */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>Limit</name><operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>limitCount</name><operator>)</operator></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* Greenplum Database Limit Offset */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>Limit</name><operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>limitOffset</name><operator>)</operator></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* Other fields are simple items and lists of simple items. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_Motion</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator><name>node</name><operator>)</operator><operator>-&gt;</operator><name>hashExprs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<break>break;</break>

		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Flow</name></expr>:</case>
			<comment type="block">/* Nothing to walk in Flow nodes at present. */</comment>
			<break>break;</break>

		<case>case <expr><name>T_SubPlan</name></expr>:</case>

			<comment type="block">/*
			 * SubPlan is handled by expression_tree_walker() , but that
			 * walker doesn't recur into the plan itself.  Here, we do so
			 * by using information in the prefix structure defined in
			 * cdbplan.h.
			 *
			 * NB Callers usually don't have to take special account of
			 *    the range table, but should be sure to understand what
			 *    stage of processing they occur in (e.g., early planning,
			 *    late planning, dispatch, or execution) since this affects
			 *    what value are available.
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan_plan</name> <init>= <expr><call><name>plan_tree_base_subplan_get_plan</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subplan_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* recurse into the exprs list */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* recurse into the subplan's plan, a kind of Plan node */</comment>
				<if_stmt><if>if <condition>(<expr><name>recurse_into_subplans</name> <operator>&amp;&amp;</operator> <call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan_plan</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* also examine args list */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_IntList</name></expr>:</case>
		<case>case <expr><name>T_OidList</name></expr>:</case>

			<comment type="block">/*
			 * Note that expression_tree_walker handles T_List but not these.
			 * No contained stuff, so just succeed.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>plans</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>withCheckOptionLists</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>onConflictSet</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>onConflictWhere</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>returningLists</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<break>break;</break>

		<case>case <expr><name>T_LockRows</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
		<case>case <expr><name>T_AssertOp</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walk_plan_node_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Query nodes are handled by the Postgres query_tree_walker. We
			 * just use it without setting any ignore flags.  The caller must
			 * handle query nodes specially to get other behavior, e.g. by
			 * calling query_tree_walker directly.
			 */</comment>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

			<comment type="block">/*
			 * The following cases are handled by expression_tree_walker.  In
			 * addition, we let expression_tree_walker handle unrecognized
			 * nodes.
			 *
			 * TODO: Identify node types that should never appear in plan trees
			 * and disallow them here by issuing an error or asserting false.
			 */</comment>
		<case>case <expr><name>T_Var</name></expr>:</case>
		<case>case <expr><name>T_Const</name></expr>:</case>
		<case>case <expr><name>T_Param</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
		<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
		<case>case <expr><name>T_TargetEntry</name></expr>:</case>
		<case>case <expr><name>T_List</name></expr>:</case>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
		<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
		<case>case <expr><name>T_SpecialJoinInfo</name></expr>:</case>
		<case>case <expr><name>T_TableValueExpr</name></expr>:</case>

		<default>default:</default>
			<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the plan associated with a SubPlan node in a walker.  (This is used by
 * framework, not by users of the framework.)
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type><name>plan_tree_base_subplan_get_plan</name><parameter_list>(<parameter><decl><type><name>plan_tree_base_prefix</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>base</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>exec_subplan_get_plan</name><argument_list>(<argument><expr><operator>(</operator><name>PlannedStmt</name><operator>*</operator><operator>)</operator><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>planner_subplan_get_plan</name><argument_list>(<argument><expr><operator>(</operator><name>PlannerInfo</name><operator>*</operator><operator>)</operator><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>PlannerGlobal</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannerInfo</name></type> <name>rootdata</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rootdata</name><operator>.</operator><name>glob</name></name> <operator>=</operator> <operator>(</operator><name>PlannerGlobal</name><operator>*</operator><operator>)</operator><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
		<return>return <expr><call><name>planner_subplan_get_plan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rootdata</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Rewrite the plan associated with a SubPlan node in a mutator.  (This is used by
 * framework, not by users of the framework.)
 */</comment>
<function><type><name>void</name></type> <name>plan_tree_base_subplan_put_plan</name><parameter_list>(<parameter><decl><type><name>plan_tree_base_prefix</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>exec_subplan_put_plan</name><argument_list>(<argument><expr><operator>(</operator><name>PlannedStmt</name><operator>*</operator><operator>)</operator><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>planner_subplan_put_plan</name><argument_list>(<argument><expr><operator>(</operator><name>PlannerInfo</name><operator>*</operator><operator>)</operator><name><name>base</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"Must provide relevant base info."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * These are helpers to retrieve nodes from plans.
 */</comment>
<typedef>typedef <type><struct>struct <name>extract_context</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for plan_tree_walker/mutator */</comment>
 	<decl_stmt><decl><type><name>bool</name></type> <name>descendIntoSubqueries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeTag</name></type>  <name>nodeTag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
}</block></struct></type> <name>extract_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extract_nodes_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>extract_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extract_nodes_expression_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>extract_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Extract nodes with specific tag.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type><name>extract_nodes</name><parameter_list>(<parameter><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>extract_context</name></type> <name>context</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>glob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nodeTag</name></name> <operator>=</operator> <name>nodeTag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>descendIntoSubqueries</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extract_nodes_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>context</name><operator>.</operator><name>nodes</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Extract nodes with specific tag.
 * Same as above, but starts off a Plan node rather than a PlannedStmt
 *
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type><name>extract_nodes_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>pl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeTag</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>descendIntoSubqueries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>extract_context</name></type> <name>context</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nodeTag</name></name> <operator>=</operator> <name>nodeTag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>descendIntoSubqueries</name></name> <operator>=</operator> <name>descendIntoSubqueries</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extract_nodes_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>pl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>context</name><operator>.</operator><name>nodes</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extract_nodes_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>extract_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>nodeTag</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_SubPlan</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * SubPlan has both of expressions and subquery.  In case the caller wants
		 * non-subquery version, still we need to walk through its expressions.
		 * NB: Since we're not going to descend into SUBPLANs anyway (see below),
		 * look at the SUBPLAN node here, even if descendIntoSubqueries is false
		 * lest we miss some nodes there.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>extract_nodes_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
								   <argument><expr><name>extract_nodes_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Do not descend into subplans.
		 * Even if descendIntoSubqueries indicates the caller wants to descend into
		 * subqueries, SubPlan seems special; Some partitioning code assumes this
		 * should return immediately without descending.  See MPP-17168.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_SubqueryScan</name>
		<operator>&amp;&amp;</operator> <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>descendIntoSubqueries</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Do not descend into subquery scans. */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_TableFunctionScan</name>
		<operator>&amp;&amp;</operator> <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>descendIntoSubqueries</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Do not descend into table function subqueries */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>extract_nodes_walker</name></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Extract nodes with specific tag.
 * Same as above, but starts off a scalar expression node rather than a PlannedStmt
 *
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type><name>extract_nodes_expression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeTag</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>descendIntoSubqueries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>extract_context</name></type> <name>context</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nodeTag</name></name> <operator>=</operator> <name>nodeTag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>descendIntoSubqueries</name></name> <operator>=</operator> <name>descendIntoSubqueries</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extract_nodes_expression_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><name><name>context</name><operator>.</operator><name>nodes</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extract_nodes_expression_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>extract_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>node</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>nodeTag</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_Query</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>descendIntoSubqueries</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>extract_nodes_expression_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		   <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>extract_nodes_expression_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>extract_nodes_expression_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>extract_nodes_expression_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * These are helpers to find node in queries
 */</comment>
<typedef>typedef <type><struct>struct <name>find_nodes_context</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeTags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>foundNode</name></decl>;</decl_stmt>
}</block></struct></type> <name>find_nodes_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>find_nodes_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>find_nodes_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Looks for nodes that belong to the given list.
 * Returns the index of the first such node that it encounters, or -1 if none
 */</comment>
<function><type><name>int</name></type> <name>find_nodes</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeTags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>find_nodes_context</name></type> <name>context</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nodeTags</name></name> <operator>=</operator> <name>nodeTags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>foundNode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>find_nodes_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>foundNode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_nodes_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>find_nodes_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>node</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>find_nodes_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* flags */</comment>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;nodeTags</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NodeTag</name></type> <name>nodeTag</name> <init>= <expr><operator>(</operator><name>NodeTag</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nodeTag</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>foundNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>find_nodes_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * GPDB_91_MERGE_FIXME: collation
 * Look for nodes with non-default collation; return 1 if any exist, -1
 * otherwise.
 */</comment>
<typedef>typedef <type><struct>struct <name>check_collation_context</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>foundNonDefaultCollation</name></decl>;</decl_stmt>
}</block></struct></type> <name>check_collation_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_collation_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>check_collation_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type> <name>check_collation</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>check_collation_context</name></type> <name>context</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>foundNonDefaultCollation</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_collation_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>foundNonDefaultCollation</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_collation_in_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colllist</name></decl></parameter>, <parameter><decl><type><name>check_collation_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>colllist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>coll</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>!=</operator> <name>coll</name> <operator>&amp;&amp;</operator> <name>DEFAULT_COLLATION_OID</name> <operator>!=</operator> <name>coll</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>foundNonDefaultCollation</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_collation_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>check_collation_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>collation</name></decl>, <decl><type ref="prev"/><name>inputCollation</name></decl>, <decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>node</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>check_collation_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* flags */</comment>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
		<case>case <expr><name>T_Const</name></expr>:</case>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>node</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>collation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NAMEOID</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>NAMEARRAYOID</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>!=</operator> <name>C_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>foundNonDefaultCollation</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>InvalidOid</name> <operator>!=</operator> <name>collation</name> <operator>&amp;&amp;</operator> <name>DEFAULT_COLLATION_OID</name> <operator>!=</operator> <name>collation</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>foundNonDefaultCollation</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
		<case>case <expr><name>T_TableValueExpr</name></expr>:</case>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
		<case>case <expr><name>T_Param</name></expr>:</case>
		<case>case <expr><name>T_SubPlan</name></expr>:</case>
		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
		<case>case <expr><name>T_DMLActionExpr</name></expr>:</case>
			<expr_stmt><expr><name>collation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>inputCollation</name> <operator>=</operator> <call><name>exprInputCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>InvalidOid</name> <operator>!=</operator> <name>collation</name> <operator>&amp;&amp;</operator> <name>DEFAULT_COLLATION_OID</name> <operator>!=</operator> <name>collation</name><operator>)</operator> <operator>||</operator>
				<operator>(</operator><name>InvalidOid</name> <operator>!=</operator> <name>inputCollation</name> <operator>&amp;&amp;</operator> <name>DEFAULT_COLLATION_OID</name> <operator>!=</operator> <name>inputCollation</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>foundNonDefaultCollation</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CollateClause</name></expr>:</case>
			<comment type="block">/* unsupported */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>foundNonDefaultCollation</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblEntry</name></expr>:</case>
			<expr_stmt><expr><call><name>check_collation_in_list</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>colcollations</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
			<expr_stmt><expr><call><name>check_collation_in_list</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funccolcollations</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>check_collation_in_list</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>ctecolcollations</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>check_collation_in_list</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>colCollations</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* make compiler happy */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>foundNonDefaultCollation</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* end recursion */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>check_collation_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

</unit>
