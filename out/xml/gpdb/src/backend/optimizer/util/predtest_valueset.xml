<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/util/predtest_valueset.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * predtest_valueset.c
 *	  Routines to prove possible values of variable based on predicates.
 *
 * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/predtest_valueset.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/predtest_valueset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT16MAX</name></cpp:macro> <cpp:value>(32767)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT16MIN</name></cpp:macro> <cpp:value>(-32768)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT32MAX</name></cpp:macro> <cpp:value>(2147483647)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT32MIN</name></cpp:macro> <cpp:value>(-2147483648)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>CreateNodeSetHashTable</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddValue</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>valueToCopy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveValue</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsValue</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TryProcessOpExprForPossibleValues</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>resultOut</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TryProcessNullTestForPossibleValues</name><parameter_list>(<parameter><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>resultOut</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct <name>ConstHashValue</name>
<block>{
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type> <name>c</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConstHashValue</name>;</typedef>

<comment type="block">/*
 * Compute a hash value for Const.
 *
 * We use equal() to check for equality, which just comparse the raw bytes.
 * Therefore, we don't need datatype-aware hashing either, we just hash the
 * raw bytes.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>ConstHashTableHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>keyPtr</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>constbyval</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Like in datumIsEqual, we use all bits of the Datum, even if the
		 * length is smaller. This assumes that the datatype is consistent
		 * about how it fills the extra bits.
		 */</comment>
		<return>return <expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>realSize</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>realSize</name> <operator>=</operator> <call><name>datumGetSize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>realSize</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ConstHashTableMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type><name>keyPtr1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>left</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Node</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>keyPtr1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>right</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Node</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>keyPtr2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><ternary><condition><expr><call><name>equal</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * returns a hashtable that can be used to map from a node to itself
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name><modifier>*</modifier></type>
<name>CreateNodeSetHashTable</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>memoryContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>	<name>hash_ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Const</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstHashValue</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>ConstHashTableHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>ConstHashTableMatch</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>memoryContext</name></expr>;</expr_stmt>

	<return>return <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ConstantSet"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
					   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * basic operation on PossibleValueSet:  initialize to "any value possible"
 */</comment>
<function><type><name>void</name></type>
<name>InitPossibleValueSetData</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Take the values from the given PossibleValueSet and return them as an allocated array.
 *
 * @param pvs the set to turn into an array
 * @param numValuesOut receives the length of the returned array
 * @return the array of Node objects
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>GetPossibleValuesAsArray</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numValuesOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstHashValue</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numValues</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numValuesOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>ConstHashValue</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>numValues</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach_with_count</name><argument_list>(<argument>lc</argument>, <argument>list</argument>, <argument>i</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>numValuesOut</name> <operator>=</operator> <name>numValues</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * basic operation on PossibleValueSet:  cleanup
 */</comment>
<function><type><name>void</name></type>
<name>DeletePossibleValueSetData</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * basic operation on PossibleValueSet:  add a value to the set field of PossibleValueSet
 *
 * The caller must verify that the valueToCopy is greenplum hashable
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddValue</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>valueToCopy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												   <argument><expr><literal type="string">"PossibleValueSet"</literal></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <call><name>CreateNodeSetHashTable</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ContainsValue</name><argument_list>(<argument><expr><name>pvs</name></expr></argument>, <argument><expr><name>valueToCopy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt> <comment type="block">/* unused but needed in call */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>valueToCopy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ConstHashValue</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetToNoValuesPossible</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												   <argument><expr><literal type="string">"PossibleValueSet"</literal></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <call><name>CreateNodeSetHashTable</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pvs</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * basic operation on PossibleValueSet:  remove a value from the set field of PossibleValueSet
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveValue</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt> <comment type="block">/* unused, needed in call */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>( <argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * basic operation on PossibleValueSet:  determine if a value is contained in the set field of PossibleValueSet
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsValue</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pvs</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * in-place union operation
 */</comment>
<function><type><name>void</name></type>
<name>AddUnmatchingValues</name><parameter_list>( <parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>, <parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>toCheck</name></decl></parameter> )</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstHashValue</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pvs</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>toCheck</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name><name>toCheck</name><operator>-&gt;</operator><name>set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>ConstHashValue</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AddValue</name><argument_list>(<argument><expr><name>pvs</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * in-place intersection operation
 */</comment>
<function><type><name>void</name></type>
<name>RemoveUnmatchingValues</name><parameter_list>(<parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>pvs</name></decl></parameter>, <parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>toCheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>toRemove</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstHashValue</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pvs</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>toCheck</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name><name>pvs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>ConstHashValue</name><operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ContainsValue</name><argument_list>(<argument><expr><name>toCheck</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>toRemove</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>toRemove</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* remove after so we don't mod hashtable underneath iteration */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>toRemove</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>value</name> <init>= <expr><operator>(</operator><name>Const</name><operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RemoveValue</name><argument_list>(<argument><expr><name>pvs</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>toRemove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Check to see if the given expression is a valid equality between the listed variable and a constant.
 *
 * @param expr the expression to check for being a valid quality
 * @param variable the variable to look for
 * @param resultOut will be updated with the modified values
 */</comment>
<function><type><name>bool</name></type>
<name>TryProcessExprForPossibleValues</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>resultOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>TryProcessOpExprForPossibleValues</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>variable</name></expr></argument>, <argument><expr><name>resultOut</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>TryProcessNullTestForPossibleValues</name><argument_list>(<argument><expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>variable</name></expr></argument>, <argument><expr><name>resultOut</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TryProcessOpExprForPossibleValues</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>resultOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftop</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rightop</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>varExpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>constExpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>constOnRight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clause_op_infos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitPossibleValueSetData</name><argument_list>(<argument><expr><name>resultOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>leftop</name> <operator>=</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightop</name> <operator>=</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>leftop</name> <operator>||</operator> <operator>!</operator><name>rightop</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check if one operand is a constant */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>varExpr</name> <operator>=</operator> <name>leftop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>constExpr</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>constOnRight</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>constExpr</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>leftop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>varExpr</name> <operator>=</operator> <name>rightop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>constOnRight</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block" format="doxygen">/** not a constant?  Learned nothing */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>constExpr</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* null doesn't help us */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>varExpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>varExpr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>varExpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rt</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>varExpr</name></expr></argument>, <argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block" format="doxygen">/**
		 * Not talking about our variable?  Learned nothing
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>clause_op_infos</name> <operator>=</operator> <call><name>get_op_btree_interpretation</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check if it's equality operation */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_equality</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpBtreeInterpretation</name> <modifier>*</modifier></type><name>clause_op_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>clause_op_infos</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>clause_op_info</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>clause_op_info</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_equality</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_equality</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>clause_op_info</name><operator>-&gt;</operator><name>oplefttype</name></name> <operator>==</operator> <name><name>clause_op_info</name><operator>-&gt;</operator><name>oprighttype</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Both sides have the same datatype. This case is simple, we can
		 * add the constant directly as a possible value.
		 */</comment>
		<expr_stmt><expr><name><name>resultOut</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AddValue</name><argument_list>(<argument><expr><name>resultOut</name></expr></argument>, <argument><expr><name>constExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Cross-datatype equality. this is more complicated, we need to
		 * construct a const with constant's value, but using the variable
		 * side's datatype. it would be tempting to cast the value, but that
		 * fails e.g. if the constant is an int4, with a large value, and
		 * the variable is int2. there will be no match in that case, but
		 * if we tried to simply cast the value, we'd get an error. So we
		 * have hard-coded knowledge of the few simple cases, namely
		 * differently-sized integer types
		 *
		 * Expand the constant to int64, then assign it back to a Datum
		 * of the variable's datatype, checking for overflow.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>const_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>var_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>constvalue</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type>		<name>isOverflow</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>new_const_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>new_const_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>new_const_datum</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>constOnRight</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>const_type</name> <operator>=</operator> <name><name>clause_op_info</name><operator>-&gt;</operator><name>oprighttype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>var_type</name> <operator>=</operator> <name><name>clause_op_info</name><operator>-&gt;</operator><name>oplefttype</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>const_type</name> <operator>=</operator> <name><name>clause_op_info</name><operator>-&gt;</operator><name>oplefttype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>var_type</name> <operator>=</operator> <name><name>clause_op_info</name><operator>-&gt;</operator><name>oprighttype</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<switch>switch <condition>(<expr><name>const_type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>INT2OID</name></expr>:</case>
				<expr_stmt><expr><name>constvalue</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>constExpr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>INT4OID</name></expr>:</case>
				<expr_stmt><expr><name>constvalue</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>constExpr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>INT8OID</name></expr>:</case>
				<expr_stmt><expr><name>constvalue</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>constExpr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<return>return <expr><name>false</name></expr>;</return> <comment type="block">/* we only know how to handle integer types */</comment>
		</block_content>}</block></switch>

		<comment type="block">/* Assign to the target type, checking for overflow */</comment>
		<expr_stmt><expr><name>isOverflow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>var_type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>INT2OID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>constvalue</name> <operator>&gt;</operator> <name>INT16MAX</name> <operator>||</operator> <name>constvalue</name> <operator>&lt;</operator> <name>INT16MIN</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>isOverflow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>new_const_type</name> <operator>=</operator> <name>INT2OID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_const_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_const_datum</name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int16</name><operator>)</operator> <name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>INT4OID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>constvalue</name> <operator>&gt;</operator> <name>INT32MAX</name> <operator>||</operator> <name>constvalue</name> <operator>&lt;</operator> <name>INT32MIN</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>isOverflow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>new_const_type</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_const_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_const_datum</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>INT8OID</name></expr>:</case>
				<expr_stmt><expr><name>new_const_type</name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_const_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_const_datum</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<return>return <expr><name>false</name></expr>;</return> <comment type="block">/* we only know how to handle integer types */</comment>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>isOverflow</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetToNoValuesPossible</name><argument_list>(<argument><expr><name>resultOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* okay, got a new constant value .. set it and done! */</comment>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>newConst</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newConst</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>new_const_type</name></expr></argument>,
								 <comment type="block">/* consttypmod */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
								 <comment type="block">/* constcollid */</comment> <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><name>new_const_len</name></expr></argument>,
								 <argument><expr><name>new_const_datum</name></expr></argument>,
								 <comment type="block">/* constisnull */</comment> <argument><expr><name>false</name></expr></argument>,
								 <comment type="block">/* constbyval */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>resultOut</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AddValue</name><argument_list>(<argument><expr><name>resultOut</name></expr></argument>, <argument><expr><name>newConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TryProcessNullTestForPossibleValues</name><parameter_list>(<parameter><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>PossibleValueSet</name> <modifier>*</modifier></type><name>resultOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>varExpr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitPossibleValueSetData</name><argument_list>(<argument><expr><name>resultOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>varExpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>varExpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>varExpr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>varExpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rt</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>varExpr</name></expr></argument>, <argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block" format="doxygen">/**
		 * Not talking about our variable?  Learned nothing
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>resultOut</name><operator>-&gt;</operator><name>isAnyValuePossible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AddValue</name><argument_list>(<argument><expr><name>resultOut</name></expr></argument>, <argument><expr><call><name>makeNullConst</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>varExpr</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>varExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* can't do anything with IS NOT NULL */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
