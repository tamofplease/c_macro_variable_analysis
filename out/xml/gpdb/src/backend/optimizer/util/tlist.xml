<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/util/tlist.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tlist.c
 *	  Target list manipulation routines
 *
 * Portions Copyright (c) 2007-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/tlist.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include> <comment type="block">/* get_typavgwidth() */</comment>

<typedef>typedef <type><struct>struct <name>maxSortGroupRef_context</name>
<block>{
	<decl_stmt><decl><type><name>Index</name></type> <name>maxsgr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>include_orderedagg</name></decl>;</decl_stmt>
}</block></struct></type> <name>maxSortGroupRef_context</name>;</typedef>

<function_decl><type><specifier>static</specifier>
<name>bool</name></type> <name>maxSortGroupRef_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>maxSortGroupRef_context</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Test if an expression node represents a SRF call.  Beware multiple eval! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SRF_CALL</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((IsA(node, FuncExpr) &amp;&amp; ((FuncExpr *) (node))-&gt;funcretset) || \
	 (IsA(node, OpExpr) &amp;&amp; ((OpExpr *) (node))-&gt;opretset))</cpp:value></cpp:define>

<comment type="block">/*
 * Data structures for split_pathtarget_at_srfs().  To preserve the identity
 * of sortgroupref items even if they are textually equal(), what we track is
 * not just bare expressions but expressions plus their sortgroupref indexes.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>			<comment type="block">/* some subexpression of a PathTarget */</comment>
	<decl_stmt><decl><type><name>Index</name></type>		<name>sortgroupref</name></decl>;</decl_stmt>	<comment type="block">/* its sortgroupref, or 0 if none */</comment>
}</block></struct></type> <name>split_pathtarget_item</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* This is a List of bare expressions: */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>input_target_exprs</name></decl>;</decl_stmt> <comment type="block">/* exprs available from input */</comment>
	<comment type="block">/* These are Lists of Lists of split_pathtarget_items: */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>level_srfs</name></decl>;</decl_stmt>		<comment type="block">/* SRF exprs to evaluate at each level */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>level_input_vars</name></decl>;</decl_stmt>	<comment type="block">/* input vars needed at each level */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>level_input_srfs</name></decl>;</decl_stmt>	<comment type="block">/* input SRFs needed at each level */</comment>
	<comment type="block">/* These are Lists of split_pathtarget_items: */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>current_input_vars</name></decl>;</decl_stmt> <comment type="block">/* vars needed in current subexpr */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>current_input_srfs</name></decl>;</decl_stmt> <comment type="block">/* SRFs needed in current subexpr */</comment>
	<comment type="block">/* Auxiliary data for current split_pathtarget_walker traversal: */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>current_depth</name></decl>;</decl_stmt>	<comment type="block">/* max SRF depth in current subexpr */</comment>
	<decl_stmt><decl><type><name>Index</name></type>		<name>current_sgref</name></decl>;</decl_stmt>	<comment type="block">/* current subexpr's sortgroupref, or 0 */</comment>
}</block></struct></type> <name>split_pathtarget_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>split_pathtarget_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									<parameter><decl><type><name>split_pathtarget_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_sp_item_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
									  <parameter><decl><type><name>split_pathtarget_item</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_sp_items_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/*****************************************************************************
 *		Target list creation and searching utilities
 *****************************************************************************/</comment>

<comment type="block">/*
 * tlist_member
 *	  Finds the (first) member of the given tlist whose expression is
 *	  equal() to the given expression.  Result is NULL if no such member.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>tlist_member</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tlentry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>tlentry</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tlentry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tlentry</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tlist_members
 *	  Finds all members of the given tlist whose expression is
 *	  equal() to the given expression.	Result is NIL if no such member.
 *	  Note: We do not make a copy of the tlist entries that match.
 *	  The caller is responsible for cleaning up the memory allocated
 *	  to the List returned.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>tlist_members</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tlentry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>tlentry</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tlentry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tlentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tlist_member_ignore_relabel
 *	  Same as above, except that we ignore top-level RelabelType nodes
 *	  while checking for a match.  This is needed for some scenarios
 *	  involving binary-compatible sort operations.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>tlist_member_ignore_relabel</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tlentry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>tlexpr</name> <init>= <expr><name><name>tlentry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>tlexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>tlexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tlexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>tlexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tlexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tlentry</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tlist_member_match_var
 *	  Same as above, except that we match the provided Var on the basis
 *	  of varno/varattno/varlevelsup/vartype only, rather than full equal().
 *
 * This is needed in some cases where we can't be sure of an exact typmod
 * match.  For safety, though, we insist on vartype match.
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>tlist_member_match_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tlentry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>tlvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tlentry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tlvar</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>tlvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tlentry</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_to_flat_tlist
 *		Add more items to a flattened tlist (if they're not already in it)
 *
 * 'tlist' is the flattened tlist
 * 'exprs' is a list of expressions (usually, but not necessarily, Vars)
 *
 * Returns the extended tlist.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>add_to_flat_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_resno</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tlist_member_ignore_relabel</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* copy needed?? */</comment>
								  <argument><expr><name>next_resno</name><operator>++</operator></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_tlist_exprs
 *		Get just the expression subtrees of a tlist
 *
 * Resjunk columns are ignored unless includeJunk is true
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_tlist_exprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>includeJunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>includeJunk</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * count_nonjunk_tlist_entries
 *		What it says ...
 */</comment>
<function><type><name>int</name></type>
<name>count_nonjunk_tlist_entries</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * tlist_same_exprs
 *		Check whether two target lists contain the same expressions
 *
 * Note: this function is used to decide whether it's safe to jam a new tlist
 * into a non-projection-capable plan node.  Obviously we can't do that unless
 * the node's tlist shows it already returns the column values we want.
 * However, we can ignore the TargetEntry attributes resname, ressortgroupref,
 * resorigtbl, resorigcol, and resjunk, because those are only labelings that
 * don't affect the row values computed by the node.  (Moreover, if we didn't
 * ignore them, we'd frequently fail to make the desired optimization, since
 * the planner tends to not bother to make resname etc. valid in intermediate
 * plan nodes.)  Note that on success, the caller must still jam the desired
 * tlist into the plan node, else it won't have the desired labeling fields.
 */</comment>
<function><type><name>bool</name></type>
<name>tlist_same_exprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist1</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>tlist2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* not same length, so can't match */</comment>

	<macro><name>forboth</name><argument_list>(<argument>lc1</argument>, <argument>tlist1</argument>, <argument>lc2</argument>, <argument>tlist2</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle1</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle2</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>tle1</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>tle2</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Does tlist have same output datatypes as listed in colTypes?
 *
 * Resjunk columns are ignored if junkOK is true; otherwise presence of
 * a resjunk column will always cause a 'false' result.
 *
 * Note: currently no callers care about comparing typmods.
 */</comment>
<function><type><name>bool</name></type>
<name>tlist_same_datatypes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>junkOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curColType</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>junkOK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>curColType</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* tlist longer than colTypes */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>curColType</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>curColType</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* tlist shorter than colTypes */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does tlist have same exposed collations as listed in colCollations?
 *
 * Identical logic to the above, but for collations.
 */</comment>
<function><type><name>bool</name></type>
<name>tlist_same_collations</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>junkOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curColColl</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>colCollations</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>junkOK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>curColColl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* tlist longer than colCollations */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColColl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>curColColl</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>curColColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>curColColl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* tlist shorter than colCollations */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * apply_tlist_labeling
 *		Apply the TargetEntry labeling attributes of src_tlist to dest_tlist
 *
 * This is useful for reattaching column names etc to a plan's final output
 * targetlist.
 */</comment>
<function><type><name>void</name></type>
<name>apply_tlist_labeling</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dest_tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>src_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ld</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ls</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>dest_tlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>src_tlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>ld</argument>, <argument>dest_tlist</argument>, <argument>ls</argument>, <argument>src_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>dest_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>src_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resorigtbl</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resorigcol</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resorigcol</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * get_sortgroupref_tle
 *		Find the targetlist entry matching the given SortGroupRef index,
 *		and return it.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>get_sortgroupref_tle</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>==</operator> <name>sortref</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tle</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ORDER/GROUP BY expression not found in targetlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgroupclause_tle
 *		Find the targetlist entry matching the given SortGroupClause
 *		by ressortgroupref, and return it.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>get_sortgroupclause_tle</name><parameter_list>(<parameter><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgClause</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>sgClause</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgroupclauses_tles
 *      Find a list of unique targetlist entries matching the given list of
 *      SortGroupClauses, or GroupingClauses.
 *
 * In each grouping set, targets that do not appear in a GroupingClause
 * will be put in the front of those that appear in a GroupingClauses.
 * The targets within the same clause will be appended in the order
 * of their appearance.
 *
 * The unique targetlist entries are returned in *tles, and the sort
 * and equality operators associated with each tle are returned in
 * *sortops and *eqops.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_sortgroupclauses_tles_recurse</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tles</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>sortops</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>eqops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc_sortop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc_eqop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_grouping_tles</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_grouping_sortops</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_grouping_eqops</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>,
													   <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><operator>*</operator><name>tles</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>tles</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tles</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>sortops</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>sortops</name></expr></argument>, <argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>eqops</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>eqops</name></expr></argument>, <argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_sortgroupclauses_tles_recurse</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
											  <argument><expr><name>tles</name></expr></argument>, <argument><expr><name>sortops</name></expr></argument>, <argument><expr><name>eqops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type in list of sort/group clauses: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Put SortGroupClauses before GroupingClauses.
	 */</comment>
	<macro><name>forthree</name><argument_list>(<argument>lc</argument>, <argument>sub_grouping_tles</argument>,
			 <argument>lc_sortop</argument>, <argument>sub_grouping_sortops</argument>,
			 <argument>lc_eqop</argument>, <argument>sub_grouping_eqops</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><operator>*</operator><name>tles</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>tles</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tles</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>sortops</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>sortops</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc_sortop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>eqops</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>eqops</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc_eqop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>get_sortgroupclauses_tles</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tles</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>sortops</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>eqops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>tles</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>sortops</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>eqops</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_sortgroupclauses_tles_recurse</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
									  <argument><expr><name>tles</name></expr></argument>, <argument><expr><name>sortops</name></expr></argument>, <argument><expr><name>eqops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgroupclause_expr
 *		Find the targetlist entry matching the given SortGroupClause
 *		by ressortgroupref, and return its expression.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>get_sortgroupclause_expr</name><parameter_list>(<parameter><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgClause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgClause</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgrouplist_exprs
 *		Given a list of SortGroupClauses, build a list
 *		of the referenced targetlist expressions.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_sortgrouplist_exprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sgClauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>sgClauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>sortexpr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sortexpr</name> <operator>=</operator> <call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sortexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgroupref_clause
 *		Find the SortGroupClause matching the given SortGroupRef index,
 *		and return it.
 */</comment>
<function><type><name>SortGroupClause</name> <modifier>*</modifier></type>
<name>get_sortgroupref_clause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <name>sortref</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cl</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ORDER/GROUP BY expression not found in list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgroupref_clause_noerr
 *		As above, but return NULL rather than throwing an error if not found.
 */</comment>
<function><type><name>SortGroupClause</name> <modifier>*</modifier></type>
<name>get_sortgroupref_clause_noerr</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <name>sortref</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cl</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * extract_grouping_ops - make an array of the equality operator OIDs
 *		for a SortGroupClause list
 */</comment>
<function><type><name>Oid</name> <modifier>*</modifier></type>
<name>extract_grouping_ops</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>groupOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>glitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>groupOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>glitem</argument>, <argument>groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>glitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>groupOperators</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>=</operator> <name><name>groupcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>groupOperators</name><index>[<expr><name>colno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>groupOperators</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * extract_grouping_collations - make an array of the grouping column collations
 *		for a SortGroupClause list
 */</comment>
<function><type><name>Oid</name> <modifier>*</modifier></type>
<name>extract_grouping_collations</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>grpCollations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>glitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>grpCollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>glitem</argument>, <argument>groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>glitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>groupcl</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>grpCollations</name><index>[<expr><name>colno</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>grpCollations</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * extract_grouping_cols - make an array of the grouping column resnos
 *		for a SortGroupClause list
 */</comment>
<function><type><name>AttrNumber</name> <modifier>*</modifier></type>
<name>extract_grouping_cols</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>glitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>grpColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>glitem</argument>, <argument>groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>glitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>groupcl</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>grpColIdx</name><index>[<expr><name>colno</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>grpColIdx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * grouping_is_sortable - is it possible to implement grouping list by sorting?
 *
 * This is easy since the parser will have included a sortop if one exists.
 */</comment>
<function><type><name>bool</name></type>
<name>grouping_is_sortable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>glitem</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>glitem</argument>, <argument>groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>glitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>groupcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * grouping_is_hashable - is it possible to implement grouping list by hashing?
 *
 * We rely on the parser to have set the hashable flag correctly.
 */</comment>
<function><type><name>bool</name></type>
<name>grouping_is_hashable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>glitem</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>glitem</argument>, <argument>groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>glitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>groupcl</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the largest sortgroupref value in use in the given
 * target list.
 *
 * If include_orderedagg is false, consider only the top-level
 * entries in the target list, i.e., those that might be occur
 * in a groupClause, distinctClause, or sortClause of the Query
 * node that immediately contains the target list.
 *
 * If include_orderedagg is true, also consider AggOrder entries
 * embedded in Aggref nodes within the target list.  Though
 * such entries will only occur in the aggregation sub_tlist
 * (input) they affect sortgroupref numbering for both sub_tlist
 * and tlist (aggregate).
 */</comment>
<function><type><name>Index</name></type> <name>maxSortGroupRef</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_orderedagg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>maxSortGroupRef_context</name></type> <name>context</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>maxsgr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>include_orderedagg</name></name> <operator>=</operator> <name>include_orderedagg</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetlist</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>( <expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument> )</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"non-targetlist argument supplied"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>maxSortGroupRef_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>targetlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>maxsgr</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>maxSortGroupRef_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>maxSortGroupRef_context</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>( <expr><name>node</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>( <expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr> )</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name><operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>( <expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>&gt;</operator> <name><name>cxt</name><operator>-&gt;</operator><name>maxsgr</name></name></expr> )</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>maxsgr</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><call><name>maxSortGroupRef_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Aggref nodes don't nest, so we can treat them here without recurring
	 * further.
	 */</comment>

	<if_stmt><if>if <condition>( <expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr> )</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><operator>(</operator><name>Aggref</name><operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>( <expr><name><name>cxt</name><operator>-&gt;</operator><name>include_orderedagg</name></name></expr> )</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ref-&gt;aggorder</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sort</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>sort</name></expr></argument>, <argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>( <argument><expr><name><name>sort</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>sort</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>&gt;</operator> <name><name>cxt</name><operator>-&gt;</operator><name>maxsgr</name></name></expr> )</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>maxsgr</name></name> <operator>=</operator> <name><name>sort</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>maxSortGroupRef_walker</name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns the width of the row by traversing through the
 * target list and adding up the width of each target entry.
 */</comment>
<function><type><name>int</name></type> <name>get_row_width</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>plc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>plc</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
    	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>pte</name> <init>= <expr><operator>(</operator><name>TargetEntry</name><operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>plc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pexpr</name> <init>= <expr><name><name>pte</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>pexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <decl_stmt><decl><type><name>Oid</name></type> <name>oidType</name> <init>= <expr><call><name>exprType</name><argument_list>( <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int32</name></type> <name>iTypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>( <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><name>width</name> <operator>+=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><name>oidType</name></expr></argument>, <argument><expr><name>iTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

    <return>return <expr><name>width</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *		PathTarget manipulation functions
 *
 * PathTarget is a somewhat stripped-down version of a full targetlist; it
 * omits all the TargetEntry decoration except (optionally) sortgroupref data,
 * and it adds evaluation cost and output data width info.
 *****************************************************************************/</comment>

<comment type="block">/*
 * make_pathtarget_from_tlist
 *	  Construct a PathTarget equivalent to the given targetlist.
 *
 * This leaves the cost and width fields as zeroes.  Most callers will want
 * to use create_pathtarget(), so as to get those set.
 */</comment>
<function><type><name>PathTarget</name> <modifier>*</modifier></type>
<name>make_pathtarget_from_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>target</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_tlist_from_pathtarget
 *	  Construct a targetlist from a PathTarget.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>make_tlist_from_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
							  <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copy_pathtarget
 *	  Copy a PathTarget.
 *
 * The new PathTarget has its own List cells, but shares the underlying
 * target expression trees with the old one.  We duplicate the List cells
 * so that items can be added to one target without damaging the other.
 */</comment>
<function><type><name>PathTarget</name> <modifier>*</modifier></type>
<name>copy_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Copy scalar fields */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PathTarget</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Shallow-copy the expression list */</comment>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Duplicate sortgrouprefs if any (if not, the memcpy handled this) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>dst</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_empty_pathtarget
 *	  Create an empty (zero columns, zero cost) PathTarget.
 */</comment>
<function><type><name>PathTarget</name> <modifier>*</modifier></type>
<name>create_empty_pathtarget</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This is easy, but we don't want callers to hard-wire this ... */</comment>
	<return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_column_to_pathtarget
 *		Append a target column to the PathTarget.
 *
 * As with make_pathtarget_from_tlist, we leave it to the caller to update
 * the cost and width fields.
 */</comment>
<function><type><name>void</name></type>
<name>add_column_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>sortgroupref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Updating the exprs list is easy ... */</comment>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... the sortgroupref data, a bit less so */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nexprs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* This might look inefficient, but actually it's usually cheap */</comment>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr></argument>, <argument><expr><name>nexprs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>nexprs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sortgroupref</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>sortgroupref</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Adding sortgroupref labeling to a previously unlabeled target */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>nexprs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nexprs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>nexprs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sortgroupref</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_new_column_to_pathtarget
 *		Append a target column to the PathTarget, but only if it's not
 *		equal() to any pre-existing target expression.
 *
 * The caller cannot specify a sortgroupref, since it would be unclear how
 * to merge that with a pre-existing column.
 *
 * As with make_pathtarget_from_tlist, we leave it to the caller to update
 * the cost and width fields.
 */</comment>
<function><type><name>void</name></type>
<name>add_new_column_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_new_columns_to_pathtarget
 *		Apply add_new_column_to_pathtarget() for each element of the list.
 */</comment>
<function><type><name>void</name></type>
<name>add_new_columns_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>add_new_column_to_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * apply_pathtarget_labeling_to_tlist
 *		Apply any sortgrouprefs in the PathTarget to matching tlist entries
 *
 * Here, we do not assume that the tlist entries are one-for-one with the
 * PathTarget.  The intended use of this function is to deal with cases
 * where createplan.c has decided to use some other tlist and we have
 * to identify what matches exist.
 */</comment>
<function><type><name>void</name></type>
<name>apply_pathtarget_labeling_to_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if PathTarget has no sortgrouprefs data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For Vars, use tlist_member_match_var's weakened matching rule;
			 * this allows us to deal with some cases where a set-returning
			 * function has been inlined, so that we now have more knowledge
			 * about what it returns than we did when the original Var was
			 * created.  Otherwise, use regular equal() to find the matching
			 * TLE.  (In current usage, only the Var case is actually needed;
			 * but it seems best to have sane behavior here for non-Vars too.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member_match_var</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Complain if noplace for the sortgrouprefs label, or if we'd
			 * have to label a column twice.  (The case where it already has
			 * the desired label probably can't happen, but we may as well
			 * allow for it.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ORDER/GROUP BY expression not found in targetlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>!=</operator> <name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"targetlist item has multiple sortgroupref labels"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * split_pathtarget_at_srfs
 *		Split given PathTarget into multiple levels to position SRFs safely
 *
 * The executor can only handle set-returning functions that appear at the
 * top level of the targetlist of a ProjectSet plan node.  If we have any SRFs
 * that are not at top level, we need to split up the evaluation into multiple
 * plan levels in which each level satisfies this constraint.  This function
 * creates appropriate PathTarget(s) for each level.
 *
 * As an example, consider the tlist expression
 *		x + srf1(srf2(y + z))
 * This expression should appear as-is in the top PathTarget, but below that
 * we must have a PathTarget containing
 *		x, srf1(srf2(y + z))
 * and below that, another PathTarget containing
 *		x, srf2(y + z)
 * and below that, another PathTarget containing
 *		x, y, z
 * When these tlists are processed by setrefs.c, subexpressions that match
 * output expressions of the next lower tlist will be replaced by Vars,
 * so that what the executor gets are tlists looking like
 *		Var1 + Var2
 *		Var1, srf1(Var2)
 *		Var1, srf2(Var2 + Var3)
 *		x, y, z
 * which satisfy the desired property.
 *
 * Another example is
 *		srf1(x), srf2(srf3(y))
 * That must appear as-is in the top PathTarget, but below that we need
 *		srf1(x), srf3(y)
 * That is, each SRF must be computed at a level corresponding to the nesting
 * depth of SRFs within its arguments.
 *
 * In some cases, a SRF has already been evaluated in some previous plan level
 * and we shouldn't expand it again (that is, what we see in the target is
 * already meant as a reference to a lower subexpression).  So, don't expand
 * any tlist expressions that appear in input_target, if that's not NULL.
 *
 * It's also important that we preserve any sortgroupref annotation appearing
 * in the given target, especially on expressions matching input_target items.
 *
 * The outputs of this function are two parallel lists, one a list of
 * PathTargets and the other an integer list of bool flags indicating
 * whether the corresponding PathTarget contains any evaluatable SRFs.
 * The lists are given in the order they'd need to be evaluated in, with
 * the "lowest" PathTarget first.  So the last list entry is always the
 * originally given PathTarget, and any entries before it indicate evaluation
 * levels that must be inserted below it.  The first list entry must not
 * contain any SRFs (other than ones duplicating input_target entries), since
 * it will typically be attached to a plan node that cannot evaluate SRFs.
 *
 * Note: using a list for the flags may seem like overkill, since there
 * are only a few possible patterns for which levels contain SRFs.
 * But this representation decouples callers from that knowledge.
 */</comment>
<function><type><name>void</name></type>
<name>split_pathtarget_at_srfs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targets_contain_srfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>split_pathtarget_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_depth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_extra_projection</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prev_level_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lci</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It's not unusual for planner.c to pass us two physically identical
	 * targets, in which case we can conclude without further ado that all
	 * expressions are available from the input.  (The logic below would
	 * arrive at the same conclusion, but much more tediously.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>target</name> <operator>==</operator> <name>input_target</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>targets</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>targets_contain_srfs</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Pass any input_target exprs down to split_pathtarget_walker() */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>input_target_exprs</name></name> <operator>=</operator> <ternary><condition><expr><name>input_target</name></expr> ?</condition><then> <expr><name><name>input_target</name><operator>-&gt;</operator><name>exprs</name></name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize with empty level-zero lists, and no levels after that.
	 * (Note: we could dispense with representing level zero explicitly, since
	 * it will never receive any SRFs, but then we'd have to special-case that
	 * level when we get to building result PathTargets.  Level zero describes
	 * the SRF-free PathTarget that will be given to the input plan node.)
	 */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_srfs</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_input_vars</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_input_srfs</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize data we'll accumulate across all the target expressions */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_input_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_input_srfs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>need_extra_projection</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Scan each expression in the PathTarget looking for SRFs */</comment>
	<expr_stmt><expr><name>lci</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Tell split_pathtarget_walker about this expr's sortgroupref */</comment>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_sgref</name></name> <operator>=</operator> <call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>lci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lci</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find all SRFs and Vars (and Var-like nodes) in this expression, and
		 * enter them into appropriate lists within the context struct.
		 */</comment>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>split_pathtarget_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* An expression containing no SRFs is of no further interest */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>current_depth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Track max SRF nesting depth over the whole PathTarget.  Also, if
		 * this expression establishes a new max depth, we no longer care
		 * whether previous expressions contained nested SRFs; we can handle
		 * any required projection for them in the final ProjectSet node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>&lt;</operator> <name><name>context</name><operator>.</operator><name>current_depth</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>max_depth</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>current_depth</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>need_extra_projection</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If any maximum-depth SRF is not at the top level of its expression,
		 * we'll need an extra Result node to compute the top-level scalar
		 * expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>==</operator> <name><name>context</name><operator>.</operator><name>current_depth</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_SRF_CALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_extra_projection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we found no SRFs needing evaluation (maybe they were all present in
	 * input_target, or maybe they were all removed by const-simplification),
	 * then no ProjectSet is needed; fall out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>targets</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>targets_contain_srfs</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The Vars and SRF outputs needed at top level can be added to the last
	 * level_input lists if we don't need an extra projection step.  If we do
	 * need one, add a SRF-free level to the lists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_extra_projection</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_srfs</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_input_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_input_vars</name></name></expr></argument>,
										   <argument><expr><name><name>context</name><operator>.</operator><name>current_input_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_input_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_input_srfs</name></name></expr></argument>,
										   <argument><expr><name><name>context</name><operator>.</operator><name>current_input_srfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_input_vars</name></name></expr></argument>, <argument><expr><name>max_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>current_input_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_input_srfs</name></name></expr></argument>, <argument><expr><name>max_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>current_input_srfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now construct the output PathTargets.  The original target can be used
	 * as-is for the last one, but we need to construct a new SRF-free target
	 * representing what the preceding plan node has to emit, as well as a
	 * target for each intermediate ProjectSet node.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>targets</name> <operator>=</operator> <operator>*</operator><name>targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_level_tlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>forthree</name><argument_list>(<argument>lc1</argument>, <argument>context.level_srfs</argument>,
			 <argument>lc2</argument>, <argument>context.level_input_vars</argument>,
			 <argument>lc3</argument>, <argument>context.level_input_srfs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>level_srfs</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>ntarget</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ntarget</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>ntarget</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * This target should actually evaluate any SRFs of the current
			 * level, and it needs to propagate forward any Vars needed by
			 * later levels, as well as SRFs computed earlier and needed by
			 * later levels.
			 */</comment>
			<expr_stmt><expr><call><name>add_sp_items_to_pathtarget</name><argument_list>(<argument><expr><name>ntarget</name></expr></argument>, <argument><expr><name>level_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(lc2)</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>input_vars</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>add_sp_items_to_pathtarget</name><argument_list>(<argument><expr><name>ntarget</name></expr></argument>, <argument><expr><name>input_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(lc3)</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>input_srfs</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcx</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lcx</argument>, <argument>input_srfs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>split_pathtarget_item</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>prev_level_tlist</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>add_sp_item_to_pathtarget</name><argument_list>(<argument><expr><name>ntarget</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<expr_stmt><expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ntarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Add current target and does-it-compute-SRFs flag to output lists.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>targets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targets</name></expr></argument>, <argument><expr><name>ntarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>targets_contain_srfs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>targets_contain_srfs</name></expr></argument>,
											<argument><expr><operator>(</operator><name>level_srfs</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remember this level's output for next pass */</comment>
		<expr_stmt><expr><name>prev_level_tlist</name> <operator>=</operator> <name><name>ntarget</name><operator>-&gt;</operator><name>exprs</name></name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively examine expressions for split_pathtarget_at_srfs.
 *
 * Note we make no effort here to prevent duplicate entries in the output
 * lists.  Duplicates will be gotten rid of later.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>split_pathtarget_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>split_pathtarget_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A subexpression that matches an expression already computed in
	 * input_target can be treated like a Var (which indeed it will be after
	 * setrefs.c gets done with it), even if it's actually a SRF.  Record it
	 * as being needed for the current expression, and ignore any
	 * substructure.  (Note in particular that this preserves the identity of
	 * any expressions that appear as sortgrouprefs in input_target.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>input_target_exprs</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>split_pathtarget_item</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>split_pathtarget_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>sortgroupref</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>current_sgref</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name></expr></argument>,
											  <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Vars and Var-like constructs are expected to be gotten from the input,
	 * too.  We assume that these constructs cannot contain any SRFs (if one
	 * does, there will be an executor failure from a misplaced SRF).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>split_pathtarget_item</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>split_pathtarget_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>sortgroupref</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>current_sgref</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name></expr></argument>,
											  <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's a SRF, recursively examine its inputs, determine its level, and
	 * make appropriate entries in the output lists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_SRF_CALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>split_pathtarget_item</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>split_pathtarget_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_input_vars</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_input_srfs</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>current_input_srfs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_current_depth</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>current_depth</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>srf_depth</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>sortgroupref</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>current_sgref</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_srfs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_sgref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* subexpressions are not sortgroup items */</comment>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>split_pathtarget_walker</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Depth is one more than any SRF below it */</comment>
		<expr_stmt><expr><name>srf_depth</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>current_depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* If new record depth, initialize another level of output lists */</comment>
		<if_stmt><if>if <condition>(<expr><name>srf_depth</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_srfs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_srfs</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_vars</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_srfs</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Record this SRF as needing to be evaluated at appropriate level */</comment>
		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_srfs</name></name></expr></argument>, <argument><expr><name>srf_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Record its inputs as being needed at the same level */</comment>
		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_vars</name></name></expr></argument>, <argument><expr><name>srf_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_srfs</name></name></expr></argument>, <argument><expr><name>srf_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_srfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restore caller-level state and update it for presence of this SRF.
		 * Notice we report the SRF itself as being needed for evaluation of
		 * surrounding expression.
		 */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name> <operator>=</operator> <name>save_input_vars</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>save_input_srfs</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_depth</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>save_current_depth</name></expr></argument>, <argument><expr><name>srf_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We're done here */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, the node is a scalar (non-set) expression, so recurse to
	 * examine its inputs.
	 */</comment>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_sgref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* subexpressions are not sortgroup items */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>split_pathtarget_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a split_pathtarget_item to the PathTarget, unless a matching item is
 * already present.  This is like add_new_column_to_pathtarget, but allows
 * for sortgrouprefs to be handled.  An item having zero sortgroupref can
 * be merged with one that has a sortgroupref, acquiring the latter's
 * sortgroupref.
 *
 * Note that we don't worry about possibly adding duplicate sortgrouprefs
 * to the PathTarget.  That would be bad, but it should be impossible unless
 * the target passed to split_pathtarget_at_srfs already had duplicates.
 * As long as it didn't, we can have at most one split_pathtarget_item with
 * any particular nonzero sortgroupref.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_sp_item_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>split_pathtarget_item</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lci</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look for a pre-existing entry that is equal() and does not have a
	 * conflicting sortgroupref already.
	 */</comment>
	<expr_stmt><expr><name>lci</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>lci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>sortgroupref</name></name> <operator>==</operator> <name>sgref</name> <operator>||</operator>
			 <name><name>item</name><operator>-&gt;</operator><name>sortgroupref</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <name>sgref</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>equal</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a match.  Assign item's sortgroupref if it has one. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>sortgroupref</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator>
						<call><name>palloc0</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>lci</name></expr>]</index></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>sortgroupref</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>lci</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * No match, so add item to PathTarget.  Copy the expr for safety.
	 */</comment>
	<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>sortgroupref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply add_sp_item_to_pathtarget to each element of list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_sp_items_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>items</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>split_pathtarget_item</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>add_sp_item_to_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
