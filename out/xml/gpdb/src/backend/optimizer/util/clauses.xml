<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/optimizer/util/clauses.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * clauses.c
 *	  routines to manipulate qualification clauses
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/clauses.c
 *
 * HISTORY
 *	  AUTHOR			DATE			MAJOR EVENT
 *	  Andrew Yu			Nov 3, 1994		clause.c and clauses.c combined
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/functions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/supportnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggSplit</name></type>	<name>aggsplit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>costs</name></decl>;</decl_stmt>
}</block></struct></type> <name>get_agg_clause_costs_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>active_fns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>case_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>estimate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>eval_stable_functions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recurse_queries</name></decl>;</decl_stmt> <comment type="block">/* recurse into query structures */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recurse_sublink_testexpr</name></decl>;</decl_stmt> <comment type="block">/* recurse into sublink test expressions */</comment>
	<decl_stmt><decl><type><name>Size</name></type>        <name>max_size</name></decl>;</decl_stmt> <comment type="block">/* max constant binary size in bytes, 0: no restrictions */</comment>
}</block></struct></type> <name>eval_const_expressions_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>usecounts</name></decl>;</decl_stmt>
}</block></struct></type> <name>substitute_actual_parameters_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>substitute_actual_srf_parameters_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>
}</block></struct></type> <name>inline_error_callback_arg</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name>max_hazard</name></decl>;</decl_stmt>		<comment type="block">/* worst proparallel hazard found so far */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>max_interesting</name></decl>;</decl_stmt>	<comment type="block">/* worst proparallel hazard of interest */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>safe_param_ids</name></decl>;</decl_stmt> <comment type="block">/* PARAM_EXEC Param IDs to treat as safe */</comment>
}</block></struct></type> <name>max_parallel_hazard_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_agg_clause_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>get_agg_clause_costs_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										<parameter><decl><type><name>get_agg_clause_costs_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>find_window_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>lists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_subplans_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_mutable_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_volatile_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_volatile_functions_not_nextval_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>max_parallel_hazard_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									   <parameter><decl><type><name>max_parallel_hazard_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_nonstrict_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_context_dependent_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_context_dependent_node_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_leaked_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relids</name></type> <name>find_nonnullable_rels_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>find_nonnullable_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_strict_saop</name><parameter_list>(<parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>falseOK</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>eval_const_expressions_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
											<parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_non_const_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ece_function_is_safe</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>,
								 <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>simplify_or_arguments</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
								   <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>haveNull</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceTrue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>simplify_and_arguments</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
									<parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
									<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>haveNull</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceFalse</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>simplify_boolean_equality</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>simplify_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>result_typmod</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>result_collid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>input_collid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>args_p</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>funcvariadic</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>process_args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_non_const</name></decl></parameter>,
							   <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>large_const</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>max_size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>reorder_function_arguments</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>add_function_defaults</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>fetch_function_defaults</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recheck_cast_function_args</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>,
									   <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>evaluate_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>result_typmod</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>result_collid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>input_collid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>funcvariadic</name></decl></parameter>,
							   <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>,
							   <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>inline_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_collid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>input_collid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>funcvariadic</name></decl></parameter>,
							 <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>,
							 <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>substitute_actual_parameters</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
										  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>usecounts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>substitute_actual_parameters_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
												  <parameter><decl><type><name>substitute_actual_parameters_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sql_inline_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>substitute_actual_srf_parameters</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>substitute_actual_srf_parameters_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
													  <parameter><decl><type><name>substitute_actual_srf_parameters_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tlist_matches_coltypelist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>coltypelist</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Greenplum specific functions
 */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>should_eval_stable_functions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/*****************************************************************************
 *		Aggregate-function clause manipulation
 *****************************************************************************/</comment>

<comment type="block">/*
 * contain_agg_clause
 *	  Recursively search for Aggref/GroupingFunc nodes within a clause.
 *
 *	  Returns true if any aggregate found.
 *
 * This does not descend into subqueries, and so should be used only after
 * reduction of sublinks to subplans, or in contexts where it's known there
 * are no subqueries.  There mustn't be outer-aggregate references either.
 *
 * (If you want something like this but able to deal with subqueries,
 * see rewriteManip.c's contain_aggs_of_level().)
 */</comment>
<function><type><name>bool</name></type>
<name>contain_agg_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_agg_clause_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_agg_clause_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* abort the tree traversal and return true */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* abort the tree traversal and return true */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>GroupId</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* abort the tree traversal and return true */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingSetId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* abort the tree traversal and return true */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_agg_clause_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_agg_clause_costs
 *	  Recursively find the Aggref nodes in an expression tree, and
 *	  accumulate cost information about them.
 *
 * 'aggsplit' tells us the expected partial-aggregation mode, which affects
 * the cost estimates.
 *
 * NOTE that the counts/costs are ADDED to those already in *costs ... so
 * the caller is responsible for zeroing the struct initially.
 *
 * We count the nodes, estimate their execution costs, and estimate the total
 * space needed for their transition state values if all are evaluated in
 * parallel (as would be done in a HashAgg plan).  Also, we check whether
 * partial aggregation is feasible.  See AggClauseCosts for the exact set
 * of statistics collected.
 *
 * In addition, we mark Aggref nodes with the correct aggtranstype, so
 * that that doesn't need to be done repeatedly.  (That makes this function's
 * name a bit of a misnomer.)
 *
 * This does not descend into subqueries, and so should be used only after
 * reduction of sublinks to subplans, or in contexts where it's known there
 * are no subqueries.  There mustn't be outer-aggregate references either.
 */</comment>
<function><type><name>void</name></type>
<name>get_agg_clause_costs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>AggSplit</name></type> <name>aggsplit</name></decl></parameter>,
					 <parameter><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>costs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>get_agg_clause_costs_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>aggsplit</name></name> <operator>=</operator> <name>aggsplit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>costs</name></name> <operator>=</operator> <name>costs</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_agg_clause_costs_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_agg_clause_costs_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>get_agg_clause_costs_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>costs</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>costs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>aggTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>aggtransfn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>aggfinalfn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>aggcombinefn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>aggserialfn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>aggdeserialfn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>aggtranstype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>aggtransspace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>argcosts</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fetch info about aggregate from pg_aggregate.  Note it's correct to
		 * ignore the moving-aggregate variant, since what we're concerned
		 * with here is aggregates not window functions.
		 */</comment>
		<expr_stmt><expr><name>aggTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>,
				 <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>aggform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggtransfn</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggtransfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggfinalfn</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggfinalfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggcombinefn</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggserialfn</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggserialfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggdeserialfn</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggtransspace</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggtransspace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Resolve the possibly-polymorphic aggregate transition type, unless
		 * already done in a previous pass over the expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name><name>inputTypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numArguments</name></decl>;</decl_stmt>

			<comment type="block">/* extract argument types (ignoring any ORDER BY expressions) */</comment>
			<expr_stmt><expr><name>numArguments</name> <operator>=</operator> <call><name>get_aggregate_argtypes</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>inputTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* resolve actual type of transition state, if polymorphic */</comment>
			<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <call><name>resolve_aggregate_transtype</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>,
													   <argument><expr><name>aggtranstype</name></expr></argument>,
													   <argument><expr><name>inputTypes</name></expr></argument>,
													   <argument><expr><name>numArguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>aggtranstype</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Count it, and check for cases requiring ordered input.  Note that
		 * ordered-set aggs always have nonempty aggorder.  Any ordered-input
		 * case also defeats partial aggregation.
		 */</comment>
		<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>numAggs</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>numOrderedAggs</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>hasNonPartial</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The PostgreSQL 'numOrderedAggs' field includes DISTINCT aggregates,
		 * too, but cdbgroup.c handles DISTINCT aggregates differently, and
		 * needs to know if there are any purely ordered aggs, not counting
		 * DISTINCT aggs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>numPureOrderedAggs</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>distinctAggrefs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>costs</name><operator>-&gt;</operator><name>distinctAggrefs</name></name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check whether partial aggregation is feasible, unless we already
		 * found out that we can't do it.
		 *
		 * In GPDB, we can do two-stage aggregation with DISTINCT-qualified
		 * aggregates, if the data distribution happens to match the DISTINCT
		 * expressions. So we keep track whether all aggregates have combine
		 * functions, even if there are DISTINCT aggregates. hasNonCombine is
		 * set if there are any aggregates without combine functions, even if
		 * there are DISTINCT aggregates.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>costs</name><operator>-&gt;</operator><name>hasNonCombine</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there is no combine function, then partial aggregation is
			 * not possible.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggcombinefn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>hasNonCombine</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>hasNonPartial</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>

			<comment type="block">/*
			 * If we have any aggs with transtype INTERNAL then we must check
			 * whether they have serialization/deserialization functions; if
			 * not, we can't serialize partial-aggregation results.
			 */</comment>
			<if type="elseif">else if <condition>(<expr><name>aggtranstype</name> <operator>==</operator> <name>INTERNALOID</name> <operator>&amp;&amp;</operator>
					 <operator>(</operator><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>hasNonSerial</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Add the appropriate component function execution costs to
		 * appropriate totals.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* charge for combining previously aggregated states */</comment>
			<expr_stmt><expr><call><name>add_function_cost</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>aggcombinefn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>costs</name><operator>-&gt;</operator><name>transCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_function_cost</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>aggtransfn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>costs</name><operator>-&gt;</operator><name>transCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_DESERIALIZE</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_function_cost</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>aggdeserialfn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>costs</name><operator>-&gt;</operator><name>transCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SERIALIZE</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_function_cost</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>aggserialfn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>costs</name><operator>-&gt;</operator><name>finalCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggfinalfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_function_cost</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>aggfinalfn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>costs</name><operator>-&gt;</operator><name>finalCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * These costs are incurred only by the initial aggregate node, so we
		 * mustn't include them again at upper levels.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* add the input expressions' cost to per-input-row costs */</comment>
			<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argcosts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Add any filter's cost to per-input-row costs.
			 *
			 * XXX Ideally we should reduce input expression costs according
			 * to filter selectivity, but it's not clear it's worth the
			 * trouble.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argcosts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>,
									<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there are direct arguments, treat their evaluation cost like the
		 * cost of the finalfn.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argcosts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
								<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>finalCost</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>finalCost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the transition type is pass-by-value then it doesn't add
		 * anything to the required size of the hashtable.  If it is
		 * pass-by-reference then we have to add the estimated size of the
		 * value itself, plus palloc overhead.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_typbyval</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type>		<name>avgwidth</name></decl>;</decl_stmt>

			<comment type="block">/* Use average width if aggregate definition gave one */</comment>
			<if_stmt><if>if <condition>(<expr><name>aggtransspace</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>avgwidth</name> <operator>=</operator> <name>aggtransspace</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>aggtransfn</name> <operator>==</operator> <name>F_ARRAY_APPEND</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the transition function is array_append(), it'll use an
				 * expanded array as transvalue, which will occupy at least
				 * ALLOCSET_SMALL_INITSIZE and possibly more.  Use that as the
				 * estimate for lack of a better idea.
				 */</comment>
				<expr_stmt><expr><name>avgwidth</name> <operator>=</operator> <name>ALLOCSET_SMALL_INITSIZE</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If transition state is of same type as first aggregated
				 * input, assume it's the same typmod (same width) as well.
				 * This works for cases like MAX/MIN and is probably somewhat
				 * reasonable otherwise.
				 */</comment>
				<decl_stmt><decl><type><name>int32</name></type>		<name>aggtranstypmod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>aggtranstype</name> <operator>==</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>aggtranstypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>avgwidth</name> <operator>=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>, <argument><expr><name>aggtranstypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>avgwidth</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>avgwidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>transitionSpace</name></name> <operator>+=</operator> <name>avgwidth</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>aggtranstype</name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * INTERNAL transition type is a special case: although INTERNAL
			 * is pass-by-value, it's almost certainly being used as a pointer
			 * to some large data structure.  The aggregate definition can
			 * provide an estimate of the size.  If it doesn't, then we assume
			 * ALLOCSET_DEFAULT_INITSIZE, which is a good guess if the data is
			 * being kept in a private memory context, as is done by
			 * array_agg() for instance.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>aggtransspace</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>transitionSpace</name></name> <operator>+=</operator> <name>aggtransspace</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>transitionSpace</name></name> <operator>+=</operator> <name>ALLOCSET_DEFAULT_INITSIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Complain if the aggregate's arguments contain any aggregates;
		 * nested agg functions are semantically nonsensical.  Aggregates in
		 * the FILTER clause are detected in transformAggregateCall().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_agg_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>contain_agg_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate function calls cannot be nested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We assume that the parser checked that there are no aggregates (of
		 * this level anyway) in the aggregated arguments, direct arguments,
		 * or filter clause.  Hence, we need not recurse into any of them.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>get_agg_clause_costs_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *		Window-function clause manipulation
 *****************************************************************************/</comment>

<comment type="block">/*
 * contain_window_function
 *	  Recursively search for WindowFunc nodes within a clause.
 *
 * Since window functions don't have level fields, but are hard-wired to
 * be associated with the current query level, this is just the same as
 * rewriteManip.c's function.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_window_function</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_windowfuncs</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_window_functions
 *	  Locate all the WindowFunc nodes in an expression tree, and organize
 *	  them by winref ID number.
 *
 * Caller must provide an upper bound on the winref IDs expected in the tree.
 */</comment>
<function><type><name>WindowFuncLists</name> <modifier>*</modifier></type>
<name>find_window_functions</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>maxWinRef</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>lists</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WindowFuncLists</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>lists</name><operator>-&gt;</operator><name>numWindowFuncs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lists</name><operator>-&gt;</operator><name>maxWinRef</name></name> <operator>=</operator> <name>maxWinRef</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lists</name><operator>-&gt;</operator><name>windowFuncs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>maxWinRef</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_window_functions_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>lists</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_window_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>lists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* winref is unsigned, so one-sided test is OK */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name> <operator>&gt;</operator> <name><name>lists</name><operator>-&gt;</operator><name>maxWinRef</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"WindowFunc contains out-of-range winref %u"</literal></expr></argument>,
				 <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* eliminate duplicates, so that we avoid repeated computation */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name><name>lists</name><operator>-&gt;</operator><name>windowFuncs</name><index>[<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>wfunc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>lists</name><operator>-&gt;</operator><name>windowFuncs</name><index>[<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name></expr>]</index></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>lists</name><operator>-&gt;</operator><name>windowFuncs</name><index>[<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>wfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lists</name><operator>-&gt;</operator><name>numWindowFuncs</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We assume that the parser checked that there are no window
		 * functions in the arguments or filter clause.  Hence, we need not
		 * recurse into them.  (If either the parser or the planner screws up
		 * on this point, the executor will still catch it; see ExecInitExpr.)
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>find_window_functions_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>lists</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *		Support for expressions returning sets
 *****************************************************************************/</comment>

<comment type="block">/*
 * expression_returns_set_rows
 *	  Estimate the number of rows returned by a set-returning expression.
 *	  The result is 1 if it's not a set-returning expression.
 *
 * We should only examine the top-level function or operator; it used to be
 * appropriate to recurse, but not anymore.  (Even if there are more SRFs in
 * the function's inputs, their multipliers are accounted for separately.)
 *
 * Note: keep this in sync with expression_returns_set() in nodes/nodeFuncs.c.
 */</comment>
<function><type><name>double</name></type>
<name>expression_returns_set_rows</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>funcretset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><call><name>get_function_rows</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><call><name>get_function_rows</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">1.0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *		Subplan clause manipulation
 *****************************************************************************/</comment>

<comment type="block">/*
 * contain_subplans
 *	  Recursively search for subplan nodes within a clause.
 *
 * If we see a SubLink node, we will return true.  This is only possible if
 * the expression tree hasn't yet been transformed by subselect.c.  We do not
 * know whether the node will produce a true subplan or just an initplan,
 * but we make the conservative assumption that it will be a subplan.
 *
 * Returns true if any subplan found.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_subplans</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_subplans_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_subplans_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* abort the tree traversal and return true */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_subplans_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *		Check clauses for mutable functions
 *****************************************************************************/</comment>

<comment type="block">/*
 * contain_mutable_functions
 *	  Recursively search for mutable functions within a clause.
 *
 * Returns true if any mutable function (or operator implemented by a
 * mutable function) is found.  This test is needed so that we don't
 * mistakenly think that something like "WHERE random() &lt; 0.5" can be treated
 * as a constant qualification.
 *
 * We will recursively look into Query nodes (i.e., SubLink sub-selects)
 * but not into SubPlans.  See comments for contain_volatile_functions().
 */</comment>
<function><type><name>bool</name></type>
<name>contain_mutable_functions</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_mutable_functions_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_mutable_functions_checker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>func_volatile</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROVOLATILE_IMMUTABLE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_mutable_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* the functions in predtest.c handle expressions and
     * RestrictInfo objects -- so make this function handle
     * them too for convenience */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type> <name>info</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>contain_mutable_functions_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name><name>info</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* Check for mutable functions in node itself */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_mutable_functions_checker</name></expr></argument>,
								<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SQLValueFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* all variants of SQLValueFunction are stable */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* NextValueExpr is volatile */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It should be safe to treat MinMaxExpr as immutable, because it will
	 * depend on a non-cross-type btree comparison function, and those should
	 * always be immutable.  Treating XmlExpr as immutable is more dubious,
	 * and treating CoerceToDomain as immutable is outright dangerous.  But we
	 * have done so historically, and changing this would probably cause more
	 * problems than it would fix.  In practice, if you have a non-immutable
	 * domain constraint you are in for pain anyhow.
	 */</comment>

	<comment type="block">/* Recurse to check arguments */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								 <argument><expr><name>contain_mutable_functions_walker</name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_mutable_functions_walker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *		Check clauses for volatile functions
 *****************************************************************************/</comment>

<comment type="block">/*
 * contain_volatile_functions
 *	  Recursively search for volatile functions within a clause.
 *
 * Returns true if any volatile function (or operator implemented by a
 * volatile function) is found. This test prevents, for example,
 * invalid conversions of volatile expressions into indexscan quals.
 *
 * We will recursively look into Query nodes (i.e., SubLink sub-selects)
 * but not into SubPlans.  This is a bit odd, but intentional.  If we are
 * looking at a SubLink, we are probably deciding whether a query tree
 * transformation is safe, and a contained sub-select should affect that;
 * for example, duplicating a sub-select containing a volatile function
 * would be bad.  However, once we've got to the stage of having SubPlans,
 * subsequent planning need not consider volatility within those, since
 * the executor won't change its evaluation rules for a SubPlan based on
 * volatility.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_volatile_functions</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_volatile_functions_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_volatile_functions_checker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>func_volatile</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_volatile_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We need to handle RestrictInfo, a case that uses this
	 * is that replicated table with a volatile restriction.
	 * We have to find the pattern and turn it into singleQE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type> <name>info</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>contain_volatile_functions_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name><name>info</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check for volatile functions in node itself */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_volatile_functions_checker</name></expr></argument>,
								<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* NextValueExpr is volatile */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * See notes in contain_mutable_functions_walker about why we treat
	 * MinMaxExpr, XmlExpr, and CoerceToDomain as immutable, while
	 * SQLValueFunction is stable.  Hence, none of them are of interest here.
	 */</comment>

	<comment type="block">/* Recurse to check arguments */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								 <argument><expr><name>contain_volatile_functions_walker</name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_volatile_functions_walker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Special purpose version of contain_volatile_functions() for use in COPY:
 * ignore nextval(), but treat all other functions normally.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_volatile_functions_not_nextval</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_volatile_functions_not_nextval_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_volatile_functions_not_nextval_checker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>func_id</name> <operator>!=</operator> <name>F_NEXTVAL_OID</name> <operator>&amp;&amp;</operator>
			<call><name>func_volatile</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_volatile_functions_not_nextval_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Check for volatile functions in node itself */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								<argument><expr><name>contain_volatile_functions_not_nextval_checker</name></expr></argument>,
								<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * See notes in contain_mutable_functions_walker about why we treat
	 * MinMaxExpr, XmlExpr, and CoerceToDomain as immutable, while
	 * SQLValueFunction is stable.  Hence, none of them are of interest here.
	 * Also, since we're intentionally ignoring nextval(), presumably we
	 * should ignore NextValueExpr.
	 */</comment>

	<comment type="block">/* Recurse to check arguments */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								 <argument><expr><name>contain_volatile_functions_not_nextval_walker</name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								  <argument><expr><name>contain_volatile_functions_not_nextval_walker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *		Check queries for parallel unsafe and/or restricted constructs
 *****************************************************************************/</comment>

<comment type="block">/*
 * max_parallel_hazard
 *		Find the worst parallel-hazard level in the given query
 *
 * Returns the worst function hazard property (the earliest in this list:
 * PROPARALLEL_UNSAFE, PROPARALLEL_RESTRICTED, PROPARALLEL_SAFE) that can
 * be found in the given parsetree.  We use this to find out whether the query
 * can be parallelized at all.  The caller will also save the result in
 * PlannerGlobal so as to short-circuit checks of portions of the querytree
 * later, in the common case where everything is SAFE.
 */</comment>
<function><type><name>char</name></type>
<name>max_parallel_hazard</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>max_parallel_hazard_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>max_hazard</name></name> <operator>=</operator> <name>PROPARALLEL_SAFE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>max_interesting</name></name> <operator>=</operator> <name>PROPARALLEL_UNSAFE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>safe_param_ids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>max_parallel_hazard_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>context</name><operator>.</operator><name>max_hazard</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_parallel_safe
 *		Detect whether the given expr contains only parallel-safe functions
 *
 * root-&gt;glob-&gt;maxParallelHazard must previously have been set to the
 * result of max_parallel_hazard() on the whole query.
 */</comment>
<function><type><name>bool</name></type>
<name>is_parallel_safe</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>max_parallel_hazard_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>proot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Even if the original querytree contained nothing unsafe, we need to
	 * search the expression if we have generated any PARAM_EXEC Params while
	 * planning, because those are parallel-restricted and there might be one
	 * in this expression.  But otherwise we don't need to look.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>maxParallelHazard</name></name> <operator>==</operator> <name>PROPARALLEL_SAFE</name> <operator>&amp;&amp;</operator>
		<name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Else use max_parallel_hazard's search logic, but stop on RESTRICTED */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>max_hazard</name></name> <operator>=</operator> <name>PROPARALLEL_SAFE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>max_interesting</name></name> <operator>=</operator> <name>PROPARALLEL_RESTRICTED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>safe_param_ids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The params that refer to the same or parent query level are considered
	 * parallel-safe.  The idea is that we compute such params at Gather or
	 * Gather Merge node and pass their value to workers.
	 */</comment>
	<for>for <control>(<init><expr><name>proot</name> <operator>=</operator> <name>root</name></expr>;</init> <condition><expr><name>proot</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>proot</name> <operator>=</operator> <name><name>proot</name><operator>-&gt;</operator><name>parent_root</name></name></expr></incr>)</control>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>proot-&gt;init_plans</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>initsubplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>initsubplan-&gt;setParam</argument>)</argument_list></macro>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>safe_param_ids</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name><name>context</name><operator>.</operator><name>safe_param_ids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<return>return <expr><operator>!</operator><call><name>max_parallel_hazard_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* core logic for all parallel-hazard checks */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>max_parallel_hazard_test</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>proparallel</name></decl></parameter>, <parameter><decl><type><name>max_parallel_hazard_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>proparallel</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PROPARALLEL_SAFE</name></expr>:</case>
			<comment type="block">/* nothing to see here, move along */</comment>
			<break>break;</break>
		<case>case <expr><name>PROPARALLEL_RESTRICTED</name></expr>:</case>
			<comment type="block">/* increase max_hazard to RESTRICTED */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>max_hazard</name></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>max_hazard</name></name> <operator>=</operator> <name>proparallel</name></expr>;</expr_stmt>
			<comment type="block">/* done if we are not expecting any unsafe functions */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>max_interesting</name></name> <operator>==</operator> <name>proparallel</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PROPARALLEL_UNSAFE</name></expr>:</case>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>max_hazard</name></name> <operator>=</operator> <name>proparallel</name></expr>;</expr_stmt>
			<comment type="block">/* we're always done at the first unsafe construct */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized proparallel value \"%c\""</literal></expr></argument>, <argument><expr><name>proparallel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* check_functions_in_node callback */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>max_parallel_hazard_checker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>max_parallel_hazard_test</name><argument_list>(<argument><expr><call><name>func_parallel</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>(</operator><name>max_parallel_hazard_context</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>max_parallel_hazard_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>max_parallel_hazard_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check for hazardous functions in node itself */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>max_parallel_hazard_checker</name></expr></argument>,
								<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It should be OK to treat MinMaxExpr as parallel-safe, since btree
	 * opclass support functions are generally parallel-safe.  XmlExpr is a
	 * bit more dubious but we can probably get away with it.  We err on the
	 * side of caution by treating CoerceToDomain as parallel-restricted.
	 * (Note: in principle that's wrong because a domain constraint could
	 * contain a parallel-unsafe function; but useful constraints probably
	 * never would have such, and assuming they do would cripple use of
	 * parallel query in the presence of domain types.)  SQLValueFunction
	 * should be safe in all cases.  NextValueExpr is parallel-unsafe.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>max_parallel_hazard_test</name><argument_list>(<argument><expr><name>PROPARALLEL_RESTRICTED</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>

	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>max_parallel_hazard_test</name><argument_list>(<argument><expr><name>PROPARALLEL_UNSAFE</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Treat window functions as parallel-restricted because we aren't sure
	 * whether the input row ordering is fully deterministic, and the output
	 * of window functions might vary across workers if not.  (In some cases,
	 * like where the window frame orders by a primary key, we could relax
	 * this restriction.  But it doesn't currently seem worth expending extra
	 * effort to do so.)
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>max_parallel_hazard_test</name><argument_list>(<argument><expr><name>PROPARALLEL_RESTRICTED</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * As a notational convenience for callers, look through RestrictInfo.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<return>return <expr><call><name>max_parallel_hazard_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Really we should not see SubLink during a max_interesting == restricted
	 * scan, but if we do, return true.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>max_parallel_hazard_test</name><argument_list>(<argument><expr><name>PROPARALLEL_RESTRICTED</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Only parallel-safe SubPlans can be sent to workers.  Within the
	 * testexpr of the SubPlan, Params representing the output columns of the
	 * subplan can be treated as parallel-safe, so temporarily add their IDs
	 * to the safe_param_ids list while examining the testexpr.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_safe_param_ids</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subplan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
			<call><name>max_parallel_hazard_test</name><argument_list>(<argument><expr><name>PROPARALLEL_RESTRICTED</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>save_safe_param_ids</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>safe_param_ids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>safe_param_ids</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>paramIds</name></name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>safe_param_ids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>max_parallel_hazard_walker</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* no need to restore safe_param_ids */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>safe_param_ids</name></name> <operator>=</operator> <name>save_safe_param_ids</name></expr>;</expr_stmt>
		<comment type="block">/* we must also check args, but no special Param treatment there */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>max_parallel_hazard_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* don't want to recurse normally, so we're done */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>

	<comment type="block">/*
	 * We can't pass Params to workers at the moment either, so they are also
	 * parallel-restricted, unless they are PARAM_EXTERN Params or are
	 * PARAM_EXEC Params listed in safe_param_ids, meaning they could be
	 * either generated within the worker or can be computed in master and
	 * then their value can be passed to the worker.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXTERN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>!=</operator> <name>PARAM_EXEC</name> <operator>||</operator>
			<operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>safe_param_ids</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>max_parallel_hazard_test</name><argument_list>(<argument><expr><name>PROPARALLEL_RESTRICTED</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* nothing to recurse to */</comment>
	</block_content>}</block></if>

	<comment type="block">/*
	 * When we're first invoked on a completely unplanned tree, we must
	 * recurse into subqueries so to as to locate parallel-unsafe constructs
	 * anywhere in the tree.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* SELECT FOR UPDATE/SHARE must be treated as unsafe */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>max_hazard</name></name> <operator>=</operator> <name>PROPARALLEL_UNSAFE</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Recurse into subselects */</comment>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><name>max_parallel_hazard_walker</name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Recurse to check arguments */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								  <argument><expr><name>max_parallel_hazard_walker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *		Check clauses for nonstrict functions
 *****************************************************************************/</comment>

<comment type="block">/*
 * contain_nonstrict_functions
 *	  Recursively search for nonstrict functions within a clause.
 *
 * Returns true if any nonstrict construct is found --- ie, anything that
 * could produce non-NULL output with a NULL input.
 *
 * The idea here is that the caller has verified that the expression contains
 * one or more Var or Param nodes (as appropriate for the caller's need), and
 * now wishes to prove that the expression result will be NULL if any of these
 * inputs is NULL.  If we return false, then the proof succeeded.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_nonstrict_functions</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_nonstrict_functions_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_nonstrict_functions_checker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>func_strict</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_nonstrict_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* an aggregate could return non-null with null input */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A GroupingFunc doesn't evaluate its arguments, and therefore must
		 * be treated as nonstrict.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* a window function could return non-null with null input */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * subscripting assignment is nonstrict, but subscripting itself is
		 * strict
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>refassgnexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* else fall through to check args */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* IS DISTINCT FROM is inherently non-strict */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* NULLIF is inherently non-strict */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AND_EXPR</name></expr>:</case>
			<case>case <expr><name>OR_EXPR</name></expr>:</case>
				<comment type="block">/* AND, OR are inherently non-strict */</comment>
				<return>return <expr><name>true</name></expr>;</return>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* In some cases a sublink might be strict, but in general not */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * CoerceViaIO is strict regardless of whether the I/O functions are,
		 * so just go look at its argument; asking check_functions_in_node is
		 * useless expense and could deliver the wrong answer.
		 */</comment>
		<return>return <expr><call><name>contain_nonstrict_functions_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
												  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * ArrayCoerceExpr is strict at the array level, regardless of what
		 * the per-element expression is; so we should ignore elemexpr and
		 * recurse only into the arg.
		 */</comment>
		<return>return <expr><call><name>contain_nonstrict_functions_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
												  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check other function-containing nodes */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_nonstrict_functions_checker</name></expr></argument>,
								<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_nonstrict_functions_walker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *		Check clauses for context-dependent nodes
 *****************************************************************************/</comment>

<comment type="block">/*
 * contain_context_dependent_node
 *	  Recursively search for context-dependent nodes within a clause.
 *
 * CaseTestExpr nodes must appear directly within the corresponding CaseExpr,
 * not nested within another one, or they'll see the wrong test value.  If one
 * appears "bare" in the arguments of a SQL function, then we can't inline the
 * SQL function for fear of creating such a situation.  The same applies for
 * CaseTestExpr used within the elemexpr of an ArrayCoerceExpr.
 *
 * CoerceToDomainValue would have the same issue if domain CHECK expressions
 * could get inlined into larger expressions, but presently that's impossible.
 * Still, it might be allowed in future, or other node types with similar
 * issues might get invented.  So give this function a generic name, and set
 * up the recursion state to allow multiple flag bits.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_context_dependent_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>contain_context_dependent_node_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCDN_CASETESTEXPR_OK</name></cpp:macro>	<cpp:value>0x0001</cpp:value></cpp:define>	<comment type="block">/* CaseTestExpr okay here? */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_context_dependent_node_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>!</operator><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>CCDN_CASETESTEXPR_OK</name><operator>)</operator></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this CASE doesn't have a test expression, then it doesn't create
		 * a context in which CaseTestExprs should appear, so just fall
		 * through and treat it as a generic expression node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_flags</name> <init>= <expr><operator>*</operator><name>flags</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Note: in principle, we could distinguish the various sub-parts
			 * of a CASE construct and set the flag bit only for some of them,
			 * since we are only expecting CaseTestExprs to appear in the
			 * "expr" subtree of the CaseWhen nodes.  But it doesn't really
			 * seem worth any extra code.  If there are any bare CaseTestExprs
			 * elsewhere in the CASE, something's wrong already.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>CCDN_CASETESTEXPR_OK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
										 <argument><expr><name>contain_context_dependent_node_walker</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <name>save_flags</name></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_flags</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

		<comment type="block">/* Check the array expression */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_context_dependent_node_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ac</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Check the elemexpr, which is allowed to contain CaseTestExpr */</comment>
		<expr_stmt><expr><name>save_flags</name> <operator>=</operator> <operator>*</operator><name>flags</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>CCDN_CASETESTEXPR_OK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>contain_context_dependent_node_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ac</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>,
													<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <name>save_flags</name></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_context_dependent_node_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *		  Check clauses for Vars passed to non-leakproof functions
 *****************************************************************************/</comment>

<comment type="block">/*
 * contain_leaked_vars
 *		Recursively scan a clause to discover whether it contains any Var
 *		nodes (of the current query level) that are passed as arguments to
 *		leaky functions.
 *
 * Returns true if the clause contains any non-leakproof functions that are
 * passed Var nodes of the current query level, and which might therefore leak
 * data.  Such clauses must be applied after any lower-level security barrier
 * clauses.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_leaked_vars</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_leaked_vars_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_leaked_vars_checker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>get_func_leakproof</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_leaked_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
		<case>case <expr><name>T_Const</name></expr>:</case>
		<case>case <expr><name>T_Param</name></expr>:</case>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
		<case>case <expr><name>T_List</name></expr>:</case>

			<comment type="block">/*
			 * We know these node types don't contain function calls; but
			 * something further down in the node tree might.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>

			<comment type="block">/*
			 * If node contains a leaky function call, and there's any Var
			 * underneath it, reject.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_leaked_vars_checker</name></expr></argument>,
										<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>contain_var_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * It's worth special-casing this because a leaky comparison
				 * function only compromises one pair of row elements, which
				 * might not contain Vars while others do.
				 */</comment>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>opid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>larg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rarg</name></decl>;</decl_stmt>

				<macro><name>forthree</name><argument_list>(<argument>opid</argument>, <argument>rcexpr-&gt;opnos</argument>,
						 <argument>larg</argument>, <argument>rcexpr-&gt;largs</argument>,
						 <argument>rarg</argument>, <argument>rcexpr-&gt;rargs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name> <init>= <expr><call><name>get_opcode</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_func_leakproof</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<operator>(</operator><call><name>contain_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
						 <call><name>contain_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * MinMaxExpr is leakproof if the comparison function it calls
				 * is leakproof.
				 */</comment>
				<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>minmaxexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>leakproof</name></decl>;</decl_stmt>

				<comment type="block">/* Look up the btree comparison function for the datatype */</comment>
				<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>minmaxtype</name></name></expr></argument>,
											 <argument><expr><name>TYPECACHE_CMP_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>leakproof</name> <operator>=</operator> <call><name>get_func_leakproof</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * The executor will throw an error, but here we just
					 * treat the missing function as leaky.
					 */</comment>
					<expr_stmt><expr><name>leakproof</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>leakproof</name> <operator>&amp;&amp;</operator>
					<call><name>contain_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>minmaxexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>

			<comment type="block">/*
			 * WHERE CURRENT OF doesn't contain leaky function calls.
			 * Moreover, it is essential that this is considered non-leaky,
			 * since the planner must always generate a TID scan when CURRENT
			 * OF is present -- cf. cost_tidscan.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>

		<default>default:</default>

			<comment type="block">/*
			 * If we don't recognize the node tag, assume it might be leaky.
			 * This prevents an unexpected security hole if someone adds a new
			 * node type that can call a function.
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_leaked_vars_walker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_nonnullable_rels
 *		Determine which base rels are forced nonnullable by given clause.
 *
 * Returns the set of all Relids that are referenced in the clause in such
 * a way that the clause cannot possibly return TRUE if any of these Relids
 * is an all-NULL row.  (It is OK to err on the side of conservatism; hence
 * the analysis here is simplistic.)
 *
 * The semantics here are subtly different from contain_nonstrict_functions:
 * that function is concerned with NULL results from arbitrary expressions,
 * but here we assume that the input is a Boolean expression, and wish to
 * see if NULL inputs will provably cause a FALSE-or-NULL result.  We expect
 * the expression to have been AND/OR flattened and converted to implicit-AND
 * format.
 *
 * Note: this function is largely duplicative of find_nonnullable_vars().
 * The reason not to simplify this function into a thin wrapper around
 * find_nonnullable_vars() is that the tested conditions really are different:
 * a clause like "t1.v1 IS NOT NULL OR t1.v2 IS NOT NULL" does not prove
 * that either v1 or v2 can't be NULL, but it does prove that the t1 row
 * as a whole can't be all-NULL.  Also, the behavior for PHVs is different.
 *
 * top_level is true while scanning top-level AND/OR structure; here, showing
 * the result is either FALSE or NULL is good enough.  top_level is false when
 * we have descended below a NOT or a strict function: now we must be able to
 * prove that the subexpression goes to NULL.
 *
 * We don't use expression_tree_walker here because we don't want to descend
 * through very many kinds of nodes; only the ones we can be sure are strict.
 */</comment>
<function><type><name>Relids</name></type>
<name>find_nonnullable_rels</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>find_nonnullable_rels_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At top level, we are examining an implicit-AND list: if any of the
		 * arms produces FALSE-or-NULL then the result is FALSE-or-NULL. If
		 * not at top level, we are examining the arguments of a strict
		 * function: if any of them produce NULL then the result of the
		 * function must be NULL.  So in both cases, the set of nonnullable
		 * rels is the union of those found in the arms, and we pass down the
		 * top_level flag unmodified.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) node</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
							  <argument><expr><call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
														   <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>func_strict</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>func_strict</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Strict if it's "foo op ANY array" and op is strict */</comment>
		<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>useOr</name></name> <operator>&amp;&amp;</operator> <call><name>op_strict</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AND_EXPR</name></expr>:</case>
				<comment type="block">/* At top level we can just recurse (to the List case) */</comment>
				<if_stmt><if>if <condition>(<expr><name>top_level</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
														  <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Below top level, even if one arm produces NULL, the result
				 * could be FALSE (hence not NULL).  However, if *all* the
				 * arms produce NULL then the result is NULL, so we can take
				 * the intersection of the sets of nonnullable rels, just as
				 * for OR.  Fall through to share code.
				 */</comment>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>OR_EXPR</name></expr>:</case>

				<comment type="block">/*
				 * OR is strict if all of its arms are, so we can take the
				 * intersection of the sets of nonnullable rels for each arm.
				 * This works for both values of top_level.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Relids</name></type>		<name>subresult</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>subresult</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
															 <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* first subresult? */</comment>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <name>subresult</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_int_members</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>subresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<comment type="block">/*
					 * If the intersection is empty, we can stop looking. This
					 * also justifies the test for first-subresult above.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>NOT_EXPR</name></expr>:</case>
				<comment type="block">/* NOT will return null if its arg is null */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not clear this is useful, but it can't hurt */</comment>
		<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ArrayCoerceExpr is strict at the array level; ignore elemexpr */</comment>
		<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not clear this is useful, but it can't hurt */</comment>
		<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* IS NOT NULL can be considered strict, but only at top level */</comment>
		<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>top_level</name> <operator>&amp;&amp;</operator> <name><name>expr</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NOT_NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>expr</name><operator>-&gt;</operator><name>argisrow</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Boolean tests that reject NULL are strict at top level */</comment>
		<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>top_level</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_TRUE</name> <operator>||</operator>
			 <name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_FALSE</name> <operator>||</operator>
			 <name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_UNKNOWN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the contained expression forces any rels non-nullable, so does
		 * the PHV.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_rels_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the PHV's syntactic scope is exactly one rel, it will be forced
		 * to be evaluated at that rel, and so it will behave like a Var of
		 * that rel: if the rel's entire output goes to null, so will the PHV.
		 * (If the syntactic scope is a join, we know that the PHV will go to
		 * null if the whole join does; but that is AND semantics while we
		 * need OR semantics for find_nonnullable_rels' result, so we can't do
		 * anything with the knowledge.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>bms_membership</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BMS_SINGLETON</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_nonnullable_vars
 *		Determine which Vars are forced nonnullable by given clause.
 *
 * Returns a list of all level-zero Vars that are referenced in the clause in
 * such a way that the clause cannot possibly return TRUE if any of these Vars
 * is NULL.  (It is OK to err on the side of conservatism; hence the analysis
 * here is simplistic.)
 *
 * The semantics here are subtly different from contain_nonstrict_functions:
 * that function is concerned with NULL results from arbitrary expressions,
 * but here we assume that the input is a Boolean expression, and wish to
 * see if NULL inputs will provably cause a FALSE-or-NULL result.  We expect
 * the expression to have been AND/OR flattened and converted to implicit-AND
 * format.
 *
 * The result is a palloc'd List, but we have not copied the member Var nodes.
 * Also, we don't bother trying to eliminate duplicate entries.
 *
 * top_level is true while scanning top-level AND/OR structure; here, showing
 * the result is either FALSE or NULL is good enough.  top_level is false when
 * we have descended below a NOT or a strict function: now we must be able to
 * prove that the subexpression goes to NULL.
 *
 * We don't use expression_tree_walker here because we don't want to descend
 * through very many kinds of nodes; only the ones we can be sure are strict.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>find_nonnullable_vars</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>find_nonnullable_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At top level, we are examining an implicit-AND list: if any of the
		 * arms produces FALSE-or-NULL then the result is FALSE-or-NULL. If
		 * not at top level, we are examining the arguments of a strict
		 * function: if any of them produce NULL then the result of the
		 * function must be NULL.  So in both cases, the set of nonnullable
		 * vars is the union of those found in the arms, and we pass down the
		 * top_level flag unmodified.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) node</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
								 <argument><expr><call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
															  <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>func_strict</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>func_strict</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_strict_saop</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AND_EXPR</name></expr>:</case>
				<comment type="block">/* At top level we can just recurse (to the List case) */</comment>
				<if_stmt><if>if <condition>(<expr><name>top_level</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
														  <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Below top level, even if one arm produces NULL, the result
				 * could be FALSE (hence not NULL).  However, if *all* the
				 * arms produce NULL then the result is NULL, so we can take
				 * the intersection of the sets of nonnullable vars, just as
				 * for OR.  Fall through to share code.
				 */</comment>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>OR_EXPR</name></expr>:</case>

				<comment type="block">/*
				 * OR is strict if all of its arms are, so we can take the
				 * intersection of the sets of nonnullable vars for each arm.
				 * This works for both values of top_level.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subresult</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>subresult</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
															 <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* first subresult? */</comment>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <name>subresult</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_intersection</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>subresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<comment type="block">/*
					 * If the intersection is empty, we can stop looking. This
					 * also justifies the test for first-subresult above.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>NOT_EXPR</name></expr>:</case>
				<comment type="block">/* NOT will return null if its arg is null */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not clear this is useful, but it can't hurt */</comment>
		<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ArrayCoerceExpr is strict at the array level; ignore elemexpr */</comment>
		<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not clear this is useful, but it can't hurt */</comment>
		<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* IS NOT NULL can be considered strict, but only at top level */</comment>
		<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>top_level</name> <operator>&amp;&amp;</operator> <name><name>expr</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NOT_NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>expr</name><operator>-&gt;</operator><name>argisrow</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Boolean tests that reject NULL are strict at top level */</comment>
		<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>top_level</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_TRUE</name> <operator>||</operator>
			 <name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_FALSE</name> <operator>||</operator>
			 <name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_UNKNOWN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_nonnullable_vars_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_forced_null_vars
 *		Determine which Vars must be NULL for the given clause to return TRUE.
 *
 * This is the complement of find_nonnullable_vars: find the level-zero Vars
 * that must be NULL for the clause to return TRUE.  (It is OK to err on the
 * side of conservatism; hence the analysis here is simplistic.  In fact,
 * we only detect simple "var IS NULL" tests at the top level.)
 *
 * The result is a palloc'd List, but we have not copied the member Var nodes.
 * Also, we don't bother trying to eliminate duplicate entries.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>find_forced_null_vars</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Check single-clause cases using subroutine */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>find_forced_null_var</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* Otherwise, handle AND-conditions */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At top level, we are examining an implicit-AND list: if any of the
		 * arms produces FALSE-or-NULL then the result is FALSE-or-NULL.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) node</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
								 <argument><expr><call><name>find_forced_null_vars</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We don't bother considering the OR case, because it's fairly
		 * unlikely anyone would write "v1 IS NULL OR v1 IS NULL". Likewise,
		 * the NOT case isn't worth expending code on.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>AND_EXPR</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* At top level we can just recurse (to the List case) */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_forced_null_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_forced_null_var
 *		Return the Var forced null by the given clause, or NULL if it's
 *		not an IS NULL-type clause.  For success, the clause must enforce
 *		*only* nullness of the particular Var, not any other conditions.
 *
 * This is just the single-clause case of find_forced_null_vars(), without
 * any allowance for AND conditions.  It's used by initsplan.c on individual
 * qual clauses.  The reason for not just applying find_forced_null_vars()
 * is that if an AND of an IS NULL clause with something else were to somehow
 * survive AND/OR flattening, initsplan.c might get fooled into discarding
 * the whole clause when only the IS NULL part of it had been proved redundant.
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>find_forced_null_var</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check for var IS NULL */</comment>
		<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>expr</name><operator>-&gt;</operator><name>argisrow</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>var</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>var</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* var IS UNKNOWN is equivalent to var IS NULL */</comment>
		<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_UNKNOWN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>var</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>var</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Can we treat a ScalarArrayOpExpr as strict?
 *
 * If "falseOK" is true, then a "false" result can be considered strict,
 * else we need to guarantee an actual NULL result for NULL input.
 *
 * "foo op ALL array" is strict if the op is strict *and* we can prove
 * that the array input isn't an empty array.  We can check that
 * for the cases of an array constant and an ARRAY[] construct.
 *
 * "foo op ANY array" is strict in the falseOK sense if the op is strict.
 * If not falseOK, the test is the same as for "foo op ALL array".
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_strict_saop</name><parameter_list>(<parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>falseOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rightop</name></decl>;</decl_stmt>

	<comment type="block">/* The contained operator must be strict. */</comment>
	<expr_stmt><expr><call><name>set_sa_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>func_strict</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* If ANY and falseOK, that's all we need to check. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>useOr</name></name> <operator>&amp;&amp;</operator> <name>falseOK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Else, we have to see if the array is provably non-empty. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rightop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>arraydatum</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>arrayisnull</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>arrayisnull</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rightop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrayexpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>rightop</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>arrayexpr</name><operator>-&gt;</operator><name>multidims</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>



<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name>exec_location</name></decl>;</decl_stmt>
}</block></struct></type> <name>check_execute_on_functions_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_execute_on_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								  <parameter><decl><type><name>check_execute_on_functions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>exec_location</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exec_location</name> <operator>=</operator> <call><name>func_exec_location</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>exec_location</name> <operator>!=</operator> <name>PROEXECLOCATION_ANY</name> <operator>&amp;&amp;</operator> <name>exec_location</name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>exec_location</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>exec_location</name></name> <operator>!=</operator> <name>PROEXECLOCATION_ANY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot mix EXECUTE ON MASTER and EXECUTE ON ALL SEGMENTS functions in same query level"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>exec_location</name></name> <operator>=</operator> <name>exec_location</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* fall through to check args */</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>check_execute_on_functions_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>char</name></type>
<name>check_execute_on_functions</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>check_execute_on_functions_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>exec_location</name></name> <operator>=</operator> <name>PROEXECLOCATION_ANY</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_execute_on_functions_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>exec_location</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *		Check for "pseudo-constant" clauses
 *****************************************************************************/</comment>

<comment type="block">/*
 * is_pseudo_constant_clause
 *	  Detect whether an expression is "pseudo constant", ie, it contains no
 *	  variables of the current query level and no uses of volatile functions.
 *	  Such an expr is not necessarily a true constant: it can still contain
 *	  Params and outer-level Vars, not to mention functions whose results
 *	  may vary from one statement to the next.  However, the expr's value
 *	  will be constant over any one scan of the current query, so it can be
 *	  used as, eg, an indexscan key.  (Actually, the condition for indexscan
 *	  keys is weaker than this; see is_pseudo_constant_for_index().)
 *
 * CAUTION: this function omits to test for one very important class of
 * not-constant expressions, namely aggregates (Aggrefs).  In current usage
 * this is only applied to WHERE clauses and so a check for Aggrefs would be
 * a waste of cycles; but be sure to also check contain_agg_clause() if you
 * want to know about pseudo-constness in other contexts.  The same goes
 * for window functions (WindowFuncs).
 */</comment>
<function><type><name>bool</name></type>
<name>is_pseudo_constant_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We could implement this check in one recursive scan.  But since the
	 * check for volatile functions is both moderately expensive and unlikely
	 * to fail, it seems better to look for Vars first and only check for
	 * volatile functions if we find no Vars.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_var_clause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_pseudo_constant_clause_relids
 *	  Same as above, except caller already has available the var membership
 *	  of the expression; this lets us avoid the contain_var_clause() scan.
 */</comment>
<function><type><name>bool</name></type>
<name>is_pseudo_constant_clause_relids</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *																			 *
 *		General clause-manipulating routines								 *
 *																			 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * NumRelids
 *		(formerly clause_relids)
 *
 * Returns the number of different relations referenced in 'clause'.
 */</comment>
<function><type><name>int</name></type>
<name>NumRelids</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>varnos</name> <init>= <expr><call><name>pull_varnos</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>varnos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>varnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CommuteOpExpr: commute a binary operator clause
 *
 * XXX the clause is destructively modified!
 */</comment>
<function><type><name>void</name></type>
<name>CommuteOpExpr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<comment type="block">/* Sanity checks: caller is at fault if these fail */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot commute non-binary-operator clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>opoid</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find commutator for operator %u"</literal></expr></argument>,
			 <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * modify the clause in-place!
	 */</comment>
	<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>opoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<comment type="block">/* opresulttype, opretset, opcollid, inputcollid need not change */</comment>

	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for eval_const_expressions: check that datatype of an attribute
 * is still what it was when the expression was parsed.  This is needed to
 * guard against improper simplification after ALTER COLUMN TYPE.  (XXX we
 * may well need to make similar checks elsewhere?)
 *
 * rowtypeid may come from a whole-row Var, and therefore it can be a domain
 * over composite, but for this purpose we only care about checking the type
 * of a contained field.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rowtype_field_matches</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rowtypeid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fieldnum</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>expectedtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>expectedtypmod</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>expectedcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

	<comment type="block">/* No issue for RECORD, since there is no way to ALTER such a type */</comment>
	<if_stmt><if>if <condition>(<expr><name>rowtypeid</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_domain</name><argument_list>(<argument><expr><name>rowtypeid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fieldnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fieldnum</name> <operator>&gt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator>
		<name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>expectedtype</name> <operator>||</operator>
		<name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name>expectedtypmod</name> <operator>||</operator>
		<name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name>expectedcollation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * fold_constants
 *
 * Recurses into query tree and folds all constant expressions.
 */</comment>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>fold_constants</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>max_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>eval_const_expressions_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>boundParams</name></name> <operator>=</operator> <name>boundParams</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>active_fns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* nothing being recursively simplified */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>case_val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* no CASE being examined */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>estimate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* safe transformations only */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>recurse_queries</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* recurse into query structures */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>recurse_sublink_testexpr</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* do not recurse into sublink test expressions */</comment>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>max_size</name></name> <operator>=</operator> <name>max_size</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>eval_stable_functions</name></name> <operator>=</operator> <call><name>should_eval_stable_functions</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>query_or_expression_tree_mutator</name>
						<argument_list>(
						<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>q</name></expr></argument>,
						<argument><expr><name>eval_const_expressions_mutator</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>
						)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a small array constant to an ArrayExpr.
 *
 * This is used by ORCA, to transform the array argument of a ScalarArrayExpr
 * into an ArrayExpr. If a ScalarArrayExpr has an ArrayExpr argument, ORCA can
 * perform some optimizations - partition pruning at least - by first expanding
 * the ArrayExpr into its disjunctive normal form and then deriving constraints
 * based on the elements in the ArrayExpr. It doesn't currently know how to
 * extract elements from an Array const, however, so to enable those
 * optimizations in ORCA, we convert Array Consts into corresponding
 * ArrayExprs.
 *
 * If the argument is not an array constant return the original Const unmodified.
 * We convert an array const of any size to ArrayExpr. ORCA can use it to derive
 * statistics.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>transform_array_Const_to_ArrayExpr</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elemtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>elemlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>elembyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>elemalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>aexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Does it look like the right kind of an array Const? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>c</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* NULL const */</comment>

	<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>c</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not an array */</comment>

	<expr_stmt><expr><name>ac</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nelems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All set, extract the elements, and an ArrayExpr to hold them. */</comment>
	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elembyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>, <argument><expr><name>elemlen</name></expr></argument>, <argument><expr><name>elembyval</name></expr></argument>, <argument><expr><name>elemalign</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>elems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aexpr</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aexpr</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name>elemtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aexpr</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>aexpr</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>,
								  <argument><expr><call><name>makeConst</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											<argument><expr><name><name>c</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>,
											<argument><expr><name>elemlen</name></expr></argument>,
											<argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											<argument><expr><name>elembyval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>aexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*--------------------
 * eval_const_expressions
 *
 * Reduce any recognizably constant subexpressions of the given
 * expression tree, for example "2 + 2" =&gt; "4".  More interestingly,
 * we can reduce certain boolean expressions even when they contain
 * non-constant subexpressions: "x OR true" =&gt; "true" no matter what
 * the subexpression x is.  (XXX We assume that no such subexpression
 * will have important side-effects, which is not necessarily a good
 * assumption in the presence of user-defined functions; do we need a
 * pg_proc flag that prevents discarding the execution of a function?)
 *
 * We do understand that certain functions may deliver non-constant
 * results even with constant inputs, "nextval()" being the classic
 * example.  Functions that are not marked "immutable" in pg_proc
 * will not be pre-evaluated here, although we will reduce their
 * arguments as far as possible.
 *
 * Whenever a function is eliminated from the expression by means of
 * constant-expression evaluation or inlining, we add the function to
 * root-&gt;glob-&gt;invalItems.  This ensures the plan is known to depend on
 * such functions, even though they aren't referenced anymore.
 *
 * We assume that the tree has already been type-checked and contains
 * only operators and functions that are reasonable to try to execute.
 *
 * NOTE: "root" can be passed as NULL if the caller never wants to do any
 * Param substitutions nor receive info about inlined functions.
 *
 * NOTE: the planner assumes that this will always flatten nested AND and
 * OR clauses into N-argument form.  See comments in prepqual.c.
 *
 * NOTE: another critical effect is that any function calls that require
 * default arguments will be expanded, and named-argument calls will be
 * converted to positional notation.  The executor won't handle either.
 *--------------------
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>eval_const_expressions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>eval_const_expressions_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>                          <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>                          <modifier>*</modifier></type><name>saved_oid_assignments</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>root</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>boundParams</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>boundParams</name></name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* bound Params */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>boundParams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>		<comment type="block">/* for inlined-function dependencies */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>active_fns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* nothing being recursively simplified */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>case_val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* no CASE being examined */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>estimate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* safe transformations only */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>recurse_queries</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* do not recurse into query structures */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>recurse_sublink_testexpr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>max_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>eval_stable_functions</name></name> <operator>=</operator> <call><name>should_eval_stable_functions</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>saved_oid_assignments</name> <operator>=</operator> <call><name>SaveOidAssignments</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RestoreOidAssignments</name><argument_list>(<argument><expr><name>saved_oid_assignments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*--------------------
 * estimate_expression_value
 *
 * This function attempts to estimate the value of an expression for
 * planning purposes.  It is in essence a more aggressive version of
 * eval_const_expressions(): we will perform constant reductions that are
 * not necessarily 100% safe, but are reasonable for estimation purposes.
 *
 * Currently the extra steps that are taken in this mode are:
 * 1. Substitute values for Params, where a bound Param value has been made
 *	  available by the caller of planner(), even if the Param isn't marked
 *	  constant.  This effectively means that we plan using the first supplied
 *	  value of the Param.
 * 2. Fold stable, as well as immutable, functions to constants.
 * 3. Reduce PlaceHolderVar nodes to their contained expressions.
 *--------------------
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>estimate_expression_value</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>eval_const_expressions_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>boundParams</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>boundParams</name></name></expr>;</expr_stmt>	<comment type="block">/* bound Params */</comment>
	<comment type="block">/* we do not need to mark the plan as depending on inlined functions */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>active_fns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* nothing being recursively simplified */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>case_val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* no CASE being examined */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>estimate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* unsafe transformations OK */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>recurse_queries</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* do not recurse into query structures */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>recurse_sublink_testexpr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>max_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>eval_stable_functions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The generic case in eval_const_expressions_mutator is to recurse using
 * expression_tree_mutator, which will copy the given node unchanged but
 * const-simplify its arguments (if any) as far as possible.  If the node
 * itself does immutable processing, and each of its arguments were reduced
 * to a Const, we can then reduce it to a Const using evaluate_expr.  (Some
 * node types need more complicated logic; for example, a CASE expression
 * might be reducible to a constant even if not all its subtrees are.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ece_generic_processing</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>expression_tree_mutator((Node *) (node), eval_const_expressions_mutator, \
							(void *) context)</cpp:value></cpp:define>

<comment type="block">/*
 * Check whether all arguments of the given node were reduced to Consts.
 * By going directly to expression_tree_walker, contain_non_const_walker
 * is not applied to the node itself, only to its children.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ece_all_arguments_const</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(!expression_tree_walker((Node *) (node), contain_non_const_walker, NULL))</cpp:value></cpp:define>

<comment type="block">/* Generic macro for applying evaluate_expr */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ece_evaluate_expr</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((Node *) evaluate_expr((Expr *) (node), \
							exprType((Node *) (node)), \
							exprTypmod((Node *) (node)), \
							exprCollation((Node *) (node))))</cpp:value></cpp:define>

<comment type="block">/*
 * Recursive guts of eval_const_expressions/estimate_expression_value
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>eval_const_expressions_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundParams</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Look to see if we've been given a value for this Param */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXTERN</name> <operator>&amp;&amp;</operator>
					<name>paramLI</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&lt;=</operator> <name><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ParamExternData</name></type> <name>prmdata</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Give hook a chance in case parameter is dynamic.  Tell
					 * it that this fetch is speculative, so it should avoid
					 * erroring out if parameter is unavailable.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name><argument_list>(<argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prmdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<comment type="block">/*
					 * We don't just check OidIsValid, but insist that the
					 * fetched type match the Param, just in case the hook did
					 * something unexpected.  No need to throw an error here
					 * though; leave that for runtime.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* OK to substitute parameter value? */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>estimate</name></name> <operator>||</operator>
							<operator>(</operator><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>&amp;</operator> <name>PARAM_FLAG_CONST</name><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Return a Const representing the param value.
							 * Must copy pass-by-ref datatypes, since the
							 * Param might be in a memory context
							 * shorter-lived than our output plan should be.
							 */</comment>
							<decl_stmt><decl><type><name>int16</name></type>		<name>typLen</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>typByVal</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Datum</name></type>		<name>pval</name></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>||</operator> <name>typByVal</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>pval</name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
							<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>,
													  <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>,
													  <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name></expr></argument>,
													  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>typLen</name></expr></argument>,
													  <argument><expr><name>pval</name></expr></argument>,
													  <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
													  <argument><expr><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</return>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Not replaceable, so just copy the Param (no need to
				 * recurse)
				 */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>aggfilter</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>func_tuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * We can't really simplify a WindowFunc node, but we mustn't
				 * just fall through to the default processing, because we
				 * have to apply expand_function_arguments to its argument
				 * list.  That takes care of inserting default arguments and
				 * expanding named-argument notation.
				 */</comment>
				<expr_stmt><expr><name>func_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>expand_function_arguments</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>wintype</name></name></expr></argument>,
												 <argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Now, recursively simplify the args (which are a List) */</comment>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
					<call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>args</name></expr></argument>,
											<argument><expr><name>eval_const_expressions_mutator</name></expr></argument>,
											<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* ... and the filter expression, which isn't */</comment>
				<expr_stmt><expr><name>aggfilter</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
					<call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>,
												   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* And build the replacement WindowFunc node */</comment>
				<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>winfnoid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>winfnoid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>wintype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>wintype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>wincollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>wincollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>aggfilter</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>winref</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>winref</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>winstar</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>winstar</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>winagg</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>winagg</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>windistinct</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>windistinct</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>simple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Code for op/func reduction is pretty bulky, so split it out
				 * as a separate function.  Note: exprTypmod normally returns
				 * -1 for a FuncExpr, but not when the node is recognizably a
				 * length coercion; we want to preserve the typmod in the
				 * eventual Const if so.
				 */</comment>
				<expr_stmt><expr><name>simple</name> <operator>=</operator> <call><name>simplify_function</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>,
										   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>,
										   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funccollid</name></name></expr></argument>,
										   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,
										   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* successfully simplified it */</comment>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>simple</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * The expression cannot be simplified any further, so build
				 * and return a replacement FuncExpr node using the
				 * possibly-simplified arguments.  Note that we have also
				 * converted the argument list to positional notation.
				 */</comment>
				<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcretset</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funccollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>simple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Need to get OID of underlying function.  Okay to scribble
				 * on input to this extent.
				 */</comment>
				<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Code for op/func reduction is pretty bulky, so split it out
				 * as a separate function.
				 */</comment>
				<expr_stmt><expr><name>simple</name> <operator>=</operator> <call><name>simplify_function</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>,
										   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opcollid</name></name></expr></argument>,
										   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* successfully simplified it */</comment>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>simple</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If the operator is boolean equality or inequality, we know
				 * how to simplify cases involving one constant and one
				 * non-constant argument.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name> <operator>==</operator> <name>BooleanEqualOperator</name> <operator>||</operator>
					<name><name>expr</name><operator>-&gt;</operator><name>opno</name></name> <operator>==</operator> <name>BooleanNotEqualOperator</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>simple</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>simplify_boolean_equality</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
																<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* successfully simplified it */</comment>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>simple</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * The expression cannot be simplified any further, so build
				 * and return a replacement OpExpr node using the
				 * possibly-simplified arguments.
				 */</comment>
				<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opretset</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_null_input</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>all_null_input</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_nonconst_input</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>simple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Reduce constants in the DistinctExpr's arguments.  We know
				 * args is either NIL or a List node, so we can call
				 * expression_tree_mutator directly rather than recursing to
				 * self.
				 */</comment>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
														<argument><expr><name>eval_const_expressions_mutator</name></expr></argument>,
														<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We must do our own check for NULLs because DistinctExpr has
				 * different results for NULL input than the underlying
				 * operator does.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>args</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>has_null_input</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>all_null_input</name> <operator>&amp;=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>has_nonconst_input</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>

				<comment type="block">/* all constants? then can optimize this out */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_nonconst_input</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* all nulls? then not distinct */</comment>
					<if_stmt><if>if <condition>(<expr><name>all_null_input</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/* one null? then distinct */</comment>
					<if_stmt><if>if <condition>(<expr><name>has_null_input</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/* otherwise try to evaluate the '=' operator */</comment>
					<comment type="block">/* (NOT okay to try to inline it, though!) */</comment>

					<comment type="block">/*
					 * Need to get OID of underlying function.  Okay to
					 * scribble on input to this extent.
					 */</comment>
					<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* rely on struct
													 * equivalence */</comment>

					<comment type="block">/*
					 * Code for op/func reduction is pretty bulky, so split it
					 * out as a separate function.
					 */</comment>
					<expr_stmt><expr><name>simple</name> <operator>=</operator> <call><name>simplify_function</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>,
											   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opcollid</name></name></expr></argument>,
											   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition> <comment type="block">/* successfully simplified it */</comment>
					<block>{<block_content>
						<comment type="block">/*
						 * Since the underlying operator is "=", must negate
						 * its result
						 */</comment>
						<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>csimple</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>simple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>csimple</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator>
							<call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>csimple</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>csimple</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * The expression cannot be simplified any further, so build
				 * and return a replacement DistinctExpr node using the
				 * possibly-simplified arguments.
				 */</comment>
				<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opretset</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name></decl>;</decl_stmt>

				<comment type="block">/* Copy the node and const-simplify its arguments */</comment>
				<expr_stmt><expr><name>saop</name> <operator>=</operator> <operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <call><name>ece_generic_processing</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Make sure we know underlying function */</comment>
				<expr_stmt><expr><call><name>set_sa_opfuncid</name><argument_list>(<argument><expr><name>saop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If all arguments are Consts, and it's a safe function, we
				 * can fold to a constant
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>ece_all_arguments_const</name><argument_list>(<argument><expr><name>saop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>ece_function_is_safe</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>ece_evaluate_expr</name><argument_list>(<argument><expr><name>saop</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>saop</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>OR_EXPR</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>haveNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>forceTrue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>simplify_or_arguments</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
															<argument><expr><name>context</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>haveNull</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>forceTrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>forceTrue</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name>haveNull</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>,
												  <argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<comment type="block">/* If all the inputs are FALSE, result is FALSE */</comment>
							<if_stmt><if>if <condition>(<expr><name>newargs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

							<comment type="block">/*
							 * If only one nonconst-or-NULL input, it's the
							 * result
							 */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
							<comment type="block">/* Else we still need an OR node */</comment>
							<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_orclause</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return>
						</block_content>}</block>
					<case>case <expr><name>AND_EXPR</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>haveNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>forceFalse</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>simplify_and_arguments</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
															 <argument><expr><name>context</name></expr></argument>,
															 <argument><expr><operator>&amp;</operator><name>haveNull</name></expr></argument>,
															 <argument><expr><operator>&amp;</operator><name>forceFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>forceFalse</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name>haveNull</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>,
												  <argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<comment type="block">/* If all the inputs are TRUE, result is TRUE */</comment>
							<if_stmt><if>if <condition>(<expr><name>newargs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

							<comment type="block">/*
							 * If only one nonconst-or-NULL input, it's the
							 * result
							 */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
							<comment type="block">/* Else we still need an AND node */</comment>
							<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_andclause</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return>
						</block_content>}</block>
					<case>case <expr><name>NOT_EXPR</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
																 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * Use negate_clause() to see if we can simplify
							 * away the NOT.
							 */</comment>
							<return>return <expr><call><name>negate_clause</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
						</block_content>}</block>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_SubPlan</name></expr>:</case>
		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>

			<comment type="block">/*
			 * Return a SubPlan unchanged --- too late to do anything with it.
			 *
			 * XXX should we ereport() here instead?  Probably this routine
			 * should never be invoked after SubPlan creation.
			 */</comment>
			<return>return <expr><name>node</name></expr>;</return>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If we can simplify the input to a constant, then we don't
				 * need the RelabelType node anymore: just change the type
				 * field of the Const node.  Otherwise, must copy the
				 * RelabelType node.
				 */</comment>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>relabel</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>relabel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
													 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we find stacked RelabelTypes (eg, from foo :: int ::
				 * oid) we can discard all but the top one.
				 */</comment>
				<while>while <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

				<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name><name>relabel</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>=</operator> <name><name>relabel</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>=</operator> <name><name>relabel</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>con</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>newrelabel</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>relabel</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name><name>relabel</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name><name>relabel</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>=</operator> <name><name>relabel</name><operator>-&gt;</operator><name>relabelformat</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>relabel</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newrelabel</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>outfunc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>outtypisvarlena</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>infunc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>intypioparam</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>simple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

				<comment type="block">/* Make a List so we can use simplify_function */</comment>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * CoerceViaIO represents calling the source type's output
				 * function then the result type's input function.  So, try to
				 * simplify it as though it were a stack of two such function
				 * calls.  First we need to know what the functions are.
				 *
				 * Note that the coercion functions are assumed not to care
				 * about input collation, so we just pass InvalidOid for that.
				 */</comment>
				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>outfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outtypisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>infunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intypioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>simple</name> <operator>=</operator> <call><name>simplify_function</name><argument_list>(<argument><expr><name>outfunc</name></expr></argument>,
										   <argument><expr><name>CSTRINGOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition>		<comment type="block">/* successfully simplified output fn */</comment>
				<block>{<block_content>
					<comment type="block">/*
					 * Input functions may want 1 to 3 arguments.  We always
					 * supply all three, trusting that nothing downstream will
					 * complain.
					 */</comment>
					<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>simple</name></expr></argument>,
									  <argument><expr><call><name>makeConst</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>,
												<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												<argument><expr><name>InvalidOid</name></expr></argument>,
												<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
												<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>intypioparam</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
												<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												<argument><expr><name>InvalidOid</name></expr></argument>,
												<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
												<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>simple</name> <operator>=</operator> <call><name>simplify_function</name><argument_list>(<argument><expr><name>infunc</name></expr></argument>,
											   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>resultcollid</name></name></expr></argument>,
											   <argument><expr><name>InvalidOid</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>true</name></expr></argument>,
											   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* successfully simplified input fn */</comment>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>simple</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * The expression cannot be simplified any further, so build
				 * and return a replacement CoerceViaIO node using the
				 * possibly-simplified argument.
				 */</comment>
				<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>coerceformat</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>save_case_val</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Copy the node and const-simplify its arguments.  We can't
				 * use ece_generic_processing() here because we need to mess
				 * with case_val only while processing the elemexpr.
				 */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
					<call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ac</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
												   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Set up for the CaseTestExpr node contained in the elemexpr.
				 * We must prevent it from absorbing any outer CASE value.
				 */</comment>
				<expr_stmt><expr><name>save_case_val</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>case_val</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>case_val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>elemexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
					<call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ac</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>,
												   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>case_val</name></name> <operator>=</operator> <name>save_case_val</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If constant argument and the per-element expression is
				 * immutable, we can simplify the whole thing to a constant.
				 * Exception: although contain_mutable_functions considers
				 * CoerceToDomain immutable for historical reasons, let's not
				 * do so here; this ensures coercion to an array-over-domain
				 * does not apply the domain's constraints until runtime.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>ac</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>ac</name><operator>-&gt;</operator><name>elemexpr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ac</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>ece_evaluate_expr</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ac</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If we can simplify the input to a constant, then we don't
				 * need the CollateExpr node at all: just change the
				 * constcollid field of the Const node.  Otherwise, replace
				 * the CollateExpr with a RelabelType. (We do that so as to
				 * improve uniformity of expression representation and thus
				 * simplify comparison of expressions.)
				 */</comment>
				<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>collate</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>collate</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
													 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>=</operator> <name><name>collate</name><operator>-&gt;</operator><name>collOid</name></name></expr>;</expr_stmt>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>con</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>collate</name><operator>-&gt;</operator><name>collOid</name></name> <operator>==</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Don't need a RelabelType either... */</comment>
					<return>return <expr><name>arg</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>relabel</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>relabel</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>relabel</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>relabel</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name><name>collate</name><operator>-&gt;</operator><name>collOid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>relabel</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>relabel</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>collate</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

					<comment type="block">/* Don't create stacked RelabelTypes */</comment>
					<while>while <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>
					<expr_stmt><expr><name><name>relabel</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>relabel</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*----------
				 * CASE expressions can be simplified if there are constant
				 * condition clauses:
				 *		FALSE (or NULL): drop the alternative
				 *		TRUE: drop all remaining alternatives
				 * If the first non-FALSE alternative is a constant TRUE,
				 * we can simplify the entire CASE to that alternative's
				 * expression.  If there are no non-FALSE alternatives,
				 * we simplify the entire CASE to the default result (ELSE).
				 *
				 * If we have a simple-form CASE with constant test
				 * expression, we substitute the constant value for contained
				 * CaseTestExpr placeholder nodes, so that we have the
				 * opportunity to reduce constant test conditions.  For
				 * example this allows
				 *		CASE 0 WHEN 0 THEN 1 ELSE 1/0 END
				 * to reduce to 1 rather than drawing a divide-by-0 error.
				 * Note that when the test expression is constant, we don't
				 * have to include it in the resulting CASE; for example
				 *		CASE 0 WHEN x THEN y ELSE z END
				 * is transformed by the parser to
				 *		CASE 0 WHEN CaseTestExpr = x THEN y ELSE z END
				 * which we can simplify to
				 *		CASE WHEN 0 = x THEN y ELSE z END
				 * It is not necessary for the executor to evaluate the "arg"
				 * expression when executing the CASE, since any contained
				 * CaseTestExprs that might have referred to it will have been
				 * replaced by the constant.
				 *----------
				 */</comment>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>newcase</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>save_case_val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newarg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>const_true_cond</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>defresult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<comment type="block">/* Simplify the test expression, if any */</comment>
				<expr_stmt><expr><name>newarg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
														<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Set up for contained CaseTestExpr nodes */</comment>
				<expr_stmt><expr><name>save_case_val</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>case_val</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>newarg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>newarg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>case_val</name></name> <operator>=</operator> <name>newarg</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newarg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* not needed anymore, see above */</comment>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>case_val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* Simplify the WHEN clauses */</comment>
				<expr_stmt><expr><name>newargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>const_true_cond</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>caseexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>oldcasewhen</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>casecond</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>caseresult</name></decl>;</decl_stmt>

					<comment type="block">/* Simplify this alternative's test condition */</comment>
					<expr_stmt><expr><name>casecond</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oldcasewhen</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
															  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If the test condition is constant FALSE (or NULL), then
					 * drop this WHEN clause completely, without processing
					 * the result.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>casecond</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>casecond</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>const_input</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>casecond</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>const_input</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>||</operator>
							<operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>const_input</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* drop alternative with FALSE cond */</comment>
						<comment type="block">/* Else it's constant TRUE */</comment>
						<expr_stmt><expr><name>const_true_cond</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Simplify this alternative's result value */</comment>
					<expr_stmt><expr><name>caseresult</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oldcasewhen</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
																<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* If non-constant test condition, emit a new WHEN node */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>const_true_cond</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>newcasewhen</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>newcasewhen</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>casecond</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newcasewhen</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>caseresult</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newcasewhen</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>oldcasewhen</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newcasewhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Found a TRUE condition, so none of the remaining
					 * alternatives can be reached.  We treat the result as
					 * the default result.
					 */</comment>
					<expr_stmt><expr><name>defresult</name> <operator>=</operator> <name>caseresult</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<comment type="block">/* Simplify the default result, unless we replaced it above */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>const_true_cond</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>defresult</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>,
															   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>case_val</name></name> <operator>=</operator> <name>save_case_val</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If no non-FALSE alternatives, CASE reduces to the default
				 * result
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>newargs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>defresult</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* Otherwise we need a new CASE node */</comment>
				<expr_stmt><expr><name>newcase</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcase</name><operator>-&gt;</operator><name>casetype</name></name> <operator>=</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>casetype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcase</name><operator>-&gt;</operator><name>casecollid</name></name> <operator>=</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>casecollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcase</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newarg</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcase</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newargs</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcase</name><operator>-&gt;</operator><name>defresult</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>defresult</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcase</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcase</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If we know a constant test value for the current CASE
				 * construct, substitute it for the placeholder.  Else just
				 * return the placeholder as-is.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>case_val</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>case_val</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Generic handling for node types whose own processing is
				 * known to be immutable, and for which we need no smarts
				 * beyond "simplify if all inputs are constants".
				 *
				 * Treating MinMaxExpr this way amounts to assuming that the
				 * btree comparison function it calls is immutable; see the
				 * reasoning in contain_mutable_functions_walker.
				 */</comment>

				<comment type="block">/* Copy the node and const-simplify its arguments */</comment>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ece_generic_processing</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* If all arguments are Consts, we can fold to a constant */</comment>
				<comment type="block">/* In gpdb, RowExpr's TupleDesc will lost in QE if we evaluate
				 * expr in planner. It is hard to dispatch these TupleDesc to QE
				 * since it affect typecache more complex.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>ece_all_arguments_const</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>row_typeid</name> <operator>!=</operator> <name>RECORDOID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>ece_evaluate_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><name>node</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesceexpr</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>newcoalesce</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>newargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>coalesceexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * We can remove null constants from the list. For a
					 * non-null constant, if it has not been preceded by any
					 * other non-null-constant expressions then it is the
					 * result. Otherwise, it's the next argument, but we can
					 * drop following arguments since they will never be
					 * reached.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>e</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* drop null constant */</comment>
						<if_stmt><if>if <condition>(<expr><name>newargs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>e</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* first expr */</comment>
						<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * If all the arguments were constant null, the result is just
				 * null
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>newargs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name><name>coalesceexpr</name><operator>-&gt;</operator><name>coalescetype</name></name></expr></argument>,
												  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												  <argument><expr><name><name>coalesceexpr</name><operator>-&gt;</operator><name>coalescecollid</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>newcoalesce</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcoalesce</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name><name>coalesceexpr</name><operator>-&gt;</operator><name>coalescetype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcoalesce</name><operator>-&gt;</operator><name>coalescecollid</name></name> <operator>=</operator> <name><name>coalesceexpr</name><operator>-&gt;</operator><name>coalescecollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcoalesce</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newargs</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcoalesce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>coalesceexpr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcoalesce</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * All variants of SQLValueFunction are stable, so if we are
				 * estimating the expression's value, we should evaluate the
				 * current function value.
				 *
				 * In GPDB, we add eval_stable_functions field in the context
				 * to decide whether we should pre-evaluate this stable function.
				 * If it is true, we evaluate the function value here so that we
				 * can directly dispatch a single row insertion query that contains
				 * SQLValueFunction (Otherwise we need to add a redistribution
				 * motion). In a specific case where we use prepare/execute statement,
				 * we need to set oneoffPlan to true so that we can re-evaluate 
				 * the SQLValueFunction in the execute statement.
				 *
				 * If neither condition holds, we just copy.
				 */</comment>
				<decl_stmt><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name> <init>= <expr><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>eval_stable_functions</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>oneoffPlan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>evaluate_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>svf</name></expr></argument>,
												  <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
												  <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>,
												  <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>estimate</name></name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>evaluate_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>svf</name></expr></argument>,
												  <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
												  <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>,
												  <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>svf</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * We can optimize field selection from a whole-row Var into a
				 * simple Var.  (This case won't be generated directly by the
				 * parser, because ParseComplexProjection short-circuits it.
				 * But it can arise while simplifying functions.)  Also, we
				 * can optimize field selection from a RowExpr construct, or
				 * of course from a constant.
				 *
				 * However, replacing a whole-row Var in this way has a
				 * pitfall: if we've already built the rel targetlist for the
				 * source relation, then the whole-row Var is scheduled to be
				 * produced by the relation scan, but the simple Var probably
				 * isn't, which will lead to a failure in setrefs.c.  This is
				 * not a problem when handling simple single-level queries, in
				 * which expression simplification always happens first.  It
				 * is a risk for lateral references from subqueries, though.
				 * To avoid such failures, don't optimize uplevel references.
				 *
				 * We must also check that the declared type of the field is
				 * still the same as when the FieldSelect was created --- this
				 * can change if someone did ALTER COLUMN TYPE on the rowtype.
				 * If it isn't, we skip the optimization; the case will
				 * probably fail at runtime, but that's not our problem here.
				 */</comment>
				<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>newfselect</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
													 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>rowtype_field_matches</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>vartype</name></expr></argument>,
											  <argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name></expr></argument>,
											  <argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
											  <argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
											  <argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>resultcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>varno</name></expr></argument>,
												<argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name></expr></argument>,
												<argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
												<argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
												<argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>resultcollid</name></name></expr></argument>,
												<argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
						<name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>fld</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
															<argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>rowtype_field_matches</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name></expr></argument>,
												  <argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name></expr></argument>,
												  <argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
												  <argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
												  <argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>resultcollid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>==</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<name><name>fselect</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>==</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<name><name>fselect</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>==</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>fld</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>newfselect</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newfselect</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newfselect</name><operator>-&gt;</operator><name>fieldnum</name></name> <operator>=</operator> <name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newfselect</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newfselect</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name><name>fselect</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newfselect</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name><name>fselect</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>rowtype_field_matches</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
											  <argument><expr><name><name>newfselect</name><operator>-&gt;</operator><name>fieldnum</name></name></expr></argument>,
											  <argument><expr><name><name>newfselect</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
											  <argument><expr><name><name>newfselect</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
											  <argument><expr><name><name>newfselect</name><operator>-&gt;</operator><name>resultcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><call><name>ece_evaluate_expr</name><argument_list>(<argument><expr><name>newfselect</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newfselect</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>newntest</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
													 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>&amp;&amp;</operator> <name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We break ROW(...) IS [NOT] NULL into separate tests on
					 * its component fields.  This form is usually more
					 * efficient to evaluate, as well as being more amenable
					 * to optimization.
					 */</comment>
					<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rarg</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rarg-&gt;args</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>relem</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * A constant field refutes the whole NullTest if it's
						 * of the wrong nullness; else we can discard it.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>relem</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>relem</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>carg</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>relem</name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name></expr> ?</condition><then>
								<expr><operator>(</operator><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NOT_NULL</name><operator>)</operator></expr> </then><else>:
								<expr><operator>(</operator><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name><operator>)</operator></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * Else, make a scalar (argisrow == false) NullTest
						 * for this field.  Scalar semantics are required
						 * because IS [NOT] NULL doesn't recurse; see comments
						 * in ExecEvalRowNullInt().
						 */</comment>
						<expr_stmt><expr><name>newntest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newntest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>relem</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newntest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>ntest</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newntest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<comment type="block">/* If all the inputs were constants, result is TRUE */</comment>
					<if_stmt><if>if <condition>(<expr><name>newargs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
					<comment type="block">/* If only one nonconst input, it's the result */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
					<comment type="block">/* Else we need an AND node */</comment>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_andclause</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>&amp;&amp;</operator> <name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>carg</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

					<switch>switch <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>IS_NULL</name></expr>:</case>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_NOT_NULL</name></expr>:</case>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>!</operator><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
							<break>break;</break>
					</block_content>}</block></switch>

					<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>newntest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newntest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newntest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>ntest</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newntest</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * This case could be folded into the generic handling used
				 * for SubscriptingRef etc.  But because the simplification
				 * logic is so trivial, applying evaluate_expr() to perform it
				 * would be a heavy overhead.  BooleanTest is probably common
				 * enough to justify keeping this bespoke implementation.
				 */</comment>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>newbtest</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
													 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>carg</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

					<switch>switch <condition>(<expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>IS_TRUE</name></expr>:</case>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator>
									  <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>carg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>||</operator>
									  <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>carg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_FALSE</name></expr>:</case>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator>
									  <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>carg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>||</operator>
									  <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>carg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>!</operator><name><name>carg</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
							<break>break;</break>
					</block_content>}</block></switch>

					<return>return <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>newbtest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newbtest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newbtest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>=</operator> <name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newbtest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>btest</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newbtest</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If the domain currently has no constraints, we replace the
				 * CoerceToDomain node with a simple RelabelType, which is
				 * both far faster to execute and more amenable to later
				 * optimization.  We must then mark the plan as needing to be
				 * rebuilt if the domain's constraints change.
				 *
				 * Also, in estimation mode, always replace CoerceToDomain
				 * nodes, effectively assuming that the coercion will succeed.
				 */</comment>
				<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>cdomain</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>newcdomain</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
													 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>estimate</name></name> <operator>||</operator>
					<operator>!</operator><call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name><name>cdomain</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Record dependency, if this isn't estimation mode */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>estimate</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>record_plan_type_dependency</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
													<argument><expr><name><name>cdomain</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Generate RelabelType to substitute for CoerceToDomain */</comment>
					<comment type="block">/* This should match the RelabelType logic above */</comment>

					<while>while <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

					<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>con</name></expr>;</return>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>newrelabel</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>coercionformat</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newrelabel</name></expr>;</return>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>newcdomain</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcdomain</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcdomain</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcdomain</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcdomain</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcdomain</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>coercionformat</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcdomain</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcdomain</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>

			<comment type="block">/*
			 * In estimation mode, just strip the PlaceHolderVar node
			 * altogether; this amounts to estimating that the contained value
			 * won't be forced to null by an outer join.  In regular mode we
			 * just use the default behavior (ie, simplify the expression but
			 * leave the PlaceHolderVar node intact).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>estimate</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>,
													  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>cre</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>newcre</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cre</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
													 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>newcre</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcre</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>cre</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcre</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>=</operator> <name><name>cre</name><operator>-&gt;</operator><name>convertformat</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newcre</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cre</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * In case of a nested ConvertRowtypeExpr, we can convert the
				 * leaf row directly to the topmost row format without any
				 * intermediate conversions. (This works because
				 * ConvertRowtypeExpr is used only for child-&gt;parent
				 * conversion in inheritance trees, which works by exact match
				 * of column name, and a column absent in an intermediate
				 * result can't be present in the final result.)
				 *
				 * No need to check more than one level deep, because the
				 * above recursion will have flattened anything else.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>argcre</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>argcre</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Make sure an outer implicit conversion can't hide an
					 * inner explicit one.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>newcre</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>newcre</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>=</operator> <name><name>argcre</name><operator>-&gt;</operator><name>convertformat</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>newcre</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>ece_evaluate_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcre</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcre</name></expr>;</return>
			</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* prevent recursion into sublinks */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>recurse_sublink_testexpr</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>newnode</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>sublink</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Also invoke the mutator on the sublink's Query node, so it
		 * can recurse into the sub-query if it wants to.
		 */</comment>
		<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>subselect</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><name>eval_const_expressions_mutator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* recurse into query structure if requested */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>recurse_queries</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
					<call><name>query_tree_mutator</name>
					<argument_list>(
					<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
					<argument><expr><name>eval_const_expressions_mutator</name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
					<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For any node type not handled above, copy the node unchanged but
	 * const-simplify its subexpressions.  This is the correct thing for node
	 * types whose behavior might change between planning and execution, such
	 * as CurrentOfExpr.  It's also a safe default for new node types not
	 * known to this routine.
	 */</comment>
	<return>return <expr><call><name>ece_generic_processing</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for eval_const_expressions: check for non-Const nodes.
 *
 * We can abort recursion immediately on finding a non-Const node.  This is
 * critical for performance, else eval_const_expressions_mutator would take
 * O(N^2) time on non-simplifiable trees.  However, we do need to descend
 * into List nodes since expression_tree_walker sometimes invokes the walker
 * function directly on List subtrees.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_non_const_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_non_const_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Otherwise, abort the tree traversal and return true */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for eval_const_expressions: check if a function is OK to evaluate
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ece_function_is_safe</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>provolatile</name> <init>= <expr><call><name>func_volatile</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ordinarily we are only allowed to simplify immutable functions. But for
	 * purposes of estimation, we consider it okay to simplify functions that
	 * are merely stable; the risk that the result might change from planning
	 * time to execution time is worth taking in preference to not being able
	 * to estimate the value at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>provolatile</name> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>estimate</name></name> <operator>&amp;&amp;</operator> <name>provolatile</name> <operator>==</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for eval_const_expressions: process arguments of an OR clause
 *
 * This includes flattening of nested ORs as well as recursion to
 * eval_const_expressions to simplify the OR arguments.
 *
 * After simplification, OR arguments are handled as follows:
 *		non constant: keep
 *		FALSE: drop (does not affect result)
 *		TRUE: force result to TRUE
 *		NULL: keep only one
 * We must keep one NULL input because OR expressions evaluate to NULL when no
 * input is TRUE and at least one is NULL.  We don't actually include the NULL
 * here, that's supposed to be done by the caller.
 *
 * The output arguments *haveNull and *forceTrue must be initialized false
 * by the caller.  They will be set true if a NULL constant or TRUE constant,
 * respectively, is detected anywhere in the argument list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>simplify_or_arguments</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
					  <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>haveNull</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceTrue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>unprocessed_args</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want to ensure that any OR immediately beneath another OR gets
	 * flattened into a single OR-list, so as to simplify later reasoning.
	 *
	 * To avoid stack overflow from recursion of eval_const_expressions, we
	 * resort to some tenseness here: we keep a list of not-yet-processed
	 * inputs, and handle flattening of nested ORs by prepending to the to-do
	 * list instead of recursing.  Now that the parser generates N-argument
	 * ORs from simple lists, this complexity is probably less necessary than
	 * it once was, but we might as well keep the logic.
	 */</comment>
	<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>unprocessed_args</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>unprocessed_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>unprocessed_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* flatten nested ORs as per above comment */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_orclause</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subargs</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* overly tense code to avoid leaking unused list header */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>unprocessed_args</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <name>subargs</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oldhdr</name> <init>= <expr><name>unprocessed_args</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subargs</name></expr></argument>, <argument><expr><name>unprocessed_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If it's not an OR, simplify it */</comment>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It is unlikely but not impossible for simplification of a non-OR
		 * clause to produce an OR.  Recheck, but don't be too tense about it
		 * since it's not a mainstream case. In particular we don't worry
		 * about const-simplifying the input twice.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_orclause</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subargs</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subargs</name></expr></argument>, <argument><expr><name>unprocessed_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * OK, we have a const-simplified non-OR argument.  Process it per
		 * comments above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>const_input</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>const_input</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>haveNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>const_input</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>forceTrue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Once we detect a TRUE result we can just exit the loop
				 * immediately.  However, if we ever add a notion of
				 * non-removable functions, we'd need to keep scanning.
				 */</comment>
				<return>return <expr><name>NIL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* otherwise, we can drop the constant-false input */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* else emit the simplified arg into the result list */</comment>
		<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>newargs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for eval_const_expressions: process arguments of an AND clause
 *
 * This includes flattening of nested ANDs as well as recursion to
 * eval_const_expressions to simplify the AND arguments.
 *
 * After simplification, AND arguments are handled as follows:
 *		non constant: keep
 *		TRUE: drop (does not affect result)
 *		FALSE: force result to FALSE
 *		NULL: keep only one
 * We must keep one NULL input because AND expressions evaluate to NULL when
 * no input is FALSE and at least one is NULL.  We don't actually include the
 * NULL here, that's supposed to be done by the caller.
 *
 * The output arguments *haveNull and *forceFalse must be initialized false
 * by the caller.  They will be set true if a null constant or false constant,
 * respectively, is detected anywhere in the argument list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>simplify_and_arguments</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
					   <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>haveNull</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceFalse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>unprocessed_args</name></decl>;</decl_stmt>

	<comment type="block">/* See comments in simplify_or_arguments */</comment>
	<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>unprocessed_args</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>unprocessed_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>unprocessed_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* flatten nested ANDs as per above comment */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_andclause</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subargs</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* overly tense code to avoid leaking unused list header */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>unprocessed_args</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <name>subargs</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oldhdr</name> <init>= <expr><name>unprocessed_args</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subargs</name></expr></argument>, <argument><expr><name>unprocessed_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If it's not an AND, simplify it */</comment>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It is unlikely but not impossible for simplification of a non-AND
		 * clause to produce an AND.  Recheck, but don't be too tense about it
		 * since it's not a mainstream case. In particular we don't worry
		 * about const-simplifying the input twice.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_andclause</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subargs</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>unprocessed_args</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subargs</name></expr></argument>, <argument><expr><name>unprocessed_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * OK, we have a const-simplified non-AND argument.  Process it per
		 * comments above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>const_input</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>const_input</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>haveNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>const_input</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>forceFalse</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Once we detect a FALSE result we can just exit the loop
				 * immediately.  However, if we ever add a notion of
				 * non-removable functions, we'd need to keep scanning.
				 */</comment>
				<return>return <expr><name>NIL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* otherwise, we can drop the constant-true input */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* else emit the simplified arg into the result list */</comment>
		<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>newargs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for eval_const_expressions: try to simplify boolean equality
 * or inequality condition
 *
 * Inputs are the operator OID and the simplified arguments to the operator.
 * Returns a simplified expression if successful, or NULL if cannot
 * simplify the expression.
 *
 * The idea here is to reduce "x = true" to "x" and "x = false" to "NOT x",
 * or similarly "x &lt;&gt; true" to "NOT x" and "x &lt;&gt; false" to "x".
 * This is only marginally useful in itself, but doing it in constant folding
 * ensures that we will recognize these forms as being equivalent in, for
 * example, partial index matching.
 *
 * We come here only if simplify_function has failed; therefore we cannot
 * see two constant inputs, nor a constant-NULL input.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>simplify_boolean_equality</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rightop</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftop</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightop</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>leftop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opno</name> <operator>==</operator> <name>BooleanEqualOperator</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>rightop</name></expr>;</return></block_content></block></if> <comment type="block">/* true = foo */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><call><name>negate_clause</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* false = foo */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>negate_clause</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>	<comment type="block">/* true &lt;&gt; foo */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>rightop</name></expr>;</return></block_content></block></else></if_stmt> <comment type="block">/* false &lt;&gt; foo */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rightop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opno</name> <operator>==</operator> <name>BooleanEqualOperator</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>leftop</name></expr>;</return></block_content></block></if>	<comment type="block">/* foo = true */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><call><name>negate_clause</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* foo = false */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>negate_clause</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>	<comment type="block">/* foo &lt;&gt; true */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>leftop</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* foo &lt;&gt; false */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for eval_const_expressions: try to simplify a function call
 * (which might originally have been an operator; we don't care)
 *
 * Inputs are the function OID, actual result type OID (which is needed for
 * polymorphic functions), result typmod, result collation, the input
 * collation to use for the function, the original argument list (not
 * const-simplified yet, unless process_args is false), and some flags;
 * also the context data for eval_const_expressions.
 *
 * Returns a simplified expression if successful, or NULL if cannot
 * simplify the function call.
 *
 * This function is also responsible for converting named-notation argument
 * lists into positional notation and/or adding any needed default argument
 * expressions; which is a bit grotty, but it avoids extra fetches of the
 * function's pg_proc tuple.  For this reason, the args list is
 * pass-by-reference.  Conversion and const-simplification of the args list
 * will be done even if simplification of the function call itself is not
 * possible.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>simplify_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>result_typmod</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>result_collid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>input_collid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>args_p</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>funcvariadic</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>process_args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_non_const</name></decl></parameter>,
				  <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>*</operator><name>args_p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>func_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>func_form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We have three strategies for simplification: execute the function to
	 * deliver a constant result, use a transform function to generate a
	 * substitute node tree, or expand in-line the body of the function
	 * definition (which only works for simple SQL-language functions, but
	 * that is a common case).  Each case needs access to the function's
	 * pg_proc tuple, so fetch it just once.
	 *
	 * Note: the allow_non_const flag suppresses both the second and third
	 * strategies; so if !allow_non_const, simplify_function can only return a
	 * Const or NULL.  Argument-list rewriting happens anyway, though.
	 */</comment>
	<expr_stmt><expr><name>func_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>func_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process the function arguments, unless the caller did it already.
	 *
	 * Here we must deal with named or defaulted arguments, and then
	 * recursively apply eval_const_expressions to the whole argument list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>process_args</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>expand_function_arguments</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>args</name></expr></argument>,
												<argument><expr><name>eval_const_expressions_mutator</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Argument processing done, give it back to the caller */</comment>
		<expr_stmt><expr><operator>*</operator><name>args_p</name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now attempt simplification of the function call proper. */</comment>

	<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>evaluate_function</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>result_typmod</name></expr></argument>,
								<argument><expr><name>result_collid</name></expr></argument>, <argument><expr><name>input_collid</name></expr></argument>,
								<argument><expr><name>args</name></expr></argument>, <argument><expr><name>funcvariadic</name></expr></argument>,
								<argument><expr><name>func_tuple</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>large_const</name><argument_list>(<argument><expr><name>newexpr</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>max_size</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// folded expression prohibitively large</comment>
		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newexpr</name> <operator>&amp;&amp;</operator> <name>allow_non_const</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>func_form</name><operator>-&gt;</operator><name>prosupport</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Build a SupportRequestSimplify node to pass to the support
		 * function, pointing to a dummy FuncExpr node containing the
		 * simplified arg list.  We use this approach to present a uniform
		 * interface to the support function regardless of how the target
		 * function is actually being invoked.
		 */</comment>
		<decl_stmt><decl><type><name>SupportRequestSimplify</name></type> <name>req</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncExpr</name></type>	<name>fexpr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>xpr</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_FuncExpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>funcid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>funcresulttype</name></name> <operator>=</operator> <name>result_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>funcretset</name></name> <operator>=</operator> <name><name>func_form</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>funcvariadic</name></name> <operator>=</operator> <name>funcvariadic</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>funcformat</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CALL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>funccollid</name></name> <operator>=</operator> <name>result_collid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>inputcollid</name></name> <operator>=</operator> <name>input_collid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>.</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>req</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_SupportRequestSimplify</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>req</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>req</name><operator>.</operator><name>fcall</name></name> <operator>=</operator> <operator>&amp;</operator><name>fexpr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name><name>func_form</name><operator>-&gt;</operator><name>prosupport</name></name></expr></argument>,
											 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* catch a possible API misunderstanding */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newexpr</name> <operator>!=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>fexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newexpr</name> <operator>&amp;&amp;</operator> <name>allow_non_const</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>inline_function</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>result_collid</name></expr></argument>,
								  <argument><expr><name>input_collid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>funcvariadic</name></expr></argument>,
								  <argument><expr><name>func_tuple</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * expand_function_arguments: convert named-notation args to positional args
 * and/or insert default args, as needed
 *
 * If we need to change anything, the input argument list is copied, not
 * modified.
 *
 * Note: this gets applied to operator argument lists too, even though the
 * cases it handles should never occur there.  This should be OK since it
 * will fall through very quickly if there's nothing to do.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>expand_function_arguments</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_named_args</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Do we have any named arguments? */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>has_named_args</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* If so, we must apply reorder_function_arguments */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_named_args</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>reorder_function_arguments</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Recheck argument types and add casts if needed */</comment>
		<expr_stmt><expr><call><name>recheck_cast_function_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No named args, but we seem to be short some defaults */</comment>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>add_function_defaults</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Recheck argument types and add casts if needed */</comment>
		<expr_stmt><expr><call><name>recheck_cast_function_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>args</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * reorder_function_arguments: convert named-notation args to positional args
 *
 * This function also inserts default argument values as needed, since it's
 * impossible to form a truly valid positional call without that.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>reorder_function_arguments</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pronargs</name> <init>= <expr><name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargsprovided</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name><name>argarray</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargsprovided</name> <operator>&lt;=</operator> <name>pronargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pronargs</name> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many function arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>argarray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pronargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deconstruct the argument list into an array indexed by argnumber */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* positional argument, assumed to precede all named args */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argarray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>argarray</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>na</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argarray</name><index>[<expr><name><name>na</name><operator>-&gt;</operator><name>argnumber</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>argarray</name><index>[<expr><name><name>na</name><operator>-&gt;</operator><name>argnumber</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>na</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Fetch default expressions, if needed, and insert into array at proper
	 * locations (they aren't necessarily consecutive or all used)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargsprovided</name> <operator>&lt;</operator> <name>pronargs</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>defaults</name> <init>= <expr><call><name>fetch_function_defaults</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>pronargs</name> <operator>-</operator> <name><name>funcform</name><operator>-&gt;</operator><name>pronargdefaults</name></name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>defaults</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>argarray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>argarray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now reconstruct the args list in proper order */</comment>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pronargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argarray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>argarray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>args</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_function_defaults: add missing function arguments from its defaults
 *
 * This is used only when the argument list was positional to begin with,
 * and so we know we just need to add defaults at the end.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>add_function_defaults</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargsprovided</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>defaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndelete</name></decl>;</decl_stmt>

	<comment type="block">/* Get all the default expressions from the pg_proc tuple */</comment>
	<expr_stmt><expr><name>defaults</name> <operator>=</operator> <call><name>fetch_function_defaults</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete any unused defaults from the list */</comment>
	<expr_stmt><expr><name>ndelete</name> <operator>=</operator> <name>nargsprovided</name> <operator>+</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndelete</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough default arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><name>ndelete</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>defaults</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* And form the combined argument list, not modifying the input list */</comment>
	<return>return <expr><call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>defaults</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fetch_function_defaults: get function's default arguments as expression list
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fetch_function_defaults</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>defaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proargdefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<comment type="block">/* The error cases here shouldn't happen, but check anyway */</comment>
	<expr_stmt><expr><name>proargdefaults</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>func_tuple</name></expr></argument>,
									 <argument><expr><name>Anum_pg_proc_proargdefaults</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough default arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>proargdefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>defaults</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>defaults</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * recheck_cast_function_args: recheck function args and typecast as needed
 * after adding defaults.
 *
 * It is possible for some of the defaulted arguments to be polymorphic;
 * therefore we can't assume that the default expressions have the correct
 * data types already.  We have to re-resolve polymorphics and do coercion
 * just like the parser did.
 *
 * This should be a no-op if there are no polymorphic arguments,
 * but we do it anyway to be sure.
 *
 * Note: if any casts are needed, the args list is modified in-place;
 * caller should have already copied the list structure.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>recheck_cast_function_args</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>actual_arg_types</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>declared_arg_types</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many function arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>actual_arg_types</name><index>[<expr><name>nargs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>declared_arg_types</name></expr></argument>, <argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></argument>,
		   <argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rettype</name> <operator>=</operator> <call><name>enforce_generic_type_consistency</name><argument_list>(<argument><expr><name>actual_arg_types</name></expr></argument>,
											   <argument><expr><name>declared_arg_types</name></expr></argument>,
											   <argument><expr><name>nargs</name></expr></argument>,
											   <argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* let's just check we got the same answer as the parser did ... */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>!=</operator> <name>result_type</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function's resolved result type changed during planning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* perform any necessary typecasting of arguments */</comment>
	<expr_stmt><expr><call><name>make_fn_arguments</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>actual_arg_types</name></expr></argument>, <argument><expr><name>declared_arg_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * large_const: check if given expression is a Const expression larger than
 * the given size
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>large_const</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>max_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>expr</name> <operator>||</operator> <literal type="number">0</literal> <operator>==</operator> <name>max_size</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_expr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>const_expr</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><call><name>datumGetSize</name><argument_list>(<argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>, <argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>size</name> <operator>&gt;</operator> <name>max_size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * evaluate_function: try to pre-evaluate a function call
 *
 * We can do this if the function is strict and has any constant-null inputs
 * (just return a null constant), or if the function is immutable and has all
 * constant inputs (call it and return the result as a Const node).  In
 * estimation mode we are willing to pre-evaluate stable functions too.
 *
 * Returns a simplified expression if successful, or NULL if cannot
 * simplify the function.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>evaluate_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>result_typmod</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>result_collid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>input_collid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>funcvariadic</name></decl></parameter>,
				  <parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>,
				  <parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_nonconst_input</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_null_input</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Can't simplify if it returns a set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>proretset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't simplify if it returns RECORD.  The immediate problem is that it
	 * will be needing an expected tupdesc which we can't supply here.
	 *
	 * In the case where it has OUT parameters, it could get by without an
	 * expected tupdesc, but we still have issues: get_expr_result_type()
	 * doesn't know how to extract type info from a RECORD constant, and in
	 * the case of a NULL function result there doesn't seem to be any clean
	 * way to fix that.  In view of the likelihood of there being still other
	 * gotchas, seems best to leave the function call unreduced.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for constant inputs and especially constant-NULL inputs.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>has_null_input</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>has_nonconst_input</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If the function is strict and has a constant-NULL input, it will never
	 * be called at all, so we can replace the call by a NULL constant, even
	 * if there are other inputs that aren't constant, and even if the
	 * function is not otherwise immutable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>proisstrict</name></name> <operator>&amp;&amp;</operator> <name>has_null_input</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>result_typmod</name></expr></argument>,
									  <argument><expr><name>result_collid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, can simplify only if all inputs are constants. (For a
	 * non-strict function, constant NULL inputs are treated the same as
	 * constant non-NULL inputs.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_nonconst_input</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ordinarily we are only allowed to simplify immutable functions. But for
	 * purposes of estimation, we consider it okay to simplify functions that
	 * are merely stable; the risk that the result might change from planning
	 * time to execution time is worth taking in preference to not being able
	 * to estimate the value at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>estimate</name></name> <operator>&amp;&amp;</operator> <name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>eval_stable_functions</name></name> <operator>&amp;&amp;</operator> <name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* okay, but we cannot reuse this plan */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>oneoffPlan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * OK, looks like we can simplify this operator/function.
	 *
	 * Build a new FuncExpr node containing the already-simplified arguments.
	 */</comment>
	<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name>result_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>funcvariadic</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CALL</name></expr>;</expr_stmt> <comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name>result_collid</name></expr>;</expr_stmt>	<comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name>input_collid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>evaluate_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr></argument>, <argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>result_typmod</name></expr></argument>,
						 <argument><expr><name>result_collid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * inline_function: try to expand a function call inline
 *
 * If the function is a sufficiently simple SQL-language function
 * (just "SELECT expression"), then we can inline it and avoid the rather
 * high per-call overhead of SQL functions.  Furthermore, this can expose
 * opportunities for constant-folding within the function expression.
 *
 * We have to beware of some special cases however.  A directly or
 * indirectly recursive function would cause us to recurse forever,
 * so we keep track of which functions we are already expanding and
 * do not re-expand them.  Also, if a parameter is used more than once
 * in the SQL-function body, we require it not to contain any volatile
 * functions (volatiles might deliver inconsistent answers) nor to be
 * unreasonably expensive to evaluate.  The expensiveness check not only
 * prevents us from doing multiple evaluations of an expensive parameter
 * at runtime, but is a safety value to limit growth of an expression due
 * to repeated inlining.
 *
 * We must also beware of changing the volatility or strictness status of
 * functions by inlining them.
 *
 * Also, at the moment we can't inline functions returning RECORD.  This
 * doesn't work in the general case because it discards information such
 * as OUT-parameter declarations.
 *
 * Also, context-dependent expression nodes in the argument list are trouble.
 *
 * Returns a simplified expression if successful, or NULL if cannot
 * simplify the function.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>inline_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_collid</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>input_collid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>funcvariadic</name></decl></parameter>,
				<parameter><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl></parameter>,
				<parameter><decl><type><name>eval_const_expressions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>modifyTargetList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mycxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>inline_error_callback_arg</name></type> <name>callback_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>sqlerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>querytree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>usecounts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Forget it if the function is not SQL-language or has other showstopper
	 * properties.  (The prokind and nargs checks are just paranoia.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>prolang</name></name> <operator>!=</operator> <name>SQLlanguageId</name> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>prokind</name></name> <operator>!=</operator> <name>PROKIND_FUNCTION</name> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>prosecdef</name></name> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>proretset</name></name> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator>
		<operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proconfig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check for recursive function, and give up trying to expand if so */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>active_fns</name></name></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check permission to call function (fail later, if not) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check whether a plugin wants to hook function entry/exit */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FmgrHookIsNeeded</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make a temporary memory context, so that we don't leak all the stuff
	 * that parsing might create.
	 */</comment>
	<expr_stmt><expr><name>mycxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"inline_function"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch the function body */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
						  <argument><expr><name>func_tuple</name></expr></argument>,
						  <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport().  This is so that we can
	 * finger the function that bad information came from.
	 */</comment>
	<expr_stmt><expr><name><name>callback_arg</name><operator>.</operator><name>proname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>callback_arg</name><operator>.</operator><name>prosrc</name></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>sql_inline_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>callback_arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>sqlerrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up to handle parameters while parsing the function body.  We need a
	 * dummy FuncExpr node containing the already-simplified arguments to pass
	 * to prepare_sql_fn_parse_info.  (It is really only needed if there are
	 * some polymorphic arguments, but for simplicity we always build it.)
	 */</comment>
	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name>result_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>funcvariadic</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CALL</name></expr>;</expr_stmt>	<comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name>result_collid</name></expr>;</expr_stmt>	<comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name>input_collid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>pinfo</name> <operator>=</operator> <call><name>prepare_sql_fn_parse_info</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr></argument>,
									  <argument><expr><name>input_collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We just do parsing and parse analysis, not rewriting, because rewriting
	 * will not affect table-free-SELECT-only queries, which is all that we
	 * care about.  Also, we can punt as soon as we detect more than one
	 * command in the function body.
	 */</comment>
	<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sql_fn_parser_setup</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>querytree</name> <operator>=</operator> <call><name>transformTopLevelStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The single command must be a simple "SELECT expression".
	 *
	 * Note: if you change the tests involved in this, see also plpgsql's
	 * exec_simple_check_plan().  That generally needs to have the same idea
	 * of what's a "simple expression", so that inlining a function that
	 * previously wasn't inlined won't change plpgsql's conclusion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>querytree</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>cteList</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>rtable</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>querytree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure the function (still) returns what it's declared to.  This
	 * will raise an error if wrong, but that's okay since the function would
	 * fail at runtime anyway.  Note that check_sql_fn_retval will also insert
	 * a RelabelType if needed to make the tlist expression match the declared
	 * type of the function.
	 *
	 * Note: we do not try this until we have verified that no rewriting was
	 * needed; that's probably not important, but let's be careful.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_sql_fn_retval</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><name>result_type</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>querytree</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>modifyTargetList</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* reject whole-tuple-result cases */</comment>

	<comment type="block">/* Now we can grab the tlist expression */</comment>
	<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>querytree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the SQL function returns VOID, we can only inline it if it is a
	 * SELECT of an expression returning VOID (ie, it's just a redirection to
	 * another VOID-returning function).  In all non-VOID-returning cases,
	 * check_sql_fn_retval should ensure that newexpr returns the function's
	 * declared result type, so this test shouldn't fail otherwise; but we may
	 * as well cope gracefully if it does.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>newexpr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>result_type</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* check_sql_fn_retval couldn't have made any dangerous tlist changes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>modifyTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Additional validity checks on the expression.  It mustn't be more
	 * volatile than the surrounding function (this is to avoid breaking hacks
	 * that involve pretending a function is immutable when it really ain't).
	 * If the surrounding function is declared strict, then the expression
	 * must contain only strict constructs and must use all of the function
	 * parameters (this is overkill, but an exact analysis is hard).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name> <operator>&amp;&amp;</operator>
		<call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>newexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_STABLE</name> <operator>&amp;&amp;</operator>
			 <call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>newexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>proisstrict</name></name> <operator>&amp;&amp;</operator>
		<call><name>contain_nonstrict_functions</name><argument_list>(<argument><expr><name>newexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If any parameter expression contains a context-dependent node, we can't
	 * inline, for fear of putting such a node into the wrong context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_context_dependent_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We may be able to do it; there are still checks on parameter usage to
	 * make, but those are most easily done in combination with the actual
	 * substitution of the inputs.  So start building expression with inputs
	 * substituted.
	 */</comment>
	<expr_stmt><expr><name>usecounts</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>substitute_actual_parameters</name><argument_list>(<argument><expr><name>newexpr</name></expr></argument>, <argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>,
										   <argument><expr><name>args</name></expr></argument>, <argument><expr><name>usecounts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now check for parameter usage */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>usecounts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Param not used at all: uncool if func is strict */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>proisstrict</name></name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>usecounts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Param used multiple times: uncool if expensive or volatile */</comment>
			<decl_stmt><decl><type><name>QualCost</name></type>	<name>eval_cost</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We define "expensive" as "contains any subplan or more than 10
			 * operators".  Note that the subplan search has to be done
			 * explicitly, since cost_qual_eval() will barf on unplanned
			 * subselects.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_subplans</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eval_cost</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>eval_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>eval_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>&gt;</operator>
				<literal type="number">10</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check volatility last since this is more expensive than the
			 * above tests
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Whew --- we can make the substitution.  Copy the modified expression
	 * out of the temporary memory context, and clean up.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>newexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>mycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the result is of a collatable type, force the result to expose the
	 * correct collation.  In most cases this does not matter, but it's
	 * possible that the function result is used directly as a sort key or in
	 * other places where we expect exprCollation() to tell the truth.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result_collid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>exprcoll</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>newexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>exprcoll</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>exprcoll</name> <operator>!=</operator> <name>result_collid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>newnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name>result_collid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since there is now no trace of the function in the plan tree, we must
	 * explicitly record the plan's dependency on the function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>record_plan_function_dependency</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Recursively try to simplify the modified expression.  Here we must add
	 * the current function to the context list of active functions.
	 */</comment>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>active_fns</name></name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>active_fns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>eval_const_expressions_mutator</name><argument_list>(<argument><expr><name>newexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>active_fns</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>active_fns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>

	<comment type="block">/* Here if func is not inlinable: release temp memory and return NULL */</comment>
<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>mycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replace Param nodes by appropriate actual parameters
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>substitute_actual_parameters</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>usecounts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>substitute_actual_parameters_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>usecounts</name></name> <operator>=</operator> <name>usecounts</name></expr>;</expr_stmt>

	<return>return <expr><call><name>substitute_actual_parameters_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>substitute_actual_parameters_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									 <parameter><decl><type><name>substitute_actual_parameters_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>!=</operator> <name>PARAM_EXTERN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected paramkind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>nargs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid paramid: %d"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Count usage of parameter */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>usecounts</name><index>[<expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Select the appropriate actual arg and replace the Param with it */</comment>
		<comment type="block">/* We don't need to copy at this time (it'll get done later) */</comment>
		<return>return <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>substitute_actual_parameters_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * error context callback to let us supply a call-stack traceback
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sql_inline_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>inline_error_callback_arg</name> <modifier>*</modifier></type><name>callback_arg</name> <init>= <expr><operator>(</operator><name>inline_error_callback_arg</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>syntaxerrposition</name></decl>;</decl_stmt>

	<comment type="block">/* If it's a syntax error, convert to internal syntax error report */</comment>
	<expr_stmt><expr><name>syntaxerrposition</name> <operator>=</operator> <call><name>geterrposition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>syntaxerrposition</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>errposition</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrposition</name><argument_list>(<argument><expr><name>syntaxerrposition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrquery</name><argument_list>(<argument><expr><name><name>callback_arg</name><operator>-&gt;</operator><name>prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL function \"%s\" during inlining"</literal></expr></argument>, <argument><expr><name><name>callback_arg</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * evaluate_expr: pre-evaluate a constant expression
 *
 * We use the executor's routine ExecEvalExpr() to avoid duplication of
 * code and ensure we get the same result as the executor would get.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>evaluate_expr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>result_typmod</name></decl></parameter>,
			  <parameter><decl><type><name>Oid</name></type> <name>result_collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>const_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>const_is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>resultTypLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resultTypByVal</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To use the executor, we need an EState.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can use the estate's working context to avoid memory leaks. */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure any opfuncids are filled in. */</comment>
	<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare expr for execution.  (Note: we can't use ExecPrepareExpr
	 * because it'd result in recursively invoking eval_const_expressions.)
	 */</comment>
	<expr_stmt><expr><name>exprstate</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And evaluate it.
	 *
	 * It is OK to use a default econtext because none of the ExecEvalExpr()
	 * code used in this situation will use econtext.  That might seem
	 * fortuitous, but it's not so unreasonable --- a constant expression does
	 * not depend on context, by definition, n'est ce pas?
	 */</comment>
	<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>,
										  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>const_is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get info needed about result datatype */</comment>
	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>result_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get back to outer memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must copy result out of sub-context used by expression eval.
	 *
	 * Also, if it's varlena, forcibly detoast it.  This protects us against
	 * storing TOAST pointers into plans that might outlive the referenced
	 * data.  (makeConst would handle detoasting anyway, but it's worth a few
	 * extra lines here so that we can do the copy and detoast in one step.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>const_is_null</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>resultTypLen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM_COPY</name><argument_list>(<argument><expr><name>const_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>const_val</name></expr></argument>, <argument><expr><name>resultTypByVal</name></expr></argument>, <argument><expr><name>resultTypLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release all the junk we just created */</comment>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the constant result node.
	 */</comment>
	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>result_typmod</name></expr></argument>, <argument><expr><name>result_collation</name></expr></argument>,
							  <argument><expr><name>resultTypLen</name></expr></argument>,
							  <argument><expr><name>const_val</name></expr></argument>, <argument><expr><name>const_is_null</name></expr></argument>,
							  <argument><expr><name>resultTypByVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * inline_set_returning_function
 *		Attempt to "inline" a set-returning function in the FROM clause.
 *
 * "rte" is an RTE_FUNCTION rangetable entry.  If it represents a call of a
 * set-returning SQL function that can safely be inlined, expand the function
 * and return the substitute Query structure.  Otherwise, return NULL.
 *
 * This has a good deal of similarity to inline_function(), but that's
 * for the non-set-returning case, and there are enough differences to
 * justify separate functions.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>inline_set_returning_function</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>func_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>func_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>modifyTargetList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mycxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>saveInvalItems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>inline_error_callback_arg</name></type> <name>callback_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>sqlerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>querytree</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It doesn't make a lot of sense for a SQL SRF to refer to itself in its
	 * own FROM clause, since that must cause infinite recursion at runtime.
	 * It will cause this code to recurse too, so check for stack overflow.
	 * (There's no need to do more.)
	 */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fail if the RTE has ORDINALITY - we don't implement that here. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Fail if RTE isn't a single, simple FuncExpr */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rtfunc</name> <operator>=</operator> <operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>func_oid</name> <operator>=</operator> <name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The function must be declared to return a set, else inlining would
	 * change the results if the contained SELECT didn't return exactly one
	 * row.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fexpr</name><operator>-&gt;</operator><name>funcretset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Refuse to inline if the arguments contain any volatile functions or
	 * sub-selects.  Volatile functions are rejected because inlining may
	 * result in the arguments being evaluated multiple times, risking a
	 * change in behavior.  Sub-selects are rejected partly for implementation
	 * reasons (pushing them down another level might change their behavior)
	 * and partly because they're likely to be expensive and so multiple
	 * evaluation would be bad.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>contain_subplans</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check permission to call function (fail later, if not) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check whether a plugin wants to hook function entry/exit */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FmgrHookIsNeeded</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * OK, let's take a look at the function's pg_proc entry.
	 */</comment>
	<expr_stmt><expr><name>func_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>funcform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Forget it if the function is not SQL-language or has other showstopper
	 * properties.  In particular it mustn't be declared STRICT, since we
	 * couldn't enforce that.  It also mustn't be VOLATILE, because that is
	 * supposed to cause it to be executed with its own snapshot, rather than
	 * sharing the snapshot of the calling query.  We also disallow returning
	 * SETOF VOID, because inlining would result in exposing the actual result
	 * of the function's last SELECT, which should not happen in that case.
	 * (Rechecking prokind and proretset is just paranoia.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>prolang</name></name> <operator>!=</operator> <name>SQLlanguageId</name> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>prokind</name></name> <operator>!=</operator> <name>PROKIND_FUNCTION</name> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>proisstrict</name></name> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>==</operator> <name>VOIDOID</name> <operator>||</operator>
		<name><name>funcform</name><operator>-&gt;</operator><name>prosecdef</name></name> <operator>||</operator>
		<operator>!</operator><name><name>funcform</name><operator>-&gt;</operator><name>proretset</name></name> <operator>||</operator>
		<operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proconfig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make a temporary memory context, so that we don't leak all the stuff
	 * that parsing might create.
	 */</comment>
	<expr_stmt><expr><name>mycxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"inline_set_returning_function"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When we call eval_const_expressions below, it might try to add items to
	 * root-&gt;glob-&gt;invalItems.  Since it is running in the temp context, those
	 * items will be in that context, and will need to be copied out if we're
	 * successful.  Temporarily reset the list so that we can keep those items
	 * separate from the pre-existing list contents.
	 */</comment>
	<expr_stmt><expr><name>saveInvalItems</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Fetch the function body */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
						  <argument><expr><name>func_tuple</name></expr></argument>,
						  <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc for function %u"</literal></expr></argument>, <argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport().  This is so that we can
	 * finger the function that bad information came from.
	 */</comment>
	<expr_stmt><expr><name><name>callback_arg</name><operator>.</operator><name>proname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>callback_arg</name><operator>.</operator><name>prosrc</name></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>sql_inline_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>callback_arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>sqlerrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run eval_const_expressions on the function call.  This is necessary to
	 * ensure that named-argument notation is converted to positional notation
	 * and any default arguments are inserted.  It's a bit of overkill for the
	 * arguments, since they'll get processed again later, but no harm will be
	 * done.
	 */</comment>
	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It should still be a call of the same function, but let's check */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>!=</operator> <name>func_oid</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Arg list length should now match the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up to handle parameters while parsing the function body.  We can
	 * use the FuncExpr just created as the input for
	 * prepare_sql_fn_parse_info.
	 */</comment>
	<expr_stmt><expr><name>pinfo</name> <operator>=</operator> <call><name>prepare_sql_fn_parse_info</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr></argument>,
									  <argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse, analyze, and rewrite (unlike inline_function(), we can't skip
	 * rewriting here).  We can fail as soon as we find more than one query,
	 * though.
	 */</comment>
	<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite_params</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>src</name></expr></argument>,
												   <argument><expr><operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>sql_fn_parser_setup</name></expr></argument>,
												   <argument><expr><name>pinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>querytree</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The single command must be a plain SELECT.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>querytree</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>querytree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure the function (still) returns what it's declared to.  This
	 * will raise an error if wrong, but that's okay since the function would
	 * fail at runtime anyway.  Note that check_sql_fn_retval will also insert
	 * RelabelType(s) and/or NULL columns if needed to make the tlist
	 * expression(s) match the declared type of the function.
	 *
	 * If the function returns a composite type, don't inline unless the check
	 * shows it's returning a whole tuple result; otherwise what it's
	 * returning is a single composite column which is not what we need. (Like
	 * check_sql_fn_retval, we deliberately exclude domains over composite
	 * here.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_sql_fn_retval</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>,
							 <argument><expr><name>querytree_list</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>modifyTargetList</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>get_typtype</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>||</operator>
		 <name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>==</operator> <name>RECORDOID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* reject not-whole-tuple-result cases */</comment>

	<comment type="block">/*
	 * If we had to modify the tlist to make it match, and the statement is
	 * one in which changing the tlist contents could change semantics, we
	 * have to punt and not inline.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>modifyTargetList</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it returns RECORD, we have to check against the column type list
	 * provided in the RTE; check_sql_fn_retval can't do that.  (If no match,
	 * we just fail to inline, rather than complaining; see notes for
	 * tlist_matches_coltypelist.)	We don't have to do this for functions
	 * with declared OUT parameters, even though their funcresulttype is
	 * RECORDOID, so check get_func_result_type too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
		<call><name>get_func_result_type</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPEFUNC_RECORD</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>tlist_matches_coltypelist</name><argument_list>(<argument><expr><name><name>querytree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
								   <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Looks good --- substitute parameters into the query.
	 */</comment>
	<expr_stmt><expr><name>querytree</name> <operator>=</operator> <call><name>substitute_actual_srf_parameters</name><argument_list>(<argument><expr><name>querytree</name></expr></argument>,
												 <argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>,
												 <argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the modified query out of the temporary memory context, and clean
	 * up.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>querytree</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>querytree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy up any new invalItems, too */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>saveInvalItems</name></expr></argument>,
										 <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>mycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't have to fix collations here because the upper query is already
	 * parsed, ie, the collations in the RTE are what count.
	 */</comment>

	<comment type="block">/*
	 * Since there is now no trace of the function in the plan tree, we must
	 * explicitly record the plan's dependency on the function.
	 */</comment>
	<expr_stmt><expr><call><name>record_plan_function_dependency</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>querytree</name></expr>;</return>

	<comment type="block">/* Here if func is not inlinable: release temp memory and return NULL */</comment>
<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>saveInvalItems</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>mycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replace Param nodes by appropriate actual parameters
 *
 * This is just enough different from substitute_actual_parameters()
 * that it needs its own code.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>substitute_actual_srf_parameters</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>substitute_actual_srf_parameters_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>query_tree_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
							  <argument><expr><name>substitute_actual_srf_parameters_mutator</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>substitute_actual_srf_parameters_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										 <parameter><decl><type><name>substitute_actual_srf_parameters_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
											 <argument><expr><name>substitute_actual_srf_parameters_mutator</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
											 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXTERN</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>nargs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid paramid: %d"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Since the parameter is being inserted into a subquery, we must
			 * adjust levels.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								   <argument><expr><name>substitute_actual_srf_parameters_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * flatten_join_alias_var_optimizer
 *	  Replace Vars that reference JOIN outputs with references to the original
 *	  relation variables instead.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>flatten_join_alias_var_optimizer</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queryLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryNew</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Flatten join alias for expression in
	 * 1. targetlist
	 * 2. returningList
	 * 3. having qual
	 * 4. scatterClause
	 * 5. limit offset
	 * 6. limit count
	 * 
	 * We flatten the above expressions since these entries may be moved during the query 
	 * normalization step before algebrization. In contrast, the planner flattens alias 
	 * inside quals to allow predicates involving such vars to be pushed down. 
	 * 
	 * Here we ignore the flattening of quals due to the following reasons:
	 * 1. we assume that the function will be called before Query-&gt;DXL translation:
	 * 2. the quals never gets moved from old query to the new top-level query in the 
	 * query normalization phase before algebrization. In other words, the quals hang of 
	 * the same query structure that is now the new derived table.
	 * 3. the algebrizer can resolve the abiquity of join aliases in quals since we maintain 
	 * all combinations of &lt;query level, varno, varattno&gt; to DXL-ColId during Query-&gt;DXL translation.
	 * 
	 */</comment>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name><name>queryNew</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>targetList</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryNew</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>queryNew</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>returningList</name> <init>= <expr><name><name>queryNew</name><operator>-&gt;</operator><name>returningList</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>returningList</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryNew</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>queryNew</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name> <init>= <expr><name><name>queryNew</name><operator>-&gt;</operator><name>havingQual</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>havingQual</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryNew</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>queryNew</name></expr></argument>, <argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>scatterClause</name> <init>= <expr><name><name>queryNew</name><operator>-&gt;</operator><name>scatterClause</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>scatterClause</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryNew</name><operator>-&gt;</operator><name>scatterClause</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>queryNew</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scatterClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scatterClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name> <init>= <expr><name><name>queryNew</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>limitOffset</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryNew</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>queryNew</name></expr></argument>, <argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>windowClause</name> <init>= <expr><name><name>queryNew</name><operator>-&gt;</operator><name>windowClause</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name><name>queryNew</name><operator>-&gt;</operator><name>windowClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>windowClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>wc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>queryNew</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>queryNew</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name> <init>= <expr><name><name>queryNew</name><operator>-&gt;</operator><name>limitCount</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>limitCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryNew</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>queryNew</name></expr></argument>, <argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><name>queryNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Structs and Methods to support searching of matching subexpressions.
 */</comment>

<typedef>typedef <type><struct>struct <name>subexpression_matching_context</name>
<block>{
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>needle</name></decl>;</decl_stmt>	<comment type="block">/* This is the expression being searched */</comment>
}</block></struct></type> <name>subexpression_matching_context</name>;</typedef>

<comment type="block" format="doxygen">/**
 * expression_matching_walker checks if the expression 'needle' in context is a sub-expression of hayStack.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>subexpression_matching_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>hayStack</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>subexpression_matching_context</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>subexpression_matching_context</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>needle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hayStack</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>needle</name></name></expr></argument>, <argument><expr><name>hayStack</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>hayStack</name></expr></argument>, <argument><expr><name>subexpression_matching_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Method checks if expr1 is a subexpression of expr2.
 * For example, expr1 = (x + 2) and expr = (x + 2 ) * 100 + 20 would return true.
 */</comment>
<function><type><name>bool</name></type> <name>subexpression_match</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>subexpression_matching_context</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>needle</name></name> <operator>=</operator> <name>expr1</name></expr>;</expr_stmt>
	<return>return <expr><call><name>subexpression_matching_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr2</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether a SELECT targetlist emits the specified column types,
 * to see if it's safe to inline a function returning record.
 *
 * We insist on exact match here.  The executor allows binary-coercible
 * cases too, but we don't have a way to preserve the correct column types
 * in the correct places if we inline the function in such a case.
 *
 * Note that we only check type OIDs not typmods; this agrees with what the
 * executor would do at runtime, and attributing a specific typmod to a
 * function result is largely wishful thinking anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tlist_matches_coltypelist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>coltypelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlistitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>clistitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>clistitem</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>coltypelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>tlistitem</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlistitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>coltype</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk columns */</comment>

		<if_stmt><if>if <condition>(<expr><name>clistitem</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* too many tlist items */</comment>

		<expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>clistitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>clistitem</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>clistitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>coltype</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* column type mismatch */</comment>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>clistitem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* too few tlist items */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If this expression is part of a query, and the query isn't a simple
 * "SELECT foo()" style query with no actual tables involved, then we
 * also aggressively evaluate stable functions, in addition to immutable
 * ones. Such plans cannot be reused, and therefore need to be re-planned
 * on every execution, but it can be a big win if it allows partition
 * elimination to happen. That's considered a good tradeoff in GPDB, as
 * typical queries are long-running.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_eval_stable_functions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Without PlannerGlobal, we cannot mark the plan as a `oneoffPlan`
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the query has no range table, then there is no reason to need to
	 * pre-evaluate stable functions, as the output cannot be used as part
	 * of static partition elimination, unless the query is part of a
	 * subquery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>rtable_num_total</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* RTE_RESULT is a dummy RTE generated by empty from clause */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RESULT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rtable_num_total</name> <operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>rtable_num_total</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_leftscalararrayop
 *
 * Returns the left operand of a clause of the form (scalar op ANY/ALL (array))
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>get_leftscalararrayop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rightscalararrayop
 *
 * Returns the right operand in a clause of the form (scalar op ANY/ALL (array)).
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>get_rightscalararrayop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
