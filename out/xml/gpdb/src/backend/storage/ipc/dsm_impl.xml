<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/storage/ipc/dsm_impl.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * dsm_impl.c
 *	  manage dynamic shared memory segments
 *
 * This file provides low-level APIs for creating and destroying shared
 * memory segments using several different possible techniques.  We refer
 * to these segments as dynamic because they can be created, altered, and
 * destroyed at any point during the server life cycle.  This is unlike
 * the main shared memory segment, of which there is always exactly one
 * and which is always mapped at a fixed address in every PostgreSQL
 * background process.
 *
 * Because not all systems provide the same primitives in this area, nor
 * do all primitives behave the same way on all systems, we provide
 * several implementations of this facility.  Many systems implement
 * POSIX shared memory (shm_open etc.), which is well-suited to our needs
 * in this area, with the exception that shared memory identifiers live
 * in a flat system-wide namespace, raising the uncomfortable prospect of
 * name collisions with other processes (including other copies of
 * PostgreSQL) running on the same system.  Some systems only support
 * the older System V shared memory interface (shmget etc.) which is
 * also usable; however, the default allocation limits are often quite
 * small, and the namespace is even more restricted.
 *
 * We also provide an mmap-based shared memory implementation.  This may
 * be useful on systems that provide shared memory via a special-purpose
 * filesystem; by opting for this implementation, the user can even
 * control precisely where their shared memory segments are placed.  It
 * can also be used as a fallback for systems where shm_open and shmget
 * are not available or can't be used for some reason.  Of course,
 * mapping a file residing on an actual spinning disk is a fairly poor
 * approximation for shared memory because writeback may hurt performance
 * substantially, but there should be few systems where we must make do
 * with such poor tools.
 *
 * As ever, Windows requires its own implementation.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/ipc/dsm_impl.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_IPC_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ipc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SHM_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/shm.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_POSIX</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dsm_impl_posix</name><parameter_list>(<parameter><decl><type><name>dsm_op</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>request_size</name></decl></parameter>,
						   <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapped_address</name></decl></parameter>,
						   <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>mapped_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>dsm_impl_posix_resize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_SYSV</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dsm_impl_sysv</name><parameter_list>(<parameter><decl><type><name>dsm_op</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>request_size</name></decl></parameter>,
						  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapped_address</name></decl></parameter>,
						  <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>mapped_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_WINDOWS</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dsm_impl_windows</name><parameter_list>(<parameter><decl><type><name>dsm_op</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>request_size</name></decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapped_address</name></decl></parameter>,
							 <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>mapped_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_MMAP</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dsm_impl_mmap</name><parameter_list>(<parameter><decl><type><name>dsm_op</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>request_size</name></decl></parameter>,
						  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapped_address</name></decl></parameter>,
						  <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>mapped_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>errcode_for_dynamic_shared_memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>dynamic_shared_memory_options</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_POSIX</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"posix"</literal></expr>, <expr><name>DSM_IMPL_POSIX</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_SYSV</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"sysv"</literal></expr>, <expr><name>DSM_IMPL_SYSV</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_WINDOWS</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"windows"</literal></expr>, <expr><name>DSM_IMPL_WINDOWS</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_MMAP</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"mmap"</literal></expr>, <expr><name>DSM_IMPL_MMAP</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Implementation selector. */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>dynamic_shared_memory_type</name></decl>;</decl_stmt>

<comment type="block">/* Size of buffer to be used for zero-filling. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZBUFFER_SIZE</name></cpp:macro>				<cpp:value>8192</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_NAME_PREFIX</name></cpp:macro>			<cpp:value>"Global/PostgreSQL"</cpp:value></cpp:define>

<comment type="block">/*------
 * Perform a low-level shared memory operation in a platform-specific way,
 * as dictated by the selected implementation.  Each implementation is
 * required to implement the following primitives.
 *
 * DSM_OP_CREATE.  Create a segment whose size is the request_size and
 * map it.
 *
 * DSM_OP_ATTACH.  Map the segment, whose size must be the request_size.
 *
 * DSM_OP_DETACH.  Unmap the segment.
 *
 * DSM_OP_DESTROY.  Unmap the segment, if it is mapped.  Destroy the
 * segment.
 *
 * Arguments:
 *	 op: The operation to be performed.
 *	 handle: The handle of an existing object, or for DSM_OP_CREATE, the
 *	   a new handle the caller wants created.
 *	 request_size: For DSM_OP_CREATE, the requested size.  Otherwise, 0.
 *	 impl_private: Private, implementation-specific data.  Will be a pointer
 *	   to NULL for the first operation on a shared memory segment within this
 *	   backend; thereafter, it will point to the value to which it was set
 *	   on the previous call.
 *	 mapped_address: Pointer to start of current mapping; pointer to NULL
 *	   if none.  Updated with new mapping address.
 *	 mapped_size: Pointer to size of current mapping; pointer to 0 if none.
 *	   Updated with new mapped size.
 *	 elevel: Level at which to log errors.
 *
 * Return value: true on success, false on failure.  When false is returned,
 * a message should first be logged at the specified elevel, except in the
 * case where DSM_OP_CREATE experiences a name collision, which should
 * silently return false.
 *-----
 */</comment>
<function><type><name>bool</name></type>
<name>dsm_impl_op</name><parameter_list>(<parameter><decl><type><name>dsm_op</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>request_size</name></decl></parameter>,
			<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapped_address</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>mapped_size</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>DSM_OP_CREATE</name> <operator>||</operator> <name>request_size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>op</name> <operator>!=</operator> <name>DSM_OP_CREATE</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>!=</operator> <name>DSM_OP_ATTACH</name><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><operator>*</operator><name>mapped_address</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>mapped_size</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>dynamic_shared_memory_type</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_POSIX</name></cpp:ifdef>
		<case>case <expr><name>DSM_IMPL_POSIX</name></expr>:</case>
			<return>return <expr><call><name>dsm_impl_posix</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>, <argument><expr><name>impl_private</name></expr></argument>,
								  <argument><expr><name>mapped_address</name></expr></argument>, <argument><expr><name>mapped_size</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_SYSV</name></cpp:ifdef>
		<case>case <expr><name>DSM_IMPL_SYSV</name></expr>:</case>
			<return>return <expr><call><name>dsm_impl_sysv</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>, <argument><expr><name>impl_private</name></expr></argument>,
								 <argument><expr><name>mapped_address</name></expr></argument>, <argument><expr><name>mapped_size</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_WINDOWS</name></cpp:ifdef>
		<case>case <expr><name>DSM_IMPL_WINDOWS</name></expr>:</case>
			<return>return <expr><call><name>dsm_impl_windows</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>, <argument><expr><name>impl_private</name></expr></argument>,
									<argument><expr><name>mapped_address</name></expr></argument>, <argument><expr><name>mapped_size</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_MMAP</name></cpp:ifdef>
		<case>case <expr><name>DSM_IMPL_MMAP</name></expr>:</case>
			<return>return <expr><call><name>dsm_impl_mmap</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>, <argument><expr><name>impl_private</name></expr></argument>,
								 <argument><expr><name>mapped_address</name></expr></argument>, <argument><expr><name>mapped_size</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected dynamic shared memory type: %d"</literal></expr></argument>,
				 <argument><expr><name>dynamic_shared_memory_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_POSIX</name></cpp:ifdef>
<comment type="block">/*
 * Operating system primitives to support POSIX shared memory.
 *
 * POSIX shared memory segments are created and attached using shm_open()
 * and shm_unlink(); other operations, such as sizing or mapping the
 * segment, are performed as if the shared memory segments were files.
 *
 * Indeed, on some platforms, they may be implemented that way.  While
 * POSIX shared memory segments seem intended to exist in a flat namespace,
 * some operating systems may implement them as files, even going so far
 * to treat a request for /xyz as a request to create a file by that name
 * in the root directory.  Users of such broken platforms should select
 * a different shared memory implementation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dsm_impl_posix</name><parameter_list>(<parameter><decl><type><name>dsm_op</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>request_size</name></decl></parameter>,
			   <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapped_address</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>mapped_size</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"/PostgreSQL.%u"</literal></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle teardown cases. */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_DETACH</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>DSM_OP_DESTROY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>mapped_address</name> <operator>!=</operator> <name>NULL</name>
			<operator>&amp;&amp;</operator> <call><name>munmap</name><argument_list>(<argument><expr><operator>*</operator><name>mapped_address</name></expr></argument>, <argument><expr><operator>*</operator><name>mapped_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not unmap shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>mapped_address</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>mapped_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_DESTROY</name> <operator>&amp;&amp;</operator> <call><name>shm_unlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create new segment or open an existing one for attach.
	 *
	 * Even though we're not going through fd.c, we should be safe against
	 * running out of file descriptors, because of NUM_RESERVED_FDS.  We're
	 * only opening one extra descriptor here, and we'll close it before
	 * returning.
	 */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>O_RDWR</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>op</name> <operator>==</operator> <name>DSM_OP_CREATE</name></expr> ?</condition><then> <expr><name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>shm_open</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>PG_FILE_MODE_OWNER</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're attaching the segment, determine the current size; if we are
	 * creating the segment, set the size to the requested value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_ATTACH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

			<comment type="block">/* Back out what's already been done. */</comment>
			<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>request_size</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>dsm_impl_posix_resize</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

		<comment type="block">/* Back out what's already been done. */</comment>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_unlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we received a query cancel or termination signal, we will have
		 * EINTR set here.  If the caller said that errors are OK here, check
		 * for interrupts immediately.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name> <operator>&amp;&amp;</operator> <name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not resize shared memory segment \"%s\" to %zu bytes: %m"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Map it. */</comment>
	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>, <argument><expr><name>PROT_READ</name> <operator>|</operator> <name>PROT_WRITE</name></expr></argument>,
				   <argument><expr><name>MAP_SHARED</name> <operator>|</operator> <name>MAP_HASSEMAPHORE</name> <operator>|</operator> <name>MAP_NOSYNC</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>address</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

		<comment type="block">/* Back out what's already been done. */</comment>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_CREATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shm_unlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not map shared memory segment \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>mapped_address</name> <operator>=</operator> <name>address</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>mapped_size</name> <operator>=</operator> <name>request_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the size of a virtual memory region associated with a file descriptor.
 * If necessary, also ensure that virtual memory is actually allocated by the
 * operating system, to avoid nasty surprises later.
 *
 * Returns non-zero if either truncation or allocation fails, and sets errno.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dsm_impl_posix_resize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* Truncate (or extend) the file to the requested size. */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * On Linux, a shm_open fd is backed by a tmpfs file.  After resizing with
	 * ftruncate, the file may contain a hole.  Accessing memory backed by a
	 * hole causes tmpfs to allocate pages, which fails with SIGBUS if there
	 * is no more tmpfs space available.  So we ask tmpfs to allocate pages
	 * here, so we can fail gracefully with ENOSPC now rather than risking
	 * SIGBUS later.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POSIX_FALLOCATE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We may get interrupted.  If so, just retry unless there is an
		 * interrupt pending.  This avoids the possibility of looping forever
		 * if another backend is repeatedly trying to interrupt us.
		 */</comment>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>posix_fallocate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>rc</name> <operator>==</operator> <name>EINTR</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>ProcDiePending</name> <operator>||</operator> <name>QueryCancelPending</name><operator>)</operator></expr>)</condition>;</do>

		<comment type="block">/*
		 * The caller expects errno to be set, but posix_fallocate() doesn't
		 * set it.  Instead it returns error numbers directly.  So set errno,
		 * even though we'll also return rc to indicate success or failure.
		 */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_POSIX_FALLOCATE &amp;&amp; __linux__ */</comment>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_DSM_POSIX */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_SYSV</name></cpp:ifdef>
<comment type="block">/*
 * Operating system primitives to support System V shared memory.
 *
 * System V shared memory segments are manipulated using shmget(), shmat(),
 * shmdt(), and shmctl().  As the default allocation limits for System V
 * shared memory are usually quite low, the POSIX facilities may be
 * preferable; but those are not supported everywhere.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dsm_impl_sysv</name><parameter_list>(<parameter><decl><type><name>dsm_op</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>request_size</name></decl></parameter>,
			  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapped_address</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>mapped_size</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>key_t</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ident</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>ident_cache</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * POSIX shared memory and mmap-based shared memory identify segments with
	 * names.  To avoid needless error message variation, we use the handle as
	 * the name.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The System V shared memory namespace is very restricted; names are of
	 * type key_t, which is expected to be some sort of integer data type, but
	 * not necessarily the same one as dsm_handle.  Since we use dsm_handle to
	 * identify shared memory segments across processes, this might seem like
	 * a problem, but it's really not.  If dsm_handle is bigger than key_t,
	 * the cast below might truncate away some bits from the handle the
	 * user-provided, but it'll truncate exactly the same bits away in exactly
	 * the same fashion every time we use that handle, which is all that
	 * really matters.  Conversely, if dsm_handle is smaller than key_t, we
	 * won't use the full range of available key space, but that's no big deal
	 * either.
	 *
	 * We do make sure that the key isn't negative, because that might not be
	 * portable.
	 */</comment>
	<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><name>key_t</name><operator>)</operator> <name>handle</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>key</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* avoid compiler warning if type is unsigned */</comment>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>-</operator><name>key</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * There's one special key, IPC_PRIVATE, which can't be used.  If we end
	 * up with that value by chance during a create operation, just pretend it
	 * already exists, so that caller will retry.  If we run into it anywhere
	 * else, the caller has passed a handle that doesn't correspond to
	 * anything we ever created, which should not happen.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>IPC_PRIVATE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>DSM_OP_CREATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"System V shared memory key may not be IPC_PRIVATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EEXIST</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Before we can do anything with a shared memory segment, we have to map
	 * the shared memory key to a shared memory identifier using shmget(). To
	 * avoid repeated lookups, we store the key using impl_private.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>impl_private</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ident_cache</name> <operator>=</operator> <operator>*</operator><name>impl_private</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ident</name> <operator>=</operator> <operator>*</operator><name>ident_cache</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><name>IPCProtection</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>segsize</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Allocate the memory BEFORE acquiring the resource, so that we don't
		 * leak the resource if memory allocation fails.
		 */</comment>
		<expr_stmt><expr><name>ident_cache</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When using shmget to find an existing segment, we must pass the
		 * size as 0.  Passing a non-zero size which is greater than the
		 * actual size will result in EINVAL.
		 */</comment>
		<expr_stmt><expr><name>segsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_CREATE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>IPC_CREAT</name> <operator>|</operator> <name>IPC_EXCL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>segsize</name> <operator>=</operator> <name>request_size</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ident</name> <operator>=</operator> <call><name>shmget</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ident_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not get shared memory segment: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>ident_cache</name> <operator>=</operator> <name>ident</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>impl_private</name> <operator>=</operator> <name>ident_cache</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Handle teardown cases. */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_DETACH</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>DSM_OP_DESTROY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ident_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>impl_private</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>mapped_address</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>shmdt</name><argument_list>(<argument><expr><operator>*</operator><name>mapped_address</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not unmap shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>mapped_address</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>mapped_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_DESTROY</name> <operator>&amp;&amp;</operator> <call><name>shmctl</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we're attaching it, we must use IPC_STAT to determine the size. */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_ATTACH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>shmid_ds</name></name></type> <name>shm</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>shmctl</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><name>IPC_STAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shm</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>request_size</name> <operator>=</operator> <name><name>shm</name><operator>.</operator><name>shm_segsz</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Map it. */</comment>
	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>shmat</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_SHMAT_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>address</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

		<comment type="block">/* Back out what's already been done. */</comment>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_CREATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shmctl</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not map shared memory segment \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>mapped_address</name> <operator>=</operator> <name>address</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>mapped_size</name> <operator>=</operator> <name>request_size</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_WINDOWS</name></cpp:ifdef>
<comment type="block">/*
 * Operating system primitives to support Windows shared memory.
 *
 * Windows shared memory implementation is done using file mapping
 * which can be backed by either physical file or system paging file.
 * Current implementation uses system paging file as other effects
 * like performance are not clear for physical file and it is used in similar
 * way for main shared memory in windows.
 *
 * A memory mapping object is a kernel object - they always get deleted when
 * the last reference to them goes away, either explicitly via a CloseHandle or
 * when the process containing the reference exits.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dsm_impl_windows</name><parameter_list>(<parameter><decl><type><name>dsm_op</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>request_size</name></decl></parameter>,
				 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapped_address</name></decl></parameter>,
				 <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>mapped_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>hmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MEMORY_BASIC_INFORMATION</name></type> <name>info</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Storing the shared memory segment in the Global\ namespace, can allow
	 * any process running in any session to access that file mapping object
	 * provided that the caller has the required access rights. But to avoid
	 * issues faced in main shared memory, we are using the naming convention
	 * similar to main shared memory. We can change here once issue mentioned
	 * in GetSharedMemName is resolved.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>SEGMENT_NAME_PREFIX</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Handle teardown cases.  Since Windows automatically destroys the object
	 * when no references remain, we can treat it the same as detach.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_DETACH</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>DSM_OP_DESTROY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>mapped_address</name> <operator>!=</operator> <name>NULL</name>
			<operator>&amp;&amp;</operator> <call><name>UnmapViewOfFile</name><argument_list>(<argument><expr><operator>*</operator><name>mapped_address</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not unmap shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>impl_private</name> <operator>!=</operator> <name>NULL</name>
			<operator>&amp;&amp;</operator> <call><name>CloseHandle</name><argument_list>(<argument><expr><operator>*</operator><name>impl_private</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>impl_private</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>mapped_address</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>mapped_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Create new segment or open an existing one for attach. */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_CREATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>size_high</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>size_low</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>errcode</name></decl>;</decl_stmt>

		<comment type="block">/* Shifts &gt;= the width of the type are undefined. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
		<expr_stmt><expr><name>size_high</name> <operator>=</operator> <name>request_size</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>size_high</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>size_low</name> <operator>=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator> <name>request_size</name></expr>;</expr_stmt>

		<comment type="block">/* CreateFileMapping might not clear the error code on success */</comment>
		<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>hmap</name> <operator>=</operator> <call><name>CreateFileMapping</name><argument_list>(<argument><expr><name>INVALID_HANDLE_VALUE</name></expr></argument>,	<comment type="block">/* Use the pagefile */</comment>
								 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* Default security attrs */</comment>
								 <argument><expr><name>PAGE_READWRITE</name></expr></argument>,	<comment type="block">/* Memory is read/write */</comment>
								 <argument><expr><name>size_high</name></expr></argument>, <comment type="block">/* Upper 32 bits of size */</comment>
								 <argument><expr><name>size_low</name></expr></argument>,	<comment type="block">/* Lower 32 bits of size */</comment>
								 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>==</operator> <name>ERROR_ALREADY_EXISTS</name> <operator>||</operator> <name>errcode</name> <operator>==</operator> <name>ERROR_ACCESS_DENIED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * On Windows, when the segment already exists, a handle for the
			 * existing segment is returned.  We must close it before
			 * returning.  However, if the existing segment is created by a
			 * service, then it returns ERROR_ACCESS_DENIED. We don't do
			 * _dosmaperr here, so errno won't be modified.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>hmap</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hmap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>hmap</name> <operator>=</operator> <call><name>OpenFileMapping</name><argument_list>(<argument><expr><name>FILE_MAP_WRITE</name> <operator>|</operator> <name>FILE_MAP_READ</name></expr></argument>,
							   <argument><expr><name>FALSE</name></expr></argument>,	<comment type="block">/* do not inherit the name */</comment>
							   <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* name of mapping object */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hmap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Map it. */</comment>
	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>MapViewOfFile</name><argument_list>(<argument><expr><name>hmap</name></expr></argument>, <argument><expr><name>FILE_MAP_WRITE</name> <operator>|</operator> <name>FILE_MAP_READ</name></expr></argument>,
							<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>address</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Back out what's already been done. */</comment>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not map shared memory segment \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * VirtualQuery gives size in page_size units, which is 4K for Windows. We
	 * need size only when we are attaching, but it's better to get the size
	 * when creating new segment to keep size consistent both for
	 * DSM_OP_CREATE and DSM_OP_ATTACH.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VirtualQuery</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Back out what's already been done. */</comment>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnmapViewOfFile</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat shared memory segment \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>mapped_address</name> <operator>=</operator> <name>address</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>mapped_size</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>RegionSize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>impl_private</name> <operator>=</operator> <name>hmap</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_MMAP</name></cpp:ifdef>
<comment type="block">/*
 * Operating system primitives to support mmap-based shared memory.
 *
 * Calling this "shared memory" is somewhat of a misnomer, because what
 * we're really doing is creating a bunch of files and mapping them into
 * our address space.  The operating system may feel obliged to
 * synchronize the contents to disk even if nothing is being paged out,
 * which will not serve us well.  The user can relocate the pg_dynshmem
 * directory to a ramdisk to avoid this problem, if available.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dsm_impl_mmap</name><parameter_list>(<parameter><decl><type><name>dsm_op</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>request_size</name></decl></parameter>,
			  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapped_address</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>mapped_size</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name>PG_DYNSHMEM_DIR</name> <literal type="string">"/"</literal> <name>PG_DYNSHMEM_MMAP_FILE_PREFIX</name> <literal type="string">"%u"</literal></expr></argument>,
			 <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle teardown cases. */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_DETACH</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>DSM_OP_DESTROY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>mapped_address</name> <operator>!=</operator> <name>NULL</name>
			<operator>&amp;&amp;</operator> <call><name>munmap</name><argument_list>(<argument><expr><operator>*</operator><name>mapped_address</name></expr></argument>, <argument><expr><operator>*</operator><name>mapped_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not unmap shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>mapped_address</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>mapped_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_DESTROY</name> <operator>&amp;&amp;</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Create new segment or open an existing one for attach. */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>O_RDWR</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>op</name> <operator>==</operator> <name>DSM_OP_CREATE</name></expr> ?</condition><then> <expr><name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're attaching the segment, determine the current size; if we are
	 * creating the segment, set the size to the requested value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_ATTACH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

			<comment type="block">/* Back out what's already been done. */</comment>
			<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat shared memory segment \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>request_size</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Allocate a buffer full of zeros.
		 *
		 * Note: palloc zbuffer, instead of just using a local char array, to
		 * ensure it is reasonably well-aligned; this may save a few cycles
		 * transferring data to the kernel.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>zbuffer</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ZBUFFER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>remaining</name> <init>= <expr><name>request_size</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Zero-fill the file. We have to do this the hard way to ensure that
		 * all the file space has really been allocated, so that we don't
		 * later seg fault when accessing the memory mapping.  This is pretty
		 * pessimal.
		 */</comment>
		<while>while <condition>(<expr><name>success</name> <operator>&amp;&amp;</operator> <name>remaining</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>goal</name> <init>= <expr><name>remaining</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>goal</name> <operator>&gt;</operator> <name>ZBUFFER_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>goal</name> <operator>=</operator> <name>ZBUFFER_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_DSM_FILL_ZERO_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>zbuffer</name></expr></argument>, <argument><expr><name>goal</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>goal</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>remaining</name> <operator>-=</operator> <name>goal</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

			<comment type="block">/* Back out what's already been done. */</comment>
			<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not resize shared memory segment \"%s\" to %zu bytes: %m"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Map it. */</comment>
	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>, <argument><expr><name>PROT_READ</name> <operator>|</operator> <name>PROT_WRITE</name></expr></argument>,
				   <argument><expr><name>MAP_SHARED</name> <operator>|</operator> <name>MAP_HASSEMAPHORE</name> <operator>|</operator> <name>MAP_NOSYNC</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>address</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

		<comment type="block">/* Back out what's already been done. */</comment>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DSM_OP_CREATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not map shared memory segment \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>mapped_address</name> <operator>=</operator> <name>address</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>mapped_size</name> <operator>=</operator> <name>request_size</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close shared memory segment \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Implementation-specific actions that must be performed when a segment is to
 * be preserved even when no backend has it attached.
 *
 * Except on Windows, we don't need to do anything at all.  But since Windows
 * cleans up segments automatically when no references remain, we duplicate
 * the segment handle into the postmaster process.  The postmaster needn't
 * do anything to receive the handle; Windows transfers it automatically.
 */</comment>
<function><type><name>void</name></type>
<name>dsm_impl_pin_segment</name><parameter_list>(<parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>impl_private</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private_pm_handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>dynamic_shared_memory_type</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_WINDOWS</name></cpp:ifdef>
		<case>case <expr><name>DSM_IMPL_WINDOWS</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HANDLE</name></type>		<name>hmap</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>impl_private</name></expr></argument>,
									 <argument><expr><name>PostmasterHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
									 <argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>SEGMENT_NAME_PREFIX</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not duplicate handle for \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Here, we remember the handle that we created in the
				 * postmaster process.  This handle isn't actually usable in
				 * any process other than the postmaster, but that doesn't
				 * matter.  We're just holding onto it so that, if the segment
				 * is unpinned, dsm_impl_unpin_segment can close it.
				 */</comment>
				<expr_stmt><expr><operator>*</operator><name>impl_private_pm_handle</name> <operator>=</operator> <name>hmap</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Implementation-specific actions that must be performed when a segment is no
 * longer to be preserved, so that it will be cleaned up when all backends
 * have detached from it.
 *
 * Except on Windows, we don't need to do anything at all.  For Windows, we
 * close the extra handle that dsm_impl_pin_segment created in the
 * postmaster's process space.
 */</comment>
<function><type><name>void</name></type>
<name>dsm_impl_unpin_segment</name><parameter_list>(<parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>impl_private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>dynamic_shared_memory_type</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DSM_WINDOWS</name></cpp:ifdef>
		<case>case <expr><name>DSM_IMPL_WINDOWS</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>impl_private</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>PostmasterHandle</name></expr></argument>, <argument><expr><operator>*</operator><name>impl_private</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
									 <argument><expr><name>DUPLICATE_CLOSE_SOURCE</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>SEGMENT_NAME_PREFIX</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_dynamic_shared_memory</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not duplicate handle for \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><operator>*</operator><name>impl_private</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>errcode_for_dynamic_shared_memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EFBIG</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENOMEM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
