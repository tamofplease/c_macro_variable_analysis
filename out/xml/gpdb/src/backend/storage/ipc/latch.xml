<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/storage/ipc/latch.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * latch.c
 *	  Routines for inter-process latches
 *
 * The Unix implementation uses the so-called self-pipe trick to overcome the
 * race condition involved with poll() (or epoll_wait() on linux) and setting
 * a global flag in the signal handler. When a latch is set and the current
 * process is waiting for it, the signal handler wakes up the poll() in
 * WaitLatch by writing a byte to a pipe. A signal by itself doesn't interrupt
 * poll() on all platforms, and even on platforms where it does, a signal that
 * arrives just before the poll() call does not prevent poll() from entering
 * sleep. An incoming byte on a pipe however reliably interrupts the sleep,
 * and causes poll() to return immediately even if the signal arrives before
 * poll() begins.
 *
 * When SetLatch is called from the same process that owns the latch,
 * SetLatch writes the byte directly to the pipe. If it's owned by another
 * process, SIGUSR1 is sent and the signal handler in the waiting process
 * writes the byte to the pipe on behalf of the signaling process.
 *
 * The Windows implementation uses Windows events that are inherited by all
 * postmaster child processes. There's no need for the self-pipe trick there.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/storage/ipc/latch.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_EPOLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/epoll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Select the fd readiness primitive to use. Normally the "most modern"
 * primitive supported by the OS will be used, but for testing it can be
 * useful to manually specify the used primitive.  If desired, just add a
 * define somewhere before this block.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_POLL</name></expr></argument>)</argument_list></call> <operator>||</operator> \
	<call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* don't overwrite manual choice */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_EPOLL_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_USE_EPOLL</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_USE_POLL</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>WIN32</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_USE_WIN32</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"no wait set implementation available"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* typedef in latch.h */</comment>
<struct>struct <name>WaitEventSet</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nevents</name></decl>;</decl_stmt>		<comment type="block">/* number of registered events */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nevents_space</name></decl>;</decl_stmt>	<comment type="block">/* maximum number of events in this set */</comment>

	<comment type="block">/*
	 * Array, of nevents_space length, storing the definition of events this
	 * set is waiting for.
	 */</comment>
	<decl_stmt><decl><type><name>WaitEvent</name>  <modifier>*</modifier></type><name>events</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If WL_LATCH_SET is specified in any wait event, latch is a pointer to
	 * said latch, and latch_pos the offset in the -&gt;events array. This is
	 * useful because we check the state of the latch before performing doing
	 * syscalls related to waiting.
	 */</comment>
	<decl_stmt><decl><type><name>Latch</name>	   <modifier>*</modifier></type><name>latch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>latch_pos</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * WL_EXIT_ON_PM_DEATH is converted to WL_POSTMASTER_DEATH, but this flag
	 * is set so that we'll exit immediately if postmaster death is detected,
	 * instead of returning.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exit_on_postmaster_death</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type>			<name>epoll_fd</name></decl>;</decl_stmt>
	<comment type="block">/* epoll_wait returns events in a user provided arrays, allocate once */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>epoll_event</name></name> <modifier>*</modifier></type><name>epoll_ret_events</name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<comment type="block">/* poll expects events to be waited on every poll() call, prepare once */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>pollfds</name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>

	<comment type="block">/*
	 * Array of windows events. The first element always contains
	 * pgwin32_signal_event, so the remaining elements are offset by one (i.e.
	 * event-&gt;pos + 1).
	 */</comment>
	<decl_stmt><decl><type><name>HANDLE</name>	   <modifier>*</modifier></type><name>handles</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<comment type="block">/* Are we currently in WaitLatch? The signal handler would like to know. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>waiting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Read and write ends of the self-pipe */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>selfpipe_readfd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>selfpipe_writefd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Process owning the self-pipe --- needed for checking purposes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>selfpipe_owner_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Private function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendSelfPipeByte</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>drainSelfPipe</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitEventAdjustEpoll</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitEventAdjustPoll</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitEventAdjustWin32</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>WaitEventSetWaitBlock</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_timeout</name></decl></parameter>,
										<parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>occurred_events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nevents</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialize the process-local latch infrastructure.
 *
 * This must be called once during startup of any process that can wait on
 * latches, before it issues any InitLatch() or OwnLatch() calls.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeLatchSupport</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>pipefd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We might have inherited connections to a self-pipe created by the
		 * postmaster.  It's critical that child processes create their own
		 * self-pipes, of course, and we really want them to close the
		 * inherited FDs for safety's sake.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>selfpipe_owner_pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Assert we go through here but once in a child process */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>selfpipe_owner_pid</name> <operator>!=</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Release postmaster's pipe FDs; ignore any error */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>selfpipe_readfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>selfpipe_writefd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Clean up, just for safety's sake; we'll set these below */</comment>
			<expr_stmt><expr><name>selfpipe_readfd</name> <operator>=</operator> <name>selfpipe_writefd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>selfpipe_owner_pid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Postmaster didn't create a self-pipe ... or else we're in an
			 * EXEC_BACKEND build, in which case it doesn't matter since the
			 * postmaster's pipe FDs were closed by the action of FD_CLOEXEC.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>selfpipe_readfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* In postmaster or standalone backend, assert we do this but once */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>selfpipe_readfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>selfpipe_owner_pid</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Set up the self-pipe that allows a signal handler to wake up the
	 * poll()/epoll_wait() in WaitLatch. Make the write-end non-blocking, so
	 * that SetLatch won't block if the event has already been set many times
	 * filling the kernel buffer. Make the read-end non-blocking too, so that
	 * we can easily clear the pipe by reading until EAGAIN or EWOULDBLOCK.
	 * Also, make both FDs close-on-exec, since we surely do not want any
	 * child processes messing with them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>pipefd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"pipe() failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fcntl(F_SETFL) failed on read-end of self-pipe: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fcntl(F_SETFL) failed on write-end of self-pipe: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fcntl(F_SETFD) failed on read-end of self-pipe: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fcntl(F_SETFD) failed on write-end of self-pipe: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>selfpipe_readfd</name> <operator>=</operator> <name><name>pipefd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>selfpipe_writefd</name> <operator>=</operator> <name><name>pipefd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>selfpipe_owner_pid</name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* currently, nothing to do here for Windows */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a process-local latch.
 */</comment>
<function><type><name>void</name></type>
<name>InitLatch</name><parameter_list>(<parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>is_set</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>is_shared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<comment type="block">/* Assert InitializeLatchSupport has been called in this process */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>selfpipe_readfd</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>selfpipe_owner_pid</name> <operator>==</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>latch</name><operator>-&gt;</operator><name>event</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CreateEvent failed: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a shared latch that can be set from other processes. The latch
 * is initially owned by no-one; use OwnLatch to associate it with the
 * current process.
 *
 * InitSharedLatch needs to be called in postmaster before forking child
 * processes, usually right after allocating the shared memory block
 * containing the latch with ShmemInitStruct. (The Unix implementation
 * doesn't actually require that, but the Windows one does.) Because of
 * this restriction, we have no concurrency issues to worry about here.
 *
 * Note that other handles created in this module are never marked as
 * inheritable.  Thus we do not need to worry about cleaning up child
 * process references to postmaster-private latches or WaitEventSets.
 */</comment>
<function><type><name>void</name></type>
<name>InitSharedLatch</name><parameter_list>(<parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>sa</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set up security attributes to specify that the events are inherited.
	 */</comment>
	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sa</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>nLength</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sa</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>bInheritHandle</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>latch</name><operator>-&gt;</operator><name>event</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CreateEvent failed: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>is_set</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>is_shared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Associate a shared latch with the current process, allowing it to
 * wait on the latch.
 *
 * Although there is a sanity check for latch-already-owned, we don't do
 * any sort of locking here, meaning that we could fail to detect the error
 * if two processes try to own the same latch at about the same time.  If
 * there is any risk of that, caller must provide an interlock to prevent it.
 *
 * In any process that calls OwnLatch(), make sure that
 * latch_sigusr1_handler() is called from the SIGUSR1 signal handler,
 * as shared latches use SIGUSR1 for inter-process communication.
 */</comment>
<function><type><name>void</name></type>
<name>OwnLatch</name><parameter_list>(<parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>latch</name><operator>-&gt;</operator><name>is_shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<comment type="block">/* Assert InitializeLatchSupport has been called in this process */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>selfpipe_readfd</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>selfpipe_owner_pid</name> <operator>==</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"latch already owned by pid %d (is_set: %d)"</literal></expr></argument>,
			 <argument><expr><name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>latch</name><operator>-&gt;</operator><name>is_set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Disown a shared latch currently owned by the current process.
 */</comment>
<function><type><name>void</name></type>
<name>DisownLatch</name><parameter_list>(<parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>latch</name><operator>-&gt;</operator><name>is_shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for a given latch to be set, or for postmaster death, or until timeout
 * is exceeded. 'wakeEvents' is a bitmask that specifies which of those events
 * to wait for. If the latch is already set (and WL_LATCH_SET is given), the
 * function returns immediately.
 *
 * The "timeout" is given in milliseconds. It must be &gt;= 0 if WL_TIMEOUT flag
 * is given.  Although it is declared as "long", we don't actually support
 * timeouts longer than INT_MAX milliseconds.  Note that some extra overhead
 * is incurred when WL_TIMEOUT is given, so avoid using a timeout if possible.
 *
 * The latch must be owned by the current process, ie. it must be a
 * process-local latch initialized with InitLatch, or a shared latch
 * associated with the current process by calling OwnLatch.
 *
 * Returns bit mask indicating which condition(s) caused the wake-up. Note
 * that if multiple wake-up conditions are true, there is no guarantee that
 * we return all of them in one call, but we will return at least one.
 */</comment>
<function><type><name>int</name></type>
<name>WaitLatch</name><parameter_list>(<parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wakeEvents</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>,
		  <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>latch</name></expr></argument>, <argument><expr><name>wakeEvents</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>,
							 <argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like WaitLatch, but with an extra socket argument for WL_SOCKET_*
 * conditions.
 *
 * When waiting on a socket, EOF and error conditions always cause the socket
 * to be reported as readable/writable/connected, so that the caller can deal
 * with the condition.
 *
 * wakeEvents must include either WL_EXIT_ON_PM_DEATH for automatic exit
 * if the postmaster dies or WL_POSTMASTER_DEATH for a flag set in the
 * return value if the postmaster dies.  The latter is useful for rare cases
 * where some behavior other than immediate exit is needed.
 *
 * NB: These days this is just a wrapper around the WaitEventSet API. When
 * using a latch very frequently, consider creating a longer living
 * WaitEventSet instead; that's more efficient.
 */</comment>
<function><type><name>int</name></type>
<name>WaitLatchOrSocket</name><parameter_list>(<parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wakeEvents</name></decl></parameter>, <parameter><decl><type><name>pgsocket</name></type> <name>sock</name></decl></parameter>,
				  <parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEvent</name></type>	<name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name> <init>= <expr><call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>wakeEvents</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>timeout</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>timeout</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>wakeEvents</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>,
						  <argument><expr><name>latch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Postmaster-managed callers must handle postmaster death somehow. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsUnderPostmaster</name> <operator>||</operator>
		   <operator>(</operator><name>wakeEvents</name> <operator>&amp;</operator> <name>WL_EXIT_ON_PM_DEATH</name><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name>wakeEvents</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>wakeEvents</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>wakeEvents</name> <operator>&amp;</operator> <name>WL_EXIT_ON_PM_DEATH</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>WL_EXIT_ON_PM_DEATH</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>wakeEvents</name> <operator>&amp;</operator> <name>WL_SOCKET_MASK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ev</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ev</name> <operator>=</operator> <name>wakeEvents</name> <operator>&amp;</operator> <name>WL_SOCKET_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>event</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>|=</operator> <name>WL_TIMEOUT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>|=</operator> <name><name>event</name><operator>.</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>WL_LATCH_SET</name> <operator>|</operator>
							   <name>WL_POSTMASTER_DEATH</name> <operator>|</operator>
							   <name>WL_SOCKET_MASK</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sets a latch and wakes up anyone waiting on it.
 *
 * This is cheap if the latch is already set, otherwise not so much.
 *
 * NB: when calling this in a signal handler, be sure to save and restore
 * errno around it.  (That's standard practice in most signal handlers, of
 * course, but we used to omit it in handlers that only set a flag.)
 *
 * NB: this function is called from critical sections and signal handlers so
 * throwing an error is not a good idea.
 */</comment>
<function><type><name>void</name></type>
<name>SetLatch</name><parameter_list>(<parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>owner_pid</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>handle</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * The memory barrier has to be placed here to ensure that any flag
	 * variables possibly changed by this process have been flushed to main
	 * memory, before we check/set is_set.
	 */</comment>
	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick exit if already set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>latch</name><operator>-&gt;</operator><name>is_set</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>is_set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

	<comment type="block">/*
	 * See if anyone's waiting for the latch. It can be the current process if
	 * we're in a signal handler. We use the self-pipe to wake up the
	 * poll()/epoll_wait() in that case. If it's another process, send a
	 * signal.
	 *
	 * Fetch owner_pid only once, in case the latch is concurrently getting
	 * owned or disowned. XXX: This assumes that pid_t is atomic, which isn't
	 * guaranteed to be true! In practice, the effective range of pid_t fits
	 * in a 32 bit integer, and so should be atomic. In the worst case, we
	 * might end up signaling the wrong process. Even then, you're very
	 * unlucky if a process with that bogus pid exists and belongs to
	 * Postgres; and PG database processes should handle excess SIGUSR1
	 * interrupts without a problem anyhow.
	 *
	 * Another sort of race condition that's possible here is for a new
	 * process to own the latch immediately after we look, so we don't signal
	 * it. This is okay so long as all callers of ResetLatch/WaitLatch follow
	 * the standard coding convention of waiting at the bottom of their loops,
	 * not the top, so that they'll correctly process latch-setting events
	 * that happen before they enter the loop.
	 */</comment>
	<expr_stmt><expr><name>owner_pid</name> <operator>=</operator> <name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>owner_pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>owner_pid</name> <operator>==</operator> <name>MyProcPid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>waiting</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sendSelfPipeByte</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>owner_pid</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * See if anyone's waiting for the latch. It can be the current process if
	 * we're in a signal handler.
	 *
	 * Use a local variable here just in case somebody changes the event field
	 * concurrently (which really should not happen).
	 */</comment>
	<expr_stmt><expr><name>handle</name> <operator>=</operator> <name><name>latch</name><operator>-&gt;</operator><name>event</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>handle</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that we silently ignore any errors. We might be in a signal
		 * handler or other critical path where it's not safe to call elog().
		 */</comment>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<comment type="block">/*
 * Clear the latch. Calling WaitLatch after this will sleep, unless
 * the latch is set again before the WaitLatch call.
 */</comment>
<function><type><name>void</name></type>
<name>ResetLatch</name><parameter_list>(<parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only the owner should reset the latch */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>latch</name><operator>-&gt;</operator><name>is_set</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure that the write to is_set gets flushed to main memory before we
	 * examine any flag variables.  Otherwise a concurrent SetLatch might
	 * falsely conclude that it needn't signal us, even though we have missed
	 * seeing some flag updates that SetLatch was supposed to inform us of.
	 */</comment>
	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a WaitEventSet with space for nevents different events to wait for.
 *
 * These events can then be efficiently waited upon together, using
 * WaitEventSetWait().
 */</comment>
<function><type><name>WaitEventSet</name> <modifier>*</modifier></type>
<name>CreateWaitEventSet</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nevents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use MAXALIGN size/alignment to guarantee that later uses of memory are
	 * aligned correctly. E.g. epoll_event might need 8 byte alignment on some
	 * platforms, but earlier allocations like WaitEventSet and WaitEvent
	 * might not sized to guarantee that when purely using sizeof().
	 */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WaitEventSet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WaitEvent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>epoll_event</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<comment type="block">/* need space for the pgwin32_signal_event */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HANDLE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nevents</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>set</name> <operator>=</operator> <operator>(</operator><name>WaitEventSet</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WaitEventSet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <operator>(</operator><name>WaitEvent</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WaitEvent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>epoll_ret_events</name></name> <operator>=</operator> <operator>(</operator>struct <name>epoll_event</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>epoll_event</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>pollfds</name></name> <operator>=</operator> <operator>(</operator>struct <name>pollfd</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>handles</name></name> <operator>=</operator> <operator>(</operator><name>HANDLE</name><operator>)</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HANDLE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>nevents_space</name></name> <operator>=</operator> <name>nevents</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>exit_on_postmaster_death</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EPOLL_CLOEXEC</name></cpp:ifdef>
	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>epoll_fd</name></name> <operator>=</operator> <call><name>epoll_create1</name><argument_list>(<argument><expr><name>EPOLL_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>epoll_fd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"epoll_create1 failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* cope with ancient glibc lacking epoll_create1 (e.g., RHEL5) */</comment>
	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>epoll_fd</name></name> <operator>=</operator> <call><name>epoll_create</name><argument_list>(<argument><expr><name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>epoll_fd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"epoll_create failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>epoll_fd</name></name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fcntl(F_SETFD) failed on epoll descriptor: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EPOLL_CLOEXEC */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>

	<comment type="block">/*
	 * To handle signals while waiting, we need to add a win32 specific event.
	 * We accounted for the additional event at the top of this routine. See
	 * port/win32/signal.c for more details.
	 *
	 * Note: pgwin32_signal_event should be first to ensure that it will be
	 * reported when multiple events are set.  We want to guarantee that
	 * pending signals are serviced.
	 */</comment>
	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>handles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pgwin32_signal_event</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>WSA_INVALID_EVENT</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>set</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a previously created WaitEventSet.
 *
 * Note: preferably, this shouldn't have to free any resources that could be
 * inherited across an exec().  If it did, we'd likely leak those resources in
 * many scenarios.  For the epoll case, we ensure that by setting FD_CLOEXEC
 * when the FD is created.  For the Windows case, we assume that the handles
 * involved are non-inheritable.
 */</comment>
<function><type><name>void</name></type>
<name>FreeWaitEventSet</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>epoll_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<decl_stmt><decl><type><name>WaitEvent</name>  <modifier>*</modifier></type><name>cur_event</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>cur_event</name> <operator>=</operator> <name><name>set</name><operator>-&gt;</operator><name>events</name></name></expr>;</init>
		 <condition><expr><name>cur_event</name> <operator>&lt;</operator> <operator>(</operator><name><name>set</name><operator>-&gt;</operator><name>events</name></name> <operator>+</operator> <name><name>set</name><operator>-&gt;</operator><name>nevents</name></name><operator>)</operator></expr>;</condition>
		 <incr><expr><name>cur_event</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* uses the latch's HANDLE */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* uses PostmasterHandle */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Clean up the event object we created for the socket */</comment>
			<expr_stmt><expr><call><name>WSAEventSelect</name><argument_list>(<argument><expr><name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WSACloseEvent</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>handles</name><index>[<expr><name><name>cur_event</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ---
 * Add an event to the set. Possible events are:
 * - WL_LATCH_SET: Wait for the latch to be set
 * - WL_POSTMASTER_DEATH: Wait for postmaster to die
 * - WL_SOCKET_READABLE: Wait for socket to become readable,
 *	 can be combined in one event with other WL_SOCKET_* events
 * - WL_SOCKET_WRITEABLE: Wait for socket to become writeable,
 *	 can be combined with other WL_SOCKET_* events
 * - WL_SOCKET_CONNECTED: Wait for socket connection to be established,
 *	 can be combined with other WL_SOCKET_* events (on non-Windows
 *	 platforms, this is the same as WL_SOCKET_WRITEABLE)
 * - WL_EXIT_ON_PM_DEATH: Exit immediately if the postmaster dies
 *
 * Returns the offset in WaitEventSet-&gt;events (starting from 0), which can be
 * used to modify previously added wait events using ModifyWaitEvent().
 *
 * In the WL_LATCH_SET case the latch must be owned by the current process,
 * i.e. it must be a process-local latch initialized with InitLatch, or a
 * shared latch associated with the current process by calling OwnLatch.
 *
 * In the WL_SOCKET_READABLE/WRITEABLE/CONNECTED cases, EOF and error
 * conditions cause the socket to be reported as readable/writable/connected,
 * so that the caller can deal with the condition.
 *
 * The user_data pointer specified here will be set for the events returned
 * by WaitEventSetWait(), allowing to easily associate additional data with
 * events.
 */</comment>
<function><type><name>int</name></type>
<name>AddWaitEventToSet</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>pgsocket</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WaitEvent</name>  <modifier>*</modifier></type><name>event</name></decl>;</decl_stmt>

	<comment type="block">/* not enough space */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>nevents</name></name> <operator>&lt;</operator> <name><name>set</name><operator>-&gt;</operator><name>nevents_space</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>events</name> <operator>==</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>events</name> <operator>=</operator> <name>WL_POSTMASTER_DEATH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>exit_on_postmaster_death</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>latch</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>latch</name><operator>-&gt;</operator><name>owner_pid</name></name> <operator>!=</operator> <name>MyProcPid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot wait on a latch owned by another process"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>latch</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot wait on more than one latch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>events</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name><operator>)</operator> <operator>!=</operator> <name>WL_LATCH_SET</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"latch events only support being set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>events</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot wait on latch without a specified latch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* waiting for socket readiness without a socket indicates a bug */</comment>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>events</name> <operator>&amp;</operator> <name>WL_SOCKET_MASK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot wait on socket event without a socket"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>event</name> <operator>=</operator> <operator>&amp;</operator><name><name>set</name><operator>-&gt;</operator><name>events</name><index>[<expr><name><name>set</name><operator>-&gt;</operator><name>nevents</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>set</name><operator>-&gt;</operator><name>nevents</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>events</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator> <name>user_data</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>reset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>events</name> <operator>==</operator> <name>WL_LATCH_SET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <name>latch</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>latch_pos</name></name> <operator>=</operator> <name><name>event</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>selfpipe_readfd</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>events</name> <operator>==</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name><name>postmaster_alive_fds</name><index>[<expr><name>POSTMASTER_FD_WATCH</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* perform wait primitive specific initialization, if needed */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>WaitEventAdjustEpoll</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>EPOLL_CTL_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><call><name>WaitEventAdjustPoll</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><call><name>WaitEventAdjustWin32</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name><name>event</name><operator>-&gt;</operator><name>pos</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Change the event mask and, in the WL_LATCH_SET case, the latch associated
 * with the WaitEvent.
 *
 * 'pos' is the id returned by AddWaitEventToSet.
 */</comment>
<function><type><name>void</name></type>
<name>ModifyWaitEvent</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WaitEvent</name>  <modifier>*</modifier></type><name>event</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pos</name> <operator>&lt;</operator> <name><name>set</name><operator>-&gt;</operator><name>nevents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>event</name> <operator>=</operator> <operator>&amp;</operator><name><name>set</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If neither the event mask nor the associated latch changes, return
	 * early. That's an important optimization for some sockets, where
	 * ModifyWaitEvent is frequently used to switch from waiting for reads to
	 * waiting on writes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>events</name> <operator>==</operator> <name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>!</operator><operator>(</operator><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_LATCH_SET</name><operator>)</operator> <operator>||</operator> <name><name>set</name><operator>-&gt;</operator><name>latch</name></name> <operator>==</operator> <name>latch</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_LATCH_SET</name> <operator>&amp;&amp;</operator>
		<name>events</name> <operator>!=</operator> <name><name>event</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we could allow to disable latch events for a while */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot modify latch event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot modify postmaster death event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* FIXME: validate event mask */</comment>
	<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>events</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>events</name> <operator>==</operator> <name>WL_LATCH_SET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <name>latch</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>WaitEventAdjustEpoll</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>EPOLL_CTL_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><call><name>WaitEventAdjustPoll</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><call><name>WaitEventAdjustWin32</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * action can be one of EPOLL_CTL_ADD | EPOLL_CTL_MOD | EPOLL_CTL_DEL
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitEventAdjustEpoll</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>epoll_event</name></name></type> <name>epoll_ev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* pointer to our event, returned by epoll_wait */</comment>
	<expr_stmt><expr><name><name>epoll_ev</name><operator>.</operator><name>data</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>event</name></expr>;</expr_stmt>
	<comment type="block">/* always wait for errors */</comment>
	<expr_stmt><expr><name><name>epoll_ev</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>EPOLLERR</name> <operator>|</operator> <name>EPOLLHUP</name></expr>;</expr_stmt>

	<comment type="block">/* prepare pollfd entry once */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_LATCH_SET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>latch</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>epoll_ev</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>EPOLLIN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>epoll_ev</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>EPOLLIN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>fd</name></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>epoll_ev</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>EPOLLIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_WRITEABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>epoll_ev</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>EPOLLOUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Even though unused, we also pass epoll_ev as the data argument if
	 * EPOLL_CTL_DEL is passed as action.  There used to be an epoll bug
	 * requiring that, and actually it makes the code simpler...
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>epoll_ctl</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>epoll_fd</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><name><name>event</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epoll_ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is a syscall name, such as "poll()" */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s failed: %m"</literal></expr></argument>,
						<argument><expr><literal type="string">"epoll_ctl()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitEventAdjustPoll</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>pollfd</name> <init>= <expr><operator>&amp;</operator><name><name>set</name><operator>-&gt;</operator><name>pollfds</name><index>[<expr><name><name>event</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pollfd</name><operator>-&gt;</operator><name>revents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pollfd</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name><name>event</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

	<comment type="block">/* prepare pollfd entry once */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_LATCH_SET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>latch</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pollfd</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pollfd</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pollfd</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pollfd</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>POLLIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_WRITEABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pollfd</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>POLLOUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>fd</name></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitEventAdjustWin32</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HANDLE</name>	   <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>set</name><operator>-&gt;</operator><name>handles</name><index>[<expr><name><name>event</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_LATCH_SET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>latch</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>handle</name> <operator>=</operator> <name><name>set</name><operator>-&gt;</operator><name>latch</name><operator>-&gt;</operator><name>event</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>handle</name> <operator>=</operator> <name>PostmasterHandle</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><name>FD_CLOSE</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* always check for errors/EOF */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FD_READ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_WRITEABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FD_WRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_CONNECTED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FD_CONNECT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>handle</name> <operator>==</operator> <name>WSA_INVALID_EVENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>handle</name> <operator>=</operator> <call><name>WSACreateEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>handle</name> <operator>==</operator> <name>WSA_INVALID_EVENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to create event for socket: error code %u"</literal></expr></argument>,
					 <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>WSAEventSelect</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>*</operator><name>handle</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to set up event for socket: error code %u"</literal></expr></argument>,
				 <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>fd</name></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Wait for events added to the set to happen, or until the timeout is
 * reached.  At most nevents occurred events are returned.
 *
 * If timeout = -1, block until an event occurs; if 0, check sockets for
 * readiness, but don't block; if &gt; 0, block for at most timeout milliseconds.
 *
 * Returns the number of events occurred, or 0 if the timeout was reached.
 *
 * Returned events will have the fd, pos, user_data fields set to the
 * values associated with the registered event.
 */</comment>
<function><type><name>int</name></type>
<name>WaitEventSetWait</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>,
				 <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>occurred_events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nevents</name></decl></parameter>,
				 <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returned_events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>start_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>cur_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>cur_timeout</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nevents</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize timeout if requested.  We must record the current time so
	 * that we can determine the remaining timeout if interrupted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>timeout</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>timeout</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <name>timeout</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>waiting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Ensure that signals are serviced even if latch is already set */</comment>
	<expr_stmt><expr><call><name>pgwin32_dispatch_queued_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<while>while <condition>(<expr><name>returned_events</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check if the latch is set already. If so, leave the loop
		 * immediately, avoid blocking again. We don't attempt to report any
		 * other events that might also be satisfied.
		 *
		 * If someone sets the latch between this and the
		 * WaitEventSetWaitBlock() below, the setter will write a byte to the
		 * pipe (or signal us and the signal handler will do that), and the
		 * readiness routine will return immediately.
		 *
		 * On unix, If there's a pending byte in the self pipe, we'll notice
		 * whenever blocking. Only clearing the pipe in that case avoids
		 * having to drain it every time WaitLatchOrSocket() is used. Should
		 * the pipe-buffer fill up we're still ok, because the pipe is in
		 * nonblocking mode. It's unlikely for that to happen, because the
		 * self pipe isn't filled unless we're blocking (waiting = true), or
		 * from inside a signal handler in latch_sigusr1_handler().
		 *
		 * On windows, we'll also notice if there's a pending event for the
		 * latch when blocking, but there's no danger of anything filling up,
		 * as "Setting an event that is already set has no effect.".
		 *
		 * Note: we assume that the kernel calls involved in latch management
		 * will provide adequate synchronization on machines with weak memory
		 * ordering, so that we cannot miss seeing is_set if a notification
		 * has already been queued.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>latch</name></name> <operator>&amp;&amp;</operator> <name><name>set</name><operator>-&gt;</operator><name>latch</name><operator>-&gt;</operator><name>is_set</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>set</name><operator>-&gt;</operator><name>latch_pos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator>
				<name><name>set</name><operator>-&gt;</operator><name>events</name><index>[<expr><name><name>set</name><operator>-&gt;</operator><name>latch_pos</name></name></expr>]</index></name><operator>.</operator><name>user_data</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>WL_LATCH_SET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait for events using the readiness primitive chosen at the top of
		 * this file. If -1 is returned, a timeout has occurred, if 0 we have
		 * to retry, everything &gt;= 1 is the number of returned events.
		 */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitEventSetWaitBlock</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>cur_timeout</name></expr></argument>,
								   <argument><expr><name>occurred_events</name></expr></argument>, <argument><expr><name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>				<comment type="block">/* timeout occurred */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>returned_events</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* If we're not done, update cur_timeout for next iteration */</comment>
		<if_stmt><if>if <condition>(<expr><name>returned_events</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>timeout</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>cur_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>cur_time</name></expr></argument>, <argument><expr><name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <name>timeout</name> <operator>-</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>cur_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cur_timeout</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>waiting</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>returned_events</name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/*
 * Wait using linux's epoll_wait(2).
 *
 * This is the preferable wait method, as several readiness notifications are
 * delivered, without having to iterate through all of set-&gt;events. The return
 * epoll_event struct contain a pointer to our events, making association
 * easy.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>WaitEventSetWaitBlock</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_timeout</name></decl></parameter>,
					  <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>occurred_events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nevents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returned_events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEvent</name>  <modifier>*</modifier></type><name>cur_event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>epoll_event</name></name> <modifier>*</modifier></type><name>cur_epoll_event</name></decl>;</decl_stmt>

	<comment type="block">/* Sleep */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>epoll_wait</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>epoll_fd</name></name></expr></argument>, <argument><expr><name><name>set</name><operator>-&gt;</operator><name>epoll_ret_events</name></name></expr></argument>,
					<argument><expr><name>nevents</name></expr></argument>, <argument><expr><name>cur_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check return code */</comment>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* EINTR is okay, otherwise complain */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>waiting</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: %s is a syscall name, such as "poll()" */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s failed: %m"</literal></expr></argument>,
							<argument><expr><literal type="string">"epoll_wait()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* timeout exceeded */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At least one event occurred, iterate over the returned epoll events
	 * until they're either all processed, or we've returned all the events
	 * the caller desired.
	 */</comment>
	<for>for <control>(<init><expr><name>cur_epoll_event</name> <operator>=</operator> <name><name>set</name><operator>-&gt;</operator><name>epoll_ret_events</name></name></expr>;</init>
		 <condition><expr><name>cur_epoll_event</name> <operator>&lt;</operator> <operator>(</operator><name><name>set</name><operator>-&gt;</operator><name>epoll_ret_events</name></name> <operator>+</operator> <name>rc</name><operator>)</operator> <operator>&amp;&amp;</operator>
		 <name>returned_events</name> <operator>&lt;</operator> <name>nevents</name></expr>;</condition>
		 <incr><expr><name>cur_epoll_event</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* epoll's data pointer is set to the associated WaitEvent */</comment>
		<expr_stmt><expr><name>cur_event</name> <operator>=</operator> <operator>(</operator><name>WaitEvent</name> <operator>*</operator><operator>)</operator> <name><name>cur_epoll_event</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>user_data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_LATCH_SET</name> <operator>&amp;&amp;</operator>
			<name><name>cur_epoll_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>EPOLLIN</name> <operator>|</operator> <name>EPOLLERR</name> <operator>|</operator> <name>EPOLLHUP</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* There's data in the self-pipe, clear it. */</comment>
			<expr_stmt><expr><call><name>drainSelfPipe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>latch</name><operator>-&gt;</operator><name>is_set</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>WL_LATCH_SET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_POSTMASTER_DEATH</name> <operator>&amp;&amp;</operator>
				 <name><name>cur_epoll_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>EPOLLIN</name> <operator>|</operator> <name>EPOLLERR</name> <operator>|</operator> <name>EPOLLHUP</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We expect an EPOLLHUP when the remote end is closed, but
			 * because we don't expect the pipe to become readable or to have
			 * any errors either, treat those cases as postmaster death, too.
			 *
			 * Be paranoid about a spurious event signalling the postmaster as
			 * being dead.  There have been reports about that happening with
			 * older primitives (select(2) to be specific), and a spurious
			 * WL_POSTMASTER_DEATH event would be painful. Re-checking doesn't
			 * cost much.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAliveInternal</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>exit_on_postmaster_death</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>WL_POSTMASTER_DEATH</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>cur_epoll_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>EPOLLIN</name> <operator>|</operator> <name>EPOLLERR</name> <operator>|</operator> <name>EPOLLHUP</name><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* data available in socket, or EOF */</comment>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>WL_SOCKET_READABLE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_WRITEABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>cur_epoll_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>EPOLLOUT</name> <operator>|</operator> <name>EPOLLERR</name> <operator>|</operator> <name>EPOLLHUP</name><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* writable, or EOF */</comment>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>returned_events</name></expr>;</return>
</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<comment type="block">/*
 * Wait using poll(2).
 *
 * This allows to receive readiness notifications for several events at once,
 * but requires iterating through all of set-&gt;pollfds.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>WaitEventSetWaitBlock</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_timeout</name></decl></parameter>,
					  <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>occurred_events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nevents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returned_events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEvent</name>  <modifier>*</modifier></type><name>cur_event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>cur_pollfd</name></decl>;</decl_stmt>

	<comment type="block">/* Sleep */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>pollfds</name></name></expr></argument>, <argument><expr><name><name>set</name><operator>-&gt;</operator><name>nevents</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>cur_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check return code */</comment>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* EINTR is okay, otherwise complain */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>waiting</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: %s is a syscall name, such as "poll()" */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s failed: %m"</literal></expr></argument>,
							<argument><expr><literal type="string">"poll()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* timeout exceeded */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>cur_event</name> <operator>=</operator> <name><name>set</name><operator>-&gt;</operator><name>events</name></name></expr><operator>,</operator> <expr><name>cur_pollfd</name> <operator>=</operator> <name><name>set</name><operator>-&gt;</operator><name>pollfds</name></name></expr>;</init>
		 <condition><expr><name>cur_event</name> <operator>&lt;</operator> <operator>(</operator><name><name>set</name><operator>-&gt;</operator><name>events</name></name> <operator>+</operator> <name><name>set</name><operator>-&gt;</operator><name>nevents</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		 <name>returned_events</name> <operator>&lt;</operator> <name>nevents</name></expr>;</condition>
		 <incr><expr><name>cur_event</name><operator>++</operator></expr><operator>,</operator> <expr><name>cur_pollfd</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* no activity on this FD, skip */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_pollfd</name><operator>-&gt;</operator><name>revents</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>user_data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_LATCH_SET</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>cur_pollfd</name><operator>-&gt;</operator><name>revents</name></name> <operator>&amp;</operator> <operator>(</operator><name>POLLIN</name> <operator>|</operator> <name>POLLHUP</name> <operator>|</operator> <name>POLLERR</name> <operator>|</operator> <name>POLLNVAL</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* There's data in the self-pipe, clear it. */</comment>
			<expr_stmt><expr><call><name>drainSelfPipe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>latch</name><operator>-&gt;</operator><name>is_set</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>WL_LATCH_SET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_POSTMASTER_DEATH</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>cur_pollfd</name><operator>-&gt;</operator><name>revents</name></name> <operator>&amp;</operator> <operator>(</operator><name>POLLIN</name> <operator>|</operator> <name>POLLHUP</name> <operator>|</operator> <name>POLLERR</name> <operator>|</operator> <name>POLLNVAL</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We expect an POLLHUP when the remote end is closed, but because
			 * we don't expect the pipe to become readable or to have any
			 * errors either, treat those cases as postmaster death, too.
			 *
			 * Be paranoid about a spurious event signalling the postmaster as
			 * being dead.  There have been reports about that happening with
			 * older primitives (select(2) to be specific), and a spurious
			 * WL_POSTMASTER_DEATH event would be painful. Re-checking doesn't
			 * cost much.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAliveInternal</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>exit_on_postmaster_death</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>WL_POSTMASTER_DEATH</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>errflags</name> <init>= <expr><name>POLLHUP</name> <operator>|</operator> <name>POLLERR</name> <operator>|</operator> <name>POLLNVAL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name> <operator>&gt;=</operator> <name>PGINVALID_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>cur_pollfd</name><operator>-&gt;</operator><name>revents</name></name> <operator>&amp;</operator> <operator>(</operator><name>POLLIN</name> <operator>|</operator> <name>errflags</name><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* data available in socket, or EOF */</comment>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>WL_SOCKET_READABLE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_WRITEABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>cur_pollfd</name><operator>-&gt;</operator><name>revents</name></name> <operator>&amp;</operator> <operator>(</operator><name>POLLOUT</name> <operator>|</operator> <name>errflags</name><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* writeable, or EOF */</comment>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>returned_events</name></expr>;</return>
</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WAIT_USE_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<comment type="block">/*
 * Wait using Windows' WaitForMultipleObjects().
 *
 * Unfortunately this will only ever return a single readiness notification at
 * a time.  Note that while the official documentation for
 * WaitForMultipleObjects is ambiguous about multiple events being "consumed"
 * with a single bWaitAll = FALSE call,
 * https://blogs.msdn.microsoft.com/oldnewthing/20150409-00/?p=44273 confirms
 * that only one event is "consumed".
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>WaitEventSetWaitBlock</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_timeout</name></decl></parameter>,
					  <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>occurred_events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nevents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returned_events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEvent</name>  <modifier>*</modifier></type><name>cur_event</name></decl>;</decl_stmt>

	<comment type="block">/* Reset any wait events that need it */</comment>
	<for>for <control>(<init><expr><name>cur_event</name> <operator>=</operator> <name><name>set</name><operator>-&gt;</operator><name>events</name></name></expr>;</init>
		 <condition><expr><name>cur_event</name> <operator>&lt;</operator> <operator>(</operator><name><name>set</name><operator>-&gt;</operator><name>events</name></name> <operator>+</operator> <name><name>set</name><operator>-&gt;</operator><name>nevents</name></name><operator>)</operator></expr>;</condition>
		 <incr><expr><name>cur_event</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>reset</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WaitEventAdjustWin32</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>cur_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_event</name><operator>-&gt;</operator><name>reset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Windows does not guarantee to log an FD_WRITE network event
		 * indicating that more data can be sent unless the previous send()
		 * failed with WSAEWOULDBLOCK.  While our caller might well have made
		 * such a call, we cannot assume that here.  Therefore, if waiting for
		 * write-ready, force the issue by doing a dummy send().  If the dummy
		 * send() succeeds, assume that the socket is in fact write-ready, and
		 * return immediately.  Also, if it fails with something other than
		 * WSAEWOULDBLOCK, return a write-ready indication to let our caller
		 * deal with the error condition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_WRITEABLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WSABUF</name></type>		<name>buf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DWORD</name></type>		<name>sent</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <operator>&amp;</operator><name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WSASend</name><argument_list>(<argument><expr><name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>user_data</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Sleep.
	 *
	 * Need to wait for -&gt;nevents + 1, because signal handle is in [0].
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>nevents</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>set</name><operator>-&gt;</operator><name>handles</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
								<argument><expr><name>cur_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check return code */</comment>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>WAIT_FAILED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"WaitForMultipleObjects() failed: error code %lu"</literal></expr></argument>,
			 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>WAIT_TIMEOUT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* timeout exceeded */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>WAIT_OBJECT_0</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Service newly-arrived signals */</comment>
		<expr_stmt><expr><call><name>pgwin32_dispatch_queued_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>				<comment type="block">/* retry */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * With an offset of one, due to the always present pgwin32_signal_event,
	 * the handle offset directly corresponds to a wait event.
	 */</comment>
	<expr_stmt><expr><name>cur_event</name> <operator>=</operator> <operator>(</operator><name>WaitEvent</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>set</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>rc</name> <operator>-</operator> <name>WAIT_OBJECT_0</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>user_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_LATCH_SET</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ResetEvent</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>latch</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ResetEvent failed: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>latch</name><operator>-&gt;</operator><name>is_set</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>WL_LATCH_SET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>==</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Postmaster apparently died.  Since the consequences of falsely
		 * returning WL_POSTMASTER_DEATH could be pretty unpleasant, we take
		 * the trouble to positively verify this with PostmasterIsAlive(),
		 * even though there is no known reason to think that the event could
		 * be falsely set on Windows.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAliveInternal</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>exit_on_postmaster_death</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>WL_POSTMASTER_DEATH</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_MASK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WSANETWORKEVENTS</name></type> <name>resEvents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HANDLE</name></type>		<name>handle</name> <init>= <expr><name><name>set</name><operator>-&gt;</operator><name>handles</name><index>[<expr><name><name>cur_event</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resEvents</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resEvents</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>WSAEnumNetworkEvents</name><argument_list>(<argument><expr><name><name>cur_event</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resEvents</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to enumerate network events: error code %u"</literal></expr></argument>,
				 <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>resEvents</name><operator>.</operator><name>lNetworkEvents</name></name> <operator>&amp;</operator> <name>FD_READ</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* data available in socket */</comment>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>WL_SOCKET_READABLE</name></expr>;</expr_stmt>

			<comment type="block">/*------
			 * WaitForMultipleObjects doesn't guarantee that a read event will
			 * be returned if the latch is set at the same time.  Even if it
			 * did, the caller might drop that event expecting it to reoccur
			 * on next call.  So, we must force the event to be reset if this
			 * WaitEventSet is used again in order to avoid an indefinite
			 * hang.  Refer https://msdn.microsoft.com/en-us/library/windows/desktop/ms741576(v=vs.85).aspx
			 * for the behavior of socket events.
			 *------
			 */</comment>
			<expr_stmt><expr><name><name>cur_event</name><operator>-&gt;</operator><name>reset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_WRITEABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>resEvents</name><operator>.</operator><name>lNetworkEvents</name></name> <operator>&amp;</operator> <name>FD_WRITE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* writeable */</comment>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_CONNECTED</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>resEvents</name><operator>.</operator><name>lNetworkEvents</name></name> <operator>&amp;</operator> <name>FD_CONNECT</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connected */</comment>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>WL_SOCKET_CONNECTED</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>resEvents</name><operator>.</operator><name>lNetworkEvents</name></name> <operator>&amp;</operator> <name>FD_CLOSE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* EOF/error, so signal all caller-requested socket flags */</comment>
			<expr_stmt><expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <operator>(</operator><name><name>cur_event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_MASK</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>occurred_events</name><operator>-&gt;</operator><name>events</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>occurred_events</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>returned_events</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>returned_events</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * SetLatch uses SIGUSR1 to wake up the process waiting on the latch.
 *
 * Wake up WaitLatch, if we're waiting.  (We might not be, since SIGUSR1 is
 * overloaded for multiple purposes; or we might not have reached WaitLatch
 * yet, in which case we don't need to fill the pipe either.)
 *
 * NB: when calling this in a signal handler, be sure to save and restore
 * errno around it.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<function><type><name>void</name></type>
<name>latch_sigusr1_handler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>waiting</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sendSelfPipeByte</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !WIN32 */</comment>

<comment type="block">/* Send one byte to the self-pipe, to wake up WaitLatch */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendSelfPipeByte</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>dummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<label><name>retry</name>:</label>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>selfpipe_writefd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If interrupted by signal, just retry */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the pipe is full, we don't need to retry, the data that's there
		 * already is enough to wake up WaitLatch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Oops, the write() failed for some other reason. We might be in a
		 * signal handler, so it's not safe to elog(). We have no choice but
		 * silently ignore the error.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !WIN32 */</comment>

<comment type="block">/*
 * Read all available data from the self-pipe
 *
 * Note: this is only called when waiting = true.  If it fails and doesn't
 * return, it must reset that flag first (though ideally, this will never
 * happen).
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drainSelfPipe</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * There shouldn't normally be more than one byte in the pipe, or maybe a
	 * few bytes if multiple processes run SetLatch at the same instant.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>selfpipe_readfd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if>			<comment type="block">/* the pipe is empty */</comment>
			<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>		<comment type="block">/* retry */</comment>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>waiting</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"read() on self-pipe failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>waiting</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected EOF on self-pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we successfully drained the pipe; no need to read() again */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* else buffer wasn't big enough, so read again */</comment>
	</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !WIN32 */</comment>
</unit>
