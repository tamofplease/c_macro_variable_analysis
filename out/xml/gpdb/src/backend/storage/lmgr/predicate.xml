<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/storage/lmgr/predicate.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * predicate.c
 *	  POSTGRES predicate locking
 *	  to support full serializable transaction isolation
 *
 *
 * The approach taken is to implement Serializable Snapshot Isolation (SSI)
 * as initially described in this paper:
 *
 *	Michael J. Cahill, Uwe RÃ¶hm, and Alan D. Fekete. 2008.
 *	Serializable isolation for snapshot databases.
 *	In SIGMOD '08: Proceedings of the 2008 ACM SIGMOD
 *	international conference on Management of data,
 *	pages 729-738, New York, NY, USA. ACM.
 *	http://doi.acm.org/10.1145/1376616.1376690
 *
 * and further elaborated in Cahill's doctoral thesis:
 *
 *	Michael James Cahill. 2009.
 *	Serializable Isolation for Snapshot Databases.
 *	Sydney Digital Theses.
 *	University of Sydney, School of Information Technologies.
 *	http://hdl.handle.net/2123/5353
 *
 *
 * Predicate locks for Serializable Snapshot Isolation (SSI) are SIREAD
 * locks, which are so different from normal locks that a distinct set of
 * structures is required to handle them.  They are needed to detect
 * rw-conflicts when the read happens before the write.  (When the write
 * occurs first, the reading transaction can check for a conflict by
 * examining the MVCC data.)
 *
 * (1)	Besides tuples actually read, they must cover ranges of tuples
 *		which would have been read based on the predicate.  This will
 *		require modelling the predicates through locks against database
 *		objects such as pages, index ranges, or entire tables.
 *
 * (2)	They must be kept in RAM for quick access.  Because of this, it
 *		isn't possible to always maintain tuple-level granularity -- when
 *		the space allocated to store these approaches exhaustion, a
 *		request for a lock may need to scan for situations where a single
 *		transaction holds many fine-grained locks which can be coalesced
 *		into a single coarser-grained lock.
 *
 * (3)	They never block anything; they are more like flags than locks
 *		in that regard; although they refer to database objects and are
 *		used to identify rw-conflicts with normal write locks.
 *
 * (4)	While they are associated with a transaction, they must survive
 *		a successful COMMIT of that transaction, and remain until all
 *		overlapping transactions complete.  This even means that they
 *		must survive termination of the transaction's process.  If a
 *		top level transaction is rolled back, however, it is immediately
 *		flagged so that it can be ignored, and its SIREAD locks can be
 *		released any time after that.
 *
 * (5)	The only transactions which create SIREAD locks or check for
 *		conflicts with them are serializable transactions.
 *
 * (6)	When a write lock for a top level transaction is found to cover
 *		an existing SIREAD lock for the same transaction, the SIREAD lock
 *		can be deleted.
 *
 * (7)	A write from a serializable transaction must ensure that an xact
 *		record exists for the transaction, with the same lifespan (until
 *		all concurrent transaction complete or the transaction is rolled
 *		back) so that rw-dependencies to that transaction can be
 *		detected.
 *
 * We use an optimization for read-only transactions. Under certain
 * circumstances, a read-only transaction's snapshot can be shown to
 * never have conflicts with other transactions.  This is referred to
 * as a "safe" snapshot (and one known not to be is "unsafe").
 * However, it can't be determined whether a snapshot is safe until
 * all concurrent read/write transactions complete.
 *
 * Once a read-only transaction is known to have a safe snapshot, it
 * can release its predicate locks and exempt itself from further
 * predicate lock tracking. READ ONLY DEFERRABLE transactions run only
 * on safe snapshots, waiting as necessary for one to be available.
 *
 *
 * Lightweight locks to manage access to the predicate locking shared
 * memory objects must be taken in this order, and should be released in
 * reverse order:
 *
 *	SerializableFinishedListLock
 *		- Protects the list of transactions which have completed but which
 *			may yet matter because they overlap still-active transactions.
 *
 *	SerializablePredicateLockListLock
 *		- Protects the linked list of locks held by a transaction.  Note
 *			that the locks themselves are also covered by the partition
 *			locks of their respective lock targets; this lock only affects
 *			the linked list connecting the locks related to a transaction.
 *		- All transactions share this single lock (with no partitioning).
 *		- There is never a need for a process other than the one running
 *			an active transaction to walk the list of locks held by that
 *			transaction, except parallel query workers sharing the leader's
 *			transaction.  In the parallel case, an extra per-sxact lock is
 *			taken; see below.
 *		- It is relatively infrequent that another process needs to
 *			modify the list for a transaction, but it does happen for such
 *			things as index page splits for pages with predicate locks and
 *			freeing of predicate locked pages by a vacuum process.  When
 *			removing a lock in such cases, the lock itself contains the
 *			pointers needed to remove it from the list.  When adding a
 *			lock in such cases, the lock can be added using the anchor in
 *			the transaction structure.  Neither requires walking the list.
 *		- Cleaning up the list for a terminated transaction is sometimes
 *			not done on a retail basis, in which case no lock is required.
 *		- Due to the above, a process accessing its active transaction's
 *			list always uses a shared lock, regardless of whether it is
 *			walking or maintaining the list.  This improves concurrency
 *			for the common access patterns.
 *		- A process which needs to alter the list of a transaction other
 *			than its own active transaction must acquire an exclusive
 *			lock.
 *
 *	SERIALIZABLEXACT's member 'predicateLockListLock'
 *		- Protects the linked list of locks held by a transaction.  Only
 *			needed for parallel mode, where multiple backends share the
 *			same SERIALIZABLEXACT object.  Not needed if
 *			SerializablePredicateLockListLock is held exclusively.
 *
 *	PredicateLockHashPartitionLock(hashcode)
 *		- The same lock protects a target, all locks on that target, and
 *			the linked list of locks on the target.
 *		- When more than one is needed, acquire in ascending address order.
 *		- When all are needed (rare), acquire in ascending index order with
 *			PredicateLockHashPartitionLockByIndex(index).
 *
 *	SerializableXactHashLock
 *		- Protects both PredXact and SerializableXidHash.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/lmgr/predicate.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *
 * housekeeping for setting up shared memory predicate lock structures
 *		InitPredicateLocks(void)
 *		PredicateLockShmemSize(void)
 *
 * predicate lock reporting
 *		GetPredicateLockStatusData(void)
 *		PageIsPredicateLocked(Relation relation, BlockNumber blkno)
 *
 * predicate lock maintenance
 *		GetSerializableTransactionSnapshot(Snapshot snapshot)
 *		SetSerializableTransactionSnapshot(Snapshot snapshot,
 *										   VirtualTransactionId *sourcevxid)
 *		RegisterPredicateLockingXid(void)
 *		PredicateLockRelation(Relation relation, Snapshot snapshot)
 *		PredicateLockPage(Relation relation, BlockNumber blkno,
 *						Snapshot snapshot)
 *		PredicateLockTuple(Relation relation, HeapTuple tuple,
 *						Snapshot snapshot)
 *		PredicateLockPageSplit(Relation relation, BlockNumber oldblkno,
 *							   BlockNumber newblkno)
 *		PredicateLockPageCombine(Relation relation, BlockNumber oldblkno,
 *								 BlockNumber newblkno)
 *		TransferPredicateLocksToHeapRelation(Relation relation)
 *		ReleasePredicateLocks(bool isCommit, bool isReadOnlySafe)
 *
 * conflict detection (may also trigger rollback)
 *		CheckForSerializableConflictOut(bool visible, Relation relation,
 *										HeapTupleData *tup, Buffer buffer,
 *										Snapshot snapshot)
 *		CheckForSerializableConflictIn(Relation relation, HeapTupleData *tup,
 *									   Buffer buffer)
 *		CheckTableForSerializableConflictIn(Relation relation)
 *
 * final rollback checking
 *		PreCommit_CheckForSerializationFailure(void)
 *
 * two-phase commit support
 *		AtPrepare_PredicateLocks(void);
 *		PostPrepare_PredicateLocks(TransactionId xid);
 *		PredicateLockTwoPhaseFinish(TransactionId xid, bool isCommit);
 *		predicatelock_twophase_recover(TransactionId xid, uint16 info,
 *									   void *recdata, uint32 len);
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/slru.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase_rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<comment type="block">/* Uncomment the next line to test the graceful degradation code. */</comment>
<comment type="block">/* #define TEST_OLDSERXID */</comment>

<comment type="block">/*
 * Test the most selective fields first, for performance.
 *
 * a is covered by b if all of the following hold:
 *	1) a.database = b.database
 *	2) a.relation = b.relation
 *	3) b.offset is invalid (b is page-granularity or higher)
 *	4) either of the following:
 *		4a) a.offset is valid (a is tuple-granularity) and a.page = b.page
 *	 or 4b) a.offset is invalid and b.page is invalid (a is
 *			page-granularity and b is relation-granularity
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TargetTagIsCoveredBy</name><parameter_list>(<parameter><type><name>covered_target</name></type></parameter>, <parameter><type><name>covering_target</name></type></parameter>)</parameter_list></cpp:macro>			\
	<cpp:value>((GET_PREDICATELOCKTARGETTAG_RELATION(covered_target) == <comment type="block">/* (2) */</comment>	\
	  GET_PREDICATELOCKTARGETTAG_RELATION(covering_target))				\
	 &amp;&amp; (GET_PREDICATELOCKTARGETTAG_OFFSET(covering_target) ==			\
		 InvalidOffsetNumber)								 <comment type="block">/* (3) */</comment>	\
	 &amp;&amp; (((GET_PREDICATELOCKTARGETTAG_OFFSET(covered_target) !=			\
		   InvalidOffsetNumber)								 <comment type="block">/* (4a) */</comment> \
		  &amp;&amp; (GET_PREDICATELOCKTARGETTAG_PAGE(covering_target) ==		\
			  GET_PREDICATELOCKTARGETTAG_PAGE(covered_target)))			\
		 || ((GET_PREDICATELOCKTARGETTAG_PAGE(covering_target) ==		\
			  InvalidBlockNumber)							 <comment type="block">/* (4b) */</comment> \
			 &amp;&amp; (GET_PREDICATELOCKTARGETTAG_PAGE(covered_target)		\
				 != InvalidBlockNumber)))								\
	 &amp;&amp; (GET_PREDICATELOCKTARGETTAG_DB(covered_target) ==	 <comment type="block">/* (1) */</comment>	\
		 GET_PREDICATELOCKTARGETTAG_DB(covering_target)))</cpp:value></cpp:define>

<comment type="block">/*
 * The predicate locking target and lock shared hash tables are partitioned to
 * reduce contention.  To determine which partition a given target belongs to,
 * compute the tag's hash code with PredicateLockTargetTagHashCode(), then
 * apply one of these macros.
 * NB: NUM_PREDICATELOCK_PARTITIONS must be a power of 2!
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PredicateLockHashPartition</name><parameter_list>(<parameter><type><name>hashcode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((hashcode) % NUM_PREDICATELOCK_PARTITIONS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PredicateLockHashPartitionLock</name><parameter_list>(<parameter><type><name>hashcode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(&amp;MainLWLockArray[PREDICATELOCK_MANAGER_LWLOCK_OFFSET + \
		PredicateLockHashPartition(hashcode)].lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PredicateLockHashPartitionLockByIndex</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(&amp;MainLWLockArray[PREDICATELOCK_MANAGER_LWLOCK_OFFSET + (i)].lock)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NPREDICATELOCKTARGETENTS</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>mul_size(max_predicate_locks_per_xact, add_size(MaxBackends, max_prepared_xacts))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsOnFinishedList</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!SHMQueueIsDetached(&amp;((sxact)-&gt;finishedLink)))</cpp:value></cpp:define>

<comment type="block">/*
 * Note that a sxact is marked "prepared" once it has passed
 * PreCommit_CheckForSerializationFailure, even if it isn't using
 * 2PC. This is the point at which it can no longer be aborted.
 *
 * The PREPARED flag remains set after commit, so SxactIsCommitted
 * implies SxactIsPrepared.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsCommitted</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_COMMITTED) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsPrepared</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_PREPARED) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsRolledBack</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_ROLLED_BACK) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsDoomed</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_DOOMED) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsReadOnly</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_READ_ONLY) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactHasSummaryConflictIn</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_SUMMARY_CONFLICT_IN) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactHasSummaryConflictOut</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_SUMMARY_CONFLICT_OUT) != 0)</cpp:value></cpp:define>
<comment type="block">/*
 * The following macro actually means that the specified transaction has a
 * conflict out *to a transaction which committed ahead of it*.  It's hard
 * to get that into a name of a reasonable length.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactHasConflictOut</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_CONFLICT_OUT) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsDeferrableWaiting</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_DEFERRABLE_WAITING) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsROSafe</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_RO_SAFE) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsROUnsafe</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_RO_UNSAFE) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SxactIsPartiallyReleased</name><parameter_list>(<parameter><type><name>sxact</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sxact)-&gt;flags &amp; SXACT_FLAG_PARTIALLY_RELEASED) != 0)</cpp:value></cpp:define>

<comment type="block">/*
 * Compute the hash code associated with a PREDICATELOCKTARGETTAG.
 *
 * To avoid unnecessary recomputations of the hash code, we try to do this
 * just once per function, and then pass it around as needed.  Aside from
 * passing the hashcode to hash_search_with_hash_value(), we can extract
 * the lock partition number from the hashcode.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PredicateLockTargetTagHashCode</name><parameter_list>(<parameter><type><name>predicatelocktargettag</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>get_hash_value(PredicateLockTargetHash, predicatelocktargettag)</cpp:value></cpp:define>

<comment type="block">/*
 * Given a predicate lock tag, and the hash for its target,
 * compute the lock hash.
 *
 * To make the hash code also depend on the transaction, we xor the sxid
 * struct's address into the hash code, left-shifted so that the
 * partition-number bits don't change.  Since this is only a hash, we
 * don't care if we lose high-order bits of the address; use an
 * intermediate variable to suppress cast-pointer-to-int warnings.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PredicateLockHashCodeFromTargetHashCode</name><parameter_list>(<parameter><type><name>predicatelocktag</name></type></parameter>, <parameter><type><name>targethash</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((targethash) ^ ((uint32) PointerGetDatum((predicatelocktag)-&gt;myXact)) \
	 &lt;&lt; LOG2_NUM_PREDICATELOCK_PARTITIONS)</cpp:value></cpp:define>


<comment type="block">/*
 * The SLRU buffer area through which we access the old xids.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SlruCtlData</name></type> <name>OldSerXidSlruCtlData</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OldSerXidSlruCtl</name></cpp:macro>			<cpp:value>(&amp;OldSerXidSlruCtlData)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OLDSERXID_PAGESIZE</name></cpp:macro>			<cpp:value>BLCKSZ</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OLDSERXID_ENTRYSIZE</name></cpp:macro>			<cpp:value>sizeof(SerCommitSeqNo)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OLDSERXID_ENTRIESPERPAGE</name></cpp:macro>	<cpp:value>(OLDSERXID_PAGESIZE / OLDSERXID_ENTRYSIZE)</cpp:value></cpp:define>

<comment type="block">/*
 * Set maximum pages based on the number needed to track all transactions.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OLDSERXID_MAX_PAGE</name></cpp:macro>			<cpp:value>(MaxTransactionId / OLDSERXID_ENTRIESPERPAGE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OldSerXidNextPage</name><parameter_list>(<parameter><type><name>page</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((page) &gt;= OLDSERXID_MAX_PAGE) ? 0 : (page) + 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OldSerXidValue</name><parameter_list>(<parameter><type><name>slotno</name></type></parameter>, <parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*((SerCommitSeqNo *) \
	(OldSerXidSlruCtl-&gt;shared-&gt;page_buffer[slotno] + \
	((((uint32) (xid)) % OLDSERXID_ENTRIESPERPAGE) * OLDSERXID_ENTRYSIZE))))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OldSerXidPage</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((uint32) (xid)) / OLDSERXID_ENTRIESPERPAGE)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>OldSerXidControlData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>headPage</name></decl>;</decl_stmt>		<comment type="block">/* newest initialized page */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>headXid</name></decl>;</decl_stmt>		<comment type="block">/* newest valid Xid in the SLRU */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>tailXid</name></decl>;</decl_stmt>		<comment type="block">/* oldest xmin we might be interested in */</comment>
}</block></struct></type>			<name>OldSerXidControlData</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>OldSerXidControlData</name></name> <modifier>*</modifier></type><name>OldSerXidControl</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>OldSerXidControl</name></type> <name>oldSerXidControl</name></decl>;</decl_stmt>

<comment type="block">/*
 * When the oldest committed transaction on the "finished" list is moved to
 * SLRU, its predicate locks will be moved to this "dummy" transaction,
 * collapsing duplicate targets.  When a duplicate is found, the later
 * commitSeqNo is used.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>OldCommittedSxact</name></decl>;</decl_stmt>


<comment type="block">/*
 * These configuration variables are used to set the predicate lock table size
 * and to control promotion of predicate locks to coarser granularity in an
 * attempt to degrade performance (mostly as false positive serialization
 * failure) gracefully in the face of memory pressurel
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_predicate_locks_per_xact</name></decl>;</decl_stmt>	<comment type="block">/* set by guc.c */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_predicate_locks_per_relation</name></decl>;</decl_stmt>	<comment type="block">/* set by guc.c */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_predicate_locks_per_page</name></decl>;</decl_stmt>	<comment type="block">/* set by guc.c */</comment>

<comment type="block">/*
 * This provides a list of objects in order to track transactions
 * participating in predicate locking.  Entries in the list are fixed size,
 * and reside in shared memory.  The memory address of an entry must remain
 * fixed during its lifetime.  The list will be protected from concurrent
 * update externally; no provision is made in this code to manage that.  The
 * number of entries in the list, and the size allowed for each entry is
 * fixed upon creation.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PredXactList</name></type> <name>PredXact</name></decl>;</decl_stmt>

<comment type="block">/*
 * This provides a pool of RWConflict data elements to use in conflict lists
 * between transactions.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>RWConflictPoolHeader</name></type> <name>RWConflictPool</name></decl>;</decl_stmt>

<comment type="block">/*
 * The predicate locking hash tables are in shared memory.
 * Each backend keeps pointers to them.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>SerializableXidHash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>PredicateLockTargetHash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>PredicateLockHash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SHM_QUEUE</name> <modifier>*</modifier></type><name>FinishedSerializableTransactions</name></decl>;</decl_stmt>

<comment type="block">/*
 * Tag for a dummy entry in PredicateLockTargetHash. By temporarily removing
 * this entry, you can ensure that there's enough scratch space available for
 * inserting one entry in the hash table. This is an otherwise-invalid tag.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name></type> <name>ScratchTargetTag</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>ScratchTargetTagHash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LWLock</name> <modifier>*</modifier></type><name>ScratchPartitionLock</name></decl>;</decl_stmt>

<comment type="block">/*
 * The local hash table used to determine when to combine multiple fine-
 * grained locks into a single courser-grained lock.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>LocalPredicateLockHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Keep a pointer to the currently-running serializable transaction (if any)
 * for quick reference. Also, remember if we have written anything that could
 * cause a rw-conflict.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>MySerializableXact</name> <init>= <expr><name>InvalidSerializableXact</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>MyXactDidWrite</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * The SXACT_FLAG_RO_UNSAFE optimization might lead us to release
 * MySerializableXact early.  If that happens in a parallel query, the leader
 * needs to defer the destruction of the SERIALIZABLEXACT until end of
 * transaction, because the workers still have a reference to it.  In that
 * case, the leader stores it here.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>SavedSerializableXact</name> <init>= <expr><name>InvalidSerializableXact</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* local functions */</comment>

<function_decl><type><specifier>static</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>CreatePredXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleasePredXact</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>FirstPredXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>NextPredXact</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RWConflictExists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetRWConflict</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetPossibleUnsafeConflict</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>roXact</name></decl></parameter>, <parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>activeXact</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseRWConflict</name><parameter_list>(<parameter><decl><type><name>RWConflict</name></type> <name>conflict</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FlagSxactUnsafe</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>OldSerXidPagePrecedesLogically</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>OldSerXidInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>OldSerXidAdd</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>SerCommitSeqNo</name></type> <name>minConflictCommitSeqNo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SerCommitSeqNo</name></type> <name>OldSerXidGetMinConflictCommitSeqNo</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>OldSerXidSetActiveSerXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>predicatelock_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SummarizeOldestCommittedSxact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>GetSafeSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>GetSerializableTransactionSnapshotInt</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
													  <parameter><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>sourcevxid</name></decl></parameter>,
													  <parameter><decl><type><name>int</name></type> <name>sourcepid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PredicateLockExists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>GetParentPredicateLockTag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>,
									  <parameter><decl><type><name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CoarserLockCovers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>newtargettag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveScratchTarget</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>lockheld</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RestoreScratchTarget</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>lockheld</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveTargetIfNoLongerUsed</name><parameter_list>(<parameter><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
									   <parameter><decl><type><name>uint32</name></type> <name>targettaghash</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeleteChildTargetLocks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>newtargettag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>MaxPredicateChildLocks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckAndPromotePredicateLockRequest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>reqtag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecrementParentLocks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreatePredicateLock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>,
								<parameter><decl><type><name>uint32</name></type> <name>targettaghash</name></decl></parameter>,
								<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeleteLockTarget</name><parameter_list>(<parameter><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>targettaghash</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TransferPredicateLocksToNewTarget</name><parameter_list>(<parameter><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>oldtargettag</name></decl></parameter>,
											  <parameter><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>newtargettag</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name></type> <name>removeOld</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PredicateLockAcquire</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropAllPredicateLocksFromTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name></type> <name>transfer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetNewSxactGlobalXmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ClearOldPredicateLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseOneSerializableXact</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>partial</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>summarize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>XidIsConcurrent</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckTargetForConflictsIn</name><parameter_list>(<parameter><decl><type><name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FlagRWConflict</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>OnConflict_CheckForSerializationFailure</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>,
													<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateLocalPredicateLockHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleasePredicateLocksLocal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*------------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * Does this relation participate in predicate locking? Temporary and system
 * relations are exempt, as are materialized views.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>PredicateLockingNeededForRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name> <operator>&lt;</operator> <name>FirstBootstrapObjectId</name> <operator>||</operator>
			 <call><name>RelationUsesLocalBuffers</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * When a public interface method is called for a read, this is the test to
 * see if we should do a quick return.
 *
 * Note: this function has side-effects! If this transaction has been flagged
 * as RO-safe since the last call, we release all predicate locks and reset
 * MySerializableXact. That makes subsequent calls to return quickly.
 *
 * This is marked as 'inline' to eliminate the function call overhead in the
 * common case that serialization is not needed.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>SerializationNeededForRead</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Nothing to do if this is not a serializable transaction */</comment>
	<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't acquire locks or conflict when scanning with a special snapshot.
	 * This excludes things like CLUSTER and REINDEX. They use the wholesale
	 * functions TransferPredicateLocksToHeapRelation() and
	 * CheckTableForSerializableConflictIn() to participate in serialization,
	 * but the scans involved don't need serialization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check if we have just become "RO-safe". If we have, immediately release
	 * all locks as they're not needed anymore. This also resets
	 * MySerializableXact, so that subsequent calls to this function can exit
	 * quickly.
	 *
	 * A transaction is flagged as RO_SAFE if all concurrent R/W transactions
	 * commit without having conflicts out to an earlier snapshot, thus
	 * ensuring that no conflicts are possible for this transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SxactIsROSafe</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleasePredicateLocks</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if the relation doesn't participate in predicate locking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PredicateLockingNeededForRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>				<comment type="block">/* no excuse to skip predicate locking */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Like SerializationNeededForRead(), but called on writes.
 * The logic is the same, but there is no snapshot and we can't be RO-safe.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>SerializationNeededForWrite</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Nothing to do if this is not a serializable transaction */</comment>
	<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check if the relation doesn't participate in predicate locking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PredicateLockingNeededForRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>				<comment type="block">/* no excuse to skip predicate locking */</comment>
</block_content>}</block></function>


<comment type="block">/*------------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * These functions are a simple implementation of a list for this specific
 * type of struct.  If there is ever a generalized shared memory list, we
 * should probably switch to that.
 */</comment>
<function><type><specifier>static</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type>
<name>CreatePredXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PredXactListElement</name></type> <name>ptle</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptle</name> <operator>=</operator> <operator>(</operator><name>PredXactListElement</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PredXactListElementData</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptle</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptle</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>activeList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ptle</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>ptle</name><operator>-&gt;</operator><name>sxact</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleasePredXact</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PredXactListElement</name></type> <name>ptle</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ShmemAddrIsValid</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptle</name> <operator>=</operator> <operator>(</operator><name>PredXactListElement</name><operator>)</operator>
		<operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>sxact</name><operator>)</operator>
		 <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PredXactListElementData</name></expr></argument>, <argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
		 <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PredXactListElementData</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptle</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ptle</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type>
<name>FirstPredXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PredXactListElement</name></type> <name>ptle</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptle</name> <operator>=</operator> <operator>(</operator><name>PredXactListElement</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>activeList</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>activeList</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PredXactListElementData</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptle</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>ptle</name><operator>-&gt;</operator><name>sxact</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type>
<name>NextPredXact</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PredXactListElement</name></type> <name>ptle</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ShmemAddrIsValid</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptle</name> <operator>=</operator> <operator>(</operator><name>PredXactListElement</name><operator>)</operator>
		<operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>sxact</name><operator>)</operator>
		 <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PredXactListElementData</name></expr></argument>, <argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
		 <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PredXactListElementData</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptle</name> <operator>=</operator> <operator>(</operator><name>PredXactListElement</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>activeList</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>ptle</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PredXactListElementData</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptle</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>ptle</name><operator>-&gt;</operator><name>sxact</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * These functions manage primitive access to the RWConflict pool and lists.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RWConflictExists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RWConflict</name></type>	<name>conflict</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reader</name> <operator>!=</operator> <name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check the ends of the purported conflict first. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call>
		<operator>||</operator> <call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call>
		<operator>||</operator> <call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>)</argument_list></call>
		<operator>||</operator> <call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* A conflict is possible; walk the list to find out. */</comment>
	<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>conflict</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name></name> <operator>==</operator> <name>writer</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* No conflict found. */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetRWConflict</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RWConflict</name></type>	<name>conflict</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reader</name> <operator>!=</operator> <name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RWConflictExists</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>RWConflictPool</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>RWConflictPool</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conflict</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough elements in RWConflictPool to record a read/write conflict"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to run fewer transactions at a time or increase max_connections."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactOut</name></name> <operator>=</operator> <name>reader</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name></name> <operator>=</operator> <name>writer</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetPossibleUnsafeConflict</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>roXact</name></decl></parameter>,
						  <parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>activeXact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RWConflict</name></type>	<name>conflict</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>roXact</name> <operator>!=</operator> <name>activeXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>roXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>activeXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>RWConflictPool</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>RWConflictPool</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conflict</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough elements in RWConflictPool to record a potential read/write conflict"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to run fewer transactions at a time or increase max_connections."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactOut</name></name> <operator>=</operator> <name>activeXact</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name></name> <operator>=</operator> <name>roXact</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>activeXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>roXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseRWConflict</name><parameter_list>(<parameter><decl><type><name>RWConflict</name></type> <name>conflict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>RWConflictPool</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FlagSxactUnsafe</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RWConflict</name></type>	<name>conflict</name></decl>,
				<decl><type ref="prev"/><name>nextConflict</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SxactIsROSafe</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_RO_UNSAFE</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We know this isn't a safe snapshot, so we can stop looking for other
	 * potential conflicts.
	 */</comment>
	<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>conflict</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sxact</name> <operator>==</operator> <name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseRWConflict</name><argument_list>(<argument><expr><name>conflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>nextConflict</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * We will work on the page range of 0..OLDSERXID_MAX_PAGE.
 * Compares using wraparound logic, as is required by slru.c.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>OldSerXidPagePrecedesLogically</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>diff</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We have to compare modulo (OLDSERXID_MAX_PAGE+1)/2.  Both inputs should
	 * be in the range 0..OLDSERXID_MAX_PAGE.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>p</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;=</operator> <name>OLDSERXID_MAX_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q</name> <operator>&lt;=</operator> <name>OLDSERXID_MAX_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>q</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;=</operator> <operator>(</operator><operator>(</operator><name>OLDSERXID_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>diff</name> <operator>-=</operator> <name>OLDSERXID_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>diff</name> <operator>&lt;</operator> <operator>-</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>OLDSERXID_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>diff</name> <operator>+=</operator> <name>OLDSERXID_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>diff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize for the tracking of old serializable committed xids.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>OldSerXidInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set up SLRU management of the pg_serial data.
	 */</comment>
	<expr_stmt><expr><name><name>OldSerXidSlruCtl</name><operator>-&gt;</operator><name>PagePrecedes</name></name> <operator>=</operator> <name>OldSerXidPagePrecedesLogically</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SimpleLruInit</name><argument_list>(<argument><expr><name>OldSerXidSlruCtl</name></expr></argument>, <argument><expr><literal type="string">"oldserxid"</literal></expr></argument>,
				  <argument><expr><name>NUM_OLDSERXID_BUFFERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OldSerXidLock</name></expr></argument>, <argument><expr><literal type="string">"pg_serial"</literal></expr></argument>,
				  <argument><expr><name>LWTRANCHE_OLDSERXID_BUFFERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Override default assumption that writes should be fsync'd */</comment>
	<expr_stmt><expr><name><name>OldSerXidSlruCtl</name><operator>-&gt;</operator><name>do_fsync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create or attach to the OldSerXidControl structure.
	 */</comment>
	<expr_stmt><expr><name>oldSerXidControl</name> <operator>=</operator> <operator>(</operator><name>OldSerXidControl</name><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"OldSerXidControlData"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OldSerXidControlData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name> <operator>==</operator> <name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Set control information to reflect empty SLRU.
		 */</comment>
		<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headPage</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record a committed read write serializable xid and the minimum
 * commitSeqNo of any transactions to which this xid had a rw-conflict out.
 * An invalid seqNo means that there were no conflicts out from xid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>OldSerXidAdd</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>SerCommitSeqNo</name></type> <name>minConflictCommitSeqNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>tailXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>targetPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstZeroPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNewPage</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetPage</name> <operator>=</operator> <call><name>OldSerXidPage</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If no serializable transactions are active, there shouldn't be anything
	 * to push out to the SLRU.  Hitting this assert would mean there's
	 * something wrong with the earlier cleanup logic.
	 */</comment>
	<expr_stmt><expr><name>tailXid</name> <operator>=</operator> <name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>tailXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the SLRU is currently unused, zero out the whole active region from
	 * tailXid to headXid before taking it into use. Otherwise zero out only
	 * any new pages that enter the tailXid-headXid range as we advance
	 * headXid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headPage</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>firstZeroPage</name> <operator>=</operator> <call><name>OldSerXidPage</name><argument_list>(<argument><expr><name>tailXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isNewPage</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>firstZeroPage</name> <operator>=</operator> <call><name>OldSerXidNextPage</name><argument_list>(<argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isNewPage</name> <operator>=</operator> <call><name>OldSerXidPagePrecedesLogically</name><argument_list>(<argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headPage</name></name></expr></argument>,
												   <argument><expr><name>targetPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headXid</name></name></expr></argument>)</argument_list></call>
		<operator>||</operator> <call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headXid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNewPage</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headPage</name></name> <operator>=</operator> <name>targetPage</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isNewPage</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize intervening pages. */</comment>
		<while>while <condition>(<expr><name>firstZeroPage</name> <operator>!=</operator> <name>targetPage</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SimpleLruZeroPage</name><argument_list>(<argument><expr><name>OldSerXidSlruCtl</name></expr></argument>, <argument><expr><name>firstZeroPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>firstZeroPage</name> <operator>=</operator> <call><name>OldSerXidNextPage</name><argument_list>(<argument><expr><name>firstZeroPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruZeroPage</name><argument_list>(<argument><expr><name>OldSerXidSlruCtl</name></expr></argument>, <argument><expr><name>targetPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>OldSerXidSlruCtl</name></expr></argument>, <argument><expr><name>targetPage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>OldSerXidValue</name><argument_list>(<argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>minConflictCommitSeqNo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>OldSerXidSlruCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the minimum commitSeqNo for any conflict out for the given xid.  For
 * a transaction which exists but has no conflict out, InvalidSerCommitSeqNo
 * will be returned.
 */</comment>
<function><type><specifier>static</specifier> <name>SerCommitSeqNo</name></type>
<name>OldSerXidGetMinConflictCommitSeqNo</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>headXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>tailXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SerCommitSeqNo</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>headXid</name> <operator>=</operator> <name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tailXid</name> <operator>=</operator> <name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>headXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>tailXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>tailXid</name></expr></argument>)</argument_list></call>
		<operator>||</operator> <call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>headXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The following function must be called without holding OldSerXidLock,
	 * but will return with that lock held, which must then be released.
	 */</comment>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage_ReadOnly</name><argument_list>(<argument><expr><name>OldSerXidSlruCtl</name></expr></argument>,
										<argument><expr><call><name>OldSerXidPage</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OldSerXidValue</name><argument_list>(<argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call this whenever there is a new xmin for active serializable
 * transactions.  We don't need to keep information on transactions which
 * precede that.  InvalidTransactionId means none active, so everything in
 * the SLRU can be discarded.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>OldSerXidSetActiveSerXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When no sxacts are active, nothing overlaps, set the xid values to
	 * invalid to show that there are no valid entries.  Don't clear headPage,
	 * though.  A new xmin might still land on that page, and we don't want to
	 * repeatedly zero out the same page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When we're recovering prepared transactions, the global xmin might move
	 * backwards depending on the order they're recovered. Normally that's not
	 * OK, but during recovery no serializable transactions will commit, so
	 * the SLRU is empty and we can get away with it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headPage</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name></expr></argument>)</argument_list></call>
		   <operator>||</operator> <call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a checkpoint --- either during shutdown, or on-the-fly
 *
 * We don't have any data that needs to survive a restart, but this is a
 * convenient place to truncate the SLRU.
 */</comment>
<function><type><name>void</name></type>
<name>CheckPointPredicate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tailPage</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Exit quickly if the SLRU is currently not in use. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headPage</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can truncate the SLRU up to the page containing tailXid */</comment>
		<expr_stmt><expr><name>tailPage</name> <operator>=</operator> <call><name>OldSerXidPage</name><argument_list>(<argument><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>tailXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The SLRU is no longer needed. Truncate to head before we set head
		 * invalid.
		 *
		 * XXX: It's possible that the SLRU is not needed again until XID
		 * wrap-around has happened, so that the segment containing headPage
		 * that we leave behind will appear to be new again. In that case it
		 * won't be removed until XID horizon advances enough to make it
		 * current again.
		 */</comment>
		<expr_stmt><expr><name>tailPage</name> <operator>=</operator> <name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headPage</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldSerXidControl</name><operator>-&gt;</operator><name>headPage</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSerXidLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Truncate away pages that are no longer required */</comment>
	<expr_stmt><expr><call><name>SimpleLruTruncate</name><argument_list>(<argument><expr><name>OldSerXidSlruCtl</name></expr></argument>, <argument><expr><name>tailPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Flush dirty SLRU pages to disk
	 *
	 * This is not actually necessary from a correctness point of view. We do
	 * it merely as a debugging aid.
	 *
	 * We're doing this after the truncation to avoid writing pages right
	 * before deleting the file in which they sit, which would be completely
	 * pointless.
	 */</comment>
	<expr_stmt><expr><call><name>SimpleLruFlush</name><argument_list>(<argument><expr><name>OldSerXidSlruCtl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * InitPredicateLocks -- Initialize the predicate locking data structures.
 *
 * This is called from CreateSharedMemoryAndSemaphores(), which see for
 * more comments.  In the normal postmaster case, the shared hash tables
 * are created here.  Backends inherit the pointers
 * to the shared tables via fork().  In the EXEC_BACKEND case, each
 * backend re-executes this code to obtain pointers to the already existing
 * shared hash tables.
 */</comment>
<function><type><name>void</name></type>
<name>InitPredicateLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>max_table_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>requestSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Compute size of predicate lock target hashtable. Note these
	 * calculations must agree with PredicateLockShmemSize!
	 */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>=</operator> <call><name>NPREDICATELOCKTARGETENTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate hash table for PREDICATELOCKTARGET structs.  This stores
	 * per-predicate-lock-target information.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PREDICATELOCKTARGETTAG</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PREDICATELOCKTARGET</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>num_partitions</name></name> <operator>=</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>PredicateLockTargetHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"PREDICATELOCKTARGET hash"</literal></expr></argument>,
											<argument><expr><name>max_table_size</name></expr></argument>,
											<argument><expr><name>max_table_size</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
											<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator>
											<name>HASH_PARTITION</name> <operator>|</operator> <name>HASH_FIXED_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reserve a dummy entry in the hash table; we use it to make sure there's
	 * always one entry available when we need to split or combine a page,
	 * because running out of space there could mean aborting a
	 * non-serializable transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ScratchTargetTag</name></expr></argument>,
						   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Pre-calculate the hash and partition lock of the scratch entry */</comment>
	<expr_stmt><expr><name>ScratchTargetTagHash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ScratchTargetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ScratchPartitionLock</name> <operator>=</operator> <call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>ScratchTargetTagHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate hash table for PREDICATELOCK structs.  This stores per
	 * xact-lock-of-a-target information.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PREDICATELOCKTAG</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>predicatelock_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>num_partitions</name></name> <operator>=</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name></expr>;</expr_stmt>

	<comment type="block">/* Assume an average of 2 xacts per target */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>PredicateLockHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"PREDICATELOCK hash"</literal></expr></argument>,
									  <argument><expr><name>max_table_size</name></expr></argument>,
									  <argument><expr><name>max_table_size</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
									  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator>
									  <name>HASH_PARTITION</name> <operator>|</operator> <name>HASH_FIXED_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute size for serializable transaction hashtable. Note these
	 * calculations must agree with PredicateLockShmemSize!
	 */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>=</operator> <operator>(</operator><name>MaxBackends</name> <operator>+</operator> <name>max_prepared_xacts</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate a list to hold information on transactions participating in
	 * predicate locking.
	 *
	 * Assume an average of 10 predicate locking transactions per backend.
	 * This allows aggressive cleanup while detail is present before data must
	 * be summarized for storage in SLRU and the "dummy" transaction.
	 */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>PredXact</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"PredXactList"</literal></expr></argument>,
							   <argument><expr><name>PredXactListDataSize</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name> <operator>==</operator> <name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>activeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>WritableSxactCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>LastSxactCommitSeqNo</name></name> <operator>=</operator> <name>FirstNormalSerCommitSeqNo</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>CanPartialClearThrough</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>HavePartialClearedThrough</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>requestSize</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>max_table_size</name></expr></argument>,
							   <argument><expr><name>PredXactListElementDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>element</name></name> <operator>=</operator> <call><name>ShmemAlloc</name><argument_list>(<argument><expr><name>requestSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Add all elements to available list, clean. */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>element</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>requestSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_table_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>sxact</name><operator>.</operator><name>predicateLockListLock</name></name></expr></argument>,
							 <argument><expr><name>LWTRANCHE_SXACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>PredXact</name><operator>-&gt;</operator><name>availableList</name></name><operator>)</operator></expr></argument>,
								 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>PredXact</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>link</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name></name> <operator>=</operator> <call><name>CreatePredXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetInvalidVirtualTransactionId</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>vxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>prepareSeqNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>lastCommitBeforeSnapshot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>predicateLocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>finishedLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>topXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>finishedBefore</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>SXACT_FLAG_COMMITTED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* This never changes, so let's keep a local copy. */</comment>
	<expr_stmt><expr><name>OldCommittedSxact</name> <operator>=</operator> <name><name>PredXact</name><operator>-&gt;</operator><name>OldCommittedSxact</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate hash table for SERIALIZABLEXID structs.  This stores per-xid
	 * information for serializable transactions which have accessed data.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SERIALIZABLEXIDTAG</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SERIALIZABLEXID</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>SerializableXidHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"SERIALIZABLEXID hash"</literal></expr></argument>,
										<argument><expr><name>max_table_size</name></expr></argument>,
										<argument><expr><name>max_table_size</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
										<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator>
										<name>HASH_FIXED_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate space for tracking rw-conflicts in lists attached to the
	 * transactions.
	 *
	 * Assume an average of 5 conflicts per transaction.  Calculations suggest
	 * that this will prevent resource exhaustion in even the most pessimal
	 * loads up to max_connections = 200 with all 200 connections pounding the
	 * database with serializable transactions.  Beyond that, there may be
	 * occasional transactions canceled when trying to flag conflicts. That's
	 * probably OK.
	 */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>*=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>RWConflictPool</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"RWConflictPool"</literal></expr></argument>,
									 <argument><expr><name>RWConflictPoolHeaderDataSize</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name> <operator>==</operator> <name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>RWConflictPool</name><operator>-&gt;</operator><name>availableList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>requestSize</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>max_table_size</name></expr></argument>,
							   <argument><expr><name>RWConflictDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RWConflictPool</name><operator>-&gt;</operator><name>element</name></name> <operator>=</operator> <call><name>ShmemAlloc</name><argument_list>(<argument><expr><name>requestSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Add all elements to available list, clean. */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>RWConflictPool</name><operator>-&gt;</operator><name>element</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>requestSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_table_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>RWConflictPool</name><operator>-&gt;</operator><name>availableList</name></name><operator>)</operator></expr></argument>,
								 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>RWConflictPool</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>outLink</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create or attach to the header for the list of finished serializable
	 * transactions.
	 */</comment>
	<expr_stmt><expr><name>FinishedSerializableTransactions</name> <operator>=</operator> <operator>(</operator><name>SHM_QUEUE</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"FinishedSerializableTransactions"</literal></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SHM_QUEUE</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name> <operator>==</operator> <name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><name>FinishedSerializableTransactions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize the SLRU storage for old committed serializable
	 * transactions.
	 */</comment>
	<expr_stmt><expr><call><name>OldSerXidInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate shared-memory space used for predicate lock table
 */</comment>
<function><type><name>Size</name></type>
<name>PredicateLockShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>max_table_size</name></decl>;</decl_stmt>

	<comment type="block">/* predicate lock target hash table */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>=</operator> <call><name>NPREDICATELOCKTARGETENTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>max_table_size</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREDICATELOCKTARGET</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* predicate lock hash table */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>max_table_size</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since NPREDICATELOCKTARGETENTS is only an estimate, add 10% safety
	 * margin.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* transaction list */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>=</operator> <name>MaxBackends</name> <operator>+</operator> <name>max_prepared_xacts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_table_size</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>PredXactListDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>max_table_size</name></expr></argument>,
								   <argument><expr><name>PredXactListElementDataSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* transaction xid table */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>max_table_size</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SERIALIZABLEXID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rw-conflict pool */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>*=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>RWConflictPoolHeaderDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>max_table_size</name></expr></argument>,
								   <argument><expr><name>RWConflictDataSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Head for list of finished serializable transactions. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SHM_QUEUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shared memory structures for SLRU tracking of old committed xids. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OldSerXidControlData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>SimpleLruShmemSize</name><argument_list>(<argument><expr><name>NUM_OLDSERXID_BUFFERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Compute the hash code associated with a PREDICATELOCKTAG.
 *
 * Because we want to use just one set of partition locks for both the
 * PREDICATELOCKTARGET and PREDICATELOCK hash tables, we have to make sure
 * that PREDICATELOCKs fall into the same partition number as their
 * associated PREDICATELOCKTARGETs.  dynahash.c expects the partition number
 * to be the low-order bits of the hash code, and therefore a
 * PREDICATELOCKTAG's hash code must have the same low-order bits as the
 * associated PREDICATELOCKTARGETTAG's hash code.  We achieve this with this
 * specialized hash function.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>predicatelock_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PREDICATELOCKTAG</name> <modifier>*</modifier></type><name>predicatelocktag</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>PREDICATELOCKTAG</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>targethash</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PREDICATELOCKTAG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look into the associated target object, and compute its hash code */</comment>
	<expr_stmt><expr><name>targethash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>predicatelocktag</name><operator>-&gt;</operator><name>myTarget</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><name>predicatelocktag</name></expr></argument>, <argument><expr><name>targethash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetPredicateLockStatusData
 *		Return a table containing the internal state of the predicate
 *		lock manager for use in pg_lock_status.
 *
 * Like GetLockStatusData, this function tries to hold the partition LWLocks
 * for as short a time as possible by returning two arrays that simply
 * contain the PREDICATELOCKTARGETTAG and SERIALIZABLEXACT for each lock
 * table entry. Multiple copies of the same PREDICATELOCKTARGETTAG and
 * SERIALIZABLEXACT will likely appear.
 */</comment>
<function><type><name>PredicateLockData</name> <modifier>*</modifier></type>
<name>GetPredicateLockStatusData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PredicateLockData</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>els</name></decl>,
				<decl><type ref="prev"/><name>el</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seqstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>predlock</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>PredicateLockData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PredicateLockData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To ensure consistency, take simultaneous locks on all partition locks
	 * in ascending order, then SerializableXactHashLock.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>PredicateLockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get number of locks and allocate appropriately-sized arrays. */</comment>
	<expr_stmt><expr><name>els</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>nelements</name></name> <operator>=</operator> <name>els</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>locktags</name></name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCKTARGETTAG</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREDICATELOCKTARGETTAG</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>els</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>xacts</name></name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXACT</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SERIALIZABLEXACT</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>els</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* Scan through PredicateLockHash and copy contents */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>, <argument><expr><name>PredicateLockHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>el</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>predlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>locktags</name><index>[<expr><name>el</name></expr>]</index></name> <operator>=</operator> <name><name>predlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myTarget</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>xacts</name><index>[<expr><name>el</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name><name>predlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myXact</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>el</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>el</name> <operator>==</operator> <name>els</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release locks in reverse order */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PredicateLockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free up shared memory structures by pushing the oldest sxact (the one at
 * the front of the SummarizeOldestCommittedSxact queue) into summary form.
 * Each call will free exactly one SERIALIZABLEXACT structure and may also
 * free one or more of these structures: SERIALIZABLEXID, PREDICATELOCK,
 * PREDICATELOCKTARGET, RWConflictData.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SummarizeOldestCommittedSxact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableFinishedListLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This function is only called if there are no sxact slots available.
	 * Some of them must belong to old, already-finished transactions, so
	 * there should be something in FinishedSerializableTransactions list that
	 * we can summarize. However, there's a race condition: while we were not
	 * holding any locks, a transaction might have ended and cleaned up all
	 * the finished sxact entries already, freeing up their sxact slots. In
	 * that case, we have nothing to do here. The caller will find one of the
	 * slots released by the other backend when it retries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><name>FinishedSerializableTransactions</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableFinishedListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Grab the first sxact off the finished list -- this will be the earliest
	 * commit.  Remove it from the list.
	 */</comment>
	<expr_stmt><expr><name>sxact</name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXACT</name> <operator>*</operator><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>FinishedSerializableTransactions</name></expr></argument>,
					 <argument><expr><name>FinishedSerializableTransactions</name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SERIALIZABLEXACT</name></expr></argument>, <argument><expr><name>finishedLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>finishedLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add to SLRU summary information. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>topXid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>OldSerXidAdd</name><argument_list>(<argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>topXid</name></name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>SxactHasConflictOut</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>
					 ?</condition><then> <expr><name><name>sxact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>earliestOutConflictCommit</name></name></expr> </then><else>: <expr><name>InvalidSerCommitSeqNo</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Summarize and release the detail. */</comment>
	<expr_stmt><expr><call><name>ReleaseOneSerializableXact</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableFinishedListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetSafeSnapshot
 *		Obtain and register a snapshot for a READ ONLY DEFERRABLE
 *		transaction. Ensures that the snapshot is "safe", i.e. a
 *		read-only transaction running on it can execute serializably
 *		without further checks. This requires waiting for concurrent
 *		transactions to complete, and retrying with a new snapshot if
 *		one of them could possibly create a conflict.
 *
 *		As with GetSerializableTransactionSnapshot (which this is a subroutine
 *		for), the passed-in Snapshot pointer should reference a static data
 *		area that can safely be passed to GetSnapshotData.
 */</comment>
<function><type><specifier>static</specifier> <name>Snapshot</name></type>
<name>GetSafeSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>origSnapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <name>XactDeferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * GetSerializableTransactionSnapshotInt is going to call
		 * GetSnapshotData, so we need to provide it the static snapshot area
		 * our caller passed to us.  The pointer returned is actually the same
		 * one passed to it, but we avoid assuming that here.
		 */</comment>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetSerializableTransactionSnapshotInt</name><argument_list>(<argument><expr><name>origSnapshot</name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>snapshot</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no concurrent r/w xacts; it's safe */</comment>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Wait for concurrent transactions to finish. Stop early if one of
		 * them marked us as conflicted.
		 */</comment>
		<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_DEFERRABLE_WAITING</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>!</operator><operator>(</operator><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				 <call><name>SxactIsROUnsafe</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcWaitForSignal</name><argument_list>(<argument><expr><name>WAIT_EVENT_SAFE_SNAPSHOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SXACT_FLAG_DEFERRABLE_WAITING</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SxactIsROUnsafe</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>				<comment type="block">/* success */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* else, need to retry... */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"deferrable snapshot was unsafe; trying a new one"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleasePredicateLocks</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Now we have a safe snapshot, so we don't need to do any further checks.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SxactIsROSafe</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleasePredicateLocks</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>snapshot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetSafeSnapshotBlockingPids
 *		If the specified process is currently blocked in GetSafeSnapshot,
 *		write the process IDs of all processes that it is blocked by
 *		into the caller-supplied buffer output[].  The list is truncated at
 *		output_size, and the number of PIDs written into the buffer is
 *		returned.  Returns zero if the given PID is not currently blocked
 *		in GetSafeSnapshot.
 */</comment>
<function><type><name>int</name></type>
<name>GetSafeSnapshotBlockingPids</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>blocked_pid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>output_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find blocked_pid's SERIALIZABLEXACT by linear search. */</comment>
	<for>for <control>(<init><expr><name>sxact</name> <operator>=</operator> <call><name>FirstPredXact</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>sxact</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>sxact</name> <operator>=</operator> <call><name>NextPredXact</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sxact</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>blocked_pid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Did we find it, and is it currently waiting in GetSafeSnapshot? */</comment>
	<if_stmt><if>if <condition>(<expr><name>sxact</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>SxactIsDeferrableWaiting</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RWConflict</name></type>	<name>possibleUnsafeConflict</name></decl>;</decl_stmt>

		<comment type="block">/* Traverse the list of possible unsafe conflicts collecting PIDs. */</comment>
		<expr_stmt><expr><name>possibleUnsafeConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>possibleUnsafeConflict</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>num_written</name> <operator>&lt;</operator> <name>output_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>output</name><index>[<expr><name>num_written</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>possibleUnsafeConflict</name><operator>-&gt;</operator><name>sxactOut</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>possibleUnsafeConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>possibleUnsafeConflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>num_written</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire a snapshot that can be used for the current transaction.
 *
 * Make sure we have a SERIALIZABLEXACT reference in MySerializableXact.
 * It should be current for this process and be contained in PredXact.
 *
 * The passed-in Snapshot pointer should reference a static data area that
 * can safely be passed to GetSnapshotData.  The return value is actually
 * always this same pointer; no new snapshot data structure is allocated
 * within this function.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>GetSerializableTransactionSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Can't use serializable mode while recovery is still active, as it is,
	 * for example, on a hot standby.  We could get here despite the check in
	 * check_XactIsoLevel() if default_transaction_isolation is set to
	 * serializable, so phrase the hint accordingly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use serializable mode in a hot standby"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"default_transaction_isolation\" is set to \"serializable\"."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can use \"SET default_transaction_isolation = 'repeatable read'\" to change the default."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A special optimization is available for SERIALIZABLE READ ONLY
	 * DEFERRABLE transactions -- we can wait for a suitable snapshot and
	 * thereby avoid all SSI overhead once it's running.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <name>XactDeferrable</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>GetSafeSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>GetSerializableTransactionSnapshotInt</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidPid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Import a snapshot to be used for the current transaction.
 *
 * This is nearly the same as GetSerializableTransactionSnapshot, except that
 * we don't take a new snapshot, but rather use the data we're handed.
 *
 * The caller must have verified that the snapshot came from a serializable
 * transaction; and if we're read-write, the source transaction must not be
 * read-only.
 */</comment>
<function><type><name>void</name></type>
<name>SetSerializableTransactionSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
								   <parameter><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>sourcevxid</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>sourcepid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is called by parallel.c in a parallel worker, we don't want to
	 * create a SERIALIZABLEXACT just yet because the leader's
	 * SERIALIZABLEXACT will be installed with AttachSerializableXact().  We
	 * also don't want to reject SERIALIZABLE READ ONLY DEFERRABLE in this
	 * case, because the leader has already determined that the snapshot it
	 * has passed us is safe.  So there is nothing for us to do.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We do not allow SERIALIZABLE READ ONLY DEFERRABLE transactions to
	 * import snapshots, since there's no way to wait for a safe snapshot when
	 * we're using the snap we're told to.  (XXX instead of throwing an error,
	 * we could just ignore the XactDeferrable flag?)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <name>XactDeferrable</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a snapshot-importing transaction must not be READ ONLY DEFERRABLE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetSerializableTransactionSnapshotInt</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>sourcevxid</name></expr></argument>,
												 <argument><expr><name>sourcepid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Guts of GetSerializableTransactionSnapshot
 *
 * If sourcexid is valid, this is actually an import operation and we should
 * skip calling GetSnapshotData, because the snapshot contents are already
 * loaded up.  HOWEVER: to avoid race conditions, we must check that the
 * source xact is still running after we acquire SerializableXactHashLock.
 * We do that by calling ProcArrayInstallImportedXmin.
 */</comment>
<function><type><specifier>static</specifier> <name>Snapshot</name></type>
<name>GetSerializableTransactionSnapshotInt</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
									  <parameter><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>sourcevxid</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>sourcepid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>othersxact</name></decl>;</decl_stmt>

	<comment type="block">/* We only do this for serializable transactions.  Once. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since all parts of a serializable transaction must use the same
	 * snapshot, it is too late to establish one after a parallel operation
	 * has begun.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot establish serializable snapshot during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First we get the sxact structure, which may involve looping and access
	 * to the "finished" list to free a structure for use.
	 *
	 * We must hold SerializableXactHashLock when taking/checking the snapshot
	 * to avoid race conditions, for much the same reasons that
	 * GetSnapshotData takes the ProcArrayLock.  Since we might have to
	 * release SerializableXactHashLock to call SummarizeOldestCommittedSxact,
	 * this means we have to create the sxact first, which is a bit annoying
	 * (in particular, an elog(ERROR) in procarray.c would cause us to leak
	 * the sxact).  Consider refactoring to avoid this.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEST_OLDSERXID</name></cpp:ifdef>
	<expr_stmt><expr><call><name>SummarizeOldestCommittedSxact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>sxact</name> <operator>=</operator> <call><name>CreatePredXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If null, push out committed sxact to SLRU summary &amp; retry. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sxact</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SummarizeOldestCommittedSxact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>sxact</name></expr>)</condition>;</do>

	<comment type="block">/* Get the snapshot, or check that it's safe to use */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sourcevxid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetSnapshotData</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ProcArrayInstallImportedXmin</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name>sourcevxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleasePredXact</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not import the requested snapshot"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The source process with PID %d is not running anymore."</literal></expr></argument>,
						   <argument><expr><name>sourcepid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there are no serializable transactions which are not read-only, we
	 * can "opt out" of predicate locking and conflict checking for a
	 * read-only transaction.
	 *
	 * The reason this is safe is that a read-only transaction can only become
	 * part of a dangerous structure if it overlaps a writable transaction
	 * which in turn overlaps a writable transaction which committed before
	 * the read-only transaction started.  A new writable transaction can
	 * overlap this one, but it can't meet the other condition of overlapping
	 * a transaction which committed before this one started.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <name><name>PredXact</name><operator>-&gt;</operator><name>WritableSxactCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleasePredXact</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>snapshot</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Maintain serializable global xmin info. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>OldSerXidSetActiveSerXmin</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Initialize the structure. */</comment>
	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>vxid</name></name> <operator>=</operator> <name>vxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>lastCommitBeforeSnapshot</name></name> <operator>=</operator> <name><name>PredXact</name><operator>-&gt;</operator><name>LastSxactCommitSeqNo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>prepareSeqNo</name></name> <operator>=</operator> <name>InvalidSerCommitSeqNo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <name>InvalidSerCommitSeqNo</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>outConflicts</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>inConflicts</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>topXid</name></name> <operator>=</operator> <call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>finishedBefore</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueElemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>finishedLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>XactReadOnly</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_READ_ONLY</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Register all concurrent r/w transactions as possible conflicts; if
		 * all of them commit without any outgoing conflicts to earlier
		 * transactions then this snapshot can be deemed safe (and we can run
		 * without tracking predicate locks).
		 */</comment>
		<for>for <control>(<init><expr><name>othersxact</name> <operator>=</operator> <call><name>FirstPredXact</name><argument_list>()</argument_list></call></expr>;</init>
			 <condition><expr><name>othersxact</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
			 <incr><expr><name>othersxact</name> <operator>=</operator> <call><name>NextPredXact</name><argument_list>(<argument><expr><name>othersxact</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>othersxact</name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>othersxact</name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>othersxact</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SetPossibleUnsafeConflict</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>, <argument><expr><name>othersxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>PredXact</name><operator>-&gt;</operator><name>WritableSxactCount</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>WritableSxactCount</name></name> <operator>&lt;=</operator>
			   <operator>(</operator><name>MaxBackends</name> <operator>+</operator> <name>max_prepared_xacts</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>MySerializableXact</name> <operator>=</operator> <name>sxact</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyXactDidWrite</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* haven't written anything yet */</comment>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CreateLocalPredicateLockHash</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>snapshot</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateLocalPredicateLockHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize the backend-local hash table of parent locks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PREDICATELOCKTARGETTAG</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LOCALPREDICATELOCK</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>LocalPredicateLockHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Local predicate lock"</literal></expr></argument>,
										 <argument><expr><name>max_predicate_locks_per_xact</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
										 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register the top level XID in SerializableXidHash.
 * Also store it for easy reference in MySerializableXact.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterPredicateLockingXid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SERIALIZABLEXIDTAG</name></type> <name>sxidtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXID</name> <modifier>*</modifier></type><name>sxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're not tracking predicate lock data for this transaction, we
	 * should ignore the request and return quickly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We should have a valid XID and be at the top level. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This should only be done once per transaction. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>topXid</name></name> <operator>==</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>topXid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sxidtag</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sxid</name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXID</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SerializableXidHash</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>sxidtag</name></expr></argument>,
										   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the structure. */</comment>
	<expr_stmt><expr><name><name>sxid</name><operator>-&gt;</operator><name>myXact</name></name> <operator>=</operator> <name>MySerializableXact</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether there are any predicate locks held by any transaction
 * for the page at the given block number.
 *
 * Note that the transaction may be completed but not yet subject to
 * cleanup due to overlapping serializable transactions.  This must
 * return valid information regardless of transaction isolation level.
 *
 * Also note that this doesn't check for a conflicting relation lock,
 * just a lock specifically on the given page.
 *
 * One use is to support proper behavior during GiST index vacuum.
 */</comment>
<function><type><name>bool</name></type>
<name>PageIsPredicateLocked</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>targettag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>targettaghash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_PAGE</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>,
									<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
									<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>targettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCKTARGET</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>,
									<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>target</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether a particular lock is held by this transaction.
 *
 * Important note: this function may return false even if the lock is
 * being held, because it uses the local lock table which is not
 * updated if another transaction modifies our lock list (e.g. to
 * split an index page). It can also return true when a coarser
 * granularity lock that covers this target is being held. Be careful
 * to only use this function in circumstances where such errors are
 * acceptable!
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PredicateLockExists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCALPREDICATELOCK</name> <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>

	<comment type="block">/* check local hash table */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCALPREDICATELOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name></expr></argument>,
											  <argument><expr><name>targettag</name></expr></argument>,
											  <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Found entry in the table, but still need to check whether it's actually
	 * held -- it could just be a parent of some held lock.
	 */</comment>
	<return>return <expr><name><name>lock</name><operator>-&gt;</operator><name>held</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the parent lock tag in the lock hierarchy: the next coarser
 * lock that covers the provided tag.
 *
 * Returns true and sets *parent to the parent tag if one exists,
 * returns false if none exists.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>GetParentPredicateLockTag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>,
						  <parameter><decl><type><name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>GET_PREDICATELOCKTARGETTAG_TYPE</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PREDLOCKTAG_RELATION</name></expr>:</case>
			<comment type="block">/* relation locks have no parent lock */</comment>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>PREDLOCKTAG_PAGE</name></expr>:</case>
			<comment type="block">/* parent lock is relation lock */</comment>
			<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><operator>*</operator><name>parent</name></expr></argument>,
												<argument><expr><call><name>GET_PREDICATELOCKTARGETTAG_DB</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>GET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>PREDLOCKTAG_TUPLE</name></expr>:</case>
			<comment type="block">/* parent lock is page lock */</comment>
			<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_PAGE</name><argument_list>(<argument><expr><operator>*</operator><name>parent</name></expr></argument>,
											<argument><expr><call><name>GET_PREDICATELOCKTARGETTAG_DB</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>GET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>GET_PREDICATELOCKTARGETTAG_PAGE</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/* not reachable */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the lock we are considering is already covered by a
 * coarser lock for our transaction.
 *
 * Like PredicateLockExists, this function might return a false
 * negative, but it will never return a false positive.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CoarserLockCovers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>newtargettag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>targettag</name></decl>,
				<decl><type ref="prev"/><name>parenttag</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>targettag</name> <operator>=</operator> <operator>*</operator><name>newtargettag</name></expr>;</expr_stmt>

	<comment type="block">/* check parents iteratively until no more */</comment>
	<while>while <condition>(<expr><call><name>GetParentPredicateLockTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parenttag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>targettag</name> <operator>=</operator> <name>parenttag</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PredicateLockExists</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* no more parents to check; lock is not covered */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the dummy entry from the predicate lock target hash, to free up some
 * scratch space. The caller must be holding SerializablePredicateLockListLock,
 * and must restore the entry with RestoreScratchTarget() before releasing the
 * lock.
 *
 * If lockheld is true, the caller is already holding the partition lock
 * of the partition containing the scratch entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveScratchTarget</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>lockheld</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockheld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ScratchPartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>ScratchTargetTag</name></expr></argument>,
								<argument><expr><name>ScratchTargetTagHash</name></expr></argument>,
								<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockheld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ScratchPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Re-insert the dummy entry in predicate lock target hash.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RestoreScratchTarget</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>lockheld</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockheld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ScratchPartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>ScratchTargetTag</name></expr></argument>,
								<argument><expr><name>ScratchTargetTagHash</name></expr></argument>,
								<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockheld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ScratchPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the list of related predicate locks is empty for a
 * predicate lock target, and remove the target if it is.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveTargetIfNoLongerUsed</name><parameter_list>(<parameter><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>targettaghash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier><name>rmtarget</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't remove it until no locks at this target. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Actually remove the target. */</comment>
	<expr_stmt><expr><name>rmtarget</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
										   <argument><expr><name>targettaghash</name></expr></argument>,
										   <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rmtarget</name> <operator>==</operator> <name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete child target locks owned by this process.
 * This implementation is assuming that the usage of each target tag field
 * is uniform.  No need to make this hard if we don't have to.
 *
 * We acquire an LWLock in the case of parallel mode, because worker
 * backends have access to the leader's SERIALIZABLEXACT.  Otherwise,
 * we aren't acquiring LWLocks for the predicate lock or lock
 * target structures associated with this transaction unless we're going
 * to modify them, because no other process is permitted to modify our
 * locks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeleteChildTargetLocks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>newtargettag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>predlock</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sxact</name> <operator>=</operator> <name>MySerializableXact</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLockListLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>predlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>xactLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>predlock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>predlocksxactlink</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>nextpredlock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCKTAG</name></type> <name>oldlocktag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>oldtarget</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>oldtargettag</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>predlocksxactlink</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><name>predlocksxactlink</name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>xactLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldlocktag</name> <operator>=</operator> <name><name>predlock</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldlocktag</name><operator>.</operator><name>myXact</name></name> <operator>==</operator> <name>sxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldtarget</name> <operator>=</operator> <name><name>oldlocktag</name><operator>.</operator><name>myTarget</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldtargettag</name> <operator>=</operator> <name><name>oldtarget</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TargetTagIsCoveredBy</name><argument_list>(<argument><expr><name>oldtargettag</name></expr></argument>, <argument><expr><operator>*</operator><name>newtargettag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>oldtargettaghash</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier><name>rmpredlock</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldtargettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldtargettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>oldtargettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><name>predlocksxactlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rmpredlock</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name>
				<argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name>oldlocktag</name></expr></argument>,
				 <argument><expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldlocktag</name></expr></argument>,
														 <argument><expr><name>oldtargettaghash</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rmpredlock</name> <operator>==</operator> <name>predlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>RemoveTargetIfNoLongerUsed</name><argument_list>(<argument><expr><name>oldtarget</name></expr></argument>, <argument><expr><name>oldtargettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>DecrementParentLocks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldtargettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>predlock</name> <operator>=</operator> <name>nextpredlock</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLockListLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the promotion limit for a given predicate lock target.  This is the
 * max number of descendant locks allowed before promoting to the specified
 * tag. Note that the limit includes non-direct descendants (e.g., both tuples
 * and pages for a relation lock).
 *
 * Currently the default limit is 2 for a page lock, and half of the value of
 * max_pred_locks_per_transaction - 1 for a relation lock, to match behavior
 * of earlier releases when upgrading.
 *
 * TODO SSI: We should probably add additional GUCs to allow a maximum ratio
 * of page and tuple locks based on the pages in a relation, and the maximum
 * ratio of tuple locks to tuples in a page.  This would provide more
 * generally "balanced" allocation of locks to where they are most useful,
 * while still allowing the absolute numbers to prevent one relation from
 * tying up all predicate lock resources.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>MaxPredicateChildLocks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>GET_PREDICATELOCKTARGETTAG_TYPE</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PREDLOCKTAG_RELATION</name></expr>:</case>
			<return>return <expr><ternary><condition><expr><name>max_predicate_locks_per_relation</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
				?</condition><then> <expr><operator>(</operator><name>max_predicate_locks_per_xact</name>
				   <operator>/</operator> <operator>(</operator><operator>-</operator><name>max_predicate_locks_per_relation</name><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>
				</then><else>: <expr><name>max_predicate_locks_per_relation</name></expr></else></ternary></expr>;</return>

		<case>case <expr><name>PREDLOCKTAG_PAGE</name></expr>:</case>
			<return>return <expr><name>max_predicate_locks_per_page</name></expr>;</return>

		<case>case <expr><name>PREDLOCKTAG_TUPLE</name></expr>:</case>

			<comment type="block">/*
			 * not reachable: nothing is finer-granularity than a tuple, so we
			 * should never try to promote to it.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/* not reachable */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For all ancestors of a newly-acquired predicate lock, increment
 * their child count in the parent hash table. If any of them have
 * more descendants than their promotion threshold, acquire the
 * coarsest such lock.
 *
 * Returns true if a parent lock was acquired and false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckAndPromotePredicateLockRequest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>reqtag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>targettag</name></decl>,
				<decl><type ref="prev"/><name>nexttag</name></decl>,
				<decl><type ref="prev"/><name>promotiontag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALPREDICATELOCK</name> <modifier>*</modifier></type><name>parentlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>,
				<decl><type ref="prev"/><name>promote</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>promote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>targettag</name> <operator>=</operator> <operator>*</operator><name>reqtag</name></expr>;</expr_stmt>

	<comment type="block">/* check parents iteratively */</comment>
	<while>while <condition>(<expr><call><name>GetParentPredicateLockTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nexttag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>targettag</name> <operator>=</operator> <name>nexttag</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentlock</name> <operator>=</operator> <operator>(</operator><name>LOCALPREDICATELOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>,
														<argument><expr><name>HASH_ENTER</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>parentlock</name><operator>-&gt;</operator><name>held</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parentlock</name><operator>-&gt;</operator><name>childLocks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>parentlock</name><operator>-&gt;</operator><name>childLocks</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parentlock</name><operator>-&gt;</operator><name>childLocks</name></name> <operator>&gt;</operator>
			<call><name>MaxPredicateChildLocks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We should promote to this parent lock. Continue to check its
			 * ancestors, however, both to get their child counts right and to
			 * check whether we should just go ahead and promote to one of
			 * them.
			 */</comment>
			<expr_stmt><expr><name>promotiontag</name> <operator>=</operator> <name>targettag</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>promote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>promote</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* acquire coarsest ancestor eligible for promotion */</comment>
		<expr_stmt><expr><call><name>PredicateLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>promotiontag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When releasing a lock, decrement the child count on all ancestor
 * locks.
 *
 * This is called only when releasing a lock via
 * DeleteChildTargetLocks (i.e. when a lock becomes redundant because
 * we've acquired its parent, possibly due to promotion) or when a new
 * MVCC write lock makes the predicate lock unnecessary. There's no
 * point in calling it when locks are released at transaction end, as
 * this information is no longer needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecrementParentLocks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>parenttag</name></decl>,
				<decl><type ref="prev"/><name>nexttag</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>parenttag</name> <operator>=</operator> <operator>*</operator><name>targettag</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>GetParentPredicateLockTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parenttag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nexttag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>targettaghash</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCALPREDICATELOCK</name> <modifier>*</modifier></type><name>parentlock</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>rmlock</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parenttag</name> <operator>=</operator> <name>nexttag</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parenttag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentlock</name> <operator>=</operator> <operator>(</operator><name>LOCALPREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>parenttag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>,
										<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * There's a small chance the parent lock doesn't exist in the lock
		 * table. This can happen if we prematurely removed it because an
		 * index split caused the child refcount to be off.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>parentlock</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>parentlock</name><operator>-&gt;</operator><name>childLocks</name></name><operator>--</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Under similar circumstances the parent lock's refcount might be
		 * zero. This only happens if we're holding that lock (otherwise we
		 * would have removed the entry).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parentlock</name><operator>-&gt;</operator><name>childLocks</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentlock</name><operator>-&gt;</operator><name>held</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parentlock</name><operator>-&gt;</operator><name>childLocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>parentlock</name><operator>-&gt;</operator><name>childLocks</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>parentlock</name><operator>-&gt;</operator><name>held</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rmlock</name> <operator>=</operator> <operator>(</operator><name>LOCALPREDICATELOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>parenttag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>,
											<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rmlock</name> <operator>==</operator> <name>parentlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Indicate that a predicate lock on the given target is held by the
 * specified transaction. Has no effect if the lock is already held.
 *
 * This updates the lock table and the sxact's lock list, and creates
 * the lock target if necessary, but does *not* do anything related to
 * granularity promotion or the local lock table. See
 * PredicateLockAcquire for that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreatePredicateLock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>,
					<parameter><decl><type><name>uint32</name></type> <name>targettaghash</name></decl></parameter>,
					<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCKTAG</name></type> <name>locktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLockListLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure that the target is represented. */</comment>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCKTARGET</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>,
									<argument><expr><name>targettag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>,
									<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_pred_locks_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We've got the sxact and target, make sure they're joined. */</comment>
	<expr_stmt><expr><name><name>locktag</name><operator>.</operator><name>myTarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locktag</name><operator>.</operator><name>myXact</name></name> <operator>=</operator> <name>sxact</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locktag</name></expr></argument>,
									<argument><expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_pred_locks_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <name>InvalidSerCommitSeqNo</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLockListLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire a predicate lock on the specified target for the current
 * connection if not already held. This updates the local lock table
 * and uses it to implement granularity promotion. It will consolidate
 * multiple locks into a coarser lock if warranted, and will release
 * any finer-grained locks covered by the new one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PredicateLockAcquire</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>targettaghash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALPREDICATELOCK</name> <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>

	<comment type="block">/* Do we have the lock already, or a covering lock? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PredicateLockExists</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CoarserLockCovers</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* the same hash and LW lock apply to the lock target and the local lock. */</comment>
	<expr_stmt><expr><name>targettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Acquire lock in local table */</comment>
	<expr_stmt><expr><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALPREDICATELOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name></expr></argument>,
									<argument><expr><name>targettag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>,
									<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>held</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>childLocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Actually create the lock */</comment>
	<expr_stmt><expr><call><name>CreatePredicateLock</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>, <argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock has been acquired. Check whether it should be promoted to a
	 * coarser granularity, or whether there are finer-granularity locks to
	 * clean up.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CheckAndPromotePredicateLockRequest</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Lock request was promoted to a coarser-granularity lock, and that
		 * lock was acquired. It will delete this lock and any of its
		 * children, so we're done.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Clean up any finer-granularity locks */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GET_PREDICATELOCKTARGETTAG_TYPE</name><argument_list>(<argument><expr><operator>*</operator><name>targettag</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PREDLOCKTAG_TUPLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DeleteChildTargetLocks</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		PredicateLockRelation
 *
 * Gets a predicate lock at the relation level.
 * Skip if not in full serializable transaction isolation level.
 * Skip if this is a temporary table.
 * Clear any finer-grained predicate locks this session has on the relation.
 */</comment>
<function><type><name>void</name></type>
<name>PredicateLockRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>tag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SerializationNeededForRead</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
										<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PredicateLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		PredicateLockPage
 *
 * Gets a predicate lock at the page level.
 * Skip if not in full serializable transaction isolation level.
 * Skip if this is a temporary table.
 * Skip if a coarser predicate lock already covers this page.
 * Clear any finer-grained predicate locks this session has on the relation.
 */</comment>
<function><type><name>void</name></type>
<name>PredicateLockPage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>tag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SerializationNeededForRead</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_PAGE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
									<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
									<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PredicateLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		PredicateLockTuple
 *
 * Gets a predicate lock at the tuple level.
 * Skip if not in full serializable transaction isolation level.
 * Skip if this is a temporary table.
 */</comment>
<function><type><name>void</name></type>
<name>PredicateLockTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>targetxmin</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SerializationNeededForRead</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's a heap tuple, return if this xact wrote it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>myxid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>targetxmin</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>myxid</name> <operator>=</operator> <call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>myxid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>targetxmin</name></expr></argument>, <argument><expr><name>TransactionXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>SubTransGetTopmostTransaction</name><argument_list>(<argument><expr><name>targetxmin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>myxid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* We wrote it; we already have a write lock. */</comment>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do quick-but-not-definitive test for a relation lock first.  This will
	 * never cause a return when the relation is *not* locked, but will
	 * occasionally let the check continue when there really *is* a relation
	 * level lock.
	 */</comment>
	<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
										<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PredicateLockExists</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tid</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_TUPLE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
									 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
									 <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PredicateLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		DeleteLockTarget
 *
 * Remove a predicate lock target along with any locks held for it.
 *
 * Caller must hold SerializablePredicateLockListLock and the
 * appropriate hash partition lock for the target.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeleteLockTarget</name><parameter_list>(<parameter><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>targettaghash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>predlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>predlocktargetlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>nextpredlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>,
								<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>predlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>predlock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>predlocktargetlink</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><name>predlocktargetlink</name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>hash_search_with_hash_value</name>
			<argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>,
			 <argument><expr><operator>&amp;</operator><name><name>predlock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
			 <argument><expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>predlock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
													 <argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>predlock</name> <operator>=</operator> <name>nextpredlock</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove the target itself, if possible. */</comment>
	<expr_stmt><expr><call><name>RemoveTargetIfNoLongerUsed</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		TransferPredicateLocksToNewTarget
 *
 * Move or copy all the predicate locks for a lock target, for use by
 * index page splits/combines and other things that create or replace
 * lock targets. If 'removeOld' is true, the old locks and the target
 * will be removed.
 *
 * Returns true on success, or false if we ran out of shared memory to
 * allocate the new target or locks. Guaranteed to always succeed if
 * removeOld is set (by using the scratch entry in PredicateLockTargetHash
 * for scratch space).
 *
 * Warning: the "removeOld" option should be used only with care,
 * because this function does not (indeed, can not) update other
 * backends' LocalPredicateLockHash. If we are only adding new
 * entries, this is not a problem: the local lock table is used only
 * as a hint, so missing entries for locks that are held are
 * OK. Having entries for locks that are no longer held, as can happen
 * when using "removeOld", is not in general OK. We can only use it
 * safely when replacing a lock with a coarser-granularity lock that
 * covers it, or if we are absolutely certain that no one will need to
 * refer to that lock in the future.
 *
 * Caller must hold SerializablePredicateLockListLock exclusively.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TransferPredicateLocksToNewTarget</name><parameter_list>(<parameter><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>oldtargettag</name></decl></parameter>,
								  <parameter><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>newtargettag</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>removeOld</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oldtargettaghash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>oldpartitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>oldtarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newtargettaghash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>newpartitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>outOfShmem</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>,
								<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldtargettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldtargettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtargettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newtargettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldpartitionLock</name> <operator>=</operator> <call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>oldtargettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newpartitionLock</name> <operator>=</operator> <call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>newtargettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>removeOld</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Remove the dummy entry to give us scratch space, so we know we'll
		 * be able to create the new lock target.
		 */</comment>
		<expr_stmt><expr><call><name>RemoveScratchTarget</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We must get the partition locks in ascending sequence to avoid
	 * deadlocks. If old and new partitions are the same, we must request the
	 * lock only once.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldpartitionLock</name> <operator>&lt;</operator> <name>newpartitionLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>oldpartitionLock</name></expr></argument>,
					  <argument><expr><operator>(</operator><ternary><condition><expr><name>removeOld</name></expr> ?</condition><then> <expr><name>LW_EXCLUSIVE</name></expr> </then><else>: <expr><name>LW_SHARED</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>newpartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>oldpartitionLock</name> <operator>&gt;</operator> <name>newpartitionLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>newpartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>oldpartitionLock</name></expr></argument>,
					  <argument><expr><operator>(</operator><ternary><condition><expr><name>removeOld</name></expr> ?</condition><then> <expr><name>LW_EXCLUSIVE</name></expr> </then><else>: <expr><name>LW_SHARED</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>newpartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Look for the old target.  If not found, that's OK; no predicate locks
	 * are affected, so we can just clean up and return. If it does exist,
	 * walk its list of predicate locks and move or copy them to the new
	 * target.
	 */</comment>
	<expr_stmt><expr><name>oldtarget</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>oldtargettag</name></expr></argument>,
											<argument><expr><name>oldtargettaghash</name></expr></argument>,
											<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldtarget</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>newtarget</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>oldpredlock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCKTAG</name></type> <name>newpredlocktag</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newtarget</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>newtargettag</name></expr></argument>,
												<argument><expr><name>newtargettaghash</name></expr></argument>,
												<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newtarget</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Failed to allocate due to insufficient shmem */</comment>
			<expr_stmt><expr><name>outOfShmem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<goto>goto <name>exit</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If we created a new entry, initialize it */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newtarget</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>newpredlocktag</name><operator>.</operator><name>myTarget</name></name> <operator>=</operator> <name>newtarget</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Loop through all the locks on the old target, replacing them with
		 * locks on the new target.
		 */</comment>
		<expr_stmt><expr><name>oldpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtarget</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtarget</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>oldpredlock</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>predlocktargetlink</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>nextpredlock</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>newpredlock</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SerCommitSeqNo</name></type> <name>oldCommitSeqNo</name> <init>= <expr><name><name>oldpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>predlocktargetlink</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>oldpredlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtarget</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><name>predlocktargetlink</name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newpredlocktag</name><operator>.</operator><name>myXact</name></name> <operator>=</operator> <name><name>oldpredlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myXact</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>removeOld</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldpredlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldpredlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>hash_search_with_hash_value</name>
					<argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>oldpredlock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
					 <argument><expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldpredlock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
															 <argument><expr><name>oldtargettaghash</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>newpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>newpredlocktag</name></expr></argument>,
											<argument><expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newpredlocktag</name></expr></argument>,
																					<argument><expr><name>newtargettaghash</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newpredlock</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Out of shared memory. Undo what we've done so far. */</comment>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>DeleteLockTarget</name><argument_list>(<argument><expr><name>newtarget</name></expr></argument>, <argument><expr><name>newtargettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>outOfShmem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<goto>goto <name>exit</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newtarget</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
									 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newpredlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newpredlocktag</name><operator>.</operator><name>myXact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
									 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newpredlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <name>oldCommitSeqNo</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>&lt;</operator> <name>oldCommitSeqNo</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <name>oldCommitSeqNo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>==</operator> <name>InvalidSerCommitSeqNo</name><operator>)</operator>
				   <operator>||</operator> <operator>(</operator><name><name>newpredlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myXact</name></name> <operator>==</operator> <name>OldCommittedSxact</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>oldpredlock</name> <operator>=</operator> <name>nextpredlock</name></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>removeOld</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldtarget</name><operator>-&gt;</operator><name>predicateLocks</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RemoveTargetIfNoLongerUsed</name><argument_list>(<argument><expr><name>oldtarget</name></expr></argument>, <argument><expr><name>oldtargettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


<label><name>exit</name>:</label>
	<comment type="block">/* Release partition locks in reverse order of acquisition. */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldpartitionLock</name> <operator>&lt;</operator> <name>newpartitionLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>newpartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>oldpartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>oldpartitionLock</name> <operator>&gt;</operator> <name>newpartitionLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>oldpartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>newpartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>newpartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>removeOld</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We shouldn't run out of memory if we're moving locks */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>outOfShmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Put the scratch entry back */</comment>
		<expr_stmt><expr><call><name>RestoreScratchTarget</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>!</operator><name>outOfShmem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Drop all predicate locks of any granularity from the specified relation,
 * which can be a heap relation or an index relation.  If 'transfer' is true,
 * acquire a relation lock on the heap for any transactions with any lock(s)
 * on the specified relation.
 *
 * This requires grabbing a lot of LW locks and scanning the entire lock
 * target table for matches.  That makes this more expensive than most
 * predicate lock management functions, but it will only be called for DDL
 * type commands that are expensive anyway, and there are fast returns when
 * no serializable transactions are active or the relation is temporary.
 *
 * We don't use the TransferPredicateLocksToNewTarget function because it
 * acquires its own locks on the partitions of the two targets involved,
 * and we'll already be holding all partition locks.
 *
 * We can't throw an error from here, because the call could be from a
 * transaction which is not serializable.
 *
 * NOTE: This is currently only called with transfer set to true, but that may
 * change.  If we decide to clean up the locks from a table on commit of a
 * transaction which executed DROP TABLE, the false condition will be useful.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropAllPredicateLocksFromTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>transfer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seqstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>oldtarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>heaptarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dbId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>heaptargettaghash</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Bail out quickly if there are no serializable transactions running.
	 * It's safe to check this without taking locks because the caller is
	 * holding an ACCESS EXCLUSIVE lock on the relation.  No new locks which
	 * would matter here can be acquired while that is held.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PredicateLockingNeededForRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dbId</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>relId</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isIndex</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>heapId</name> <operator>=</operator> <name>relId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>isIndex</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>heapId</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>heapId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>transfer</name> <operator>||</operator> <operator>!</operator><name>isIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* index OID only makes sense with
									 * transfer */</comment>

	<comment type="block">/* Retrieve first time needed, then keep. */</comment>
	<expr_stmt><expr><name>heaptargettaghash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>heaptarget</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Acquire locks on all lock partitions */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>PredicateLockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove the dummy entry to give us scratch space, so we know we'll be
	 * able to create the new lock target.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>transfer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveScratchTarget</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Scan through target map */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>, <argument><expr><name>PredicateLockTargetHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>oldtarget</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCKTARGET</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>oldpredlock</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check whether this is a target which needs attention.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><name><name>oldtarget</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>relId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* wrong relation id */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GET_PREDICATELOCKTARGETTAG_DB</name><argument_list>(<argument><expr><name><name>oldtarget</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>dbId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* wrong database id */</comment>
		<if_stmt><if>if <condition>(<expr><name>transfer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isIndex</name>
			<operator>&amp;&amp;</operator> <call><name>GET_PREDICATELOCKTARGETTAG_TYPE</name><argument_list>(<argument><expr><name><name>oldtarget</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PREDLOCKTAG_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* already the right lock */</comment>

		<comment type="block">/*
		 * If we made it here, we have work to do.  We make sure the heap
		 * relation lock exists, then we walk the list of predicate locks for
		 * the old target we found, moving all locks to the heap relation lock
		 * -- unless they already hold that.
		 */</comment>

		<comment type="block">/*
		 * First make sure we have the heap relation target.  We only need to
		 * do this once.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>transfer</name> <operator>&amp;&amp;</operator> <name>heaptarget</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>heaptargettag</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><name>heaptargettag</name></expr></argument>, <argument><expr><name>dbId</name></expr></argument>, <argument><expr><name>heapId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>heaptargettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heaptargettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>heaptarget</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>heaptargettag</name></expr></argument>,
													 <argument><expr><name>heaptargettaghash</name></expr></argument>,
													 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heaptarget</name><operator>-&gt;</operator><name>predicateLocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Loop through all the locks on the old target, replacing them with
		 * locks on the new target.
		 */</comment>
		<expr_stmt><expr><name>oldpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtarget</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtarget</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>oldpredlock</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>nextpredlock</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>newpredlock</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SerCommitSeqNo</name></type> <name>oldCommitSeqNo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>oldXact</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nextpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtarget</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldpredlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remove the old lock first. This avoids the chance of running
			 * out of lock structure entries for the hash table.
			 */</comment>
			<expr_stmt><expr><name>oldCommitSeqNo</name> <operator>=</operator> <name><name>oldpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldXact</name> <operator>=</operator> <name><name>oldpredlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myXact</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldpredlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * No need for retail delete from oldtarget list, we're removing
			 * the whole target anyway.
			 */</comment>
			<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>oldpredlock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
						<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>transfer</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PREDICATELOCKTAG</name></type> <name>newpredlocktag</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>newpredlocktag</name><operator>.</operator><name>myTarget</name></name> <operator>=</operator> <name>heaptarget</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newpredlocktag</name><operator>.</operator><name>myXact</name></name> <operator>=</operator> <name>oldXact</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
					<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>newpredlocktag</name></expr></argument>,
												<argument><expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newpredlocktag</name></expr></argument>,
																						<argument><expr><name>heaptargettaghash</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>HASH_ENTER</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>heaptarget</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
										 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newpredlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newpredlocktag</name><operator>.</operator><name>myXact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
										 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newpredlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <name>oldCommitSeqNo</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>&lt;</operator> <name>oldCommitSeqNo</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <name>oldCommitSeqNo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>newpredlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>==</operator> <name>InvalidSerCommitSeqNo</name><operator>)</operator>
					   <operator>||</operator> <operator>(</operator><name><name>newpredlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myXact</name></name> <operator>==</operator> <name>OldCommittedSxact</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>oldpredlock</name> <operator>=</operator> <name>nextpredlock</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtarget</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Put the scratch entry back */</comment>
	<if_stmt><if>if <condition>(<expr><name>transfer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RestoreScratchTarget</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release locks in reverse order */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PredicateLockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TransferPredicateLocksToHeapRelation
 *		For all transactions, transfer all predicate locks for the given
 *		relation to a single relation lock on the heap.
 */</comment>
<function><type><name>void</name></type>
<name>TransferPredicateLocksToHeapRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DropAllPredicateLocksFromTable</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		PredicateLockPageSplit
 *
 * Copies any predicate locks for the old page to the new page.
 * Skip if this is a temporary table or toast table.
 *
 * NOTE: A page split (or overflow) affects all serializable transactions,
 * even if it occurs in the context of another transaction isolation level.
 *
 * NOTE: This currently leaves the local copy of the locks without
 * information on the new lock which is in shared memory.  This could cause
 * problems if enough page splits occur on locked pages without the processes
 * which hold the locks getting in and noticing.
 */</comment>
<function><type><name>void</name></type>
<name>PredicateLockPageSplit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>oldblkno</name></decl></parameter>,
					   <parameter><decl><type><name>BlockNumber</name></type> <name>newblkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>oldtargettag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>newtargettag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Bail out quickly if there are no serializable transactions running.
	 *
	 * It's safe to do this check without taking any additional locks. Even if
	 * a serializable transaction starts concurrently, we know it can't take
	 * any SIREAD locks on the page being split because the caller is holding
	 * the associated buffer page lock. Memory reordering isn't an issue; the
	 * memory barrier in the LWLock acquisition guarantees that this read
	 * occurs while the buffer page lock is held.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PredicateLockingNeededForRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldblkno</name> <operator>!=</operator> <name>newblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>oldblkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>newblkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_PAGE</name><argument_list>(<argument><expr><name>oldtargettag</name></expr></argument>,
									<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
									<argument><expr><name>oldblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_PAGE</name><argument_list>(<argument><expr><name>newtargettag</name></expr></argument>,
									<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
									<argument><expr><name>newblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try copying the locks over to the new page's tag, creating it if
	 * necessary.
	 */</comment>
	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>TransferPredicateLocksToNewTarget</name><argument_list>(<argument><expr><name>oldtargettag</name></expr></argument>,
												<argument><expr><name>newtargettag</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No more predicate lock entries are available. Failure isn't an
		 * option here, so promote the page lock to a relation lock.
		 */</comment>

		<comment type="block">/* Get the parent relation lock's lock tag */</comment>
		<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>GetParentPredicateLockTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldtargettag</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>newtargettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Move the locks to the parent. This shouldn't fail.
		 *
		 * Note that here we are removing locks held by other backends,
		 * leading to a possible inconsistency in their local lock hash table.
		 * This is OK because we're replacing it with a lock that covers the
		 * old one.
		 */</comment>
		<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>TransferPredicateLocksToNewTarget</name><argument_list>(<argument><expr><name>oldtargettag</name></expr></argument>,
													<argument><expr><name>newtargettag</name></expr></argument>,
													<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		PredicateLockPageCombine
 *
 * Combines predicate locks for two existing pages.
 * Skip if this is a temporary table or toast table.
 *
 * NOTE: A page combine affects all serializable transactions, even if it
 * occurs in the context of another transaction isolation level.
 */</comment>
<function><type><name>void</name></type>
<name>PredicateLockPageCombine</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>oldblkno</name></decl></parameter>,
						 <parameter><decl><type><name>BlockNumber</name></type> <name>newblkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Page combines differ from page splits in that we ought to be able to
	 * remove the locks on the old page after transferring them to the new
	 * page, instead of duplicating them. However, because we can't edit other
	 * backends' local lock tables, removing the old lock would leave them
	 * with an entry in their LocalPredicateLockHash for a lock they're not
	 * holding, which isn't acceptable. So we wind up having to do the same
	 * work as a page split, acquiring a lock on the new page and keeping the
	 * old page locked too. That can lead to some false positives, but should
	 * be rare in practice.
	 */</comment>
	<expr_stmt><expr><call><name>PredicateLockPageSplit</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>oldblkno</name></expr></argument>, <argument><expr><name>newblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Walk the list of in-progress serializable transactions and find the new
 * xmin.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetNewSxactGlobalXmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>sxact</name> <operator>=</operator> <call><name>FirstPredXact</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>sxact</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>sxact</name> <operator>=</operator> <call><name>NextPredXact</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SxactIsRolledBack</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <name>sxact</name> <operator>!=</operator> <name>OldCommittedSxact</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>!=</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call>
				<operator>||</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>,
										 <argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name> <operator>=</operator> <name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>,
										 <argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>OldSerXidSetActiveSerXmin</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ReleasePredicateLocks
 *
 * Releases predicate locks based on completion of the current transaction,
 * whether committed or rolled back.  It can also be called for a read only
 * transaction when it becomes impossible for the transaction to become
 * part of a dangerous structure.
 *
 * We do nothing unless this is a serializable transaction.
 *
 * This method must ensure that shared memory hash tables are cleaned
 * up in some relatively timely fashion.
 *
 * If this transaction is committing and is holding any predicate locks,
 * it must be added to a list of completed serializable transactions still
 * holding locks.
 *
 * If isReadOnlySafe is true, then predicate locks are being released before
 * the end of the transaction because MySerializableXact has been determined
 * to be RO_SAFE.  In non-parallel mode we can release it completely, but it
 * in parallel mode we partially release the SERIALIZABLEXACT and keep it
 * around until the end of the transaction, allowing each backend to clear its
 * MySerializableXact variable and benefit from the optimization in its own
 * time.
 */</comment>
<function><type><name>void</name></type>
<name>ReleasePredicateLocks</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isReadOnlySafe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needToClear</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RWConflict</name></type>	<name>conflict</name></decl>,
				<decl><type ref="prev"/><name>nextConflict</name></decl>,
				<decl><type ref="prev"/><name>possibleUnsafeConflict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>roXact</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can't trust XactReadOnly here, because a transaction which started
	 * as READ WRITE can show as READ ONLY later, e.g., within
	 * subtransactions.  We want to flag a transaction as READ ONLY if it
	 * commits without writing so that de facto READ ONLY transactions get the
	 * benefit of some RO optimizations, so we will use this local variable to
	 * get some cleanup logic right which is based on whether the transaction
	 * was declared READ ONLY at the top level.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>topLevelIsDeclaredReadOnly</name></decl>;</decl_stmt>

	<comment type="block">/* We can't be both committing and releasing early due to RO_SAFE. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>isCommit</name> <operator>&amp;&amp;</operator> <name>isReadOnlySafe</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Are we at the end of a transaction, that is, a commit or abort? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isReadOnlySafe</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Parallel workers mustn't release predicate locks at the end of
		 * their transaction.  The leader will do that at the end of its
		 * transaction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleasePredicateLocksLocal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * By the time the leader in a parallel query reaches end of
		 * transaction, it has waited for all workers to exit.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParallelContextActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the leader in a parallel query earlier stashed a partially
		 * released SERIALIZABLEXACT for final clean-up at end of transaction
		 * (because workers might still have been accessing it), then it's
		 * time to restore it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>SavedSerializableXact</name> <operator>!=</operator> <name>InvalidSerializableXact</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>MySerializableXact</name> <operator>=</operator> <name>SavedSerializableXact</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>SavedSerializableXact</name> <operator>=</operator> <name>InvalidSerializableXact</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SxactIsPartiallyReleased</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the transaction is committing, but it has been partially released
	 * already, then treat this as a roll back.  It was marked as rolled back.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name> <operator>&amp;&amp;</operator> <call><name>SxactIsPartiallyReleased</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>isCommit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're called in the middle of a transaction because we discovered
	 * that the SXACT_FLAG_RO_SAFE flag was set, then we'll partially release
	 * it (that is, release the predicate locks and conflicts, but not the
	 * SERIALIZABLEXACT itself) if we're the first backend to have noticed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isReadOnlySafe</name> <operator>&amp;&amp;</operator> <call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The leader needs to stash a pointer to it, so that it can
		 * completely release it at end-of-transaction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>SavedSerializableXact</name> <operator>=</operator> <name>MySerializableXact</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The first backend to reach this condition will partially release
		 * the SERIALIZABLEXACT.  All others will just clear their
		 * backend-local state so that they stop doing SSI checks for the rest
		 * of the transaction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SxactIsPartiallyReleased</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleasePredicateLocksLocal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_PARTIALLY_RELEASED</name></expr>;</expr_stmt>
			<comment type="block">/* ... and proceed to perform the partial release below. */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isCommit</name> <operator>||</operator> <call><name>SxactIsPrepared</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isCommit</name> <operator>||</operator> <operator>!</operator><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SxactIsPartiallyReleased</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call>
		   <operator>||</operator> <operator>!</operator><call><name>SxactIsRolledBack</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* may not be serializable during COMMIT/ROLLBACK PREPARED */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We'd better not already be on the cleanup list. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SxactIsOnFinishedList</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>topLevelIsDeclaredReadOnly</name> <operator>=</operator> <call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't hold XidGenLock lock here, assuming that TransactionId is
	 * atomic!
	 *
	 * If this value is changing, we don't care that much whether we get the
	 * old or new value -- it is just used to determine how far
	 * GlobalSerializableXmin must advance before this transaction can be
	 * fully cleaned up.  The worst that could happen is we wait for one more
	 * transaction to complete before freeing some RAM; correctness of visible
	 * behavior is not affected.
	 */</comment>
	<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>finishedBefore</name></name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's not a commit it's either a rollback or a read-only transaction
	 * flagged SXACT_FLAG_RO_SAFE, and we can clear our locks immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_COMMITTED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>PredXact</name><operator>-&gt;</operator><name>LastSxactCommitSeqNo</name></name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* Recognize implicit read-only transaction (commit without write). */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyXactDidWrite</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_READ_ONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The DOOMED flag indicates that we intend to roll back this
		 * transaction and so it should not cause serialization failures for
		 * other transactions that conflict with it. Note that this flag might
		 * already be set, if another backend marked this transaction for
		 * abort.
		 *
		 * The ROLLED_BACK flag further indicates that ReleasePredicateLocks
		 * has been called, and so the SerializableXact is eligible for
		 * cleanup. This means it should not be considered when calculating
		 * SxactGlobalXmin.
		 */</comment>
		<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_DOOMED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_ROLLED_BACK</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the transaction was previously prepared, but is now failing due
		 * to a ROLLBACK PREPARED or (hopefully very rare) error after the
		 * prepare, clear the prepared flag.  This simplifies conflict
		 * checking.
		 */</comment>
		<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SXACT_FLAG_PREPARED</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>topLevelIsDeclaredReadOnly</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>WritableSxactCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>--</operator><operator>(</operator><name><name>PredXact</name><operator>-&gt;</operator><name>WritableSxactCount</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Release predicate locks and rw-conflicts in for all committed
			 * transactions.  There are no longer any transactions which might
			 * conflict with the locks and no chance for new transactions to
			 * overlap.  Similarly, existing conflicts in can't cause pivots,
			 * and any conflicts in which could have completed a dangerous
			 * structure would already have caused a rollback, so any
			 * remaining ones must be benign.
			 */</comment>
			<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>CanPartialClearThrough</name></name> <operator>=</operator> <name><name>PredXact</name><operator>-&gt;</operator><name>LastSxactCommitSeqNo</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Read-only transactions: clear the list of transactions that might
		 * make us unsafe. Note that we use 'inLink' for the iteration as
		 * opposed to 'outLink' for the r/w xacts.
		 */</comment>
		<expr_stmt><expr><name>possibleUnsafeConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>possibleUnsafeConflict</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>possibleUnsafeConflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name><name>possibleUnsafeConflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MySerializableXact</name> <operator>==</operator> <name><name>possibleUnsafeConflict</name><operator>-&gt;</operator><name>sxactIn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseRWConflict</name><argument_list>(<argument><expr><name>possibleUnsafeConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>possibleUnsafeConflict</name> <operator>=</operator> <name>nextConflict</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Check for conflict out to old committed transactions. */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name>
		<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <call><name>SxactHasSummaryConflictOut</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we don't know which old committed transaction we conflicted with,
		 * so be conservative and use FirstNormalSerCommitSeqNo here
		 */</comment>
		<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>earliestOutConflictCommit</name></name> <operator>=</operator>
			<name>FirstNormalSerCommitSeqNo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_CONFLICT_OUT</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Release all outConflicts to committed transactions.  If we're rolling
	 * back clear them all.  Set SXACT_FLAG_CONFLICT_OUT if any point to
	 * previously committed transactions.
	 */</comment>
	<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>conflict</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isCommit</name>
			<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SXACT_FLAG_CONFLICT_OUT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
				<operator>||</operator> <name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name><operator>-&gt;</operator><name>prepareSeqNo</name></name> <operator>&lt;</operator> <name><name>MySerializableXact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>earliestOutConflictCommit</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>earliestOutConflictCommit</name></name> <operator>=</operator> <name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name><operator>-&gt;</operator><name>prepareSeqNo</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_CONFLICT_OUT</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCommit</name>
			<operator>||</operator> <call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name></name></expr></argument>)</argument_list></call>
			<operator>||</operator> <operator>(</operator><name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>lastCommitBeforeSnapshot</name></name> <operator>&gt;=</operator> <name><name>PredXact</name><operator>-&gt;</operator><name>LastSxactCommitSeqNo</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseRWConflict</name><argument_list>(<argument><expr><name>conflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>nextConflict</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Release all inConflicts from committed and read-only transactions. If
	 * we're rolling back, clear them all.
	 */</comment>
	<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>conflict</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCommit</name>
			<operator>||</operator> <call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseRWConflict</name><argument_list>(<argument><expr><name>conflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>nextConflict</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>topLevelIsDeclaredReadOnly</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Remove ourselves from the list of possible conflicts for concurrent
		 * READ ONLY transactions, flagging them as unsafe if we have a
		 * conflict out. If any are waiting DEFERRABLE transactions, wake them
		 * up if they are known safe or known unsafe.
		 */</comment>
		<expr_stmt><expr><name>possibleUnsafeConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>possibleUnsafeConflict</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>possibleUnsafeConflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>roXact</name> <operator>=</operator> <name><name>possibleUnsafeConflict</name><operator>-&gt;</operator><name>sxactIn</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MySerializableXact</name> <operator>==</operator> <name><name>possibleUnsafeConflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>roXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Mark conflicted if necessary. */</comment>
			<if_stmt><if>if <condition>(<expr><name>isCommit</name>
				<operator>&amp;&amp;</operator> <name>MyXactDidWrite</name>
				<operator>&amp;&amp;</operator> <call><name>SxactHasConflictOut</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <operator>(</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>earliestOutConflictCommit</name></name>
					<operator>&lt;=</operator> <name><name>roXact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>lastCommitBeforeSnapshot</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This releases possibleUnsafeConflict (as well as all other
				 * possible conflicts for roXact)
				 */</comment>
				<expr_stmt><expr><call><name>FlagSxactUnsafe</name><argument_list>(<argument><expr><name>roXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseRWConflict</name><argument_list>(<argument><expr><name>possibleUnsafeConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we were the last possible conflict, flag it safe. The
				 * transaction can now safely release its predicate locks (but
				 * that transaction's backend has to do that itself).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>roXact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>roXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_RO_SAFE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Wake up the process for a waiting DEFERRABLE transaction if we
			 * now know it's either safe or conflicted.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>SxactIsDeferrableWaiting</name><argument_list>(<argument><expr><name>roXact</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>SxactIsROUnsafe</name><argument_list>(<argument><expr><name>roXact</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SxactIsROSafe</name><argument_list>(<argument><expr><name>roXact</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ProcSendSignal</name><argument_list>(<argument><expr><name><name>roXact</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>possibleUnsafeConflict</name> <operator>=</operator> <name>nextConflict</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check whether it's time to clean up old transactions. This can only be
	 * done when the last serializable transaction with the oldest xmin among
	 * serializable transactions completes.  We then find the "new oldest"
	 * xmin and purge any transactions which finished before this transaction
	 * was launched.
	 */</comment>
	<expr_stmt><expr><name>needToClear</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>--</operator><operator>(</operator><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetNewSxactGlobalXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>needToClear</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableFinishedListLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add this to the list of transactions to check for later cleanup. */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><name>FinishedSerializableTransactions</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>finishedLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're releasing a RO_SAFE transaction in parallel mode, we'll only
	 * partially release it.  That's necessary because other backends may have
	 * a reference to it.  The leader will release the SERIALIZABLEXACT itself
	 * at the end of the transaction after workers have stopped running.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseOneSerializableXact</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>,
								   <argument><expr><name>isReadOnlySafe</name> <operator>&amp;&amp;</operator> <call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableFinishedListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>needToClear</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ClearOldPredicateLocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleasePredicateLocksLocal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleasePredicateLocksLocal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>MySerializableXact</name> <operator>=</operator> <name>InvalidSerializableXact</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyXactDidWrite</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Delete per-transaction lock table */</comment>
	<if_stmt><if>if <condition>(<expr><name>LocalPredicateLockHash</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>LocalPredicateLockHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clear old predicate locks, belonging to committed transactions that are no
 * longer interesting to any in-progress transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClearOldPredicateLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>finishedSxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>predlock</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Loop through finished transactions. They are in commit order, so we can
	 * stop as soon as we find one that's still interesting.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableFinishedListLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>finishedSxact</name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXACT</name> <operator>*</operator><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>FinishedSerializableTransactions</name></expr></argument>,
					 <argument><expr><name>FinishedSerializableTransactions</name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SERIALIZABLEXACT</name></expr></argument>, <argument><expr><name>finishedLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>finishedSxact</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>nextSxact</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextSxact</name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXACT</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>FinishedSerializableTransactions</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>finishedSxact</name><operator>-&gt;</operator><name>finishedLink</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SERIALIZABLEXACT</name></expr></argument>, <argument><expr><name>finishedLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name><name>finishedSxact</name><operator>-&gt;</operator><name>finishedBefore</name></name></expr></argument>,
											 <argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This transaction committed before any in-progress transaction
			 * took its snapshot. It's no longer interesting.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>finishedSxact</name><operator>-&gt;</operator><name>finishedLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseOneSerializableXact</name><argument_list>(<argument><expr><name>finishedSxact</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>finishedSxact</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>&gt;</operator> <name><name>PredXact</name><operator>-&gt;</operator><name>HavePartialClearedThrough</name></name>
				 <operator>&amp;&amp;</operator> <name><name>finishedSxact</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>&lt;=</operator> <name><name>PredXact</name><operator>-&gt;</operator><name>CanPartialClearThrough</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Any active transactions that took their snapshot before this
			 * transaction committed are read-only, so we can clear part of
			 * its state.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>finishedSxact</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* A read-only transaction can be removed entirely */</comment>
				<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>finishedSxact</name><operator>-&gt;</operator><name>finishedLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseOneSerializableXact</name><argument_list>(<argument><expr><name>finishedSxact</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * A read-write transaction can only be partially cleared. We
				 * need to keep the SERIALIZABLEXACT but can release the
				 * SIREAD locks and conflicts in.
				 */</comment>
				<expr_stmt><expr><call><name>ReleaseOneSerializableXact</name><argument_list>(<argument><expr><name>finishedSxact</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>HavePartialClearedThrough</name></name> <operator>=</operator> <name><name>finishedSxact</name><operator>-&gt;</operator><name>commitSeqNo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Still interesting. */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>finishedSxact</name> <operator>=</operator> <name>nextSxact</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop through predicate locks on dummy transaction for summarized data.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>predlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>OldCommittedSxact</name><operator>-&gt;</operator><name>predicateLocks</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>OldCommittedSxact</name><operator>-&gt;</operator><name>predicateLocks</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>xactLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>predlock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>nextpredlock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>canDoPartialCleanup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>OldCommittedSxact</name><operator>-&gt;</operator><name>predicateLocks</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>predlock</name><operator>-&gt;</operator><name>xactLink</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>xactLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>predlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>predlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>!=</operator> <name>InvalidSerCommitSeqNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>canDoPartialCleanup</name> <operator>=</operator> <operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>&lt;=</operator> <name><name>PredXact</name><operator>-&gt;</operator><name>CanPartialClearThrough</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this lock originally belonged to an old enough transaction, we
		 * can release it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>canDoPartialCleanup</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PREDICATELOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>targettag</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>targettaghash</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name><name>predlock</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>tag</name><operator>.</operator><name>myTarget</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>targettag</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>targettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
										<argument><expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
																				<argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RemoveTargetIfNoLongerUsed</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>predlock</name> <operator>=</operator> <name>nextpredlock</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableFinishedListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is the normal way to delete anything from any of the predicate
 * locking hash tables.  Given a transaction which we know can be deleted:
 * delete all predicate locks held by that transaction and any predicate
 * lock targets which are now unreferenced by a lock; delete all conflicts
 * for the transaction; delete all xid values for the transaction; then
 * delete the transaction.
 *
 * When the partial flag is set, we can release all predicate locks and
 * in-conflict information -- we've established that there are no longer
 * any overlapping read write transactions for which this transaction could
 * matter -- but keep the transaction entry itself and any outConflicts.
 *
 * When the summarize flag is set, we've run short of room for sxact data
 * and must summarize to the SLRU.  Predicate locks are transferred to a
 * dummy "old" transaction, with duplicate locks on a single target
 * collapsing to a single lock with the "latest" commitSeqNo from among
 * the conflicting locks..
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseOneSerializableXact</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>partial</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>summarize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>predlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXIDTAG</name></type> <name>sxidtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RWConflict</name></type>	<name>conflict</name></decl>,
				<decl><type ref="prev"/><name>nextConflict</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sxact</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SxactIsRolledBack</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partial</name> <operator>||</operator> <operator>!</operator><call><name>SxactIsOnFinishedList</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>SerializableFinishedListLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First release all the predicate locks held by this xact (or transfer
	 * them to OldCommittedSxact if summarize is true)
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLockListLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>predlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>xactLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>predlock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>nextpredlock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>targetLink</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>targettag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>targettaghash</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>xactLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tag</name> <operator>=</operator> <name><name>predlock</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetLink</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>tag</name><operator>.</operator><name>myTarget</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targettag</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
									<argument><expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
																			<argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>summarize</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<comment type="block">/* Fold into dummy transaction list. */</comment>
			<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>myXact</name></name> <operator>=</operator> <name>OldCommittedSxact</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>predlock</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
												   <argument><expr><call><name>PredicateLockHashCodeFromTargetHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
																						   <argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>predlock</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_pred_locks_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>predlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>predlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>!=</operator> <name>InvalidSerCommitSeqNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>predlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>&lt;</operator> <name><name>sxact</name><operator>-&gt;</operator><name>commitSeqNo</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>predlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <name><name>sxact</name><operator>-&gt;</operator><name>commitSeqNo</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
									 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>OldCommittedSxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
									 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>predlock</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <name><name>sxact</name><operator>-&gt;</operator><name>commitSeqNo</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RemoveTargetIfNoLongerUsed</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>predlock</name> <operator>=</operator> <name>nextpredlock</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Rather than retail removal, just re-init the head after we've run
	 * through the list.
	 */</comment>
	<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLockListLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sxidtag</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name><name>sxact</name><operator>-&gt;</operator><name>topXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release all outConflicts (unless 'partial' is true) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partial</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>conflict</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>summarize</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_SUMMARY_CONFLICT_IN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ReleaseRWConflict</name><argument_list>(<argument><expr><name>conflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>nextConflict</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release all inConflicts. */</comment>
	<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>conflict</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sxact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>summarize</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_SUMMARY_CONFLICT_OUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseRWConflict</name><argument_list>(<argument><expr><name>conflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>nextConflict</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Finally, get rid of the xid and the record of the transaction itself. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partial</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sxidtag</name><operator>.</operator><name>xid</name></name> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SerializableXidHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sxidtag</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleasePredXact</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tests whether the given top level transaction is concurrent with
 * (overlaps) our current transaction.
 *
 * We need to identify the top level transaction for SSI, anyway, so pass
 * that to this function to save the overhead of checking the snapshot's
 * subxip array.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>XidIsConcurrent</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>xid</name> <operator>==</operator> <name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CheckForSerializableConflictOut
 *		We are reading a tuple which has been modified.  If it is visible to
 *		us but has been deleted, that indicates a rw-conflict out.  If it's
 *		not visible and was created by a concurrent (overlapping)
 *		serializable transaction, that is also a rw-conflict out,
 *
 * We will determine the top level xid of the writing transaction with which
 * we may be in conflict, and check for overlap with our own transaction.
 * If the transactions overlap (i.e., they cannot see each other's writes),
 * then we have a conflict out.
 *
 * This function should be called just about anywhere in heapam.c where a
 * tuple has been read. The caller must hold at least a shared lock on the
 * buffer, because this function might set hint bits on the tuple. There is
 * currently no known reason to call this function from an index AM.
 */</comment>
<function><type><name>void</name></type>
<name>CheckForSerializableConflictOut</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>visible</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
								<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
								<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXIDTAG</name></type> <name>sxidtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXID</name> <modifier>*</modifier></type><name>sxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTSV_Result</name></type> <name>htsvResult</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SerializationNeededForRead</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check if someone else has already decided that we need to die */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to read/write dependencies among transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Reason code: Canceled on identification as a pivot, during conflict out checking."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The transaction might succeed if retried."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check to see whether the tuple has been written to by a concurrent
	 * transaction, either to create it not visible to us, or to delete it
	 * while it is visible to us.  The "visible" bool indicates whether the
	 * tuple is visible to us, while HeapTupleSatisfiesVacuum checks what else
	 * is going on with it.
	 */</comment>
	<expr_stmt><expr><name>htsvResult</name> <operator>=</operator> <call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>TransactionXmin</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>htsvResult</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>visible</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>visible</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>
			<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>
			<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>
			<return>return;</return>
		<default>default:</default>

			<comment type="block">/*
			 * The only way to get to this default clause is if a new value is
			 * added to the enum type without adding it to this switch
			 * statement.  That's a bug, so elog.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized return value from HeapTupleSatisfiesVacuum: %u"</literal></expr></argument>, <argument><expr><name>htsvResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In spite of having all enum values covered and calling elog on
			 * this default, some compilers think this is a code path which
			 * allows xid to be used below without initialization. Silence
			 * that warning.
			 */</comment>
			<expr_stmt><expr><name>xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>TransactionXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find top level xid.  Bail out if xid is too early to be a conflict, or
	 * if it's our own xid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>SubTransGetTopmostTransaction</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>TransactionXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find sxact or summarized info for the top level xid.
	 */</comment>
	<expr_stmt><expr><name><name>sxidtag</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sxid</name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXID</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>SerializableXidHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sxidtag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sxid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Transaction not found in "normal" SSI structures.  Check whether it
		 * got pushed out to SLRU storage for "old committed" transactions.
		 */</comment>
		<decl_stmt><decl><type><name>SerCommitSeqNo</name></type> <name>conflictCommitSeqNo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>conflictCommitSeqNo</name> <operator>=</operator> <call><name>OldSerXidGetMinConflictCommitSeqNo</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>conflictCommitSeqNo</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>conflictCommitSeqNo</name> <operator>!=</operator> <name>InvalidSerCommitSeqNo</name>
				<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call>
					<operator>||</operator> <name>conflictCommitSeqNo</name>
					<operator>&lt;=</operator> <name><name>MySerializableXact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>lastCommitBeforeSnapshot</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to read/write dependencies among transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Reason code: Canceled on conflict out to old pivot %u."</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The transaction might succeed if retried."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>SxactHasSummaryConflictIn</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call>
				<operator>||</operator> <operator>!</operator><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to read/write dependencies among transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Reason code: Canceled on identification as a pivot, with conflict out to old committed transaction %u."</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The transaction might succeed if retried."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_SUMMARY_CONFLICT_OUT</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* It's not serializable or otherwise not important. */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>sxact</name> <operator>=</operator> <name><name>sxid</name><operator>-&gt;</operator><name>myXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>topXid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sxact</name> <operator>==</operator> <name>MySerializableXact</name> <operator>||</operator> <call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Can't conflict with ourself or a transaction that will roll back. */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have a conflict out to a transaction which has a conflict out to a
	 * summarized transaction.  That summarized transaction must have
	 * committed first, and we can't tell when it committed in relation to our
	 * snapshot acquisition, so something needs to be canceled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SxactHasSummaryConflictOut</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SxactIsPrepared</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_DOOMED</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to read/write dependencies among transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Reason code: Canceled on conflict out to old pivot."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The transaction might succeed if retried."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this is a read-only transaction and the writing transaction has
	 * committed, and it doesn't have a rw-conflict to a transaction which
	 * committed before it, no conflict.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactHasSummaryConflictOut</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>SxactHasConflictOut</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
			<operator>||</operator> <name><name>MySerializableXact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>lastCommitBeforeSnapshot</name></name> <operator>&lt;</operator> <name><name>sxact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>earliestOutConflictCommit</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Read-only transaction will appear to run first.  No conflict. */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XidIsConcurrent</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This write was already in our snapshot; no conflict. */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RWConflictExists</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>, <argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We don't want duplicate conflict records in the list. */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Flag the conflict.  But first, if this conflict creates a dangerous
	 * structure, ereport an error.
	 */</comment>
	<expr_stmt><expr><call><name>FlagRWConflict</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>, <argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check a particular target for rw-dependency conflict in. A subroutine of
 * CheckForSerializableConflictIn().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckTargetForConflictsIn</name><parameter_list>(<parameter><decl><type><name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>targettag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>targettaghash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>predlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>mypredlock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCKTAG</name></type> <name>mypredlocktag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MySerializableXact</name> <operator>!=</operator> <name>InvalidSerializableXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The same hash and LW lock apply to the lock target and the lock itself.
	 */</comment>
	<expr_stmt><expr><name>targettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>PredicateLockHashPartitionLock</name><argument_list>(<argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCKTARGET</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockTargetHash</name></expr></argument>,
									<argument><expr><name>targettag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>,
									<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>target</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Nothing has this target locked; we're done here. */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Each lock for an overlapping transaction represents a conflict: a
	 * rw-dependency in to this transaction.
	 */</comment>
	<expr_stmt><expr><name>predlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>predlock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>predlocktargetlink</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>nextpredlock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>predlocktargetlink</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><name>predlocktargetlink</name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sxact</name> <operator>=</operator> <name><name>predlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myXact</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sxact</name> <operator>==</operator> <name>MySerializableXact</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we're getting a write lock on a tuple, we don't need a
			 * predicate (SIREAD) lock on the same tuple. We can safely remove
			 * our SIREAD lock, but we'll defer doing so until after the loop
			 * because that requires upgrading to an exclusive partition lock.
			 *
			 * We can't use this optimization within a subtransaction because
			 * the subtransaction could roll back, and we would be left
			 * without any lock at the top level.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSubTransaction</name><argument_list>()</argument_list></call>
				<operator>&amp;&amp;</operator> <call><name>GET_PREDICATELOCKTARGETTAG_OFFSET</name><argument_list>(<argument><expr><operator>*</operator><name>targettag</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>mypredlock</name> <operator>=</operator> <name>predlock</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>mypredlocktag</name> <operator>=</operator> <name><name>predlock</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
				 <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
					 <operator>||</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>xmin</name></expr></argument>,
											  <argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>finishedBefore</name></name></expr></argument>)</argument_list></call><operator>)</operator>
				 <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RWConflictExists</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>, <argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Re-check after getting exclusive lock because the other
			 * transaction may have flagged a conflict.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call>
					<operator>||</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>xmin</name></expr></argument>,
											 <argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>finishedBefore</name></name></expr></argument>)</argument_list></call><operator>)</operator>
				<operator>&amp;&amp;</operator> <operator>!</operator><call><name>RWConflictExists</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>, <argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>FlagRWConflict</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>, <argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>predlock</name> <operator>=</operator> <name>nextpredlock</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we found one of our own SIREAD locks to remove, remove it now.
	 *
	 * At this point our transaction already has an ExclusiveRowLock on the
	 * relation, so we are OK to drop the predicate lock on the tuple, if
	 * found, without fearing that another write against the tuple will occur
	 * before the MVCC information makes it to the buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mypredlock</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>predlockhashcode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>rmpredlock</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>predicateLockListLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Remove the predicate lock from shared memory, if it wasn't removed
		 * while the locks were released.  One way that could happen is from
		 * autovacuum cleaning up an index.
		 */</comment>
		<expr_stmt><expr><name>predlockhashcode</name> <operator>=</operator> <call><name>PredicateLockHashCodeFromTargetHashCode</name>
			<argument_list>(<argument><expr><operator>&amp;</operator><name>mypredlocktag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rmpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>mypredlocktag</name></expr></argument>,
										<argument><expr><name>predlockhashcode</name></expr></argument>,
										<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rmpredlock</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rmpredlock</name> <operator>==</operator> <name>mypredlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>mypredlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>mypredlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>rmpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>PredicateLockHash</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>mypredlocktag</name></expr></argument>,
											<argument><expr><name>predlockhashcode</name></expr></argument>,
											<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rmpredlock</name> <operator>==</operator> <name>mypredlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>RemoveTargetIfNoLongerUsed</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>predicateLockListLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rmpredlock</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Remove entry in local lock table if it exists. It's OK if it
			 * doesn't exist; that means the lock was transferred to a new
			 * target by a different backend.
			 */</comment>
			<expr_stmt><expr><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name></expr></argument>,
										<argument><expr><name>targettag</name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>,
										<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>DecrementParentLocks</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckForSerializableConflictIn
 *		We are writing the given tuple.  If that indicates a rw-conflict
 *		in from another serializable transaction, take appropriate action.
 *
 * Skip checking for any granularity for which a parameter is missing.
 *
 * A tuple update or delete is in conflict if we have a predicate lock
 * against the relation or page in which the tuple exists, or against the
 * tuple itself.
 */</comment>
<function><type><name>void</name></type>
<name>CheckForSerializableConflictIn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
							   <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name></type> <name>targettag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SerializationNeededForWrite</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check if someone else has already decided that we need to die */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to read/write dependencies among transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Reason code: Canceled on identification as a pivot, during conflict in checking."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The transaction might succeed if retried."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We're doing a write which might cause rw-conflicts now or later.
	 * Memorize that fact.
	 */</comment>
	<expr_stmt><expr><name>MyXactDidWrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It is important that we check for locks from the finest granularity to
	 * the coarsest granularity, so that granularity promotion doesn't cause
	 * us to miss a lock.  The new (coarser) lock will be acquired before the
	 * old (finer) locks are released.
	 *
	 * It is not possible to take and hold a lock across the checks for all
	 * granularities because each target could be in a separate partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_TUPLE</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>,
										 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
										 <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTargetForConflictsIn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_PAGE</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>,
										<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
										<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTargetForConflictsIn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><name>targettag</name></expr></argument>,
										<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckTargetForConflictsIn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targettag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckTableForSerializableConflictIn
 *		The entire table is going through a DDL-style logical mass delete
 *		like TRUNCATE or DROP TABLE.  If that causes a rw-conflict in from
 *		another serializable transaction, take appropriate action.
 *
 * While these operations do not operate entirely within the bounds of
 * snapshot isolation, they can occur inside a serializable transaction, and
 * will logically occur after any reads which saw rows which were destroyed
 * by these operations, so we do what we can to serialize properly under
 * SSI.
 *
 * The relation passed in must be a heap relation. Any predicate lock of any
 * granularity on the heap will cause a rw-conflict in to this transaction.
 * Predicate locks on indexes do not matter because they only exist to guard
 * against conflicting inserts into the index, and this is a mass *delete*.
 * When a table is truncated or dropped, the index will also be truncated
 * or dropped, and we'll deal with locks on the index when that happens.
 *
 * Dropping or truncating a table also needs to drop any existing predicate
 * locks on heap tuples or pages, because they're about to go away. This
 * should be done before altering the predicate locks because the transaction
 * could be rolled back because of a conflict, in which case the lock changes
 * are not needed. (At the moment, we don't actually bother to drop the
 * existing locks on a dropped or truncated table at the moment. That might
 * lead to some false positives, but it doesn't seem worth the trouble.)
 */</comment>
<function><type><name>void</name></type>
<name>CheckTableForSerializableConflictIn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seqstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PREDICATELOCKTARGET</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dbId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Bail out quickly if there are no serializable transactions running.
	 * It's safe to check this without taking locks because the caller is
	 * holding an ACCESS EXCLUSIVE lock on the relation.  No new locks which
	 * would matter here can be acquired while that is held.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SerializationNeededForWrite</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We're doing a write which might cause rw-conflicts now or later.
	 * Memorize that fact.
	 */</comment>
	<expr_stmt><expr><name>MyXactDidWrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* not an index relation */</comment>

	<expr_stmt><expr><name>dbId</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>heapId</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>PredicateLockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan through target list */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>, <argument><expr><name>PredicateLockTargetHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>target</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCKTARGET</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>predlock</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check whether this is a target which needs attention.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>heapId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* wrong relation id */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GET_PREDICATELOCKTARGETTAG_DB</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>dbId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* wrong database id */</comment>

		<comment type="block">/*
		 * Loop through locks for this target and flag conflicts.
		 */</comment>
		<expr_stmt><expr><name>predlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>predlock</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>nextpredlock</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nextpredlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>targetLink</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>predlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myXact</name></name> <operator>!=</operator> <name>MySerializableXact</name>
				<operator>&amp;&amp;</operator> <operator>!</operator><call><name>RWConflictExists</name><argument_list>(<argument><expr><name><name>predlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myXact</name></name></expr></argument>, <argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>FlagRWConflict</name><argument_list>(<argument><expr><name><name>predlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myXact</name></name></expr></argument>, <argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>predlock</name> <operator>=</operator> <name>nextpredlock</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></while>

	<comment type="block">/* Release locks in reverse order */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PredicateLockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Flag a rw-dependency between two serializable transactions.
 *
 * The caller is responsible for ensuring that we have a LW lock on
 * the transaction hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FlagRWConflict</name><parameter_list>(<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reader</name> <operator>!=</operator> <name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First, see if this conflict causes failure. */</comment>
	<expr_stmt><expr><call><name>OnConflict_CheckForSerializationFailure</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Actually do the conflict flagging. */</comment>
	<if_stmt><if>if <condition>(<expr><name>reader</name> <operator>==</operator> <name>OldCommittedSxact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>writer</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_SUMMARY_CONFLICT_IN</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>writer</name> <operator>==</operator> <name>OldCommittedSxact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_SUMMARY_CONFLICT_OUT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetRWConflict</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------------------
 * We are about to add a RW-edge to the dependency graph - check that we don't
 * introduce a dangerous structure by doing so, and abort one of the
 * transactions if so.
 *
 * A serialization failure can only occur if there is a dangerous structure
 * in the dependency graph:
 *
 *		Tin ------&gt; Tpivot ------&gt; Tout
 *			  rw			 rw
 *
 * Furthermore, Tout must commit first.
 *
 * One more optimization is that if Tin is declared READ ONLY (or commits
 * without writing), we can only have a problem if Tout committed before Tin
 * acquired its snapshot.
 *----------------------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>OnConflict_CheckForSerializationFailure</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>,
										<parameter><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>failure</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RWConflict</name></type>	<name>conflict</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>failure</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*------------------------------------------------------------------------
	 * Check for already-committed writer with rw-conflict out flagged
	 * (conflict-flag on W means that T2 committed before W):
	 *
	 *		R ------&gt; W ------&gt; T2
	 *			rw		  rw
	 *
	 * That is a dangerous structure, so we must abort. (Since the writer
	 * has already committed, we must be the reader)
	 *------------------------------------------------------------------------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>(</operator><call><name>SxactHasConflictOut</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SxactHasSummaryConflictOut</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*------------------------------------------------------------------------
	 * Check whether the writer has become a pivot with an out-conflict
	 * committed transaction (T2), and T2 committed first:
	 *
	 *		R ------&gt; W ------&gt; T2
	 *			rw		  rw
	 *
	 * Because T2 must've committed first, there is no anomaly if:
	 * - the reader committed before T2
	 * - the writer committed before T2
	 * - the reader is a READ ONLY transaction and the reader was concurrent
	 *	 with T2 (= reader acquired its snapshot before T2 committed)
	 *
	 * We also handle the case that T2 is prepared but not yet committed
	 * here. In that case T2 has already checked for conflicts, so if it
	 * commits first, making the above conflict real, it's too late for it
	 * to abort.
	 *------------------------------------------------------------------------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>failure</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>SxactHasSummaryConflictOut</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<while>while <condition>(<expr><name>conflict</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>t2</name> <init>= <expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactIn</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>SxactIsPrepared</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call>
					<operator>||</operator> <name><name>t2</name><operator>-&gt;</operator><name>prepareSeqNo</name></name> <operator>&lt;=</operator> <name><name>reader</name><operator>-&gt;</operator><name>commitSeqNo</name></name><operator>)</operator>
				<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call>
					<operator>||</operator> <name><name>t2</name><operator>-&gt;</operator><name>prepareSeqNo</name></name> <operator>&lt;=</operator> <name><name>writer</name><operator>-&gt;</operator><name>commitSeqNo</name></name><operator>)</operator>
				<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call>
					<operator>||</operator> <name><name>t2</name><operator>-&gt;</operator><name>prepareSeqNo</name></name> <operator>&lt;=</operator> <name><name>reader</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>lastCommitBeforeSnapshot</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>outConflicts</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>outLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>outLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*------------------------------------------------------------------------
	 * Check whether the reader has become a pivot with a writer
	 * that's committed (or prepared):
	 *
	 *		T0 ------&gt; R ------&gt; W
	 *			 rw		   rw
	 *
	 * Because W must've committed first for an anomaly to occur, there is no
	 * anomaly if:
	 * - T0 committed before the writer
	 * - T0 is READ ONLY, and overlaps the writer
	 *------------------------------------------------------------------------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>failure</name> <operator>&amp;&amp;</operator> <call><name>SxactIsPrepared</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>SxactHasSummaryConflictIn</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<while>while <condition>(<expr><name>conflict</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>t0</name> <init>= <expr><name><name>conflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call>
					<operator>||</operator> <name><name>t0</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>&gt;=</operator> <name><name>writer</name><operator>-&gt;</operator><name>prepareSeqNo</name></name><operator>)</operator>
				<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call>
					<operator>||</operator> <name><name>t0</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>lastCommitBeforeSnapshot</name></name> <operator>&gt;=</operator> <name><name>writer</name><operator>-&gt;</operator><name>prepareSeqNo</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>conflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>failure</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have to kill a transaction to avoid a possible anomaly from
		 * occurring. If the writer is us, we can just ereport() to cause a
		 * transaction abort. Otherwise we flag the writer for termination,
		 * causing it to abort when it tries to commit. However, if the writer
		 * is a prepared transaction, already prepared, we can't abort it
		 * anymore, so we have to kill the reader instead.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>==</operator> <name>writer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to read/write dependencies among transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Reason code: Canceled on identification as a pivot, during write."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The transaction might succeed if retried."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>SxactIsPrepared</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* if we're not the writer, we have to be the reader */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MySerializableXact</name> <operator>==</operator> <name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to read/write dependencies among transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Reason code: Canceled on conflict out to pivot %u, during read."</literal></expr></argument>, <argument><expr><name><name>writer</name><operator>-&gt;</operator><name>topXid</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The transaction might succeed if retried."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>writer</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_DOOMED</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PreCommit_CheckForSerializableConflicts
 *		Check for dangerous structures in a serializable transaction
 *		at commit.
 *
 * We're checking for a dangerous structure as each conflict is recorded.
 * The only way we could have a problem at commit is if this is the "out"
 * side of a pivot, and neither the "in" side nor the pivot has yet
 * committed.
 *
 * If a dangerous structure is found, the pivot (the near conflict) is
 * marked for death, because rolling back another transaction might mean
 * that we flail without ever making progress.  This transaction is
 * committing writes, so letting it commit ensures progress.  If we
 * canceled the far conflict, it might immediately fail again on retry.
 */</comment>
<function><type><name>void</name></type>
<name>PreCommit_CheckForSerializationFailure</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RWConflict</name></type>	<name>nearConflict</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if someone else has already decided that we need to die */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SxactIsPartiallyReleased</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to read/write dependencies among transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Reason code: Canceled on identification as a pivot, during commit attempt."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The transaction might succeed if retried."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>nearConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>nearConflict</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name><name>nearConflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name><name>nearConflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RWConflict</name></type>	<name>farConflict</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>farConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nearConflict</name><operator>-&gt;</operator><name>sxactOut</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>nearConflict</name><operator>-&gt;</operator><name>sxactOut</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>farConflict</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>farConflict</name><operator>-&gt;</operator><name>sxactOut</name></name> <operator>==</operator> <name>MySerializableXact</name>
					<operator>||</operator> <operator>(</operator><operator>!</operator><call><name>SxactIsCommitted</name><argument_list>(<argument><expr><name><name>farConflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call>
						<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name><name>farConflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call>
						<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SxactIsDoomed</name><argument_list>(<argument><expr><name><name>farConflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Normally, we kill the pivot transaction to make sure we
					 * make progress if the failing transaction is retried.
					 * However, we can't kill it if it's already prepared, so
					 * in that case we commit suicide instead.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>SxactIsPrepared</name><argument_list>(<argument><expr><name><name>nearConflict</name><operator>-&gt;</operator><name>sxactOut</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to read/write dependencies among transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Reason code: Canceled on commit attempt with conflict in from prepared pivot."</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The transaction might succeed if retried."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>nearConflict</name><operator>-&gt;</operator><name>sxactOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_DOOMED</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>farConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
					<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nearConflict</name><operator>-&gt;</operator><name>sxactOut</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>farConflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>,
								 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>nearConflict</name> <operator>=</operator> <operator>(</operator><name>RWConflict</name><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MySerializableXact</name><operator>-&gt;</operator><name>inConflicts</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>nearConflict</name><operator>-&gt;</operator><name>inLink</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RWConflictData</name></expr></argument>, <argument><expr><name>inLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>prepareSeqNo</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>PredXact</name><operator>-&gt;</operator><name>LastSxactCommitSeqNo</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_PREPARED</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * Two-phase commit support
 */</comment>

<comment type="block">/*
 * AtPrepare_Locks
 *		Do the preparatory work for a PREPARE: make 2PC state file
 *		records for all predicate locks currently held.
 */</comment>
<function><type><name>void</name></type>
<name>AtPrepare_PredicateLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PREDICATELOCK</name> <modifier>*</modifier></type><name>predlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TwoPhasePredicateRecord</name></type> <name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TwoPhasePredicateXactRecord</name> <modifier>*</modifier></type><name>xactRecord</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TwoPhasePredicateLockRecord</name> <modifier>*</modifier></type><name>lockRecord</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sxact</name> <operator>=</operator> <name>MySerializableXact</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xactRecord</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>record</name><operator>.</operator><name>data</name><operator>.</operator><name>xactRecord</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockRecord</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>record</name><operator>.</operator><name>data</name><operator>.</operator><name>lockRecord</name></name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Generate an xact record for our SERIALIZABLEXACT */</comment>
	<expr_stmt><expr><name><name>record</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>TWOPHASEPREDICATERECORD_XACT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xactRecord</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>MySerializableXact</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xactRecord</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>MySerializableXact</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that we don't include the list of conflicts in our out in the
	 * statefile, because new conflicts can be added even after the
	 * transaction prepares. We'll just make a conservative assumption during
	 * recovery instead.
	 */</comment>

	<expr_stmt><expr><call><name>RegisterTwoPhaseRecord</name><argument_list>(<argument><expr><name>TWOPHASE_RM_PREDICATELOCK_ID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>record</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate a lock record for each lock.
	 *
	 * To do this, we need to walk the predicate lock list in our sxact rather
	 * than using the local predicate lock table because the latter is not
	 * guaranteed to be accurate.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No need to take sxact-&gt;predicateLockListLock in parallel mode because
	 * there cannot be any parallel workers running while we are preparing a
	 * transaction.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ParallelContextActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>predlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>xactLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>predlock</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>record</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>TWOPHASEPREDICATERECORD_LOCK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lockRecord</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name><name>predlock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myTarget</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RegisterTwoPhaseRecord</name><argument_list>(<argument><expr><name>TWOPHASE_RM_PREDICATELOCK_ID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>record</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>predlock</name> <operator>=</operator> <operator>(</operator><name>PREDICATELOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>predlock</name><operator>-&gt;</operator><name>xactLink</name></name><operator>)</operator></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PREDICATELOCK</name></expr></argument>, <argument><expr><name>xactLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializablePredicateLockListLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PostPrepare_Locks
 *		Clean up after successful PREPARE. Unlike the non-predicate
 *		lock manager, we do not need to transfer locks to a dummy
 *		PGPROC because our SERIALIZABLEXACT will stay around
 *		anyway. We only need to clean up our local state.
 */</comment>
<function><type><name>void</name></type>
<name>PostPrepare_PredicateLocks</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SxactIsPrepared</name><argument_list>(<argument><expr><name>MySerializableXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MySerializableXact</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>LocalPredicateLockHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LocalPredicateLockHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>MySerializableXact</name> <operator>=</operator> <name>InvalidSerializableXact</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyXactDidWrite</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PredicateLockTwoPhaseFinish
 *		Release a prepared transaction's predicate locks once it
 *		commits or aborts.
 */</comment>
<function><type><name>void</name></type>
<name>PredicateLockTwoPhaseFinish</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SERIALIZABLEXID</name> <modifier>*</modifier></type><name>sxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SERIALIZABLEXIDTAG</name></type> <name>sxidtag</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sxidtag</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sxid</name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXID</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>SerializableXidHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sxidtag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* xid will not be found if it wasn't a serializable transaction */</comment>
	<if_stmt><if>if <condition>(<expr><name>sxid</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Release its locks */</comment>
	<expr_stmt><expr><name>MySerializableXact</name> <operator>=</operator> <name><name>sxid</name><operator>-&gt;</operator><name>myXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyXactDidWrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* conservatively assume that we wrote
								 * something */</comment>
	<expr_stmt><expr><call><name>ReleasePredicateLocks</name><argument_list>(<argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Re-acquire a predicate lock belonging to a transaction that was prepared.
 */</comment>
<function><type><name>void</name></type>
<name>predicatelock_twophase_recover</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
							   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TwoPhasePredicateRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhasePredicateRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>TwoPhasePredicateRecord</name> <operator>*</operator><operator>)</operator> <name>recdata</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TWOPHASEPREDICATERECORD_XACT</name><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TWOPHASEPREDICATERECORD_LOCK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TWOPHASEPREDICATERECORD_XACT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Per-transaction record. Set up a SERIALIZABLEXACT. */</comment>
		<decl_stmt><decl><type><name>TwoPhasePredicateXactRecord</name> <modifier>*</modifier></type><name>xactRecord</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SERIALIZABLEXID</name> <modifier>*</modifier></type><name>sxid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SERIALIZABLEXIDTAG</name></type> <name>sxidtag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>xactRecord</name> <operator>=</operator> <operator>(</operator><name>TwoPhasePredicateXactRecord</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>xactRecord</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sxact</name> <operator>=</operator> <call><name>CreatePredXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sxact</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* vxid for a prepared xact is InvalidBackendId/xid; no pid */</comment>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>vxid</name><operator>.</operator><name>backendId</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>vxid</name><operator>.</operator><name>localTransactionId</name></name> <operator>=</operator> <operator>(</operator><name>LocalTransactionId</name><operator>)</operator> <name>xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* a prepared xact hasn't committed yet */</comment>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>prepareSeqNo</name></name> <operator>=</operator> <name>RecoverySerCommitSeqNo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>commitSeqNo</name></name> <operator>=</operator> <name>InvalidSerCommitSeqNo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>finishedBefore</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>SeqNo</name><operator>.</operator><name>lastCommitBeforeSnapshot</name></name> <operator>=</operator> <name>RecoverySerCommitSeqNo</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Don't need to track this; no transactions running at the time the
		 * recovered xact started are still active, except possibly other
		 * prepared xacts and we don't care whether those are RO_SAFE or not.
		 */</comment>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>possibleUnsafeConflicts</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>predicateLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueElemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>finishedLink</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>topXid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>xactRecord</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>xactRecord</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SxactIsPrepared</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SxactIsReadOnly</name><argument_list>(<argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>PredXact</name><operator>-&gt;</operator><name>WritableSxactCount</name></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>WritableSxactCount</name></name> <operator>&lt;=</operator>
				   <operator>(</operator><name>MaxBackends</name> <operator>+</operator> <name>max_prepared_xacts</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We don't know whether the transaction had any conflicts or not, so
		 * we'll conservatively assume that it had both a conflict in and a
		 * conflict out, and represent that with the summary conflict flags.
		 */</comment>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>outConflicts</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sxact</name><operator>-&gt;</operator><name>inConflicts</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_SUMMARY_CONFLICT_IN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxact</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SXACT_FLAG_SUMMARY_CONFLICT_OUT</name></expr>;</expr_stmt>

		<comment type="block">/* Register the transaction's xid */</comment>
		<expr_stmt><expr><name><name>sxidtag</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sxid</name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXID</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SerializableXidHash</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>sxidtag</name></expr></argument>,
											   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sxid</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxid</name><operator>-&gt;</operator><name>myXact</name></name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXACT</name> <operator>*</operator><operator>)</operator> <name>sxact</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update global xmin. Note that this is a special case compared to
		 * registering a normal transaction, because the global xmin might go
		 * backwards. That's OK, because until recovery is over we're not
		 * going to complete any transactions or create any non-prepared
		 * transactions, so there's no danger of throwing away.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
			<operator>(</operator><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>, <argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name> <operator>=</operator> <name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>OldSerXidSetActiveSerXmin</name><argument_list>(<argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>sxact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>PredXact</name><operator>-&gt;</operator><name>SxactGlobalXminCount</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TWOPHASEPREDICATERECORD_LOCK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Lock record. Recreate the PREDICATELOCK */</comment>
		<decl_stmt><decl><type><name>TwoPhasePredicateLockRecord</name> <modifier>*</modifier></type><name>lockRecord</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SERIALIZABLEXID</name> <modifier>*</modifier></type><name>sxid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>sxact</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SERIALIZABLEXIDTAG</name></type> <name>sxidtag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>targettaghash</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lockRecord</name> <operator>=</operator> <operator>(</operator><name>TwoPhasePredicateLockRecord</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>lockRecord</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targettaghash</name> <operator>=</operator> <call><name>PredicateLockTargetTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lockRecord</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sxidtag</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sxid</name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXID</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search</name><argument_list>(<argument><expr><name>SerializableXidHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sxidtag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SerializableXactHashLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sxid</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sxact</name> <operator>=</operator> <name><name>sxid</name><operator>-&gt;</operator><name>myXact</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sxact</name> <operator>!=</operator> <name>InvalidSerializableXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CreatePredicateLock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lockRecord</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>targettaghash</name></expr></argument>, <argument><expr><name>sxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare to share the current SERIALIZABLEXACT with parallel workers.
 * Return a handle object that can be used by AttachSerializableXact() in a
 * parallel worker.
 */</comment>
<function><type><name>SerializableXactHandle</name></type>
<name>ShareSerializableXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>MySerializableXact</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allow parallel workers to import the leader's SERIALIZABLEXACT.
 */</comment>
<function><type><name>void</name></type>
<name>AttachSerializableXact</name><parameter_list>(<parameter><decl><type><name>SerializableXactHandle</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MySerializableXact</name> <operator>==</operator> <name>InvalidSerializableXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MySerializableXact</name> <operator>=</operator> <operator>(</operator><name>SERIALIZABLEXACT</name> <operator>*</operator><operator>)</operator> <name>handle</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>MySerializableXact</name> <operator>!=</operator> <name>InvalidSerializableXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateLocalPredicateLockHash</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
