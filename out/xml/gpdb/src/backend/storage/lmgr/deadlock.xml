<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/storage/lmgr/deadlock.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * deadlock.c
 *	  POSTGRES deadlock detection code
 *
 * See src/backend/storage/lmgr/README for a description of the deadlock
 * detection and resolution algorithms.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/lmgr/deadlock.c
 *
 *	Interface:
 *
 *	DeadLockCheck()
 *	DeadLockReport()
 *	RememberSimpleDeadLock()
 *	InitDeadLockChecking()
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resscheduler.h"</cpp:file></cpp:include>


<comment type="block">/*
 * One edge in the waits-for graph.
 *
 * waiter and blocker may or may not be members of a lock group, but if either
 * is, it will be the leader rather than any other member of the lock group.
 * The group leaders act as representatives of the whole group even though
 * those particular processes need not be waiting at all.  There will be at
 * least one member of the waiter's lock group on the wait queue for the given
 * lock, maybe more.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>waiter</name></decl>;</decl_stmt>			<comment type="block">/* the leader of the waiting lock group */</comment>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>blocker</name></decl>;</decl_stmt>		<comment type="block">/* the leader of the group it is waiting for */</comment>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>			<comment type="block">/* the lock being waited for */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>pred</name></decl>;</decl_stmt>			<comment type="block">/* workspace for TopoSort */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>link</name></decl>;</decl_stmt>			<comment type="block">/* workspace for TopoSort */</comment>
}</block></struct></type> <name>EDGE</name>;</typedef>

<comment type="block">/* One potential reordering of a lock's wait queue */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>			<comment type="block">/* the lock whose wait queue is described */</comment>
	<decl_stmt><decl><type><name>PGPROC</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>procs</name></decl>;</decl_stmt>			<comment type="block">/* array of PGPROC *'s in new wait order */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nProcs</name></decl>;</decl_stmt>
}</block></struct></type> <name>WAIT_ORDER</name>;</typedef>

<comment type="block">/*
 * Information saved about each edge in a detected deadlock cycle.  This
 * is used to print a diagnostic message upon failure.
 *
 * Note: because we want to examine this info after releasing the lock
 * manager's partition locks, we can't just store LOCK and PGPROC pointers;
 * we must extract out all the info we want to be able to print.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>locktag</name></decl>;</decl_stmt>		<comment type="block">/* ID of awaited lock object */</comment>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>		<comment type="block">/* type of lock we're waiting for */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>pid</name></decl>;</decl_stmt>			<comment type="block">/* PID of blocked backend */</comment>
}</block></struct></type> <name>DEADLOCK_INFO</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DeadLockCheckRecurse</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>TestConfiguration</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>startProc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FindLockCycle</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>checkProc</name></decl></parameter>,
						  <parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>softEdges</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nSoftEdges</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FindLockCycleRecurse</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>checkProc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>,
								 <parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>softEdges</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nSoftEdges</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FindLockCycleRecurseMember</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>checkProc</name></decl></parameter>,
									   <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>checkProcLeader</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>softEdges</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nSoftEdges</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExpandConstraints</name><parameter_list>(<parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nConstraints</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TopoSort</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nConstraints</name></decl></parameter>,
					 <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier><modifier>*</modifier></type><name>ordering</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_DEADLOCK</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrintLockQueue</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Working space for the deadlock detector
 */</comment>

<comment type="block">/* Workspace for FindLockCycle */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PGPROC</name> <modifier>*</modifier><modifier>*</modifier></type><name>visitedProcs</name></decl>;</decl_stmt>	<comment type="block">/* Array of visited procs */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nVisitedProcs</name></decl>;</decl_stmt>

<comment type="block">/* Workspace for TopoSort */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PGPROC</name> <modifier>*</modifier><modifier>*</modifier></type><name>topoProcs</name></decl>;</decl_stmt>		<comment type="block">/* Array of not-yet-output procs */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>beforeConstraints</name></decl>;</decl_stmt>	<comment type="block">/* Counts of remaining before-constraints */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>afterConstraints</name></decl>;</decl_stmt>	<comment type="block">/* List head for after-constraints */</comment>

<comment type="block">/* Output area for ExpandConstraints */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>WAIT_ORDER</name> <modifier>*</modifier></type><name>waitOrders</name></decl>;</decl_stmt>	<comment type="block">/* Array of proposed queue rearrangements */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nWaitOrders</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PGPROC</name> <modifier>*</modifier><modifier>*</modifier></type><name>waitOrderProcs</name></decl>;</decl_stmt> <comment type="block">/* Space for waitOrders queue contents */</comment>

<comment type="block">/* Current list of constraints being considered */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>EDGE</name> <modifier>*</modifier></type><name>curConstraints</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nCurConstraints</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>maxCurConstraints</name></decl>;</decl_stmt>

<comment type="block">/* Storage space for results from FindLockCycle */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>EDGE</name> <modifier>*</modifier></type><name>possibleConstraints</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nPossibleConstraints</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>maxPossibleConstraints</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DEADLOCK_INFO</name> <modifier>*</modifier></type><name>deadlockDetails</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nDeadlockDetails</name></decl>;</decl_stmt>

<comment type="block">/* PGPROC pointer of any blocking autovacuum worker found */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>blocking_autovacuum_proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * InitDeadLockChecking -- initialize deadlock checker during backend startup
 *
 * This does per-backend initialization of the deadlock checker; primarily,
 * allocation of working memory for DeadLockCheck.  We do this per-backend
 * since there's no percentage in making the kernel do copy-on-write
 * inheritance of workspace from the postmaster.  We want to allocate the
 * space at startup because (a) the deadlock checker might be invoked when
 * there's no free memory left, and (b) the checker is normally run inside a
 * signal handler, which is a very dangerous place to invoke palloc from.
 */</comment>
<function><type><name>void</name></type>
<name>InitDeadLockChecking</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure allocations are permanent */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * FindLockCycle needs at most MaxBackends entries in visitedProcs[] and
	 * deadlockDetails[].
	 */</comment>
	<expr_stmt><expr><name>visitedProcs</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>deadlockDetails</name> <operator>=</operator> <operator>(</operator><name>DEADLOCK_INFO</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DEADLOCK_INFO</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * TopoSort needs to consider at most MaxBackends wait-queue entries, and
	 * it needn't run concurrently with FindLockCycle.
	 */</comment>
	<expr_stmt><expr><name>topoProcs</name> <operator>=</operator> <name>visitedProcs</name></expr>;</expr_stmt>	<comment type="block">/* re-use this space */</comment>
	<expr_stmt><expr><name>beforeConstraints</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>afterConstraints</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to consider rearranging at most MaxBackends/2 wait queues
	 * (since it takes at least two waiters in a queue to create a soft edge),
	 * and the expanded form of the wait queues can't involve more than
	 * MaxBackends total waiters.
	 */</comment>
	<expr_stmt><expr><name>waitOrders</name> <operator>=</operator> <operator>(</operator><name>WAIT_ORDER</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>MaxBackends</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WAIT_ORDER</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>waitOrderProcs</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allow at most MaxBackends distinct constraints in a configuration. (Is
	 * this enough?  In practice it seems it should be, but I don't quite see
	 * how to prove it.  If we run out, we might fail to find a workable wait
	 * queue rearrangement even though one exists.)  NOTE that this number
	 * limits the maximum recursion depth of DeadLockCheckRecurse. Making it
	 * really big might potentially allow a stack-overflow problem.
	 */</comment>
	<expr_stmt><expr><name>maxCurConstraints</name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>curConstraints</name> <operator>=</operator> <operator>(</operator><name>EDGE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>maxCurConstraints</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EDGE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allow up to 3*MaxBackends constraints to be saved without having to
	 * re-run TestConfiguration.  (This is probably more than enough, but we
	 * can survive if we run low on space by doing excess runs of
	 * TestConfiguration to re-compute constraint lists each time needed.) The
	 * last MaxBackends entries in possibleConstraints[] are reserved as
	 * output workspace for FindLockCycle.
	 */</comment>
	<expr_stmt><expr><name>maxPossibleConstraints</name> <operator>=</operator> <name>MaxBackends</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>possibleConstraints</name> <operator>=</operator>
		<operator>(</operator><name>EDGE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>maxPossibleConstraints</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EDGE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DeadLockCheck -- Checks for deadlocks for a given process
 *
 * This code looks for deadlocks involving the given process.  If any
 * are found, it tries to rearrange lock wait queues to resolve the
 * deadlock.  If resolution is impossible, return DS_HARD_DEADLOCK ---
 * the caller is then expected to abort the given proc's transaction.
 *
 * Caller must already have locked all partitions of the lock tables.
 *
 * On failure, deadlock details are recorded in deadlockDetails[] for
 * subsequent printing by DeadLockReport().  That activity is separate
 * because (a) we don't want to do it while holding all those LWLocks,
 * and (b) we are typically invoked inside a signal handler.
 */</comment>
<function><type><name>DeadLockState</name></type>
<name>DeadLockCheck</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize to "no constraints" */</comment>
	<expr_stmt><expr><name>nCurConstraints</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nPossibleConstraints</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nWaitOrders</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Initialize to not blocked by an autovacuum worker */</comment>
	<expr_stmt><expr><name>blocking_autovacuum_proc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Search for deadlocks and possible fixes */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DeadLockCheckRecurse</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Call FindLockCycle one more time, to record the correct
		 * deadlockDetails[] for the basic state with no rearrangements.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>nSoftEdges</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_DEADLOCK_FOUND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nWaitOrders</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FindLockCycle</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>possibleConstraints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"deadlock seems to have disappeared"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>DS_HARD_DEADLOCK</name></expr>;</return>	<comment type="block">/* cannot find a non-deadlocked state */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Apply any needed rearrangements of wait queues */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nWaitOrders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name> <init>= <expr><name><name>waitOrders</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGPROC</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>procs</name> <init>= <expr><name><name>waitOrders</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>procs</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nProcs</name> <init>= <expr><name><name>waitOrders</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nProcs</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>waitQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nProcs</name> <operator>==</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_DEADLOCK</name></cpp:ifdef>
		<expr_stmt><expr><call><name>PrintLockQueue</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"DeadLockCheck:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Reset the queue and re-add procs in the desired order */</comment>
		<expr_stmt><expr><call><name>ProcQueueInit</name><argument_list>(<argument><expr><name>waitQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nProcs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>procs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>links</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_DEADLOCK</name></cpp:ifdef>
		<expr_stmt><expr><call><name>PrintLockQueue</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"rearranged to:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* See if any waiters for the lock can be woken up now.
		 * Except for resource queue because without release resource
		 * no one can procced. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name> <operator>!=</operator> <name>LOCKTAG_RESOURCE_QUEUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ProcLockWakeup</name><argument_list>(<argument><expr><call><name>GetLocksMethodTable</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Return code tells caller if we had to escape a deadlock or not */</comment>
	<if_stmt><if>if <condition>(<expr><name>nWaitOrders</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DS_SOFT_DEADLOCK</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>blocking_autovacuum_proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DS_BLOCKED_BY_AUTOVACUUM</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>DS_NO_DEADLOCK</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the PGPROC of the autovacuum that's blocking a process.
 *
 * We reset the saved pointer as soon as we pass it back.
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>GetBlockingAutoVacuumPgproc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>blocking_autovacuum_proc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>blocking_autovacuum_proc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DeadLockCheckRecurse -- recursively search for valid orderings
 *
 * curConstraints[] holds the current set of constraints being considered
 * by an outer level of recursion.  Add to this each possible solution
 * constraint for any cycle detected at this level.
 *
 * Returns true if no solution exists.  Returns false if a deadlock-free
 * state is attainable, in which case waitOrders[] shows the required
 * rearrangements of lock wait queues (if any).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DeadLockCheckRecurse</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nEdges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldPossibleConstraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>savedList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nEdges</name> <operator>=</operator> <call><name>TestConfiguration</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nEdges</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* hard deadlock --- no solution */</comment>
	<if_stmt><if>if <condition>(<expr><name>nEdges</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* good configuration found */</comment>
	<if_stmt><if>if <condition>(<expr><name>nCurConstraints</name> <operator>&gt;=</operator> <name>maxCurConstraints</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* out of room for active constraints? */</comment>
	<expr_stmt><expr><name>oldPossibleConstraints</name> <operator>=</operator> <name>nPossibleConstraints</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nPossibleConstraints</name> <operator>+</operator> <name>nEdges</name> <operator>+</operator> <name>MaxBackends</name> <operator>&lt;=</operator> <name>maxPossibleConstraints</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can save the edge list in possibleConstraints[] */</comment>
		<expr_stmt><expr><name>nPossibleConstraints</name> <operator>+=</operator> <name>nEdges</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>savedList</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Not room; will need to regenerate the edges on-the-fly */</comment>
		<expr_stmt><expr><name>savedList</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Try each available soft edge as an addition to the configuration.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nEdges</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>savedList</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Regenerate the list of possible added constraints */</comment>
			<if_stmt><if>if <condition>(<expr><name>nEdges</name> <operator>!=</operator> <call><name>TestConfiguration</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"inconsistent results during deadlock check"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>curConstraints</name><index>[<expr><name>nCurConstraints</name></expr>]</index></name> <operator>=</operator>
			<name><name>possibleConstraints</name><index>[<expr><name>oldPossibleConstraints</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nCurConstraints</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DeadLockCheckRecurse</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* found a valid solution! */</comment>
		<comment type="block">/* give up on that added constraint, try again */</comment>
		<expr_stmt><expr><name>nCurConstraints</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>nPossibleConstraints</name> <operator>=</operator> <name>oldPossibleConstraints</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>				<comment type="block">/* no solution found */</comment>
</block_content>}</block></function>


<comment type="block">/*--------------------
 * Test a configuration (current set of constraints) for validity.
 *
 * Returns:
 *		0: the configuration is good (no deadlocks)
 *	   -1: the configuration has a hard deadlock or is not self-consistent
 *		&gt;0: the configuration has one or more soft deadlocks
 *
 * In the soft-deadlock case, one of the soft cycles is chosen arbitrarily
 * and a list of its soft edges is returned beginning at
 * possibleConstraints+nPossibleConstraints.  The return value is the
 * number of soft edges.
 *--------------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>TestConfiguration</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>startProc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>softFound</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EDGE</name>	   <modifier>*</modifier></type><name>softEdges</name> <init>= <expr><name>possibleConstraints</name> <operator>+</operator> <name>nPossibleConstraints</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nSoftEdges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure we have room for FindLockCycle's output.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nPossibleConstraints</name> <operator>+</operator> <name>MaxBackends</name> <operator>&gt;</operator> <name>maxPossibleConstraints</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Expand current constraint set into wait orderings.  Fail if the
	 * constraint set is not self-consistent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExpandConstraints</name><argument_list>(<argument><expr><name>curConstraints</name></expr></argument>, <argument><expr><name>nCurConstraints</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for cycles involving startProc or any of the procs mentioned in
	 * constraints.  We check startProc last because if it has a soft cycle
	 * still to be dealt with, we want to deal with that first.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nCurConstraints</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FindLockCycle</name><argument_list>(<argument><expr><name><name>curConstraints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>waiter</name></expr></argument>, <argument><expr><name>softEdges</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nSoftEdges</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* hard deadlock detected */</comment>
			<expr_stmt><expr><name>softFound</name> <operator>=</operator> <name>nSoftEdges</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>FindLockCycle</name><argument_list>(<argument><expr><name><name>curConstraints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>blocker</name></expr></argument>, <argument><expr><name>softEdges</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nSoftEdges</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* hard deadlock detected */</comment>
			<expr_stmt><expr><name>softFound</name> <operator>=</operator> <name>nSoftEdges</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><call><name>FindLockCycle</name><argument_list>(<argument><expr><name>startProc</name></expr></argument>, <argument><expr><name>softEdges</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nSoftEdges</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* hard deadlock detected */</comment>
		<expr_stmt><expr><name>softFound</name> <operator>=</operator> <name>nSoftEdges</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>softFound</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindLockCycle -- basic check for deadlock cycles
 *
 * Scan outward from the given proc to see if there is a cycle in the
 * waits-for graph that includes this proc.  Return true if a cycle
 * is found, else false.  If a cycle is found, we return a list of
 * the "soft edges", if any, included in the cycle.  These edges could
 * potentially be eliminated by rearranging wait queues.  We also fill
 * deadlockDetails[] with information about the detected cycle; this info
 * is not used by the deadlock algorithm itself, only to print a useful
 * message after failing.
 *
 * Since we need to be able to check hypothetical configurations that would
 * exist after wait queue rearrangement, the routine pays attention to the
 * table of hypothetical queue orders in waitOrders[].  These orders will
 * be believed in preference to the actual ordering seen in the locktable.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FindLockCycle</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>checkProc</name></decl></parameter>,
			  <parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>softEdges</name></decl></parameter>,	<comment type="block">/* output argument */</comment>
			  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nSoftEdges</name></decl></parameter>)</parameter_list>	<comment type="block">/* output argument */</comment>
<block>{<block_content>
	<expr_stmt><expr><name>nVisitedProcs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nDeadlockDetails</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nSoftEdges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><call><name>FindLockCycleRecurse</name><argument_list>(<argument><expr><name>checkProc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>softEdges</name></expr></argument>, <argument><expr><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FindLockCycleRecurse</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>checkProc</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>,
					 <parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>softEdges</name></decl></parameter>,	<comment type="block">/* output argument */</comment>
					 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nSoftEdges</name></decl></parameter>)</parameter_list>	<comment type="block">/* output argument */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If this process is a lock group member, check the leader instead. (Note
	 * that we might be the leader, in which case this is a no-op.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>checkProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>checkProc</name> <operator>=</operator> <name><name>checkProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Have we already seen this proc?
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nVisitedProcs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>visitedProcs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>checkProc</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If we return to starting point, we have a deadlock cycle */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * record total length of cycle --- outer levels will now fill
				 * deadlockDetails[]
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>depth</name> <operator>&lt;=</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nDeadlockDetails</name> <operator>=</operator> <name>depth</name></expr>;</expr_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise, we have a cycle but it does not include the start
			 * point, so say "no deadlock".
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Mark proc as seen */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nVisitedProcs</name> <operator>&lt;</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>visitedProcs</name><index>[<expr><name>nVisitedProcs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>checkProc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the process is waiting, there is an outgoing waits-for edge to each
	 * process that blocks it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>checkProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>checkProc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>FindLockCycleRecurseMember</name><argument_list>(<argument><expr><name>checkProc</name></expr></argument>, <argument><expr><name>checkProc</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>softEdges</name></expr></argument>,
								   <argument><expr><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the process is not waiting, there could still be outgoing waits-for
	 * edges if it is part of a lock group, because other members of the lock
	 * group might be waiting even though this process is not.  (Given lock
	 * groups {A1, A2} and {B1, B2}, if A1 waits for B1 and B2 waits for A2,
	 * that is a deadlock even neither of B1 and A2 are waiting for anything.)
	 */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;checkProc-&gt;lockGroupMembers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>memberProc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>memberProc</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name>lockGroupLink</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>memberProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>memberProc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name>memberProc</name> <operator>!=</operator> <name>checkProc</name> <operator>&amp;&amp;</operator>
			<call><name>FindLockCycleRecurseMember</name><argument_list>(<argument><expr><name>memberProc</name></expr></argument>, <argument><expr><name>checkProc</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>softEdges</name></expr></argument>,
									   <argument><expr><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FindLockCycleRecurseMember</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>checkProc</name></decl></parameter>,
						   <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>checkProcLeader</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>,
						   <parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>softEdges</name></decl></parameter>, <comment type="block">/* output argument */</comment>
						   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nSoftEdges</name></decl></parameter>)</parameter_list> <comment type="block">/* output argument */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name> <init>= <expr><name><name>checkProc</name><operator>-&gt;</operator><name>waitLock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>pgxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>procLocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>waitQueue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queue_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>conflictMask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numLockModes</name></decl>,
				<decl><type ref="prev"/><name>lm</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <call><name>GetLocksMethodTable</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numLockModes</name> <operator>=</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>numLockModes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflictMask</name> <operator>=</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name><name>checkProc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan for procs that already hold conflicting locks.  These are "hard"
	 * edges in the waits-for graph.
	 */</comment>
	<expr_stmt><expr><name>procLocks</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
										 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>proclock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>leader</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pgxact</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>leader</name> <operator>=</operator> <ternary><condition><expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>proc</name></expr> </then><else>: <expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* A proc never blocks itself or any other lock group member */</comment>
		<if_stmt><if>if <condition>(<expr><name>leader</name> <operator>!=</operator> <name>checkProcLeader</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>lm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lm</name> <operator>&lt;=</operator> <name>numLockModes</name></expr>;</condition> <incr><expr><name>lm</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lm</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>conflictMask</name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lm</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* This proc hard-blocks checkProc */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>FindLockCycleRecurse</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											 <argument><expr><name>softEdges</name></expr></argument>, <argument><expr><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* fill deadlockDetails[] */</comment>
						<decl_stmt><decl><type><name>DEADLOCK_INFO</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>deadlockDetails</name><index>[<expr><name>depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>locktag</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>lockmode</name></name> <operator>=</operator> <name><name>checkProc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>checkProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>

						<return>return <expr><name>true</name></expr>;</return>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * No deadlock here, but see if this proc is an autovacuum
					 * that is directly hard-blocking our own proc.  If so,
					 * report it so that the caller can send a cancel signal
					 * to it, if appropriate.  If there's more than one such
					 * proc, it's indeterminate which one will be reported.
					 *
					 * We don't touch autovacuums that are indirectly blocking
					 * us; it's up to the direct blockee to take action.  This
					 * rule simplifies understanding the behavior and ensures
					 * that an autovacuum won't be canceled with less than
					 * deadlock_timeout grace period.
					 *
					 * Note we read vacuumFlags without any locking.  This is
					 * OK only for checking the PROC_IS_AUTOVACUUM flag,
					 * because that flag is set at process start and never
					 * reset.  There is logic elsewhere to avoid canceling an
					 * autovacuum that is working to prevent XID wraparound
					 * problems (which needs to read a different vacuumFlag
					 * bit), but we don't do that here to avoid grabbing
					 * ProcArrayLock.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>checkProc</name> <operator>==</operator> <name>MyProc</name> <operator>&amp;&amp;</operator>
						<name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_IS_AUTOVACUUM</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>blocking_autovacuum_proc</name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* We're done looking at this proclock */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>,
											 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Scan for procs that are ahead of this one in the lock's wait queue.
	 * Those that have conflicting requests soft-block this one.  This must be
	 * done after the hard-block search, since if another proc both hard- and
	 * soft-blocks this one, we want to call it a hard edge.
	 *
	 * If there is a proposed re-ordering of the lock's wait order, use that
	 * rather than the current wait order.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nWaitOrders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>waitOrders</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>==</operator> <name>lock</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nWaitOrders</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use the given hypothetical wait queue order */</comment>
		<decl_stmt><decl><type><name>PGPROC</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>procs</name> <init>= <expr><name><name>waitOrders</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>procs</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>queue_size</name> <operator>=</operator> <name><name>waitOrders</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nProcs</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>queue_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>leader</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>leader</name> <operator>=</operator> <ternary><condition><expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>proc</name></expr> </then><else>:
				<expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/*
			 * TopoSort will always return an ordering with group members
			 * adjacent to each other in the wait queue (see comments
			 * therein). So, as soon as we reach a process in the same lock
			 * group as checkProc, we know we've found all the conflicts that
			 * precede any member of the lock group lead by checkProcLeader.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>leader</name> <operator>==</operator> <name>checkProcLeader</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Is there a conflict with this guy's request? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>conflictMask</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* This proc soft-blocks checkProc */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>FindLockCycleRecurse</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										 <argument><expr><name>softEdges</name></expr></argument>, <argument><expr><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* fill deadlockDetails[] */</comment>
					<decl_stmt><decl><type><name>DEADLOCK_INFO</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>deadlockDetails</name><index>[<expr><name>depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>locktag</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>lockmode</name></name> <operator>=</operator> <name><name>checkProc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>checkProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Add this edge to the list of soft edges in the cycle
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>nSoftEdges</name> <operator>&lt;</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>softEdges</name><index>[<expr><operator>*</operator><name>nSoftEdges</name></expr>]</index></name><operator>.</operator><name>waiter</name> <operator>=</operator> <name>checkProcLeader</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>softEdges</name><index>[<expr><operator>*</operator><name>nSoftEdges</name></expr>]</index></name><operator>.</operator><name>blocker</name> <operator>=</operator> <name>leader</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>softEdges</name><index>[<expr><operator>*</operator><name>nSoftEdges</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>nSoftEdges</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>lastGroupMember</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Use the true lock wait queue order */</comment>
		<expr_stmt><expr><name>waitQueue</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find the last member of the lock group that is present in the wait
		 * queue.  Anything after this is not a soft lock conflict. If group
		 * locking is not in use, then we know immediately which process we're
		 * looking for, but otherwise we've got to search the wait queue to
		 * find the last process actually present.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>checkProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lastGroupMember</name> <operator>=</operator> <name>checkProc</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>queue_size</name> <operator>=</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>queue_size</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>checkProcLeader</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>lastGroupMember</name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lastGroupMember</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * OK, now rescan (or scan) the queue to identify the soft conflicts.
		 */</comment>
		<expr_stmt><expr><name>queue_size</name> <operator>=</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>queue_size</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>leader</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>leader</name> <operator>=</operator> <ternary><condition><expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>proc</name></expr> </then><else>:
				<expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/* Done when we reach the target proc */</comment>
			<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>lastGroupMember</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Is there a conflict with this guy's request? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>conflictMask</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name>leader</name> <operator>!=</operator> <name>checkProcLeader</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* This proc soft-blocks checkProc */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>FindLockCycleRecurse</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										 <argument><expr><name>softEdges</name></expr></argument>, <argument><expr><name>nSoftEdges</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* fill deadlockDetails[] */</comment>
					<decl_stmt><decl><type><name>DEADLOCK_INFO</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>deadlockDetails</name><index>[<expr><name>depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>locktag</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>lockmode</name></name> <operator>=</operator> <name><name>checkProc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>checkProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Add this edge to the list of soft edges in the cycle
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>nSoftEdges</name> <operator>&lt;</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>softEdges</name><index>[<expr><operator>*</operator><name>nSoftEdges</name></expr>]</index></name><operator>.</operator><name>waiter</name> <operator>=</operator> <name>checkProcLeader</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>softEdges</name><index>[<expr><operator>*</operator><name>nSoftEdges</name></expr>]</index></name><operator>.</operator><name>blocker</name> <operator>=</operator> <name>leader</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>softEdges</name><index>[<expr><operator>*</operator><name>nSoftEdges</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>nSoftEdges</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * No conflict detected here.
	 */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExpandConstraints -- expand a list of constraints into a set of
 *		specific new orderings for affected wait queues
 *
 * Input is a list of soft edges to be reversed.  The output is a list
 * of nWaitOrders WAIT_ORDER structs in waitOrders[], with PGPROC array
 * workspace in waitOrderProcs[].
 *
 * Returns true if able to build an ordering that satisfies all the
 * constraints, false if not (there are contradictory constraints).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExpandConstraints</name><parameter_list>(<parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>nConstraints</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nWaitOrderProcs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nWaitOrders</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan constraint list backwards.  This is because the last-added
	 * constraint is the only one that could fail, and so we want to test it
	 * for inconsistency first.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nConstraints</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name> <init>= <expr><name><name>constraints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Did we already make a list for this lock? */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>nWaitOrders</name></expr>;</init> <condition><expr><operator>--</operator><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>waitOrders</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>==</operator> <name>lock</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* No, so allocate a new list */</comment>
		<expr_stmt><expr><name><name>waitOrders</name><index>[<expr><name>nWaitOrders</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>waitOrders</name><index>[<expr><name>nWaitOrders</name></expr>]</index></name><operator>.</operator><name>procs</name> <operator>=</operator> <name>waitOrderProcs</name> <operator>+</operator> <name>nWaitOrderProcs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>waitOrders</name><index>[<expr><name>nWaitOrders</name></expr>]</index></name><operator>.</operator><name>nProcs</name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nWaitOrderProcs</name> <operator>+=</operator> <name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nWaitOrderProcs</name> <operator>&lt;=</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do the topo sort.  TopoSort need not examine constraints after this
		 * one, since they must be for different locks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TopoSort</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					  <argument><expr><name><name>waitOrders</name><index>[<expr><name>nWaitOrders</name></expr>]</index></name><operator>.</operator><name>procs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>nWaitOrders</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TopoSort -- topological sort of a wait queue
 *
 * Generate a re-ordering of a lock's wait queue that satisfies given
 * constraints about certain procs preceding others.  (Each such constraint
 * is a fact of a partial ordering.)  Minimize rearrangement of the queue
 * not needed to achieve the partial ordering.
 *
 * This is a lot simpler and slower than, for example, the topological sort
 * algorithm shown in Knuth's Volume 1.  However, Knuth's method doesn't
 * try to minimize the damage to the existing order.  In practice we are
 * not likely to be working with more than a few constraints, so the apparent
 * slowness of the algorithm won't really matter.
 *
 * The initial queue ordering is taken directly from the lock's wait queue.
 * The output is an array of PGPROC pointers, of length equal to the lock's
 * wait queue length (the caller is responsible for providing this space).
 * The partial order is specified by an array of EDGE structs.  Each EDGE
 * is one that we need to reverse, therefore the "waiter" must appear before
 * the "blocker" in the output array.  The EDGE array may well contain
 * edges associated with other locks; these should be ignored.
 *
 * Returns true if able to build an ordering that satisfies all the
 * constraints, false if not (there are contradictory constraints).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TopoSort</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>,
		 <parameter><decl><type><name>EDGE</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>nConstraints</name></decl></parameter>,
		 <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier><modifier>*</modifier></type><name>ordering</name></decl></parameter>)</parameter_list>		<comment type="block">/* output argument */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>waitQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queue_size</name> <init>= <expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>jj</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>,
				<decl><type ref="prev"/><name>kk</name></decl>,
				<decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>

	<comment type="block">/* First, fill topoProcs[] array with the procs in their current order */</comment>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>queue_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>topoProcs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Scan the constraints, and for each proc in the array, generate a count
	 * of the number of constraints that say it must be before something else,
	 * plus a list of the constraints that say it must be after something
	 * else. The count for the j'th proc is stored in beforeConstraints[j],
	 * and the head of its list in afterConstraints[j].  Each constraint
	 * stores its list link in constraints[i].link (note any constraint will
	 * be in just one list). The array index for the before-proc of the i'th
	 * constraint is remembered in constraints[i].pred.
	 *
	 * Note that it's not necessarily the case that every constraint affects
	 * this particular wait queue.  Prior to group locking, a process could be
	 * waiting for at most one lock.  But a lock group can be waiting for
	 * zero, one, or multiple locks.  Since topoProcs[] is an array of the
	 * processes actually waiting, while constraints[] is an array of group
	 * leaders, we've got to scan through topoProcs[] for each constraint,
	 * checking whether both a waiter and a blocker for that group are
	 * present.  If so, the constraint is relevant to this wait queue; if not,
	 * it isn't.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>beforeConstraints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>queue_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>afterConstraints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>queue_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nConstraints</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Find a representative process that is on the lock queue and part of
		 * the waiting lock group.  This may or may not be the leader, which
		 * may or may not be waiting at all.  If there are any other processes
		 * in the same lock group on the queue, set their number of
		 * beforeConstraints to -1 to indicate that they should be emitted
		 * with their groupmates rather than considered separately.
		 */</comment>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>constraints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>waiter</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jj</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>queue_size</name></expr>;</init> <condition><expr><operator>--</operator><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>waiter</name> <init>= <expr><name><name>topoProcs</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>waiter</name> <operator>==</operator> <name>proc</name> <operator>||</operator> <name><name>waiter</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>proc</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waiter</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>==</operator> <name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>jj</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>jj</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>beforeConstraints</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>beforeConstraints</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If no matching waiter, constraint is not relevant to this lock. */</comment>
		<if_stmt><if>if <condition>(<expr><name>jj</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Similarly, find a representative process that is on the lock queue
		 * and waiting for the blocking lock group.  Again, this could be the
		 * leader but does not need to be.
		 */</comment>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>constraints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>blocker</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>kk</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>queue_size</name></expr>;</init> <condition><expr><operator>--</operator><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>blocker</name> <init>= <expr><name><name>topoProcs</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>blocker</name> <operator>==</operator> <name>proc</name> <operator>||</operator> <name><name>blocker</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>proc</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blocker</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>==</operator> <name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>kk</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>kk</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>beforeConstraints</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>beforeConstraints</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If no matching blocker, constraint is not relevant to this lock. */</comment>
		<if_stmt><if>if <condition>(<expr><name>kk</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>beforeConstraints</name><index>[<expr><name>jj</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* waiter must come before */</comment>
		<comment type="block">/* add this constraint to list of after-constraints for blocker */</comment>
		<expr_stmt><expr><name><name>constraints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pred</name> <operator>=</operator> <name>jj</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>link</name> <operator>=</operator> <name><name>afterConstraints</name><index>[<expr><name>kk</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>afterConstraints</name><index>[<expr><name>kk</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*--------------------
	 * Now scan the topoProcs array backwards.  At each step, output the
	 * last proc that has no remaining before-constraints plus any other
	 * members of the same lock group; then decrease the beforeConstraints
	 * count of each of the procs it was constrained against.
	 * i = index of ordering[] entry we want to output this time
	 * j = search index for topoProcs[]
	 * k = temp for scanning constraint list for proc j
	 * last = last non-null index in topoProcs (avoid redundant searches)
	 *--------------------
	 */</comment>
	<expr_stmt><expr><name>last</name> <operator>=</operator> <name>queue_size</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>queue_size</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nmatches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Find next candidate to output */</comment>
		<while>while <condition>(<expr><name><name>topoProcs</name><index>[<expr><name>last</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>last</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>last</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>topoProcs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>beforeConstraints</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If no available candidate, topological sort fails */</comment>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Output everything in the lock group.  There's no point in
		 * outputting an ordering where members of the same lock group are not
		 * consecutive on the wait queue: if some other waiter is between two
		 * requests that belong to the same group, then either it conflicts
		 * with both of them and is certainly not a solution; or it conflicts
		 * with at most one of them and is thus isomorphic to an ordering
		 * where the group members are consecutive.
		 */</comment>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>topoProcs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><operator>++</operator><name>c</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>topoProcs</name><index>[<expr><name>c</name></expr>]</index></name> <operator>==</operator> <name>proc</name> <operator>||</operator> <operator>(</operator><name><name>topoProcs</name><index>[<expr><name>c</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
										 <name><name>topoProcs</name><index>[<expr><name>c</name></expr>]</index></name><operator>-&gt;</operator><name>lockGroupLeader</name> <operator>==</operator> <name>proc</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ordering</name><index>[<expr><name>i</name> <operator>-</operator> <name>nmatches</name></expr>]</index></name> <operator>=</operator> <name><name>topoProcs</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>topoProcs</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>++</operator><name>nmatches</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nmatches</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>-=</operator> <name>nmatches</name></expr>;</expr_stmt>

		<comment type="block">/* Update beforeConstraints counts of its predecessors */</comment>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name><name>afterConstraints</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name> <operator>=</operator> <name><name>constraints</name><index>[<expr><name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>link</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>beforeConstraints</name><index>[<expr><name><name>constraints</name><index>[<expr><name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pred</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<comment type="block">/* Done */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_DEADLOCK</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintLockQueue</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>waitQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queue_size</name> <init>= <expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s lock %p queue "</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>queue_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Report a detected deadlock, with available details.
 */</comment>
<function><type><name>void</name></type>
<name>DeadLockReport</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>clientbuf</name></decl>;</decl_stmt>	<comment type="block">/* errdetail for client */</comment>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>logbuf</name></decl>;</decl_stmt>		<comment type="block">/* errdetail for server log */</comment>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>locktagbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktagbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Generate the "waits for" lines sent to the client */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nDeadlockDetails</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DEADLOCK_INFO</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>deadlockDetails</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nextpid</name></decl>;</decl_stmt>

		<comment type="block">/* The last proc waits for the first one... */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nDeadlockDetails</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextpid</name> <operator>=</operator> <name><name>info</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextpid</name> <operator>=</operator> <name><name>deadlockDetails</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* reset locktagbuf to hold next object description */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktagbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DescribeLockTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktagbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>locktag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientbuf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientbuf</name></expr></argument>,
						 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Process %d waits for %s on %s; blocked by process %d."</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>info</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
						 <argument><expr><call><name>GetLockmodeName</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_lockmethodid</name></name></expr></argument>,
										 <argument><expr><name><name>info</name><operator>-&gt;</operator><name>lockmode</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>locktagbuf</name><operator>.</operator><name>data</name></name></expr></argument>,
						 <argument><expr><name>nextpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Duplicate all the above for the server ... */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><name><name>clientbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and add info about query strings */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nDeadlockDetails</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DEADLOCK_INFO</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>deadlockDetails</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>,
						 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Process %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>info</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
						 <argument><expr><call><name>pgstat_get_backend_current_activity</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pgstat_report_deadlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_DEADLOCK_DETECTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"deadlock detected"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>clientbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_log</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>logbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"See server log for query details."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RememberSimpleDeadLock: set up info for DeadLockReport when ProcSleep
 * detects a trivial (two-way) deadlock.  proc1 wants to block for lockmode
 * on lock, but proc2 is already waiting and would be blocked by proc1.
 */</comment>
<function><type><name>void</name></type>
<name>RememberSimpleDeadLock</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc1</name></decl></parameter>,
					   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
					   <parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>,
					   <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DEADLOCK_INFO</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>deadlockDetails</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>locktag</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>lockmode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>proc1</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>info</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>locktag</name></name> <operator>=</operator> <name><name>proc2</name><operator>-&gt;</operator><name>waitLock</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>lockmode</name></name> <operator>=</operator> <name><name>proc2</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>proc2</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nDeadlockDetails</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
