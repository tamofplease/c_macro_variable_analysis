<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/storage/smgr/smgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * smgr.c
 *	  public interface routines to storage manager switch.
 *
 *	  All file system operations in POSTGRES dispatch through these
 *	  routines.
 *
 * Portions Copyright (c) 2006-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/smgr/smgr.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aomd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/md.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Hook for plugins to collect statistics from storage functions
 * For example, disk quota extension will use these hooks to
 * detect active tables.
 */</comment>
<decl_stmt><decl><type><name>file_create_hook_type</name></type> <name>file_create_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>file_extend_hook_type</name></type> <name>file_extend_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>file_truncate_hook_type</name></type> <name>file_truncate_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>file_unlink_hook_type</name></type> <name>file_unlink_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>f_smgr</name></type> <name><name>smgrsw</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/* magnetic disk */</comment>
	<expr><block>{
		<expr><operator>.</operator><name>smgr_init</name> <operator>=</operator> <name>mdinit</name></expr>,
		<expr><operator>.</operator><name>smgr_shutdown</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>smgr_close</name> <operator>=</operator> <name>mdclose</name></expr>,
		<expr><operator>.</operator><name>smgr_create</name> <operator>=</operator> <name>mdcreate</name></expr>,
		<expr><operator>.</operator><name>smgr_exists</name> <operator>=</operator> <name>mdexists</name></expr>,
		<expr><operator>.</operator><name>smgr_unlink</name> <operator>=</operator> <name>mdunlink</name></expr>,
		<expr><operator>.</operator><name>smgr_extend</name> <operator>=</operator> <name>mdextend</name></expr>,
		<expr><operator>.</operator><name>smgr_prefetch</name> <operator>=</operator> <name>mdprefetch</name></expr>,
		<expr><operator>.</operator><name>smgr_read</name> <operator>=</operator> <name>mdread</name></expr>,
		<expr><operator>.</operator><name>smgr_write</name> <operator>=</operator> <name>mdwrite</name></expr>,
		<expr><operator>.</operator><name>smgr_writeback</name> <operator>=</operator> <name>mdwriteback</name></expr>,
		<expr><operator>.</operator><name>smgr_nblocks</name> <operator>=</operator> <name>mdnblocks</name></expr>,
		<expr><operator>.</operator><name>smgr_truncate</name> <operator>=</operator> <name>mdtruncate</name></expr>,
		<expr><operator>.</operator><name>smgr_immedsync</name> <operator>=</operator> <name>mdimmedsync</name></expr>,
	}</block></expr>,
	<comment type="block">/*
	 * Relation files that are different from heap, characterised by:
	 *     1. variable blocksize
	 *     2. block numbers are not consecutive
	 *     3. shared buffers are not used
	 * Append-optimized relation files currently fall in this category.
	 */</comment>
	<expr><block>{
		<expr><operator>.</operator><name>smgr_init</name> <operator>=</operator> <name>mdinit</name></expr>,
		<expr><operator>.</operator><name>smgr_shutdown</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>smgr_close</name> <operator>=</operator> <name>mdclose</name></expr>,
		<expr><operator>.</operator><name>smgr_create</name> <operator>=</operator> <name>mdcreate</name></expr>,
		<expr><operator>.</operator><name>smgr_exists</name> <operator>=</operator> <name>mdexists</name></expr>,
		<expr><operator>.</operator><name>smgr_unlink</name> <operator>=</operator> <name>mdunlink_ao</name></expr>,
		<expr><operator>.</operator><name>smgr_extend</name> <operator>=</operator> <name>mdextend</name></expr>,
		<expr><operator>.</operator><name>smgr_prefetch</name> <operator>=</operator> <name>mdprefetch</name></expr>,
		<expr><operator>.</operator><name>smgr_read</name> <operator>=</operator> <name>mdread</name></expr>,
		<expr><operator>.</operator><name>smgr_write</name> <operator>=</operator> <name>mdwrite</name></expr>,
		<expr><operator>.</operator><name>smgr_writeback</name> <operator>=</operator> <name>mdwriteback</name></expr>,
		<expr><operator>.</operator><name>smgr_nblocks</name> <operator>=</operator> <name>mdnblocks</name></expr>,
		<expr><operator>.</operator><name>smgr_truncate</name> <operator>=</operator> <name>mdtruncate</name></expr>,
		<expr><operator>.</operator><name>smgr_immedsync</name> <operator>=</operator> <name>mdimmedsync</name></expr>,
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>NSmgr</name> <init>= <expr><call><name>lengthof</name><argument_list>(<argument><expr><name>smgrsw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Each backend has a hashtable that stores all extant SMgrRelation objects.
 * In addition, "unowned" SMgrRelation objects are chained together in a list.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>SMgrRelationHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>unowned_relns</name></decl>;</decl_stmt>

<comment type="block">/* local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>smgrshutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	smgrinit(), smgrshutdown() -- Initialize or shut down storage
 *								  managers.
 *
 * Note: smgrinit is called during backend startup (normal or standalone
 * case), *not* during postmaster start.  Therefore, any resources created
 * here or destroyed in smgrshutdown are backend-local.
 */</comment>

<function><type><name>void</name></type>
<name>smgr_init_standard</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_init</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>mdinit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>smgrinit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>smgr_init_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>smgr_init_hook</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>smgr_init_standard</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* register the shutdown proc */</comment>
	<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>smgrshutdown</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * on_proc_exit hook for smgr cleanup during backend shutdown
 */</comment>


<function><type><name>void</name></type> <name>smgr_shutdown_standard</name><parameter_list>()</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_shutdown</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>smgrshutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>smgr_shutdown_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>smgr_shutdown_hook</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>smgr_shutdown_standard</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Hooks for plugins to get control in smgr */</comment>
<decl_stmt><decl><type><name>smgr_hook_type</name></type> <name>smgr_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>smgr_init_hook_type</name></type> <name>smgr_init_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>smgr_shutdown_hook_type</name></type> <name>smgr_shutdown_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name>f_smgr</name> <modifier>*</modifier></type>
<name>smgr_standard</name><parameter_list>(<parameter><decl><type><name>BackendId</name></type> <name>backend</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>SMgrImpl</name></type> <name>which</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// for md.c </comment>
	<return>return <expr><operator>&amp;</operator><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>f_smgr</name> <modifier>*</modifier></type>
<name>smgr</name><parameter_list>(<parameter><decl><type><name>BackendId</name></type> <name>backend</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>SMgrImpl</name></type> <name>which</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>f_smgr</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>smgr_hook</name></expr>)</condition>
 	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>smgr_hook</name>)<argument_list>(<argument><expr><name>backend</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>which</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>smgr_standard</name><argument_list>(<argument><expr><name>backend</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>which</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	smgropen() -- Return an SMgrRelation object, creating it if need be.
 *
 *		This does not attempt to actually open the underlying file.
 */</comment>
<function><type><name>SMgrRelation</name></type>
<name>smgropen</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>BackendId</name></type> <name>backend</name></decl></parameter>, <parameter><decl><type><name>SMgrImpl</name></type> <name>which</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>brnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* GPDB: don't support MyBackendId as a possible backend. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>backend</name> <operator>==</operator> <name>InvalidBackendId</name> <operator>||</operator> <name>backend</name> <operator>==</operator> <name>TempRelBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>SMgrRelationHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the hash table */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNodeBackend</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SMgrRelationData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>SMgrRelationHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"smgr relation table"</literal></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unowned_relns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Look up or create an entry */</comment>
	<expr_stmt><expr><name><name>brnode</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>brnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name>backend</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reln</name> <operator>=</operator> <operator>(</operator><name>SMgrRelation</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SMgrRelationHash</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>brnode</name></expr></argument>,
									  <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize it if not present before */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>forknum</name></decl>;</decl_stmt>

		<comment type="block">/* hash_search already filled in the lookup key */</comment>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_targblock</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_fsm_nblocks</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_vm_nblocks</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name> <operator>=</operator> <name>which</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name> <operator>=</operator> <call><name>smgr</name><argument_list>(<argument><expr><name>backend</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>which</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* mark it not open */</comment>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* it has no owner yet */</comment>
		<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unowned_relns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>reln</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * smgrsetowner() -- Establish a long-lived reference to an SMgrRelation object
 *
 * There can be only one owner at a time; this is sufficient since currently
 * the only such owners exist in the relcache.
 */</comment>
<function><type><name>void</name></type>
<name>smgrsetowner</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We don't support "disowning" an SMgrRelation here, use smgrclearowner */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>owner</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, unhook any old owner.  (Normally there shouldn't be any, but it
	 * seems possible that this can happen during swap_relation_files()
	 * depending on the order of processing.  It's ok to close the old
	 * relcache entry early in that case.)
	 *
	 * If there isn't an old owner, then the reln should be in the unowned
	 * list, and we need to remove it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Now establish the ownership relationship. */</comment>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>owner</name> <operator>=</operator> <name>reln</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * smgrclearowner() -- Remove long-lived reference to an SMgrRelation object
 *					   if one exists
 */</comment>
<function><type><name>void</name></type>
<name>smgrclearowner</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Do nothing if the SMgrRelation object is not owned by the owner */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>!=</operator> <name>owner</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* unset the owner's reference */</comment>
	<expr_stmt><expr><operator>*</operator><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* unset our reference to the owner */</comment>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* add to list of unowned relations */</comment>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unowned_relns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrexists() -- Does the underlying file for a fork exist?
 */</comment>
<function><type><name>bool</name></type>
<name>smgrexists</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_exists</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrclose() -- Close and delete an SMgrRelation object.
 */</comment>
<function><type><name>void</name></type>
<name>smgrclose</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>owner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_close</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>owner</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>owner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SMgrRelationHash</name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name><operator>)</operator></expr></argument>,
					<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SMgrRelation hashtable corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unhook the owner pointer, if any.  We do this last since in the remote
	 * possibility of failure above, the SMgrRelation object will still exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>owner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrcloseall() -- Close all existing SMgrRelation objects.
 */</comment>
<function><type><name>void</name></type>
<name>smgrcloseall</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if hashtable not set up */</comment>
	<if_stmt><if>if <condition>(<expr><name>SMgrRelationHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SMgrRelationHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>reln</name> <operator>=</operator> <operator>(</operator><name>SMgrRelation</name><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrclosenode() -- Close SMgrRelation object for given RelFileNode,
 *					   if one exists.
 *
 * This has the same effects as smgrclose(smgropen(rnode)), but it avoids
 * uselessly creating a hashtable entry only to drop it again when no
 * such entry exists already.
 */</comment>
<function><type><name>void</name></type>
<name>smgrclosenode</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if hashtable not set up */</comment>
	<if_stmt><if>if <condition>(<expr><name>SMgrRelationHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reln</name> <operator>=</operator> <operator>(</operator><name>SMgrRelation</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SMgrRelationHash</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rnode</name></expr></argument>,
									  <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>reln</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrcreate() -- Create a new relation.
 *
 *		Given an already-created (but presumably unused) SMgrRelation,
 *		cause the underlying disk file or other storage for the fork
 *		to be created.
 *
 *		If isRedo is true, it is okay for the underlying file to exist
 *		already because we are in a WAL replay sequence.
 */</comment>
<function><type><name>void</name></type>
<name>smgrcreate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Exit quickly in WAL replay mode if we've already opened the file. If
	 * it's open, it surely must exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isRedo</name> <operator>&amp;&amp;</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We may be using the target table space for the first time in this
	 * database, so create a per-database subdirectory if needed.
	 *
	 * XXX this is a fairly ugly violation of module layering, but this seems
	 * to be the best place to put the check.  Maybe TablespaceCreateDbspace
	 * should be here and not in commands/tablespace.c?  But that would imply
	 * importing a lot of stuff that smgr.c oughtn't know, either.
	 */</comment>
	<expr_stmt><expr><call><name>TablespaceCreateDbspace</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
							<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
							<argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_create</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>file_create_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>file_create_hook</name>)<argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		smgrcreate_ao() -- Create a new AO relation segment.
 *		Given a RelFileNode, cause the underlying disk file for the
 *		AO segment to be created.
 *
 *		If isRedo is true, it is okay for the underlying file to exist
 *		already because we are in a WAL replay sequence.
 */</comment>
<function><type><name>void</name></type>
<name>smgrcreate_ao</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>segmentFileNum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>mdcreate_ao</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>segmentFileNum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file_create_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>file_create_hook</name>)<argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrdounlinkall() -- Immediately unlink all forks of all given relations
 *
 *		All forks of all given relations are removed from the store.  This
 *		should not be used during transactional operations, since it can't be
 *		undone.
 *
 *		If isRedo is true, it is okay for the underlying file(s) to be gone
 *		already.
 */</comment>
<function><type><name>void</name></type>
<name>smgrdounlinkall</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name> <modifier>*</modifier></type><name>rnodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nrels</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * create an array which contains all relations to be dropped, and close
	 * each relation's forks at the smgr level while at it
	 */</comment>
	<expr_stmt><expr><name>rnodes</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNodeBackend</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>smgr_rnode</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>

		<comment type="block">/* Close the forks at smgr level */</comment>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			 <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>storageManager</name><operator>)</operator><operator>.</operator><call><name>smgr_close</name><argument_list>(<argument><expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Get rid of any remaining buffers for the relations.  bufmgr will just
	 * drop them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodesAllBuffers</name><argument_list>(<argument><expr><name>rnodes</name></expr></argument>, <argument><expr><name>nrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It'd be nice to tell the stats collector to forget them immediately,
	 * too. But we can't because we don't know the OIDs.
	 */</comment>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any
	 * dangling smgr references they may have for these rels.  We should do
	 * this before starting the actual unlinking, in case we fail partway
	 * through that step.  Note that the sinval messages will eventually come
	 * back to this backend, too, and thereby provide a backstop that we
	 * closed our own smgr rel.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Delete the physical file(s).
	 *
	 * Note: smgr_unlink must treat deletion failure as a WARNING, not an
	 * ERROR, because we've already decided to commit or abort the current
	 * xact.
	 */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>storageManager</name><operator>)</operator><operator>.</operator><call><name>smgr_unlink</name><argument_list>(<argument><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>file_unlink_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call>(<modifier>*</modifier><name>file_unlink_hook</name>)<argument_list>(<argument><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrdounlinkfork() -- Immediately unlink one fork of a relation.
 *
 *		The specified fork of the relation is removed from the store.  This
 *		should not be used during transactional operations, since it can't be
 *		undone.
 *
 *		If isRedo is true, it is okay for the underlying file to be gone
 *		already.
 */</comment>
<function><type><name>void</name></type>
<name>smgrdounlinkfork</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Close the fork at smgr level */</comment>
	<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_close</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get rid of any remaining buffers for the fork.  bufmgr will just drop
	 * them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodeBuffers</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It'd be nice to tell the stats collector to forget it immediately, too.
	 * But we can't because we don't know the OID (and in cases involving
	 * relfilenode swaps, it's not always clear which table OID to forget,
	 * anyway).
	 */</comment>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any
	 * dangling smgr references they may have for this rel.  We should do this
	 * before starting the actual unlinking, in case we fail partway through
	 * that step.  Note that the sinval message will eventually come back to
	 * this backend, too, and thereby provide a backstop that we closed our
	 * own smgr rel.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete the physical file(s).
	 *
	 * Note: smgr_unlink must treat deletion failure as a WARNING, not an
	 * ERROR, because we've already decided to commit or abort the current
	 * xact.
	 */</comment>
	<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_unlink</name></name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrextend() -- Add a new block to a file.
 *
 *		The semantics are nearly the same as smgrwrite(): write at the
 *		specified position.  However, this is to be used for the case of
 *		extending a relation (i.e., blocknum is at or beyond the current
 *		EOF).  Note that we assume writing a block beyond current EOF
 *		causes intervening file space to become filled with zeroes.
 *		failure we clean up by truncating.
 */</comment>
<function><type><name>void</name></type>
<name>smgrextend</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_extend</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										 <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>file_extend_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>file_extend_hook</name>)<argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrprefetch() -- Initiate asynchronous read of the specified block of a relation.
 */</comment>
<function><type><name>void</name></type>
<name>smgrprefetch</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_prefetch</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrread() -- read a particular block from a relation into the supplied
 *				  buffer.
 *
 *		This routine is called from the buffer manager in order to
 *		instantiate pages in the shared buffer cache.  All storage managers
 *		return pages in the format that POSTGRES expects.
 */</comment>
<function><type><name>void</name></type>
<name>smgrread</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_read</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrwrite() -- Write the supplied buffer out.
 *
 *		This is to be used only for updating already-existing blocks of a
 *		relation (ie, those before the current EOF).  To extend a relation,
 *		use smgrextend().
 *
 *		This is not a synchronous write -- the block is not necessarily
 *		on disk at return, only dumped out to the kernel.  However,
 *		provisions will be made to fsync the write before the next checkpoint.
 *
 *		skipFsync indicates that the caller will make other provisions to
 *		fsync the relation, so we needn't bother.  Temporary relations also
 *		do not require fsync.
 */</comment>
<function><type><name>void</name></type>
<name>smgrwrite</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_write</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	smgrwriteback() -- Trigger kernel writeback for the supplied range of
 *					   blocks.
 */</comment>
<function><type><name>void</name></type>
<name>smgrwriteback</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
			  <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_writeback</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
											<argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrnblocks() -- Calculate the number of blocks in the
 *					 supplied relation.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>smgrnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_nblocks</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrtruncate() -- Truncate supplied relation to the specified number
 *					  of blocks
 *
 * The truncation is done immediately, so this can't be rolled back.
 */</comment>
<function><type><name>void</name></type>
<name>smgrtruncate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Get rid of any buffers for the about-to-be-deleted blocks. bufmgr will
	 * just drop them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodeBuffers</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any smgr
	 * references they may have for this rel.  This is useful because they
	 * might have open file pointers to segments that got removed, and/or
	 * smgr_targblock variables pointing past the new rel end.  (The inval
	 * message will come back to our backend, too, causing a
	 * probably-unnecessary local smgr flush.  But we don't expect that this
	 * is a performance-critical path.)  As in the unlink code, we want to be
	 * sure the message is sent before we start changing things on-disk.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the truncation.
	 */</comment>
	<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_truncate</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>file_truncate_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>file_truncate_hook</name>)<argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrimmedsync() -- Force the specified relation to stable storage.
 *
 *		Synchronously force all previous writes to the specified relation
 *		down to disk.
 *
 *		This is useful for building completely new relations (eg, new
 *		indexes).  Instead of incrementally WAL-logging the index build
 *		steps, we can just write completed index pages to disk with smgrwrite
 *		or smgrextend, and then fsync the completed index file before
 *		committing the transaction.  (This is sufficient for purposes of
 *		crash recovery, since it effectively duplicates forcing a checkpoint
 *		for the completed index.  But it is *not* sufficient if one wishes
 *		to use the WAL log for PITR or replication purposes: in that case
 *		we have to make WAL entries as well.)
 *
 *		The preceding writes should specify skipFsync = true to avoid
 *		duplicative fsyncs.
 *
 *		Note that you need to do FlushRelationBuffers() first if there is
 *		any possibility that there are dirty buffers for the relation;
 *		otherwise the sync is not very meaningful.
 */</comment>
<function><type><name>void</name></type>
<name>smgrimmedsync</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name><name>reln</name><operator>-&gt;</operator><name>storageManager</name></name><operator>)</operator><operator>.</operator><name>smgr_immedsync</name></name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_SMgr
 *
 * This routine is called during transaction commit or abort (it doesn't
 * particularly care which).  All transient SMgrRelation objects are closed.
 *
 * We do this as a compromise between wanting transient SMgrRelations to
 * live awhile (to amortize the costs of blind writes of multiple blocks)
 * and needing them to not live forever (since we're probably holding open
 * a kernel file descriptor for the underlying file, and we need to ensure
 * that gets closed reasonably soon if the file gets deleted).
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_SMgr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Zap all unowned SMgrRelations.  We rely on smgrclose() to remove each
	 * one from the list.
	 */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;unowned_relns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>rel</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>SMgrRelationData</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
