<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/storage/file/fd.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fd.c
 *	  Virtual file descriptor code.
 *
 * Portions Copyright (c) 2007-2009, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/storage/file/fd.c
 *
 * NOTES:
 *
 * This code manages a cache of 'virtual' file descriptors (VFDs).
 * The server opens many file descriptors for a variety of reasons,
 * including base tables, scratch files (e.g., sort and hash spool
 * files), and random calls to C library routines like system(3); it
 * is quite easy to exceed system limits on the number of open files a
 * single process can have.  (This is around 1024 on many modern
 * operating systems, but may be lower on others.)
 *
 * VFDs are managed as an LRU pool, with actual OS file descriptors
 * being opened and closed as needed.  Obviously, if a routine is
 * opened using these interfaces, all subsequent operations must also
 * be through these interfaces (the File type is not a real file
 * descriptor).
 *
 * For this scheme to work, most (if not all) routines throughout the
 * server should use these interfaces instead of calling the C library
 * routines (e.g., open(2) and fopen(3)) themselves.  Otherwise, we
 * may find ourselves short of real file descriptors anyway.
 *
 * INTERFACE ROUTINES
 *
 * PathNameOpenFile and OpenTemporaryFile are used to open virtual files.
 * A File opened with OpenTemporaryFile is automatically deleted when the
 * File is closed, either explicitly or implicitly at end of transaction or
 * process exit. PathNameOpenFile is intended for files that are held open
 * for a long time, like relation files. It is the caller's responsibility
 * to close them, there is no automatic mechanism in fd.c for that.
 *
 * PathName(Create|Open|Delete)Temporary(File|Dir) are used to manage
 * temporary files that have names so that they can be shared between
 * backends.  Such files are automatically closed and count against the
 * temporary file limit of the backend that creates them, but unlike anonymous
 * files they are not automatically deleted.  See sharedfileset.c for a shared
 * ownership mechanism that provides automatic cleanup for shared files when
 * the last of a group of backends detaches.
 *
 * AllocateFile, AllocateDir, OpenPipeStream and OpenTransientFile are
 * wrappers around fopen(3), opendir(3), popen(3) and open(2), respectively.
 * They behave like the corresponding native functions, except that the handle
 * is registered with the current subtransaction, and will be automatically
 * closed at abort. These are intended mainly for short operations like
 * reading a configuration file; there is a limit on the number of files that
 * can be opened using these functions at any one time.
 *
 * Finally, BasicOpenFile is just a thin wrapper around open() that can
 * release file descriptors in use by the virtual file descriptors if
 * necessary. There is no automatic cleanup of file descriptors returned by
 * BasicOpenFile, it is solely the caller's responsibility to close the file
 * descriptor by calling close(2).
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>		<comment type="block">/* for getrlimit */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/workfile_mgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<comment type="line">// Provide some indirection here in case we have problems with lseek and</comment>
<comment type="line">// 64 bits on some platforms</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pg_lseek64</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(int64)lseek(a,b,c)</cpp:value></cpp:define>


<comment type="block">/* Define PG_FLUSH_DATA_WORKS if we have an implementation for pg_flush_data */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYNC_FILE_RANGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_FLUSH_DATA_WORKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_POSIX_FADVISE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_DONTNEED</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_FLUSH_DATA_WORKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Define PG_FLUSH_DATA_WORKS if we have an implementation for pg_flush_data */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYNC_FILE_RANGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_FLUSH_DATA_WORKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MS_ASYNC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_FLUSH_DATA_WORKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_POSIX_FADVISE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_DONTNEED</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_FLUSH_DATA_WORKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * We must leave some file descriptors free for system(), the dynamic loader,
 * and other code that tries to open files without consulting fd.c.  This
 * is the number left free.  (While we can be pretty sure we won't get
 * EMFILE, there's never any guarantee that we won't get ENFILE due to
 * other processes chewing up FDs.  So it's a bad idea to try to open files
 * without consulting fd.c.  Nonetheless we cannot control all code.)
 *
 * Because this is just a fixed setting, we are effectively assuming that
 * no such code will leave FDs open over the long term; otherwise the slop
 * is likely to be insufficient.  Note in particular that we expect that
 * loading a shared library does not result in any permanent increase in
 * the number of open files.  (This appears to be true on most if not
 * all platforms as of Feb 2004.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_RESERVED_FDS</name></cpp:macro>		<cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * If we have fewer than this many usable FDs after allowing for the reserved
 * ones, choke.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_MINFREE</name></cpp:macro>				<cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * A number of platforms allow individual processes to open many more files
 * than they can really support when *many* processes do the same thing.
 * This GUC parameter lets the DBA limit max_safe_fds to something less than
 * what the postmaster's initial probe suggests will work.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_files_per_process</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Maximum number of file descriptors to open for either VFD entries or
 * AllocateFile/AllocateDir/OpenTransientFile operations.  This is initialized
 * to a conservative value, and remains that way indefinitely in bootstrap or
 * standalone-backend cases.  In normal postmaster operation, the postmaster
 * calls set_max_safe_fds() late in initialization to update the value, and
 * that value is then inherited by forked subprocesses.
 *
 * Note: the value of max_files_per_process is taken into account while
 * setting this variable, and so need not be tested separately.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_safe_fds</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* default if not changed */</comment>

<comment type="block">/* Whether it is safe to continue running after fsync() fails. */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>data_sync_retry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Debugging.... */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FDDEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_DB</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		int			_do_db_save_errno = errno; \
		A; \
		errno = _do_db_save_errno; \
	} while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_DB</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFD_CLOSED</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FileIsValid</name><parameter_list>(<parameter><type><name>file</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((file) &gt; 0 &amp;&amp; (file) &lt; (int) SizeVfdCache &amp;&amp; VfdCache[file].fileName != NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FileIsNotOpen</name><parameter_list>(<parameter><type><name>file</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(VfdCache[file].fd == VFD_CLOSED)</cpp:value></cpp:define>

<comment type="block">/* these are the assigned bits in fdstate below: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_DELETE_AT_CLOSE</name></cpp:macro>	<cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>	<comment type="block">/* T = delete when closed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_CLOSE_AT_EOXACT</name></cpp:macro>	<cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>	<comment type="block">/* T = close at eoXact */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_TEMP_FILE_LIMIT</name></cpp:macro>	<cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>	<comment type="block">/* T = respect temp_file_limit */</comment>
<comment type="block">/* GPDB private flag */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_WORKFILE</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>	<comment type="block">/* tracked by workfile manager */</comment>

<typedef>typedef <type><struct>struct <name>vfd</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>				<comment type="block">/* current FD, or VFD_CLOSED if none */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>fdstate</name></decl>;</decl_stmt>		<comment type="block">/* bitflags for VFD's state */</comment>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>resowner</name></decl>;</decl_stmt>		<comment type="block">/* owner, for automatic cleanup */</comment>
	<decl_stmt><decl><type><name>File</name></type>		<name>nextFree</name></decl>;</decl_stmt>		<comment type="block">/* link to next free VFD, if in freelist */</comment>
	<decl_stmt><decl><type><name>File</name></type>		<name>lruMoreRecently</name></decl>;</decl_stmt>	<comment type="block">/* doubly linked recency-of-use list */</comment>
	<decl_stmt><decl><type><name>File</name></type>		<name>lruLessRecently</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>fileSize</name></decl>;</decl_stmt>		<comment type="block">/* current size of file (0 if not temporary) */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fileName</name></decl>;</decl_stmt>		<comment type="block">/* name of file, or NULL for unused VFD */</comment>
	<comment type="block">/* NB: fileName is malloc'd, and must be free'd when closing the VFD */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>fileFlags</name></decl>;</decl_stmt>		<comment type="block">/* open(2) flags for (re)opening the file */</comment>
	<decl_stmt><decl><type><name>mode_t</name></type>		<name>fileMode</name></decl>;</decl_stmt>		<comment type="block">/* mode to pass to open(2) */</comment>
}</block></struct></type> <name>Vfd</name>;</typedef>

<comment type="block">/*
 * Virtual File Descriptor array pointer and size.  This grows as
 * needed.  'File' values are indexes into this array.
 * Note that VfdCache[0] is not a usable VFD, just a list header.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Vfd</name> <modifier>*</modifier></type><name>VfdCache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Size</name></type> <name>SizeVfdCache</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Number of file descriptors known to be in use by VFD entries.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nfile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flag to tell whether it's worth scanning VfdCache looking for temp files
 * to close
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>have_xact_temporary_files</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Tracks the total size of all temporary files.  Note: when temp_file_limit
 * is being enforced, this cannot overflow since the limit cannot be more
 * than INT_MAX kilobytes.  When not enforcing, it could theoretically
 * overflow, but we don't care.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>temporary_files_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * List of OS handles opened with AllocateFile, AllocateDir and
 * OpenTransientFile.
 *
 * Since we don't want to encourage heavy use of those functions,
 * it seems OK to put a pretty small maximum limit on the number of
 * simultaneously allocated descs.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>AllocateDescFile</name></decl>,
	<decl><name>AllocateDescPipe</name></decl>,
	<decl><name>AllocateDescDir</name></decl>,
	<decl><name>AllocateDescRawFD</name></decl>
}</block></enum></type> <name>AllocateDescKind</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>AllocateDescKind</name></type> <name>kind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>create_subid</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	}</block>			<decl><name>desc</name></decl>;</union>
}</block></struct></type> <name>AllocateDesc</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numAllocatedDescs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>maxAllocatedDescs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>AllocateDesc</name> <modifier>*</modifier></type><name>allocatedDescs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Number of temporary files opened during the current session;
 * this is used in generation of tempfile names.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>tempFileCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Array of OIDs of temp tablespaces.  When numTempTableSpaces is -1,
 * this has not been set in the current transaction.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name> <modifier>*</modifier></type><name>tempTableSpaces</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numTempTableSpaces</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nextTempTableSpace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/*--------------------
 *
 * Private Routines
 *
 * Delete		   - delete a file from the Lru ring
 * LruDelete	   - remove a file from the Lru ring and close its FD
 * Insert		   - put a file at the front of the Lru ring
 * LruInsert	   - put a file at the front of the Lru ring and open it
 * ReleaseLruFile  - Release an fd by closing the last entry in the Lru ring
 * ReleaseLruFiles - Release fd(s) until we're under the max_safe_fds limit
 * AllocateVfd	   - grab a free (or new) file record (from VfdArray)
 * FreeVfd		   - free a file record
 *
 * The Least Recently Used ring is a doubly linked list that begins and
 * ends on element zero.  Element zero is special -- it doesn't represent
 * a file and its "fd" field always == VFD_CLOSED.  Element zero is just an
 * anchor that shows us the beginning/end of the ring.
 * Only VFD elements that are currently really open (have an FD assigned) are
 * in the Lru ring.  Elements that are "virtually" open can be recognized
 * by having a non-null fileName field.
 *
 * example:
 *
 *	   /--less----\				   /---------\
 *	   v		   \			  v			  \
 *	 #0 --more---&gt; LeastRecentlyUsed --more-\ \
 *	  ^\									| |
 *	   \\less--&gt; MostRecentlyUsedFile	&lt;---/ |
 *		\more---/					 \--less--/
 *
 *--------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Delete</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LruDelete</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Insert</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>LruInsert</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReleaseLruFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseLruFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>File</name></type> <name>AllocateVfd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreeVfd</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>FileAccess</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>File</name></type> <name>OpenTemporaryFileInTablespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tblspcOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rejectError</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>makenameunique</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>reserveAllocatedDesc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>FreeDesc</name><parameter_list>(<parameter><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtProcExit_Files</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanupTempFiles</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isProcExit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemovePgTempFilesInDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpdirname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>unlink_all</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemovePgTempRelationFiles</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tsdirname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemovePgTempRelationFilesInDbspace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbspacedirname</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>walkdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>action</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list></function_decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>process_symlinks</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_FLUSH_DATA_WORKS</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pre_sync_fname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>datadir_fsync_fname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unlink_if_exists_fname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>fsync_fname_ext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_perm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>fsync_parent_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * pg_fsync --- do fsync with or without writethrough
 */</comment>
<function><type><name>int</name></type>
<name>pg_fsync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* #if is to skip the sync_method test if there's no need for it */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSYNC_WRITETHROUGH</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FSYNC_WRITETHROUGH_IS_FSYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>sync_method</name> <operator>==</operator> <name>SYNC_METHOD_FSYNC_WRITETHROUGH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pg_fsync_writethrough</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><call><name>pg_fsync_no_writethrough</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_fsync_no_writethrough --- same as fsync except does nothing if
 *	enableFsync is off
 */</comment>
<function><type><name>int</name></type>
<name>pg_fsync_no_writethrough</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>enableFsync</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_fsync_writethrough
 */</comment>
<function><type><name>int</name></type>
<name>pg_fsync_writethrough</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>enableFsync</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<return>return <expr><call><name>_commit</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_FULLFSYNC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
		<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_FULLFSYNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSYS</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_fdatasync --- same as fdatasync except does nothing if enableFsync is off
 *
 * Not all platforms have fdatasync; treat as fsync if not available.
 */</comment>
<function><type><name>int</name></type>
<name>pg_fdatasync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>enableFsync</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FDATASYNC</name></cpp:ifdef>
		<return>return <expr><call><name>fdatasync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<return>return <expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_flush_data --- advise OS that the described dirty data should be flushed
 *
 * offset of 0 with nbytes 0 means that the entire file should be flushed
 */</comment>
<function><type><name>void</name></type>
<name>pg_flush_data</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Right now file flushing is primarily used to avoid making later
	 * fsync()/fdatasync() calls have less impact. Thus don't trigger flushes
	 * if fsyncs are disabled - that's a decision we might want to make
	 * configurable at some point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enableFsync</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We compile all alternatives that are supported on the current platform,
	 * to find portability problems more easily.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYNC_FILE_RANGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>not_implemented_by_kernel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>not_implemented_by_kernel</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * sync_file_range(SYNC_FILE_RANGE_WRITE), currently linux specific,
		 * tells the OS that writeback for the specified blocks should be
		 * started, but that we don't want to wait for completion.  Note that
		 * this call might block if too much dirty data exists in the range.
		 * This is the preferable method on OSs supporting it, as it works
		 * reliably when available (contrast to msync()) and doesn't flush out
		 * clean data (like FADV_DONTNEED).
		 */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sync_file_range</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>,
							 <argument><expr><name>SYNC_FILE_RANGE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * For systems that don't have an implementation of
			 * sync_file_range() such as Windows WSL, generate only one
			 * warning and then suppress all further attempts by this process.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOSYS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>not_implemented_by_kernel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not flush dirty data: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MS_ASYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>pagesize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * On several OSs msync(MS_ASYNC) on a mmap'ed file triggers
		 * writeback. On linux it only does so if MS_SYNC is specified, but
		 * then it does the writeback synchronously. Luckily all common linux
		 * systems have sync_file_range().  This is preferable over
		 * FADV_DONTNEED because it doesn't flush out clean data.
		 *
		 * We map the file (mmap()), tell the kernel to sync back the contents
		 * (msync()), and then remove the mapping again (munmap()).
		 */</comment>

		<comment type="block">/* mmap() needs actual length if we want to map whole file */</comment>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nbytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine dirty data size: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Some platforms reject partial-page mmap() attempts.  To deal with
		 * that, just truncate the request to a page boundary.  If any extra
		 * bytes don't get flushed, well, it's only a hint anyway.
		 */</comment>

		<comment type="block">/* fetch pagesize only once */</comment>
		<if_stmt><if>if <condition>(<expr><name>pagesize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pagesize</name> <operator>=</operator> <call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* align length to pagesize, dropping any fractional page */</comment>
		<if_stmt><if>if <condition>(<expr><name>pagesize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>nbytes</name> <operator>/</operator> <name>pagesize</name><operator>)</operator> <operator>*</operator> <name>pagesize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* fractional-page request is a no-op */</comment>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * mmap could well fail, particularly on 32-bit platforms where there
		 * may simply not be enough address space.  If so, silently fall
		 * through to the next implementation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>SSIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <name>MAP_FAILED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>MAP_FAILED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>msync</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>nbytes</name></expr></argument>, <argument><expr><name>MS_ASYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not flush dirty data: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* NB: need to fall through to munmap()! */</comment>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>munmap</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* FATAL error because mapping would remain */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not munmap() while flushing data: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_POSIX_FADVISE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_DONTNEED</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Signal the kernel that the passed in range should not be cached
		 * anymore. This has the, desired, side effect of writing out dirty
		 * data, and the, undesired, side effect of likely discarding useful
		 * clean cached blocks.  For the latter reason this is the least
		 * preferable method.
		 */</comment>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>posix_fadvise</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>POSIX_FADV_DONTNEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't error out, this is just a performance optimization */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not flush dirty data: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Retrying close in case it gets interrupted. If that happens, it will cause
 * unlink to fail later.
 */</comment>
<function><type><name>int</name></type>
<name>gp_retry_close</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>err</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>
	<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * fsync_fname -- fsync a file or directory, handling errors properly
 *
 * Try to fsync a file or directory. When doing the latter, ignore errors that
 * indicate the OS just doesn't allow/require fsyncing directories.
 */</comment>
<function><type><name>void</name></type>
<name>fsync_fname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>fsync_fname_ext</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>isdir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * durable_rename -- rename(2) wrapper, issuing fsyncs required for durability
 *
 * This routine ensures that, after returning, the effect of renaming file
 * persists in case of a crash. A crash while this routine is running will
 * leave you with either the pre-existing or the moved file in place of the
 * new file; no mixed state or truncated files are possible.
 *
 * It does so by using fsync on the old filename and the possibly existing
 * target filename before the rename, and the target file and directory after.
 *
 * Note that rename() cannot be used across arbitrary directories, as they
 * might not be on the same filesystem. Therefore this routine does not
 * support renaming across directories.
 *
 * Log errors with the caller specified severity.
 *
 * Returns 0 if the operation succeeded, -1 otherwise. Note that errno is not
 * valid upon return.
 */</comment>
<function><type><name>int</name></type>
<name>durable_rename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldfile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newfile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First fsync the old and target path (if it exists), to ensure that they
	 * are properly persistent on disk. Syncing the target file is not
	 * strictly necessary, but it makes it easier to reason about crashes;
	 * because it's then guaranteed that either source or target file exists
	 * after a crash.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fsync_fname_ext</name><argument_list>(<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>newfile</name></expr></argument>, <argument><expr><name>PG_BINARY</name> <operator>|</operator> <name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

			<comment type="block">/* close file upon error, might not be in transaction context */</comment>
			<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Time to do the real deal... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * To guarantee renaming the file is persistent, fsync the file with its
	 * new name, and its containing directory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fsync_fname_ext</name><argument_list>(<argument><expr><name>newfile</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fsync_parent_path</name><argument_list>(<argument><expr><name>newfile</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * durable_unlink -- remove a file in a durable manner
 *
 * This routine ensures that, after returning, the effect of removing file
 * persists in case of a crash. A crash while this routine is running will
 * leave the system in no mixed state.
 *
 * It does so by using fsync on the parent directory of the file after the
 * actual removal is done.
 *
 * Log errors with the severity specified by caller.
 *
 * Returns 0 if the operation succeeded, -1 otherwise. Note that errno is not
 * valid upon return.
 */</comment>
<function><type><name>int</name></type>
<name>durable_unlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * To guarantee that the removal of the file is persistent, fsync its
	 * parent directory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fsync_parent_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * durable_link_or_rename -- rename a file in a durable manner.
 *
 * Similar to durable_rename(), except that this routine tries (but does not
 * guarantee) not to overwrite the target file.
 *
 * Note that a crash in an unfortunate moment can leave you with two links to
 * the target file.
 *
 * Log errors with the caller specified severity.
 *
 * Returns 0 if the operation succeeded, -1 otherwise. Note that errno is not
 * valid upon return.
 */</comment>
<function><type><name>int</name></type>
<name>durable_link_or_rename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldfile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newfile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Ensure that, if we crash directly after the rename/link, a file with
	 * valid contents is moved into place.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fsync_fname_ext</name><argument_list>(<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_WORKING_LINK</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><call><name>link</name><argument_list>(<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not link file \"%s\" to \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>oldfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* XXX: Add racy file existence check? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Make change persistent in case of an OS crash, both the new entry and
	 * its parent directory need to be flushed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fsync_fname_ext</name><argument_list>(<argument><expr><name>newfile</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Same for parent directory */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fsync_parent_path</name><argument_list>(<argument><expr><name>newfile</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InitFileAccess --- initialize this module during backend startup
 *
 * This is called during either normal or standalone backend start.
 * It is *not* called in the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>InitFileAccess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SizeVfdCache</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* call me only once */</comment>

	<comment type="block">/* initialize cache header entry */</comment>
	<expr_stmt><expr><name>VfdCache</name> <operator>=</operator> <operator>(</operator><name>Vfd</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Vfd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>VfdCache</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Vfd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>VfdCache</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>VFD_CLOSED</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>SizeVfdCache</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* register proc-exit hook to ensure temp files are dropped at exit */</comment>
	<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>AtProcExit_Files</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * count_usable_fds --- count how many FDs the system will let us open,
 *		and estimate how many are already open.
 *
 * We stop counting if usable_fds reaches max_to_probe.  Note: a small
 * value of max_to_probe might result in an underestimate of already_open;
 * we must fill in any "gaps" in the set of used FDs before the calculation
 * of already_open will give the right answer.  In practice, max_to_probe
 * of a couple of dozen should be enough to ensure good results.
 *
 * We assume stdin (FD 0) is available for dup'ing
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>count_usable_fds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max_to_probe</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>usable_fds</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>already_open</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>highestfd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETRLIMIT</name></cpp:ifdef>
	<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>getrlimit_status</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETRLIMIT</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RLIMIT_NOFILE</name></cpp:ifdef>			<comment type="block">/* most platforms use RLIMIT_NOFILE */</comment>
	<expr_stmt><expr><name>getrlimit_status</name> <operator>=</operator> <call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* but BSD doesn't ... */</comment>
	<expr_stmt><expr><name>getrlimit_status</name> <operator>=</operator> <call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_OFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* RLIMIT_NOFILE */</comment>
	<if_stmt><if>if <condition>(<expr><name>getrlimit_status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"getrlimit failed: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_GETRLIMIT */</comment>

	<comment type="block">/* dup until failure or probe limit reached */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>thisfd</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETRLIMIT</name></cpp:ifdef>

		<comment type="block">/*
		 * don't go beyond RLIMIT_NOFILE; causes irritating kernel logs on
		 * some platforms
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>getrlimit_status</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>highestfd</name> <operator>&gt;=</operator> <name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>thisfd</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>thisfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Expect EMFILE or ENFILE, else it's fishy */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EMFILE</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENFILE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dup(0) failed after %d successes: %m"</literal></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>used</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>fd</name><index>[<expr><name>used</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>thisfd</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>highestfd</name> <operator>&lt;</operator> <name>thisfd</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>highestfd</name> <operator>=</operator> <name>thisfd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>used</name> <operator>&gt;=</operator> <name>max_to_probe</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* release the files we opened */</comment>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>used</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return results.  usable_fds is just the number of successful dups. We
	 * assume that the system limit is highestfd+1 (remember 0 is a legal FD
	 * number) and so already_open is highestfd+1 - usable_fds.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>usable_fds</name> <operator>=</operator> <name>used</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>already_open</name> <operator>=</operator> <name>highestfd</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>used</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_max_safe_fds
 *		Determine number of filedescriptors that fd.c is allowed to use
 */</comment>
<function><type><name>void</name></type>
<name>set_max_safe_fds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>usable_fds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>already_open</name></decl>;</decl_stmt>

	<comment type="block">/*----------
	 * We want to set max_safe_fds to
	 *			MIN(usable_fds, max_files_per_process - already_open)
	 * less the slop factor for files that are opened without consulting
	 * fd.c.  This ensures that we won't exceed either max_files_per_process
	 * or the experimentally-determined EMFILE limit.
	 *----------
	 */</comment>
	<expr_stmt><expr><call><name>count_usable_fds</name><argument_list>(<argument><expr><name>max_files_per_process</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>usable_fds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>already_open</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>max_safe_fds</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>usable_fds</name></expr></argument>, <argument><expr><name>max_files_per_process</name> <operator>-</operator> <name>already_open</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Take off the FDs reserved for system() etc.
	 */</comment>
	<expr_stmt><expr><name>max_safe_fds</name> <operator>-=</operator> <name>NUM_RESERVED_FDS</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure we still have enough to get by.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_safe_fds</name> <operator>&lt;</operator> <name>FD_MINFREE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient file descriptors available to start server process"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"System allows %d, we need at least %d."</literal></expr></argument>,
						   <argument><expr><name>max_safe_fds</name> <operator>+</operator> <name>NUM_RESERVED_FDS</name></expr></argument>,
						   <argument><expr><name>FD_MINFREE</name> <operator>+</operator> <name>NUM_RESERVED_FDS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"max_safe_fds = %d, usable_fds = %d, already_open = %d"</literal></expr></argument>,
		 <argument><expr><name>max_safe_fds</name></expr></argument>, <argument><expr><name>usable_fds</name></expr></argument>, <argument><expr><name>already_open</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open a file with BasicOpenFilePerm() and pass default file mode for the
 * fileMode parameter.
 */</comment>
<function><type><name>int</name></type>
<name>BasicOpenFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fileFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>BasicOpenFilePerm</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BasicOpenFilePerm --- same as open(2) except can free other FDs if needed
 *
 * This is exported for use by places that really want a plain kernel FD,
 * but need to be proof against running out of FDs.  Once an FD has been
 * successfully returned, it is the caller's responsibility to ensure that
 * it will not be leaked on ereport()!	Most users should *not* call this
 * routine directly, but instead use the VFD abstraction level, which
 * provides protection against descriptor leaks as well as management of
 * files that need to be open for more than a short period of time.
 *
 * Ideally this should be the *only* direct call of open() in the backend.
 * In practice, the postmaster calls open() directly, and there are some
 * direct open() calls done early in backend startup.  Those are OK since
 * this module wouldn't have any open files to close at that point anyway.
 */</comment>
<function><type><name>int</name></type>
<name>BasicOpenFilePerm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fileFlags</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>fileMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

<label><name>tryAgain</name>:</label>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>, <argument><expr><name>fileMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>fd</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* success! */</comment>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EMFILE</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENFILE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of file descriptors: %m; release and retry"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ReleaseLruFile</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>tryAgain</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>					<comment type="block">/* failure */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FDDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_dump_lru</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>mru</name> <init>= <expr><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lruLessRecently</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name> <init>= <expr><operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>mru</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LRU: MOST %d "</literal></expr></argument>, <argument><expr><name>mru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>mru</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>mru</name> <operator>=</operator> <name><name>vfdP</name><operator>-&gt;</operator><name>lruLessRecently</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>vfdP</name> <operator>=</operator> <operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>mru</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><name>mru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"LEAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* FDDEBUG */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Delete</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Delete %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>_dump_lru</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vfdP</name> <operator>=</operator> <operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name><name>vfdP</name><operator>-&gt;</operator><name>lruLessRecently</name></name></expr>]</index></name><operator>.</operator><name>lruMoreRecently</name> <operator>=</operator> <name><name>vfdP</name><operator>-&gt;</operator><name>lruMoreRecently</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name><name>vfdP</name><operator>-&gt;</operator><name>lruMoreRecently</name></name></expr>]</index></name><operator>.</operator><name>lruLessRecently</name> <operator>=</operator> <name><name>vfdP</name><operator>-&gt;</operator><name>lruLessRecently</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>_dump_lru</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>LruDelete</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LruDelete %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vfdP</name> <operator>=</operator> <operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close the file.  We aren't expecting this to fail; if it does, better
	 * to leak the FD than to mess up our internal state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>&amp;</operator> <name>FD_TEMP_FILE_LIMIT</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
			 <argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>VFD_CLOSED</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>--</operator><name>nfile</name></expr>;</expr_stmt>

	<comment type="block">/* delete the vfd record from the LRU ring */</comment>
	<expr_stmt><expr><call><name>Delete</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Insert</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Insert %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>_dump_lru</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vfdP</name> <operator>=</operator> <operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>lruMoreRecently</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>lruLessRecently</name></name> <operator>=</operator> <name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lruLessRecently</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lruLessRecently</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name><name>vfdP</name><operator>-&gt;</operator><name>lruLessRecently</name></name></expr>]</index></name><operator>.</operator><name>lruMoreRecently</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>_dump_lru</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* returns 0 on success, -1 on re-open failure (with errno set) */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>LruInsert</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LruInsert %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vfdP</name> <operator>=</operator> <operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FileIsNotOpen</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Close excess kernel FDs. */</comment>
		<expr_stmt><expr><call><name>ReleaseLruFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The open could still fail for lack of file descriptors, eg due to
		 * overall system file table being full.  So, be prepared to release
		 * another FD if necessary...
		 */</comment>
		<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <call><name>BasicOpenFilePerm</name><argument_list>(<argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>, <argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileFlags</name></name></expr></argument>,
									 <argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileMode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"re-open failed: %m"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>++</operator><name>nfile</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * put it at the head of the Lru ring
	 */</comment>

	<expr_stmt><expr><call><name>Insert</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release one kernel FD by closing the least-recently-used VFD.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReleaseLruFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ReleaseLruFile. Opened %d"</literal></expr></argument>, <argument><expr><name>nfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nfile</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There are opened files and so there should be at least one used vfd
		 * in the ring.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lruMoreRecently</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LruDelete</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lruMoreRecently</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* freed a file */</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* no files available to free */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Release kernel FDs as needed to get under the max_safe_fds limit.
 * After calling this, it's OK to try to open another file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseLruFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name>nfile</name> <operator>+</operator> <name>numAllocatedDescs</name> <operator>&gt;=</operator> <name>max_safe_fds</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReleaseLruFile</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>File</name></type>
<name>AllocateVfd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"AllocateVfd. Size %zu"</literal></expr></argument>, <argument><expr><name>SizeVfdCache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SizeVfdCache</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* InitFileAccess not called? */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nextFree</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The free list is empty so it is time to increase the size of the
		 * array.  We choose to double it each time this happens. However,
		 * there's not much point in starting *real* small.
		 */</comment>
		<decl_stmt><decl><type><name>Size</name></type>		<name>newCacheSize</name> <init>= <expr><name>SizeVfdCache</name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>newVfdCache</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>newCacheSize</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newCacheSize</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Be careful not to clobber VfdCache ptr if realloc fails.
		 */</comment>
		<expr_stmt><expr><name>newVfdCache</name> <operator>=</operator> <operator>(</operator><name>Vfd</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>VfdCache</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Vfd</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newCacheSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newVfdCache</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>VfdCache</name> <operator>=</operator> <name>newVfdCache</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the new entries and link them into the free list.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>SizeVfdCache</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>newCacheSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>VfdCache</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Vfd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nextFree</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name>VFD_CLOSED</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name>newCacheSize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nextFree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nextFree</name> <operator>=</operator> <name>SizeVfdCache</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Record the new size
		 */</comment>
		<expr_stmt><expr><name>SizeVfdCache</name> <operator>=</operator> <name>newCacheSize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nextFree</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nextFree</name> <operator>=</operator> <name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>nextFree</name></expr>;</expr_stmt>

	<return>return <expr><name>file</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreeVfd</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name> <init>= <expr><operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FreeVfd: %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr> ?</condition><then> <expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>nextFree</name></name> <operator>=</operator> <name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nextFree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nextFree</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* returns 0 on success, -1 on re-open failure (with errno set) */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>FileAccess</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returnValue</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FileAccess %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Is the file open?  If not, open it and put it at the head of the LRU
	 * ring (possibly closing the least recently used file to get an FD).
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>FileIsNotOpen</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>returnValue</name> <operator>=</operator> <call><name>LruInsert</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>returnValue</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>returnValue</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>VfdCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lruLessRecently</name> <operator>!=</operator> <name>file</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We now know that the file is open and that it is not the last one
		 * accessed, so we need to move it to the head of the Lru ring.
		 */</comment>

		<expr_stmt><expr><call><name>Delete</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Insert</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Called whenever a temporary file is deleted to report its size.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReportTemporaryFileUsage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pgstat_report_tempfile</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_temp_files</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator> <operator>&gt;=</operator> <name>log_temp_files</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"temporary file: path \"%s\", size %lu"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called to register a temporary file for automatic close.
 * ResourceOwnerEnlargeFiles(CurrentResourceOwner) must have been called
 * before the file was opened.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegisterTemporaryFile</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ResourceOwnerRememberFile</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>resowner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>

	<comment type="block">/* Backup mechanism for closing at end of xact. */</comment>
	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fdstate</name> <operator>|=</operator> <name>FD_CLOSE_AT_EOXACT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>have_xact_temporary_files</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	Called when we get a shared invalidation message on some relation.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>FileInvalidate</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FileIsNotOpen</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LruDelete</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Open a file with PathNameOpenFilePerm() and pass default file mode for the
 * fileMode parameter.
 */</comment>
<function><type><name>File</name></type>
<name>PathNameOpenFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fileFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PathNameOpenFilePerm</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * open a file in an arbitrary directory
 *
 * NB: if the passed pathname is relative (which it usually is),
 * it will be interpreted relative to the process' working directory
 * (which should always be $PGDATA when this code is running).
 */</comment>
<function><type><name>File</name></type>
<name>PathNameOpenFilePerm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fileFlags</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>fileMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fnamecopy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"PathNameOpenFilePerm: %s %x %o"</literal></expr></argument>,
			   <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>, <argument><expr><name>fileMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need a malloc'd copy of the file name; fail cleanly if no room.
	 */</comment>
	<expr_stmt><expr><name>fnamecopy</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fnamecopy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateVfd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vfdP</name> <operator>=</operator> <operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Close excess kernel FDs. */</comment>
	<expr_stmt><expr><call><name>ReleaseLruFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <call><name>BasicOpenFilePerm</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>, <argument><expr><name>fileMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FreeVfd</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fnamecopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>++</operator><name>nfile</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"PathNameOpenFile: success %d"</literal></expr></argument>,
			   <argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Insert</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name> <operator>=</operator> <name>fnamecopy</name></expr>;</expr_stmt>
	<comment type="block">/* Saved flags are adjusted to be OK for re-opening file */</comment>
	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileFlags</name></name> <operator>=</operator> <name>fileFlags</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_EXCL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileMode</name></name> <operator>=</operator> <name>fileMode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>resowner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>file</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create directory 'directory'.  If necessary, create 'basedir', which must
 * be the directory above it.  This is designed for creating the top-level
 * temporary directory on demand before creating a directory underneath it.
 * Do nothing if the directory already exists.
 *
 * Directories created within the top-level temporary directory should begin
 * with PG_TEMP_FILE_PREFIX, so that they can be identified as temporary and
 * deleted at startup by RemovePgTempFiles().  Further subdirectories below
 * that do not need any particular prefix.
*/</comment>
<function><type><name>void</name></type>
<name>PathNameCreateTemporaryDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basedir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Failed.  Try to create basedir first in case it's missing. Tolerate
		 * EEXIST to close a race against another process following the same
		 * algorithm.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create temporary directory \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>basedir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Try again. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create temporary subdirectory \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>directory</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete a directory and everything in it, if it exists.
 */</comment>
<function><type><name>void</name></type>
<name>PathNameDeleteTemporaryDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

	<comment type="block">/* Silently ignore missing directory. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Currently, walkdir doesn't offer a way for our passed in function to
	 * maintain state.  Perhaps it should, so that we could tell the caller
	 * whether this operation succeeded or failed.  Since this operation is
	 * used in a cleanup path, we wouldn't actually behave differently: we'll
	 * just log failures.
	 */</comment>
	<expr_stmt><expr><call><name>walkdir</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>unlink_if_exists_fname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open a temporary file that will disappear when we close it.
 *
 * This routine takes care of generating an appropriate tempfile name.
 * There's no need to pass in fileFlags or fileMode either, since only
 * one setting makes any sense for a temp file.
 *
 * Unless interXact is true, the file is remembered by CurrentResourceOwner
 * to ensure it's closed and deleted when it's no longer needed, typically at
 * the end-of-transaction. In most cases, you don't want temporary files to
 * outlive the transaction that created them, so this should be false -- but
 * if you need "somewhat" temporary storage, this might be useful. In either
 * case, the file is removed when the File is explicitly closed.
 *
 * GPDB: As a convenience for monitoring and debugging, the given 'filePrefix'
 * string is embedded in the file name. It can be NULL.
 */</comment>
<function><type><name>File</name></type>
<name>OpenTemporaryFile</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>interXact</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filePrefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure the current resource owner has space for this File before we
	 * open it, if we'll be registering it below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>interXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResourceOwnerEnlargeFiles</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If some temp tablespace(s) have been given to us, try to use the next
	 * one.  If a given tablespace can't be found, we silently fall back to
	 * the database's default tablespace.
	 *
	 * BUT: if the temp file is slated to outlive the current transaction,
	 * force it into the database's default tablespace, so that it will not
	 * pose a threat to possible tablespace drop attempts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numTempTableSpaces</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>interXact</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tblspcOid</name> <init>= <expr><call><name>GetNextTempTableSpace</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>OpenTemporaryFileInTablespace</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* rejectError */</comment>
												 <argument><expr><name>filePrefix</name></expr></argument>,
												 <argument><expr><name>true</name></expr></argument>, <comment type="block">/* makenameunique */</comment>
												 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* create */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If not, or if tablespace is bad, create in database's default
	 * tablespace.  MyDatabaseTableSpace should normally be set before we get
	 * here, but just in case it isn't, fall back to pg_default tablespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>OpenTemporaryFileInTablespace</name><argument_list>(<argument><expr><ternary><condition><expr><name>MyDatabaseTableSpace</name></expr> ?</condition><then>
											 <expr><name>MyDatabaseTableSpace</name></expr> </then><else>:
											 <expr><name>DEFAULTTABLESPACE_OID</name></expr></else></ternary></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name>filePrefix</name></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>, <comment type="block">/* makenameunique */</comment>
											 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* create */</comment>

	<comment type="block">/* Mark it for deletion at close and temporary file size limit */</comment>
	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fdstate</name> <operator>|=</operator> <name>FD_DELETE_AT_CLOSE</name> <operator>|</operator> <name>FD_TEMP_FILE_LIMIT</name></expr>;</expr_stmt>

	<comment type="block">/* Register it with the current resource owner */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>interXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RegisterTemporaryFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>file</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the path of the temp directory in a given tablespace.
 */</comment>
<function><type><name>void</name></type>
<name>TempTablespacePath</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Identify the tempfile directory for this tablespace.
	 *
	 * If someone tries to specify pg_global, use pg_default instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tablespace</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
		<name>tablespace</name> <operator>==</operator> <name>DEFAULTTABLESPACE_OID</name> <operator>||</operator>
		<name>tablespace</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"base/%s"</literal></expr></argument>, <argument><expr><name>PG_TEMP_FILES_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* All other tablespaces are accessed via symlinks */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%u/%s/%s"</literal></expr></argument>,
				 <argument><expr><name>tablespace</name></expr></argument>, <argument><expr><name>GP_TABLESPACE_VERSION_DIRECTORY</name></expr></argument>, <argument><expr><name>PG_TEMP_FILES_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open a temporary file in a specific tablespace.
 * Subroutine for OpenTemporaryFile, which see for details.
 */</comment>
<function><type><specifier>static</specifier> <name>File</name></type>
<name>OpenTemporaryFileInTablespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tblspcOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rejectError</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>makenameunique</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tempdirpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tempfilepath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TempTablespacePath</name><argument_list>(<argument><expr><name>tempdirpath</name></expr></argument>, <argument><expr><name>tblspcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate a tempfile name that should be unique within the current
	 * database instance.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>makenameunique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>makenameunique</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tempfilepath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tempfilepath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s%s%d.%ld"</literal></expr></argument>,
				 <argument><expr><name>tempdirpath</name></expr></argument>, <argument><expr><name>PG_TEMP_FILE_PREFIX</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>tempFileCounter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tempfilepath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tempfilepath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s_%s"</literal></expr></argument>,
				 <argument><expr><name>tempdirpath</name></expr></argument>, <argument><expr><name>PG_TEMP_FILE_PREFIX</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Open the file.  Note: we don't use O_EXCL, in case there is an orphaned
	 * temp file that can be reused.
	 */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>create</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>tempfilepath</name></expr></argument>,
							<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We might need to create the tablespace's tempfile directory, if no
		 * one has yet done so.
		 *
		 * Don't check for an error from MakePGDirectory; it could fail if
		 * someone else just did the same thing.  If it doesn't work then
		 * we'll bomb out on the second create attempt, instead.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>tempdirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>tempfilepath</name></expr></argument>,
								<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rejectError</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>create</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create temporary file \"%s\": %m"</literal></expr></argument>,
					 <argument><expr><name>tempfilepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open existing temporary file \"%s\": %m"</literal></expr></argument>,
					 <argument><expr><name>tempfilepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>file</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create a new file.  The directory containing it must already exist.  Files
 * created this way are subject to temp_file_limit and are automatically
 * closed at end of transaction, but are not automatically deleted on close
 * because they are intended to be shared between cooperating backends.
 *
 * If the file is inside the top-level temporary directory, its name should
 * begin with PG_TEMP_FILE_PREFIX so that it can be identified as temporary
 * and deleted at startup by RemovePgTempFiles().  Alternatively, it can be
 * inside a directory created with PathNameCreateTemporaryDir(), in which case
 * the prefix isn't needed.
 */</comment>
<function><type><name>File</name></type>
<name>PathNameCreateTemporaryFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error_on_failure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerEnlargeFiles</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the file.  Note: we don't use O_EXCL, in case there is an orphaned
	 * temp file that can be reused.
	 */</comment>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>error_on_failure</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create temporary file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>file</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Mark it for temp_file_limit accounting. */</comment>
	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fdstate</name> <operator>|=</operator> <name>FD_TEMP_FILE_LIMIT</name></expr>;</expr_stmt>

	<comment type="block">/* Register it for automatic close. */</comment>
	<expr_stmt><expr><call><name>RegisterTemporaryFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>file</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open a file that was created with PathNameCreateTemporaryFile, possibly in
 * another backend.  Files opened this way don't count against the
 * temp_file_limit of the caller, are read-only and are automatically closed
 * at the end of the transaction but are not deleted on close.
 */</comment>
<function><type><name>File</name></type>
<name>PathNameOpenTemporaryFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerEnlargeFiles</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We open the file read-only. */</comment>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If no such file, then we don't raise an error. */</comment>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open temporary file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Register it for automatic close. */</comment>
		<expr_stmt><expr><call><name>RegisterTemporaryFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>file</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete a file by pathname.  Return true if the file existed, false if
 * didn't.
 */</comment>
<function><type><name>bool</name></type>
<name>PathNameDeleteTemporaryFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error_on_failure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>filestats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>stat_errno</name></decl>;</decl_stmt>

	<comment type="block">/* Get the final size for pgstat reporting. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filestats</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stat_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>stat_errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Unlike FileClose's automatic file deletion code, we tolerate
	 * non-existence to support BufFileDeleteShared which doesn't know how
	 * many segments it has to delete until it runs out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stat_errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>error_on_failure</name></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot unlink temporary file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>stat_errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReportTemporaryFileUsage</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>filestats</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>stat_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * close a file when done with it
 */</comment>
<function><type><name>void</name></type>
<name>FileClose</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FileClose: %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vfdP</name> <operator>=</operator> <operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FileIsNotOpen</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* close the file */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>gp_retry_close</name><argument_list>(<argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We may need to panic on failure to close non-temporary files;
			 * see LruDelete.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>&amp;</operator> <name>FD_TEMP_FILE_LIMIT</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
				 <argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>--</operator><name>nfile</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>VFD_CLOSED</name></expr>;</expr_stmt>

		<comment type="block">/* remove the file from the lru ring */</comment>
		<expr_stmt><expr><call><name>Delete</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>&amp;</operator> <name>FD_TEMP_FILE_LIMIT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Subtract its size from current usage (do first in case of error) */</comment>
		<expr_stmt><expr><name>temporary_files_size</name> <operator>-=</operator> <name><name>vfdP</name><operator>-&gt;</operator><name>fileSize</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Delete the file if it was temporary, and make a log entry if wanted
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>&amp;</operator> <name>FD_DELETE_AT_CLOSE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>filestats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>stat_errno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we get an error, as could happen within the ereport/elog calls,
		 * we'll come right back here during transaction abort.  Reset the
		 * flag to ensure that we can't get into an infinite loop.  This code
		 * is arranged to ensure that the worst-case consequence is failing to
		 * emit log message(s), not failing to attempt the unlink.
		 */</comment>
		<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>&amp;=</operator> <operator>~</operator><name>FD_DELETE_AT_CLOSE</name></expr>;</expr_stmt>


		<comment type="block">/* first try the stat() */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filestats</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stat_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>stat_errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* in any case do the unlink */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"could not unlink file \"%s\": %m"</literal></expr></argument>, <argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* and last report the stat results */</comment>
		<if_stmt><if>if <condition>(<expr><name>stat_errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReportTemporaryFileUsage</name><argument_list>(<argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>, <argument><expr><name><name>filestats</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>stat_errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Unregister it from the resource owner */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vfdP</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResourceOwnerForgetFile</name><argument_list>(<argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Unregister it from the workfile set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>&amp;</operator> <name>FD_WORKFILE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WorkFileDeleted</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Return the Vfd slot to the free list
	 */</comment>
	<expr_stmt><expr><call><name>FreeVfd</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FilePrefetch - initiate asynchronous read of a given range of the file.
 *
 * Currently the only implementation of this function is using posix_fadvise
 * which is the simplest standardized interface that accomplishes this.
 * We could add an implementation using libaio in the future; but note that
 * this API is inappropriate for libaio, which wants to have a buffer provided
 * to read into.
 */</comment>
<function><type><name>int</name></type>
<name>FilePrefetch</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_POSIX_FADVISE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_WILLNEED</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type>			<name>returnCode</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FilePrefetch: %d (%s) "</literal> <name>INT64_FORMAT</name> <literal type="string">" %d"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>offset</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>FileAccess</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>returnCode</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>posix_fadvise</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>,
							   <argument><expr><name>POSIX_FADV_WILLNEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>returnCode</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>FileWriteback</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returnCode</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FileWriteback: %d (%s) "</literal> <name>INT64_FORMAT</name> <literal type="string">" "</literal> <name>INT64_FORMAT</name></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>nbytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>FileAccess</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_flush_data</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>FileRead</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>,
		 <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returnCode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FileRead: %d (%s) "</literal> <name>INT64_FORMAT</name> <literal type="string">" %d %p"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>offset</name></expr></argument>,
			   <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>FileAccess</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>returnCode</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>vfdP</name> <operator>=</operator> <operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

<label><name>retry</name>:</label>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>pg_pread</name><argument_list>(<argument><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Windows may run out of kernel buffers and return "Insufficient
		 * system resources" error.  Wait a bit and retry to solve it.
		 *
		 * It is rumored that EINTR is also possible on some Unix filesystems,
		 * in which case immediate retry is indicated.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>error</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ERROR_NO_SYSTEM_RESOURCES</name></expr>:</case>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* OK to retry if interrupted */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>returnCode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>FileWrite</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>,
		  <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returnCode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Vfd</name>		   <modifier>*</modifier></type><name>vfdP</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FileWrite: %d (%s) "</literal> <name>INT64_FORMAT</name> <literal type="string">" %d %p"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>offset</name></expr></argument>,
			   <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>FileAccess</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>returnCode</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>vfdP</name> <operator>=</operator> <operator>&amp;</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If enforcing temp_file_limit and it's a temp file, check to see if the
	 * write would overrun temp_file_limit, and throw error if so.  Note: it's
	 * really a modularity violation to throw error here; we should set errno
	 * and return -1.  However, there's no way to report a suitable error
	 * message if we do that.  All current callers would just throw error
	 * immediately anyway, so this is safe at present.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>temp_file_limit</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>&amp;</operator> <name>FD_TEMP_FILE_LIMIT</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>off_t</name></type>		<name>past_write</name> <init>= <expr><name>offset</name> <operator>+</operator> <name>amount</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>past_write</name> <operator>&gt;</operator> <name><name>vfdP</name><operator>-&gt;</operator><name>fileSize</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>newTotal</name> <init>= <expr><name>temporary_files_size</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>newTotal</name> <operator>+=</operator> <name>past_write</name> <operator>-</operator> <name><name>vfdP</name><operator>-&gt;</operator><name>fileSize</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newTotal</name> <operator>&gt;</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>temp_file_limit</name> <operator>*</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"temporary file size exceeds temp_file_limit (%dkB)"</literal></expr></argument>,
								<argument><expr><name>temp_file_limit</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Also update the stats in workfile manager. This might also
	 * throw an error, if we're over the limits.
	 *
	 * Because we update the stats in workfile manager first, if the write
	 * fails, the workfile manager's status will be out of sync with reality.
	 * That's OK, the inaccuracy doesn't accumulate, and it doesn't need to be
	 * totallyaccurate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fdstate</name> <operator>&amp;</operator> <name>FD_WORKFILE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>off_t</name></type>		<name>newPos</name> <init>= <expr><name>offset</name> <operator>+</operator> <name>amount</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>newPos</name> <operator>&gt;</operator> <name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileSize</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UpdateWorkFileSize</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>newPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>retry</name>:</label>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>pg_pwrite</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>!=</operator> <name>amount</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Maintain fileSize and temporary_files_size if it's a temp file.
		 *
		 * If seekPos is -1 (unknown), this will do nothing; but we could only
		 * get here in that state if we're not enforcing temporary_files_size,
		 * so we don't care.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>vfdP</name><operator>-&gt;</operator><name>fdstate</name></name> <operator>&amp;</operator> <name>FD_TEMP_FILE_LIMIT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>off_t</name></type>		<name>past_write</name> <init>= <expr><name>offset</name> <operator>+</operator> <name>amount</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>past_write</name> <operator>&gt;</operator> <name><name>vfdP</name><operator>-&gt;</operator><name>fileSize</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>temporary_files_size</name> <operator>+=</operator> <name>past_write</name> <operator>-</operator> <name><name>vfdP</name><operator>-&gt;</operator><name>fileSize</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vfdP</name><operator>-&gt;</operator><name>fileSize</name></name> <operator>=</operator> <name>past_write</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * See comments in FileRead()
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>error</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ERROR_NO_SYSTEM_RESOURCES</name></expr>:</case>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* OK to retry if interrupted */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>returnCode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>FileSync</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returnCode</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FileSync: %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>FileAccess</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>returnCode</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>pg_fsync</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>returnCode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the size of a physical file by using fstat()
 *
 * Returns size in bytes if successful, &lt; 0 otherwise
 */</comment>
<function><type><name>int64</name></type>
<name>FileDiskSize</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returnCode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>FileAccess</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>returnCode</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>returnCode</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <name><name>buf</name><operator>.</operator><name>st_size</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>off_t</name></type>
<name>FileSize</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FileSize %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FileIsNotOpen</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FileAccess</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>off_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>lseek</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>FileTruncate</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>returnCode</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FileTruncate %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>FileAccess</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>returnCode</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Call ftruncate with a int64 value.
	 *
	 * WARNING:DO NOT typecast this down to a 32-bit long or
	 * append-only vacuum full adjustment of the eof will erroneously remove
	 * table data.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>returnCode</name> <operator>=</operator> <call><name>ftruncate</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>returnCode</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileSize</name> <operator>&gt;</operator> <name>offset</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* adjust our state for truncation of a temp file */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fdstate</name> <operator>&amp;</operator> <name>FD_TEMP_FILE_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>temporary_files_size</name> <operator>-=</operator> <name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileSize</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileSize</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>returnCode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the pathname associated with an open file.
 *
 * The returned string points to an internal buffer, which is valid until
 * the file is closed.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>FilePathName</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the raw file descriptor of an opened file.
 *
 * The returned file descriptor will be valid until the file is closed, but
 * there are a lot of things that can make that happen.  So the caller should
 * be careful not to do much of anything else before it finishes using the
 * returned file descriptor.
 */</comment>
<function><type><name>int</name></type>
<name>FileGetRawDesc</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FileGetRawFlags - returns the file flags on open(2)
 */</comment>
<function><type><name>int</name></type>
<name>FileGetRawFlags</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileFlags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FileGetRawMode - returns the mode bitmask passed to open(2)
 */</comment>
<function><type><name>mode_t</name></type>
<name>FileGetRawMode</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileMode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make room for another allocatedDescs[] array entry if needed and possible.
 * Returns true if an array element is available.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>reserveAllocatedDesc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>newDescs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newMax</name></decl>;</decl_stmt>

	<comment type="block">/* Quick out if array already has a free slot. */</comment>
	<if_stmt><if>if <condition>(<expr><name>numAllocatedDescs</name> <operator>&lt;</operator> <name>maxAllocatedDescs</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the array hasn't yet been created in the current process, initialize
	 * it with FD_MINFREE / 2 elements.  In many scenarios this is as many as
	 * we will ever need, anyway.  We don't want to look at max_safe_fds
	 * immediately because set_max_safe_fds() may not have run yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>allocatedDescs</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newMax</name> <operator>=</operator> <name>FD_MINFREE</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>newDescs</name> <operator>=</operator> <operator>(</operator><name>AllocateDesc</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>newMax</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AllocateDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Out of memory already?  Treat as fatal error. */</comment>
		<if_stmt><if>if <condition>(<expr><name>newDescs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>allocatedDescs</name> <operator>=</operator> <name>newDescs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxAllocatedDescs</name> <operator>=</operator> <name>newMax</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Consider enlarging the array beyond the initial allocation used above.
	 * By the time this happens, max_safe_fds should be known accurately.
	 *
	 * We mustn't let allocated descriptors hog all the available FDs, and in
	 * practice we'd better leave a reasonable number of FDs for VFD use.  So
	 * set the maximum to max_safe_fds / 2.  (This should certainly be at
	 * least as large as the initial size, FD_MINFREE / 2.)
	 */</comment>
	<expr_stmt><expr><name>newMax</name> <operator>=</operator> <name>max_safe_fds</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newMax</name> <operator>&gt;</operator> <name>maxAllocatedDescs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newDescs</name> <operator>=</operator> <operator>(</operator><name>AllocateDesc</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>allocatedDescs</name></expr></argument>,
											<argument><expr><name>newMax</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AllocateDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Treat out-of-memory as a non-fatal error. */</comment>
		<if_stmt><if>if <condition>(<expr><name>newDescs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>allocatedDescs</name> <operator>=</operator> <name>newDescs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxAllocatedDescs</name> <operator>=</operator> <name>newMax</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Can't enlarge allocatedDescs[] any more. */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Routines that want to use stdio (ie, FILE*) should use AllocateFile
 * rather than plain fopen().  This lets fd.c deal with freeing FDs if
 * necessary to open the file.  When done, call FreeFile rather than fclose.
 *
 * Note that files that will be open for any significant length of time
 * should NOT be handled this way, since they cannot share kernel file
 * descriptors with other files; there is grave risk of running out of FDs
 * if anyone locks down too many FDs.  Most callers of this routine are
 * simply reading a config file that they will read and close immediately.
 *
 * fd.c will automatically close all files opened with AllocateFile at
 * transaction commit or abort; this prevents FD leakage if a routine
 * that calls AllocateFile is terminated prematurely by ereport(ERROR).
 *
 * Ideally this should be the *only* direct call of fopen() in the backend.
 */</comment>
<function><type><name>FILE</name> <modifier>*</modifier></type>
<name>AllocateFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"AllocateFile: Allocated %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>numAllocatedDescs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can we allocate another non-virtual FD? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>reserveAllocatedDesc</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exceeded maxAllocatedDescs (%d) while trying to open file \"%s\""</literal></expr></argument>,
						<argument><expr><name>maxAllocatedDescs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Close excess kernel FDs. */</comment>
	<expr_stmt><expr><call><name>ReleaseLruFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>TryAgain</name>:</label>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><name>numAllocatedDescs</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AllocateDescFile</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>create_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numAllocatedDescs</name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>file</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EMFILE</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENFILE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of file descriptors: %m; release and retry"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ReleaseLruFile</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>TryAgain</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * TEMPORARY hack to log the Windows error code on fopen failures, in
	 * hopes of diagnosing some hard-to-reproduce problems.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Windows fopen(\"%s\",\"%s\") failed: code %lu, errno %d"</literal></expr></argument>,
			 <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open a file with OpenTransientFilePerm() and pass default file mode for
 * the fileMode parameter.
 */</comment>
<function><type><name>int</name></type>
<name>OpenTransientFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fileFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>OpenTransientFilePerm</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like AllocateFile, but returns an unbuffered fd like open(2)
 */</comment>
<function><type><name>int</name></type>
<name>OpenTransientFilePerm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fileFlags</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>fileMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"OpenTransientFile: Allocated %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>numAllocatedDescs</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can we allocate another non-virtual FD? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>reserveAllocatedDesc</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exceeded maxAllocatedDescs (%d) while trying to open file \"%s\""</literal></expr></argument>,
						<argument><expr><name>maxAllocatedDescs</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Close excess kernel FDs. */</comment>
	<expr_stmt><expr><call><name>ReleaseLruFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFilePerm</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>, <argument><expr><name>fileMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><name>numAllocatedDescs</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AllocateDescRawFD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>create_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numAllocatedDescs</name><operator>++</operator></expr>;</expr_stmt>

		<return>return <expr><name>fd</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>					<comment type="block">/* failure */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Routines that want to initiate a pipe stream should use OpenPipeStream
 * rather than plain popen().  This lets fd.c deal with freeing FDs if
 * necessary.  When done, call ClosePipeStream rather than pclose.
 *
 * This function also ensures that the popen'd program is run with default
 * SIGPIPE processing, rather than the SIG_IGN setting the backend normally
 * uses.  This ensures desirable response to, eg, closing a read pipe early.
 */</comment>
<function><type><name>FILE</name> <modifier>*</modifier></type>
<name>OpenPipeStream</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"OpenPipeStream: Allocated %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>numAllocatedDescs</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can we allocate another non-virtual FD? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>reserveAllocatedDesc</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exceeded maxAllocatedDescs (%d) while trying to execute command \"%s\""</literal></expr></argument>,
						<argument><expr><name>maxAllocatedDescs</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Close excess kernel FDs. */</comment>
	<expr_stmt><expr><call><name>ReleaseLruFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>TryAgain</name>:</label>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><name>numAllocatedDescs</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AllocateDescPipe</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>create_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numAllocatedDescs</name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>file</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EMFILE</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENFILE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of file descriptors: %m; release and retry"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ReleaseLruFile</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>TryAgain</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free an AllocateDesc of any type.
 *
 * The argument *must* point into the allocatedDescs[] array.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>FreeDesc</name><parameter_list>(<parameter><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Close the underlying object */</comment>
	<switch>switch <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AllocateDescFile</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>fclose</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AllocateDescPipe</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pclose</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AllocateDescDir</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>closedir</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AllocateDescRawFD</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AllocateDesc kind not recognized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Compact storage in the allocatedDescs array */</comment>
	<expr_stmt><expr><name>numAllocatedDescs</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>desc</name> <operator>=</operator> <name><name>allocatedDescs</name><index>[<expr><name>numAllocatedDescs</name></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close a file returned by AllocateFile.
 *
 * Note we do not check fclose's return value --- it is up to the caller
 * to handle close errors.
 */</comment>
<function><type><name>int</name></type>
<name>FreeFile</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FreeFile: Allocated %d"</literal></expr></argument>, <argument><expr><name>numAllocatedDescs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove file from list of allocated files, if it's present */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>numAllocatedDescs</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AllocateDescFile</name> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>file</name></name> <operator>==</operator> <name>file</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>FreeDesc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Only get here if someone passes us a file not in allocatedDescs */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"file passed to FreeFile was not obtained from AllocateFile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close a file returned by OpenTransientFile.
 *
 * Note we do not check close's return value --- it is up to the caller
 * to handle close errors.
 */</comment>
<function><type><name>int</name></type>
<name>CloseTransientFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CloseTransientFile: Allocated %d"</literal></expr></argument>, <argument><expr><name>numAllocatedDescs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove fd from list of allocated files, if it's present */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>numAllocatedDescs</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AllocateDescRawFD</name> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>fd</name></name> <operator>==</operator> <name>fd</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>FreeDesc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Only get here if someone passes us a file not in allocatedDescs */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"fd passed to CloseTransientFile was not obtained from OpenTransientFile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Routines that want to use &lt;dirent.h&gt; (ie, DIR*) should use AllocateDir
 * rather than plain opendir().  This lets fd.c deal with freeing FDs if
 * necessary to open the directory, and with closing it after an elog.
 * When done, call FreeDir rather than closedir.
 *
 * Returns NULL, with errno set, on failure.  Note that failure detection
 * is commonly left to the following call of ReadDir or ReadDirExtended;
 * see the comments for ReadDir.
 *
 * Ideally this should be the *only* direct call of opendir() in the backend.
 */</comment>
<function><type><name>DIR</name> <modifier>*</modifier></type>
<name>AllocateDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"AllocateDir: Allocated %d (%s)"</literal></expr></argument>,
			   <argument><expr><name>numAllocatedDescs</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can we allocate another non-virtual FD? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>reserveAllocatedDesc</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exceeded maxAllocatedDescs (%d) while trying to open directory \"%s\""</literal></expr></argument>,
						<argument><expr><name>maxAllocatedDescs</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Close excess kernel FDs. */</comment>
	<expr_stmt><expr><call><name>ReleaseLruFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>TryAgain</name>:</label>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><name>numAllocatedDescs</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AllocateDescDir</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>dir</name></name> <operator>=</operator> <name>dir</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>create_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numAllocatedDescs</name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>dir</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EMFILE</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENFILE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of file descriptors: %m; release and retry"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ReleaseLruFile</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>TryAgain</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a directory opened with AllocateDir, ereport'ing any error.
 *
 * This is easier to use than raw readdir() since it takes care of some
 * otherwise rather tedious and error-prone manipulation of errno.  Also,
 * if you are happy with a generic error message for AllocateDir failure,
 * you can just do
 *
 *		dir = AllocateDir(path);
 *		while ((dirent = ReadDir(dir, path)) != NULL)
 *			process dirent;
 *		FreeDir(dir);
 *
 * since a NULL dir parameter is taken as indicating AllocateDir failed.
 * (Make sure errno isn't changed between AllocateDir and ReadDir if you
 * use this shortcut.)
 *
 * The pathname passed to AllocateDir must be passed to this routine too,
 * but it is only used for error reporting.
 */</comment>
<function><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type>
<name>ReadDir</name><parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ReadDirExtended</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Alternate version of ReadDir that allows caller to specify the elevel
 * for any error report (whether it's reporting an initial failure of
 * AllocateDir or a subsequent directory read failure).
 *
 * If elevel &lt; ERROR, returns NULL after any error.  With the normal coding
 * pattern, this will result in falling out of the loop immediately as
 * though the directory contained no (more) entries.
 */</comment>
<function><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type>
<name>ReadDirExtended</name><parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dent</name></decl>;</decl_stmt>

	<comment type="block">/* Give a generic message for AllocateDir failure, if caller didn't */</comment>
	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open directory \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>dirname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dent</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>dent</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read directory \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>dirname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close a directory opened with AllocateDir.
 *
 * Returns closedir's return value (with errno set if it's not 0).
 * Note we do not check the return value --- it is up to the caller
 * to handle close errors if wanted.
 *
 * Does nothing if dir == NULL; we assume that directory open failure was
 * already reported if desired.
 */</comment>
<function><type><name>int</name></type>
<name>FreeDir</name><parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if AllocateDir failed */</comment>
	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FreeDir: Allocated %d"</literal></expr></argument>, <argument><expr><name>numAllocatedDescs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove dir from list of allocated dirs, if it's present */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>numAllocatedDescs</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AllocateDescDir</name> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>dir</name></name> <operator>==</operator> <name>dir</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>FreeDesc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Only get here if someone passes us a dir not in allocatedDescs */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"dir passed to FreeDir was not obtained from AllocateDir"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Close a pipe stream returned by OpenPipeStream.
 */</comment>
<function><type><name>int</name></type>
<name>ClosePipeStream</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ClosePipeStream: Allocated %d"</literal></expr></argument>, <argument><expr><name>numAllocatedDescs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove file from list of allocated files, if it's present */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>numAllocatedDescs</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AllocateDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AllocateDescPipe</name> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>file</name></name> <operator>==</operator> <name>file</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>FreeDesc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Only get here if someone passes us a file not in allocatedDescs */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"file passed to ClosePipeStream was not obtained from OpenPipeStream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>pclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * closeAllVfds
 *
 * Force all VFDs into the physically-closed state, so that the fewest
 * possible number of kernel file descriptors are in use.  There is no
 * change in the logical state of the VFDs.
 */</comment>
<function><type><name>void</name></type>
<name>closeAllVfds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>SizeVfdCache</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsNotOpen</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Make sure ring not corrupted */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SizeVfdCache</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FileIsNotOpen</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LruDelete</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetTempTablespaces
 *
 * Define a list (actually an array) of OIDs of tablespaces to use for
 * temporary files.  This list will be used until end of transaction,
 * unless this function is called again before then.  It is caller's
 * responsibility that the passed-in array has adequate lifespan (typically
 * it'd be allocated in TopTransactionContext).
 */</comment>
<function><type><name>void</name></type>
<name>SetTempTablespaces</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>tableSpaces</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numSpaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numSpaces</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tempTableSpaces</name> <operator>=</operator> <name>tableSpaces</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numTempTableSpaces</name> <operator>=</operator> <name>numSpaces</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Select a random starting point in the list.  This is to minimize
	 * conflicts between backends that are most likely sharing the same list
	 * of temp tablespaces.  Note that if we create multiple temp files in the
	 * same transaction, we'll advance circularly through the list --- this
	 * ensures that large temporary sort files are nicely spread across all
	 * available tablespaces.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numSpaces</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextTempTableSpace</name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call> <operator>%</operator> <name>numSpaces</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextTempTableSpace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TempTablespacesAreSet
 *
 * Returns true if SetTempTablespaces has been called in current transaction.
 * (This is just so that tablespaces.c doesn't need its own per-transaction
 * state.)
 */</comment>
<function><type><name>bool</name></type>
<name>TempTablespacesAreSet</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>numTempTableSpaces</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetTempTablespaces
 *
 * Populate an array with the OIDs of the tablespaces that should be used for
 * temporary files.  Return the number that were copied into the output array.
 */</comment>
<function><type><name>int</name></type>
<name>GetTempTablespaces</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>tableSpaces</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numSpaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * GPDB: This function is called only by SharedFileSetInit(), in which
	 * we call PrepareTempTablespaces() just before this function. In upstream
	 * Postgres, we would only go through this code path inside a transaction.
	 * However, in GPDB, SharedFileSetInit() may also get called in the process
	 * of ExecSquelchShareInputScan(), which could happen during abort
	 * transaction. If we are not in a transaction, PrepareTempTablespaces()
	 * would have to return early without setting the temp tablespaces. The
	 * shared fileset in this case will be writen in the default table space
	 * rather than the temp tablespaces.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TempTablespacesAreSet</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsAbortInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTempTableSpaces</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>numSpaces</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tableSpaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tempTableSpaces</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNextTempTableSpace
 *
 * Select the next temp tablespace to use.  A result of InvalidOid means
 * to use the current database's default tablespace.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetNextTempTableSpace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>numTempTableSpaces</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Advance nextTempTableSpace counter with wraparound */</comment>
		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>nextTempTableSpace</name> <operator>&gt;=</operator> <name>numTempTableSpaces</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextTempTableSpace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name><name>tempTableSpaces</name><index>[<expr><name>nextTempTableSpace</name></expr>]</index></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AtEOSubXact_Files
 *
 * Take care of subtransaction commit/abort.  At abort, we close temp files
 * that the subtransaction may have opened.  At commit, we reassign the
 * files that were opened to the parent subtransaction.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_Files</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
				  <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAllocatedDescs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>allocatedDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_subid</name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>allocatedDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_subid</name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* have to recheck the item after FreeDesc (ugly) */</comment>
				<expr_stmt><expr><call><name>FreeDesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><name>i</name><operator>--</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_Files
 *
 * This routine is called during transaction commit or abort.  All still-open
 * per-transaction temporary file VFDs are closed, which also causes the
 * underlying files to be deleted (although they should've been closed already
 * by the ResourceOwner cleanup). Furthermore, all "allocated" stdio files are
 * closed. We also forget any transaction-local temp tablespace list.
 *
 * The isCommit flag is used only to decide whether to emit warnings about
 * unclosed files.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_Files</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CleanupTempFiles</name><argument_list>(<argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tempTableSpaces</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numTempTableSpaces</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtProcExit_Files
 *
 * on_proc_exit hook to clean up temp files during backend shutdown.
 * Here, we want to clean up *all* temp files including interXact ones.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtProcExit_Files</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CleanupTempFiles</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close temporary files and delete their underlying files.
 *
 * isCommit: if true, this is normal transaction commit, and we don't
 * expect any remaining files; warn if there are some.
 *
 * isProcExit: if true, this is being called as the backend process is
 * exiting. If that's the case, we should remove all temporary files; if
 * that's not the case, we are being called for transaction commit/abort
 * and should only remove transaction-local temp files.  In either case,
 * also clean up "allocated" stdio files, dirs and fds.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CleanupTempFiles</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isProcExit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Careful here: at proc_exit we need extra cleanup, not just
	 * xact_temporary files.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isProcExit</name> <operator>||</operator> <name>have_xact_temporary_files</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsNotOpen</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Make sure ring not corrupted */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SizeVfdCache</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>fdstate</name> <init>= <expr><name><name>VfdCache</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fdstate</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>fdstate</name> <operator>&amp;</operator> <name>FD_DELETE_AT_CLOSE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>fdstate</name> <operator>&amp;</operator> <name>FD_CLOSE_AT_EOXACT</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
				<name><name>VfdCache</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fileName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we're in the process of exiting a backend process, close
				 * all temporary files. Otherwise, only close temporary files
				 * local to the current transaction. They should be closed by
				 * the ResourceOwner mechanism already, so this is just a
				 * debugging cross-check.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>isProcExit</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>fdstate</name> <operator>&amp;</operator> <name>FD_CLOSE_AT_EOXACT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						 <argument><expr><literal type="string">"temporary file %s not closed at end-of-transaction"</literal></expr></argument>,
						 <argument><expr><name><name>VfdCache</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>have_xact_temporary_files</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Complain if any allocated files remain open at commit. */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name> <operator>&amp;&amp;</operator> <name>numAllocatedDescs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"%d temporary files and directories not closed at end-of-transaction"</literal></expr></argument>,
			 <argument><expr><name>numAllocatedDescs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up "allocated" stdio files, dirs and fds. */</comment>
	<while>while <condition>(<expr><name>numAllocatedDescs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeDesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>allocatedDescs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Remove temporary and temporary relation files left over from a prior
 * postmaster session
 *
 * This should be called during postmaster startup.  It will forcibly
 * remove any leftover files created by OpenTemporaryFile and any leftover
 * temporary relation files created by mdcreate.
 *
 * NOTE: we could, but don't, call this during a post-backend-crash restart
 * cycle.  The argument for not doing it is that someone might want to examine
 * the temp files for debugging purposes.  This does however mean that
 * OpenTemporaryFile had better allow for collision with an existing temp
 * file name.
 *
 * NOTE: this function and its subroutines generally report syscall failures
 * with ereport(LOG) and keep going.  Removing temp files is not so critical
 * that we should fail to start the database when we can't do it.
 */</comment>
<function><type><name>void</name></type>
<name>RemovePgTempFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>temp_path</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">11</literal> <operator>+</operator> <name>MAX_DBID_STRING_LENGTH</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GP_TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PG_TEMP_FILES_DIR</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>spc_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>spc_de</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First process temp files in pg_default ($PGDATA/base)
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>temp_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>temp_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"base/%s"</literal></expr></argument>, <argument><expr><name>PG_TEMP_FILES_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RemovePgTempFilesInDir</name><argument_list>(<argument><expr><name>temp_path</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RemovePgTempRelationFiles</name><argument_list>(<argument><expr><literal type="string">"base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cycle through temp directories for all non-default tablespaces.
	 */</comment>
	<expr_stmt><expr><name>spc_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><literal type="string">"pg_tblspc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>spc_de</name> <operator>=</operator> <call><name>ReadDirExtended</name><argument_list>(<argument><expr><name>spc_dir</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc"</literal></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>spc_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>spc_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>temp_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>temp_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%s/%s/%s"</literal></expr></argument>,
				 <argument><expr><name><name>spc_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>GP_TABLESPACE_VERSION_DIRECTORY</name></expr></argument>, <argument><expr><name>PG_TEMP_FILES_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RemovePgTempFilesInDir</name><argument_list>(<argument><expr><name>temp_path</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>temp_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>temp_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%s/%s"</literal></expr></argument>,
				 <argument><expr><name><name>spc_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>GP_TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RemovePgTempRelationFiles</name><argument_list>(<argument><expr><name>temp_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>spc_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In EXEC_BACKEND case there is a pgsql_tmp directory at the top level of
	 * DataDir as well.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<expr_stmt><expr><call><name>RemovePgTempFilesInDir</name><argument_list>(<argument><expr><name>PG_TEMP_FILES_DIR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Process one pgsql_tmp directory for RemovePgTempFiles.
 *
 * If missing_ok is true, it's all right for the named directory to not exist.
 * Any other problem results in a LOG message.  (missing_ok should be true at
 * the top level, since pgsql_tmp directories are not created until needed.)
 *
 * At the top level, this should be called with unlink_all = false, so that
 * only files matching the temporary name prefix will be unlinked.  When
 * recursing it will be called with unlink_all = true to unlink everything
 * under a top-level temporary directory.
 *
 * (These two flags could be replaced by one, but it seems clearer to keep
 * them separate.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemovePgTempFilesInDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpdirname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>unlink_all</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>temp_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>temp_de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>rm_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>temp_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>tmpdirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>temp_dir</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>temp_de</name> <operator>=</operator> <call><name>ReadDirExtended</name><argument_list>(<argument><expr><name>temp_dir</name></expr></argument>, <argument><expr><name>tmpdirname</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>temp_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>temp_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
				 <argument><expr><name>tmpdirname</name></expr></argument>, <argument><expr><name><name>temp_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>unlink_all</name> <operator>||</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name><name>temp_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>,
					<argument><expr><name>PG_TEMP_FILE_PREFIX</name></expr></argument>,
					<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>PG_TEMP_FILE_PREFIX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>rm_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* recursively remove contents, then directory itself */</comment>
				<expr_stmt><expr><call><name>RemovePgTempFilesInDir</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>rmdir</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove directory \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected file found in temporary-files directory: \"%s\""</literal></expr></argument>,
							<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>temp_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Process one tablespace directory, look for per-DB subdirectories */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemovePgTempRelationFiles</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tsdirname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>ts_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>dbspace_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ts_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>tsdirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDirExtended</name><argument_list>(<argument><expr><name>ts_dir</name></expr></argument>, <argument><expr><name>tsdirname</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're only interested in the per-database directories, which have
		 * numeric names.  Note that this code will also (properly) ignore "."
		 * and "..".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>dbspace_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbspace_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
				 <argument><expr><name>tsdirname</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RemovePgTempRelationFilesInDbspace</name><argument_list>(<argument><expr><name>dbspace_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>ts_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Process one per-dbspace directory for RemovePgTempRelationFiles */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemovePgTempRelationFilesInDbspace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbspacedirname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dbspace_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>rm_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dbspace_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>dbspacedirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDirExtended</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>, <argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>looks_like_temp_rel_name</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
				 <argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * In PostgreSQL, the pattern is:
 *
 * t&lt;digits&gt;_&lt;digits&gt;, or t&lt;digits&gt;_&lt;digits&gt;_&lt;forkname&gt;
 *
 * In GPDB, however, we leave out the first &lt;digits&gt;. In PostgreSQL it's
 * used for the backend ID, but we don't use that in GPDB because even
 * temporary relation are kept in shared buffers, and need to be accessible
 * from multiple backends. So the pattern in GPDB is:
 *
 * t_&lt;digits&gt;, or t&lt;digits&gt;_&lt;digits&gt;_&lt;forkname&gt;
 */</comment>
<function><type><name>bool</name></type>
<name>looks_like_temp_rel_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>savepos</name></decl>;</decl_stmt>

	<comment type="block">/* Must start with "t". */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Followed by underscode. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Followed by another nonempty string of digits. */</comment>
	<for>for <control>(<init><expr><name>savepos</name> <operator>=</operator> <operator>++</operator><name>pos</name></expr>;</init> <condition><expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>name</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr></incr>)</control><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>savepos</name> <operator>==</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We might have _forkname or .segment or both. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>forkchar</name> <init>= <expr><call><name>forkname_chars</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>name</name><index>[<expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>forkchar</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>forkchar</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>segchar</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>segchar</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>name</name><index>[<expr><name>pos</name> <operator>+</operator> <name>segchar</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>segchar</name></expr></incr>)</control><block type="pseudo"><block_content>
			<empty_stmt>;</empty_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><name>segchar</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>segchar</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now we should be at the end. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Synchronize all xlog files and pg_wal itself in pg_wal
 *
 * This is called at the beginning of recovery.
 */</comment>
<function><type><name>void</name></type>
<name>SyncAllXLogFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We can skip this whole thing if fsync is disabled. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enableFsync</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Synchronization of the wal directory starts."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>walkdir</name><argument_list>(<argument><expr><literal type="string">"pg_wal"</literal></expr></argument>, <argument><expr><name>datadir_fsync_fname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"synchronization of the wal directory finishes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Issue fsync recursively on PGDATA and all its contents.
 *
 * We fsync regular files and directories wherever they are, but we
 * follow symlinks only for pg_wal and immediately under pg_tblspc.
 * Other symlinks are presumed to point at files we're not responsible
 * for fsyncing, and might not have privileges to write at all.
 *
 * Errors are logged but not considered fatal; that's because this is used
 * only during database startup, to deal with the possibility that there are
 * issued-but-unsynced writes pending against the data directory.  We want to
 * ensure that such writes reach disk before anything that's done in the new
 * run.  However, aborting on error would result in failure to start for
 * harmless cases such as read-only files in the data directory, and that's
 * not good either.
 *
 * Note that if we previously crashed due to a PANIC on fsync(), we'll be
 * rewriting all changes again during recovery.
 *
 * Note we assume we're chdir'd into PGDATA to begin with.
 */</comment>
<function><type><name>void</name></type>
<name>SyncDataDirectory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>xlog_is_symlink</name></decl>;</decl_stmt>

	<comment type="block">/* We can skip this whole thing if fsync is disabled. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enableFsync</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If pg_wal is a symlink, we'll need to recurse into it separately,
	 * because the first walkdir below will ignore it.
	 */</comment>
	<expr_stmt><expr><name>xlog_is_symlink</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><literal type="string">"pg_wal"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><literal type="string">"pg_wal"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>xlog_is_symlink</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><call><name>pgwin32_is_junction</name><argument_list>(<argument><expr><literal type="string">"pg_wal"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xlog_is_symlink</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If possible, hint to the kernel that we're soon going to fsync the data
	 * directory and its contents.  Errors in this step are even less
	 * interesting than normal, so log them only at DEBUG1.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_FLUSH_DATA_WORKS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>walkdir</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>pre_sync_fname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xlog_is_symlink</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>walkdir</name><argument_list>(<argument><expr><literal type="string">"pg_wal"</literal></expr></argument>, <argument><expr><name>pre_sync_fname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>walkdir</name><argument_list>(<argument><expr><literal type="string">"pg_tblspc"</literal></expr></argument>, <argument><expr><name>pre_sync_fname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Now we do the fsync()s in the same order.
	 *
	 * The main call ignores symlinks, so in addition to specially processing
	 * pg_wal if it's a symlink, pg_tblspc has to be visited separately with
	 * process_symlinks = true.  Note that if there are any plain directories
	 * in pg_tblspc, they'll get fsync'd twice.  That's not an expected case
	 * so we don't worry about optimizing it.
	 */</comment>
	<expr_stmt><expr><call><name>walkdir</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>datadir_fsync_fname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xlog_is_symlink</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>walkdir</name><argument_list>(<argument><expr><literal type="string">"pg_wal"</literal></expr></argument>, <argument><expr><name>datadir_fsync_fname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>walkdir</name><argument_list>(<argument><expr><literal type="string">"pg_tblspc"</literal></expr></argument>, <argument><expr><name>datadir_fsync_fname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * walkdir: recursively walk a directory, applying the action to each
 * regular file and directory (including the named directory itself).
 *
 * If process_symlinks is true, the action and recursion are also applied
 * to regular files and directories that are pointed to by symlinks in the
 * given directory; otherwise symlinks are ignored.  Symlinks are always
 * ignored in subdirectories, ie we intentionally don't pass down the
 * process_symlinks flag to recursive calls.
 *
 * Errors are reported at level elevel, which might be ERROR or less.
 *
 * See also walkdir in initdb.c, which is a frontend version of this logic.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>walkdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
		<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>action</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list></function_decl></parameter>,
		<parameter><decl><type><name>bool</name></type> <name>process_symlinks</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDirExtended</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>subpath</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sret</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>process_symlinks</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sret</name> <operator>=</operator> <call><name>stat</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>sret</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>sret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>fst</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call>(<modifier>*</modifier><name>action</name>) <argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>fst</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>walkdir</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>				<comment type="block">/* we ignore any error here */</comment>

	<comment type="block">/*
	 * It's important to fsync the destination directory itself as individual
	 * file fsyncs don't guarantee that the directory entry for the file is
	 * synced.  However, skip this if AllocateDir failed; the action function
	 * might not be robust against that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>action</name>) <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Hint to the OS that it should get ready to fsync() this file.
 *
 * Ignores errors trying to open unreadable files, and logs other errors at a
 * caller-specified level.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_FLUSH_DATA_WORKS</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pre_sync_fname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<comment type="block">/* Don't try to flush directories, it'll likely just fail */</comment>
	<if_stmt><if>if <condition>(<expr><name>isdir</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EACCES</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * pg_flush_data() ignores errors, which is ok because this is only a
	 * hint.
	 */</comment>
	<expr_stmt><expr><call><name>pg_flush_data</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PG_FLUSH_DATA_WORKS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>datadir_fsync_fname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We want to silently ignoring errors about unreadable files.  Pass that
	 * desire on to fsync_fname_ext().
	 */</comment>
	<expr_stmt><expr><call><name>fsync_fname_ext</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>isdir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlink_if_exists_fname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>isdir</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>rmdir</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rmdir directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Use PathNameDeleteTemporaryFile to report filesize */</comment>
		<expr_stmt><expr><call><name>PathNameDeleteTemporaryFile</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fsync_fname_ext -- Try to fsync a file or directory
 *
 * If ignore_perm is true, ignore errors upon trying to open unreadable
 * files. Logs other errors at a caller-specified level.
 *
 * Returns 0 if the operation succeeded, -1 otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>fsync_fname_ext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_perm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>returncode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Some OSs require directories to be opened read-only whereas other
	 * systems don't allow us to fsync files opened read-only; so we need both
	 * cases here.  Using O_RDWR will cause us to fail to fsync files that are
	 * not writable by our userid, but we assume that's OK.
	 */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>PG_BINARY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isdir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_RDWR</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_RDONLY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Some OSs don't allow us to open directories at all (Windows returns
	 * EACCES), just ignore the error in that case.  If desired also silently
	 * ignoring errors about unreadable files. Log others.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>isdir</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>errno</name> <operator>==</operator> <name>EISDIR</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ignore_perm</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EACCES</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>returncode</name> <operator>=</operator> <call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Some OSes don't allow us to fsync directories at all, so we can ignore
	 * those errors. Anything else needs to be logged.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>returncode</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>isdir</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>errno</name> <operator>==</operator> <name>EBADF</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINVAL</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

		<comment type="block">/* close file upon error, might not be in transaction context */</comment>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fsync_parent_path -- fsync the parent path of a file or directory
 *
 * This is aimed at making file operations persistent on disk in case of
 * an OS crash or power failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>fsync_parent_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>parentpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_parent_directory</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get_parent_directory() returns an empty string if the input argument is
	 * just a file name (see comments in path.c), so handle that as being the
	 * current directory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fsync_fname_ext</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>FileGetFilename</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileIsValid</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DO_DB</name><argument_list>(<argument><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FileSeek: %d (%s) "</literal> <name>INT64_FORMAT</name> <literal type="string">" "</literal> <name>INT64_FORMAT</name> <literal type="string">" %d"</literal></expr></argument>,
			   <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>seekPos</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fileName</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Mark the file as a "work file" that should be tracked by the workfile manager.
 */</comment>
<function><type><name>void</name></type>
<name>FileSetIsWorkfile</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>VfdCache</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>fdstate</name> <operator>|=</operator> <name>FD_WORKFILE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a PostgreSQL data sub-directory
 *
 * The data directory itself, and most of its sub-directories, are created at
 * initdb time, but we do have some occasions when we create directories in
 * the backend (CREATE TABLESPACE, for example).  In those cases, we want to
 * make sure that those directories are created consistently.  Today, that means
 * making sure that the created directory has the correct permissions, which is
 * what pg_dir_create_mode tracks for us.
 *
 * Note that we also set the umask() based on what we understand the correct
 * permissions to be (see file_perm.c).
 *
 * For permissions other than the default, mkdir() can be used directly, but
 * be sure to consider carefully such cases -- a sub-directory with incorrect
 * permissions in a PostgreSQL data directory could cause backups and other
 * processes to fail.
 */</comment>
<function><type><name>int</name></type>
<name>MakePGDirectory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directoryName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>mkdir</name><argument_list>(<argument><expr><name>directoryName</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the passed-in error level, or PANIC if data_sync_retry is off.
 *
 * Failure to fsync any data file is cause for immediate panic, unless
 * data_sync_retry is enabled.  Data may have been written to the operating
 * system and removed from our buffer pool already, and if we are running on
 * an operating system that forgets dirty data on write-back failure, there
 * may be only one copy of the data remaining: in the WAL.  A later attempt to
 * fsync again might falsely report success.  Therefore we must not allow any
 * further checkpoints to be attempted.  data_sync_retry can in theory be
 * enabled on systems known not to drop dirty buffered data on write-back
 * failure (with the likely outcome that checkpoints will continue to fail
 * until the underlying problem is fixed).
 *
 * Any code that reports a failure from fsync() or related functions should
 * filter the error level with this function.
 */</comment>
<function><type><name>int</name></type>
<name>data_sync_elevel</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name>data_sync_retry</name></expr> ?</condition><then> <expr><name>elevel</name></expr> </then><else>: <expr><name>PANIC</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
</unit>
