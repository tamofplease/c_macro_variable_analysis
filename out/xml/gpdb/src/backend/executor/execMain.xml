<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/execMain.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execMain.c
 *	  top level executor interface routines
 *
 * INTERFACE ROUTINES
 *	ExecutorStart()
 *	ExecutorRun()
 *	ExecutorFinish()
 *	ExecutorEnd()
 *
 *	These four procedures are the external interface to the executor.
 *	In each case, the query descriptor is required as an argument.
 *
 *	ExecutorStart must be called at the beginning of execution of any
 *	query plan and ExecutorEnd must always be called at the end of
 *	execution of a plan (unless it is aborted due to error).
 *
 *	ExecutorRun accepts direction and count arguments that specify whether
 *	the plan is to be executed forwards, backwards, and for how many tuples.
 *	In some cases ExecutorRun may be called multiple times to process all
 *	the tuples for a plan.  It is also acceptable to stop short of executing
 *	the whole plan (but only if it is a SELECT).
 *
 *	ExecutorFinish must be called after the final ExecutorRun call and
 *	before ExecutorEnd.  This can be omitted only in case of EXPLAIN,
 *	which should also omit ExecutorRun.
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/execMain.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_publication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/matview.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/metrics_utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/workfile_mgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resource_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cgroup.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/createas.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbexplain.h"</cpp:file></cpp:include>             <comment type="block">/* cdbexplain_sendExecStats() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/ml_ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmotion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdboidsync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbllize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtargeteddispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbendpoint.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_PARALLEL_RETRIEVE_CURSOR</name><parameter_list>(<parameter><type><name>queryDesc</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(queryDesc-&gt;ddesc &amp;&amp;	\
										queryDesc-&gt;ddesc-&gt;parallelCursorName &amp;&amp;	\
										strlen(queryDesc-&gt;ddesc-&gt;parallelCursorName) &gt; 0)</cpp:value></cpp:define>

<comment type="block">/* Hooks for plugins to get control in ExecutorStart/Run/Finish/End */</comment>
<decl_stmt><decl><type><name>ExecutorStart_hook_type</name></type> <name>ExecutorStart_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExecutorRun_hook_type</name></type> <name>ExecutorRun_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExecutorFinish_hook_type</name></type> <name>ExecutorFinish_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExecutorEnd_hook_type</name></type> <name>ExecutorEnd_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hook for plugin to get control in ExecCheckRTPerms() */</comment>
<decl_stmt><decl><type><name>ExecutorCheckPerms_hook_type</name></type> <name>ExecutorCheckPerms_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* decls for local routines only used within this module */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitPlan</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckValidRowMarkRel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RowMarkType</name></type> <name>markType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecPostprocessPlan</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecEndPlan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecutePlan</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>use_parallel_mode</name></decl></parameter>,
						<parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>sendTuples</name></decl></parameter>,
						<parameter><decl><type><name>uint64</name></type> <name>numberTuples</name></decl></parameter>,
						<parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>,
						<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecCheckRTEPerms</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecCheckRTEPermsModified</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>,
									  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
									  <parameter><decl><type><name>AclMode</name></type> <name>requiredPerms</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecCheckXactReadOnly</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ExecBuildSlotValueDescription</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>,
										   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
										   <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
										   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EvalPlanQualStart</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>parentestate</name></decl></parameter>,
							  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>planTree</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustReplicatedTableCounts</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Note that GetAllUpdatedColumns() also exists in commands/trigger.c.  There does
 * not appear to be any good header to put it into, given the structures that
 * it uses, so we let them be duplicated.  Be sure to update both if one needs
 * to be changed, however.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetInsertedColumns</name><parameter_list>(<parameter><type><name>relinfo</name></type></parameter>, <parameter><type><name>estate</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(exec_rt_fetch((relinfo)-&gt;ri_RangeTableIndex, estate)-&gt;insertedCols)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetUpdatedColumns</name><parameter_list>(<parameter><type><name>relinfo</name></type></parameter>, <parameter><type><name>estate</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(exec_rt_fetch((relinfo)-&gt;ri_RangeTableIndex, estate)-&gt;updatedCols)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetAllUpdatedColumns</name><parameter_list>(<parameter><type><name>relinfo</name></type></parameter>, <parameter><type><name>estate</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(bms_union(exec_rt_fetch((relinfo)-&gt;ri_RangeTableIndex, estate)-&gt;updatedCols, \
			   exec_rt_fetch((relinfo)-&gt;ri_RangeTableIndex, estate)-&gt;extraUpdatedCols))</cpp:value></cpp:define>

<comment type="block">/* end of local decls */</comment>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorStart
 *
 *		This routine must be called at the beginning of any execution of any
 *		query plan
 *
 * Takes a QueryDesc previously created by CreateQueryDesc (which is separate
 * only because some places use QueryDescs for utility commands).  The tupDesc
 * field of the QueryDesc is filled in to describe the tuples that will be
 * returned, and the internal fields (estate and planstate) are set up.
 *
 * eflags contains flag bits as described in executor.h.
 *
 * NB: the CurrentMemoryContext when this is called will become the parent
 * of the per-query context used for this Executor invocation.
 *
 * We provide a function hook variable that lets loadable plugins
 * get control when ExecutorStart is called.  Such a plugin would
 * normally call standard_ExecutorStart().
 *
 * MPP: In here we take care of setting up all the necessary items that
 * will be needed to service the query, such as setting up interconnect,
 * and dispatching the query. Any other items in the future
 * must be added here.
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorStart</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ExecutorStart_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExecutorStart_hook</name>) <argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorStart</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpExecIdentity</name></type> <name>exec_identity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldDispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needDtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> 		<modifier>*</modifier></type><name>toplevelOidCache</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* sanity checks: queryDesc must not be started already */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>intoPolicy</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>intoPolicy</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>intoPolicy</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* GPDB hook for collecting query info */</comment>
	<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_QUERY_START</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>LogResManagerMemory</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>GP_RESMANAGER_MEMORY_LOG_LEVEL</name></expr></argument>, <argument><expr><literal type="string">"query requested %.0fKB of memory"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name> <operator>/</operator> <literal type="number">1024.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * Distribute memory to operators.
	 *
	 * There are some statements that do not go through the resource queue, so we cannot
	 * put in a strong assert here. Someday, we should fix resource queues.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Whether we should skip operator memory assignment
		 * - We should never skip operator memory assignment on QD.
		 * - On QE, not skip in case of resource group enabled, and customer allow QE re-calculate query_mem,
		 * as the GUC `gp_resource_group_enable_recalculate_query_mem` set to on.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>	<name>should_skip_operator_memory_assign</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If resource group is enabled, we should re-calculate query_mem on QE, because the memory
			 * of the coordinator and segment nodes or the number of instance could be different.
			 *
			 * On QE, we only try to recalculate query_mem if resource group enabled. Otherwise, we will skip this
			 * and the next operator memory assignment if resource queue enabled
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsResGroupEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> 	<name>total_memory_coordinator</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>total_memory_coordinator</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>    	<name>nsegments_coordinator</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>nsegments_coordinator</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * memSpill is not in fallback mode, and we enable resource group re-calculate the query_mem on QE,
				 * then re-calculate the query_mem and re-compute operatorMemKB using this new value
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>total_memory_coordinator</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nsegments_coordinator</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>should_skip_operator_memory_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<comment type="block">/* Get total system memory on the QE in MB */</comment>
					<decl_stmt><decl><type><name>int</name></type> 	<name>total_memory_segment</name> <init>= <expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>gettotalmemory</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> 	<name>nsegments_segment</name> <init>= <expr><call><name>ResGroupGetHostPrimaryCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>uint64</name></type>	<name>coordinator_query_mem</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * In the resource group environment, when we calculate query_mem, we can roughly use the following
					 * formula:
					 *
					 * 	query_mem = (total_memory * gp_resource_group_memory_limit * memory_limit / nsegments) * memory_spill_ratio / concurrency
					 *
					 * Only total_memory and nsegments could differ between QD and QE, so query_mem is proportional to
					 * the system's available virtual memory and inversely proportional to the number of instances.
					 */</comment>
					<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name> <operator>*=</operator> <operator>(</operator><name>total_memory_segment</name> <operator>*</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>nsegments_segment</name><operator>)</operator> <operator>/</operator>
														 <operator>(</operator><name>total_memory_coordinator</name> <operator>*</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>nsegments_coordinator</name><operator>)</operator></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"re-calculate query_mem, original QD's query_mem: %.0fKB, after recalculation QE's query_mem: %.0fKB"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>coordinator_query_mem</name> <operator>/</operator> <literal type="number">1024.0</literal></expr></argument>  , <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name> <operator>/</operator> <literal type="number">1024.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* On QD, we always traverse the plan tree and compute operatorMemKB */</comment>
			<expr_stmt><expr><name>should_skip_operator_memory_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>should_skip_operator_memory_assign</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<switch>switch<condition>(<expr><operator>*</operator><name>gp_resmanager_memory_policy</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>RESMANAGER_MEMORY_POLICY_AUTO</name></expr>:</case>
						<expr_stmt><expr><call><name>PolicyAutoAssignOperatorMemoryKB</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>,
													 <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>RESMANAGER_MEMORY_POLICY_EAGER_FREE</name></expr>:</case>
						<expr_stmt><expr><call><name>PolicyEagerFreeAssignOperatorMemoryKB</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>,
														  <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mppExecutorCleanup</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the transaction is read-only, we need to check if any writes are
	 * planned to non-temporary tables.  EXPLAIN is considered read-only.
	 *
	 * Don't allow writes in parallel mode.  Supporting UPDATE and DELETE
	 * would require (a) storing the combocid hash in shared memory, rather
	 * than synchronizing it just once at the start of parallelism, and (b) an
	 * alternative to heap_update()'s reliance on xmax for mutual exclusion.
	 * INSERT may have no such troubles, but we forbid it to simplify the
	 * checks.
	 *
	 * We have lower-level defenses in CommandCounterIncrement and elsewhere
	 * against performing unsafe operations in parallel mode, but this gives a
	 * more user-friendly error message.
	 *
	 * In GPDB, we must call ExecCheckXactReadOnly() in the QD even if the
	 * transaction is not read-only, because ExecCheckXactReadOnly() also
	 * determines if two-phase commit is needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>XactReadOnly</name> <operator>||</operator> <call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecCheckXactReadOnly</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build EState, switch into per-query memory context for startup.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/**
	 * Attached the plannedstmt from queryDesc
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in external parameters, if any, from queryDesc; and allocate
	 * workspace for internal parameters
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>params</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nParamExec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nParamExec</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name> <operator>=</operator> <operator>(</operator><name>ParamExecData</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>nParamExec</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in the query environment, if any, from queryDesc.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_queryEnv</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>queryEnv</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If non-read-only query, set the command ID to mark output tuples with
	 */</comment>
	<switch>switch <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>

			<comment type="block">/*
			 * SELECT FOR [KEY] UPDATE/SHARE and modifying CTEs need to mark
			 * tuples
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
				<name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * A SELECT without modifying CTEs can't possibly queue triggers,
			 * so force skip-triggers mode. This is just a marginal efficiency
			 * hack, since AfterTriggerBeginQuery/AfterTriggerEndQuery aren't
			 * all that expensive, but we might as well do it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name>EXEC_FLAG_SKIP_TRIGGERS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized operation code: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Copy other important information into the EState
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>crosscheck_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit_flags</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>jitFlags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>showstatctx</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>showstatctx</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Shared input info is needed when ROLE_EXECUTE or sequential plan
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sharenode</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Handling of the Slice table depends on context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up the slice table. */</comment>
		<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sliceTable</name> <operator>=</operator> <call><name>InitSliceTable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>=</operator> <name>sliceTable</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gangType</name> <operator>!=</operator> <name>GANGTYPE_UNALLOCATED</name> <operator>||</operator>
			<name><name>sliceTable</name><operator>-&gt;</operator><name>hasMotions</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>QueryDispatchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>useChangedAOOpts</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Pass EXPLAIN ANALYZE flag to qExecs. */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>

			<comment type="block">/* set our global sliceid variable for elog. */</comment>
			<expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* InitPlan() will acquire locks by walking the entire plan
			 * tree -- we'd like to avoid acquiring the locks until
			 * *after* we've set up the interconnect */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>hasMotions</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name> <operator>=</operator> <call><name>createMotionLayerState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* QD-only query, no dispatching required */</comment>
			<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If this is CREATE TABLE AS ... WITH NO DATA, there's no need
		 * need to actually execute the plan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>&amp;&amp;</operator>
			<name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>intoClause</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QueryDispatchDesc</name> <modifier>*</modifier></type><name>ddesc</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* qDisp should have sent us a slice table via MPPEXEC */</comment>
		<if_stmt><if>if <condition>(<expr><name>ddesc</name> <operator>&amp;&amp;</operator> <name><name>ddesc</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sliceTable</name> <operator>=</operator> <name><name>ddesc</name><operator>-&gt;</operator><name>sliceTable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>SliceTable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slice</name> <operator>=</operator> <operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>=</operator> <name>sliceTable</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_cursorPositions</name></name> <operator>=</operator> <name><name>ddesc</name><operator>-&gt;</operator><name>cursorPositions</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name><name>slice</name><operator>-&gt;</operator><name>rootIndex</name></name></expr>;</expr_stmt>

			<comment type="block">/* set our global sliceid variable for elog. */</comment>
			<expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Should we collect statistics for EXPLAIN ANALYZE? */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>

			<comment type="block">/* InitPlan() will acquire locks by walking the entire plan
			 * tree -- we'd like to avoid acquiring the locks until
			 * *after* we've set up the interconnect */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>hasMotions</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name> <operator>=</operator> <call><name>createMotionLayerState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<comment type="block">/*
					 * Initialize the motion layer for this query.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SetupInterconnect</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>UpdateMotionExpectedReceivers</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"qe_got_snapshot_and_interconnect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mppExecutorCleanup</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* local query in QE. */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We don't eliminate aliens if we don't have an MPP plan
	 * or we are executing on master.
	 *
	 * TODO: eliminate aliens even on master, if not EXPLAIN ANALYZE
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eliminateAliens</name></name> <operator>=</operator> <name>execute_pruned_plan</name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>hasMotions</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up an AFTER-trigger statement context, unless told not to, or
	 * unless it's EXPLAIN-only mode (when ExecutorFinish won't be called).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_SKIP_TRIGGERS</name> <operator>|</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize the plan state tree
	 *
	 * If the interconnect has been set up; we need to catch any
	 * errors to shut it down -- so we have to wrap InitPlan in a PG_TRY() block.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Initialize the plan state tree
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InitPlan</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>AssertSliceTableIsValid</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>Debug_print_slice_table</name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"slice table"</literal></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we're running as a QE and there's a slice table in our queryDesc,
		 * then we need to finish the EState setup we prepared for back in
		 * CdbExecQuery.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>motionstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Note that, at this point on a QE, the estate is setup (based on the
			 * slice table transmitted from the QD via MPPEXEC) so that fields
			 * es_sliceTable, cur_root_idx and es_cur_slice_idx are correct for
			 * the QE.
			 *
			 * If responsible for a non-root slice, arrange to enter the plan at the
			 * slice's sending Motion node rather than at the top.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>motionstate</name> <operator>=</operator> <call><name>getMotionState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>motionstate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>motionstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>Debug_print_slice_table</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"slice table"</literal></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"seg%d executing slice%d under root slice%d"</literal></expr></argument>,
					 <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>,
					 <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * if in dispatch mode, time to serialize plan and query
		 * trees, and fire off cdb_exec command to each of the qexecs
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shouldDispatch</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * MPP-2869: preprocess_initplans() may
			 * dispatch. (interacted with MPP-2859, which caused an
			 * initPlan to do a write which should have happened in
			 * main body of query) We need to call
			 * ExecutorSaysTransactionDoesWrites() before any dispatch
			 * work for this query.
			 */</comment>
			<expr_stmt><expr><name>needDtx</name> <operator>=</operator> <call><name>ExecutorSaysTransactionDoesWrites</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>needDtx</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>setupDtxTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Aviod dispatching OIDs for InitPlan.
			 *
			 * CTAS will first define relation in QD, and generate the OIDs,
			 * and then dispatch with these OIDs to QEs.
			 * QEs store these OIDs in a static variable and delete the one
			 * used to create table.
			 *
			 * If CTAS's query contains initplan, when we invoke
			 * preprocess_initplan to dispatch initplans, if with
			 * queryDesc-&gt;ddesc-&gt;oidAssignments be set, these OIDs are
			 * also dispatched to QEs.
			 *
			 * For details please see github issue https://github.com/greenplum-db/gpdb/issues/10760
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>;</expr_stmt>
				<comment type="block">/*
				 * For CTAS querys that contain initplan, we need to copy a new oid dispatch list,
				 * since the preprocess_initplan will start a subtransaction, and if it's rollbacked,
				 * the memory context of 'Oid dispatch context' will be reset, which will cause invalid
				 * list reference during the serialization of dispatch_oids when dispatching plan.
				 */</comment>
				<expr_stmt><expr><name>toplevelOidCache</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * First, pre-execute any initPlan subplans.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>preprocess_initplans</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>toplevelOidCache</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>oidAssignments</name></name> <operator>=</operator> <name>toplevelOidCache</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This call returns after launching the threads that send the
			 * plan to the appropriate segdbs.  It does not wait for them to
			 * finish unless an error is detected before all slices have been
			 * dispatched.
			 *
			 * Main plan is parallel, send plan to it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gangType</name> <operator>!=</operator> <name>GANGTYPE_UNALLOCATED</name> <operator>||</operator>
				<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>children</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CdbDispatchPlan</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>,
								<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name></expr></argument>,
								<argument><expr><name>needDtx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>toplevelOidCache</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>toplevelOidCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>toplevelOidCache</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get executor identity (who does the executor serve). we can assume
		 * Forward scan direction for now just for retrieving the identity.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>exec_identity</name> <operator>=</operator> <call><name>getGpExecIdentity</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>exec_identity</name> <operator>=</operator> <name>GP_IGNORE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If we have no slice to execute in this process, mark currentSliceId as
		 * invalid.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>GP_IGNORE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<comment type="block">/* non-root on QE */</comment>
		<if_stmt><if>if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>GP_NON_ROOT_ON_QE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>motionState</name> <init>= <expr><call><name>getMotionState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>motionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>motionState</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>GP_ROOT_SLICE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Run a root slice. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>&amp;&amp;</operator>
				<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gangType</name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name> <operator>&amp;&amp;</operator>
				<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>children</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SetupInterconnect</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UpdateMotionExpectedReceivers</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>exec_identity</name> <operator>!=</operator> <name>GP_IGNORE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"unsupported parallel execution strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>toplevelOidCache</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>toplevelOidCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>toplevelOidCache</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>mppExecutorCleanup</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to ExecutorStart end: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorRun
 *
 *		This is the main routine of the executor module. It accepts
 *		the query descriptor from the traffic cop and executes the
 *		query plan.
 *
 *		ExecutorStart must have been called already.
 *
 *		If direction is NoMovementScanDirection then nothing is done
 *		except to start up/shut down the destination.  Otherwise,
 *		we retrieve up to 'count' tuples in the specified direction.
 *
 *		Note: count = 0 is interpreted as no portal limit, i.e., run to
 *		completion.  Also note that the count limit is only applied to
 *		retrieved tuples, not for instance to those inserted/updated/deleted
 *		by a ModifyTable plan node.
 *
 *		There is no return value, but output tuples (if any) are sent to
 *		the destination receiver specified in the QueryDesc; and the number
 *		of tuples processed at the top level can be found in
 *		estate-&gt;es_processed.
 *
 *		We provide a function hook variable that lets loadable plugins
 *		get control when ExecutorRun is called.  Such a plugin would
 *		normally call standard_ExecutorRun().
 *
 *		MPP: In here we must ensure to only run the plan and not call
 *		any setup/teardown items (unless in a CATCH block).
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorRun</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
			<parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ExecutorRun_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExecutorRun_hook</name>) <argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorRun</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
					 <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sendTuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>endpointCreated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * NOTE: Any local vars that are set in the PG_TRY block and examined in the
	 * PG_CATCH block should be declared 'volatile'. (setjmp shenanigans)
	 */</comment>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>currentSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpExecIdentity</name></type>		<name>exec_identity</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch into per-query memory context
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allow instrumentation of Executor overall runtime */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
     * CDB: Update global slice id for log messages.
     */</comment>
    <expr_stmt><expr><name>currentSlice</name> <operator>=</operator> <call><name>getCurrentSlice</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>currentSlice</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator>
            <call><name>sliceRunsOnQD</name><argument_list>(<argument><expr><name>currentSlice</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <name><name>currentSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * extract information from the query descriptor and the query feature.
	 */</comment>
	<expr_stmt><expr><name>operation</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * startup tuple receiver, if we will be emitting tuples
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>sendTuples</name> <operator>=</operator> <operator>(</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				  <operator>(</operator><name>operation</name> <operator>==</operator> <name>CMD_SELECT</name> <operator>||</operator>
				   <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasReturning</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sendTuples</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ScanDirectionIsNoMovement</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>execute_once</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>already_executed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't re-execute query flagged for single execution"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>already_executed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Need a try/catch block here so that if an ereport is called from
	 * within ExecutePlan, we can clean up by calling CdbCheckDispatchResult.
	 * This cleans up the asynchronous commands running through the threads launched from
	 * CdbDispatchCommand.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Run the plan locally.  There are three ways;
		 *
		 * 1. Do nothing
		 * 2. Run a root slice
		 * 3. Run a non-root slice on a QE.
		 *
		 * Here we decide what is our identity -- root slice, non-root
		 * on QE or other (in which case we do nothing), and then run
		 * the plan if required. For more information see
		 * getGpExecIdentity() in execUtils.
		 */</comment>
		<expr_stmt><expr><name>exec_identity</name> <operator>=</operator> <call><name>getGpExecIdentity</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>GP_IGNORE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* do nothing */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_got_eos</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>GP_NON_ROOT_ON_QE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Run a non-root slice on a QE.
			 *
			 * Since the top Plan node is a (Sending) Motion, run the plan
			 * forward to completion. The plan won't return tuples locally
			 * (tuples go out over the interconnect), so the destination is
			 * uninteresting.  The command type should be SELECT, however, to
			 * avoid other sorts of DML processing..
			 *
			 * This is the center of slice plan activity -- here we arrange to
			 * blunder into the middle of the plan rather than entering at the
			 * root.
			 */</comment>

			<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>motionState</name> <init>= <expr><call><name>getMotionState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>motionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExecutePlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
						<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>motionState</name></expr></argument>,
						<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr></argument>,
						<argument><expr><name>CMD_SELECT</name></expr></argument>,
						<argument><expr><name>sendTuples</name></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>,
						<argument><expr><name>ForwardScanDirection</name></expr></argument>,
						<argument><expr><name>dest</name></expr></argument>,
						<argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>GP_ROOT_SLICE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>endpointDest</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * When run a root slice, and it is a PARALLEL RETRIEVE CURSOR, it means
			 * QD become the end point for connection. It is true, for
			 * instance, SELECT * FROM foo LIMIT 10, and the result should
			 * go out from QD.
			 *
			 * For the scenario: endpoint on QE, the query plan is changed,
			 * the root slice also exists on QE.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IS_PARALLEL_RETRIEVE_CURSOR</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SetupEndpointExecState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
									   <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>parallelCursorName</name></name></expr></argument>,
									   <argument><expr><name>operation</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>endpointDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>endpointCreated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Once the endpoint has been created in shared memory, send acknowledge
				 * message to QD so DECLARE PARALLEL RETRIEVE CURSOR statement can finish.
				 */</comment>
				<expr_stmt><expr><call><name>EndpointNotifyQD</name><argument_list>(<argument><expr><name>ENDPOINT_READY_ACK_MSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExecutePlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
							<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
							<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr></argument>,
							<argument><expr><name>operation</name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>count</name></expr></argument>,
							<argument><expr><name>direction</name></expr></argument>,
							<argument><expr><name>endpointDest</name></expr></argument>,
							<argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Run a root slice
				 * It corresponds to the "normal" path through the executor
				 * in that we enter the plan at the top and count on the
				 * motion nodes at the fringe of the top slice to return
				 * without ever calling nodes below them.
				 */</comment>
				<expr_stmt><expr><call><name>ExecutePlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
							<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
							<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr></argument>,
							<argument><expr><name>operation</name></expr></argument>,
							<argument><expr><name>sendTuples</name></expr></argument>,
							<argument><expr><name>count</name></expr></argument>,
							<argument><expr><name>direction</name></expr></argument>,
							<argument><expr><name>dest</name></expr></argument>,
							<argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"undefined parallel execution strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
    </block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
        <comment type="block">/* Close down interconnect etc. */</comment>
		<expr_stmt><expr><call><name>mppExecutorCleanup</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<comment type="block">/*
	 * Allow testing of very high number of processed rows, without spending
	 * hours actually processing that many rows.
	 *
	 * Somewhat arbitrarily, only trigger this if more than 10000 rows were truly
	 * processed. This screens out some internal queries that the system might
	 * issue during planning.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>&gt;=</operator> <literal type="number">10000</literal> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>&lt;=</operator> <literal type="number">1000000</literal></expr>)</condition>
	<comment type="line">//if (estate-&gt;es_processed &gt;= 10000)</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(<argument><expr><literal type="string">"executor_run_high_processed"</literal></expr></argument>,
										   <argument><expr><name>DDLNotSpecified</name></expr></argument>,
										   <argument><expr><literal type="string">""</literal></expr></argument> <comment type="block">/* databaseName */</comment>,
										   <argument><expr><literal type="string">""</literal></expr></argument> <comment type="block">/* tableName */</comment>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For testing purposes, pretend that we have already processed
			 * almost 2^32 rows.
			 */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name>UINT_MAX</name> <operator>-</operator> <literal type="number">10</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FAULT_INJECTOR */</comment>

	<comment type="block">/*
	 * shutdown tuple receiver, if we started it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>endpointCreated</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DestroyEndpointExecState</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sendTuples</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorFinish
 *
 *		This routine must be called after the last ExecutorRun call.
 *		It performs cleanup such as firing AFTER triggers.  It is
 *		separate from ExecutorEnd because EXPLAIN ANALYZE needs to
 *		include these actions in the total runtime.
 *
 *		We provide a function hook variable that lets loadable plugins
 *		get control when ExecutorFinish is called.  Such a plugin would
 *		normally call standard_ExecutorFinish().
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorFinish</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ExecutorFinish_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExecutorFinish_hook</name>) <argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorFinish</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This should be run once and only once per Executor instance */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch into per-query memory context */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allow instrumentation of Executor overall runtime */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Run ModifyTable nodes to completion */</comment>
	<expr_stmt><expr><call><name>ExecPostprocessPlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute queued AFTER triggers, unless told not to */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_SKIP_TRIGGERS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorEnd
 *
 *		This routine must be called at the end of execution of any
 *		query plan
 *
 *		We provide a function hook variable that lets loadable plugins
 *		get control when ExecutorEnd is called.  Such a plugin would
 *		normally call standard_ExecutorEnd().
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorEnd</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ExecutorEnd_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExecutorEnd_hook</name>) <argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorEnd</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	
	<comment type="block">/* GPDB: whether this is a inner query for extension usage */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isInnerQuery</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* GPDB: Save SPI flag first in case the memory context of plannedstmt is cleaned up*/</comment>
	<expr_stmt><expr><name>isInnerQuery</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>metricsQueryType</name></name> <operator>&gt;</operator> <name>TOP_LEVEL_QUERY</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to ExecutorEnd starting: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that ExecutorFinish was called, unless in EXPLAIN-only mode. This
	 * Assert is needed because ExecutorFinish is new as of 9.1, and callers
	 * might forget to call it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name> <operator>||</operator>
		   <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch into per-query memory context to run ExecEndPlan
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If EXPLAIN ANALYZE, qExec returns stats to qDisp now.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>&amp;&amp;</operator>
		<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>&amp;</operator> <name>INSTRUMENT_CDB</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cdbexplain_sendExecStats</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if needed, collect mpp dispatch results and tear down
	 * all mpp specific resources (e.g. interconnect).
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>mppExecutorFinishup</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * we got an error. do all the necessary cleanup.
		 */</comment>
		<expr_stmt><expr><call><name>mppExecutorCleanup</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Remove our own query's motion layer.
		 */</comment>
		<expr_stmt><expr><call><name>RemoveMotionLayer</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB specific
		 * Clean the special resources created by INITPLAN.
		 * The resources have long life cycle and are used by the main plan.
		 * It's too early to clean them in preprocess_initplans.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>postprocess_initplans</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Release EState and per-query memory context.
		 */</comment>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB specific
	 * Clean the special resources created by INITPLAN.
	 * The resources have long life cycle and are used by the main plan.
	 * It's too early to clean them in preprocess_initplans.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>postprocess_initplans</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If normal termination, let each operator clean itself up.
     * Otherwise don't risk it... an error might have left some
     * structures in an inconsistent state.
     */</comment>
	<expr_stmt><expr><call><name>ExecEndPlan</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove our own query's motion layer.
	 */</comment>
	<expr_stmt><expr><call><name>RemoveMotionLayer</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do away with our snapshots */</comment>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must switch out of context before destroying it
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release EState and per-query memory context
	 */</comment>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* GPDB hook for collecting query info */</comment>
	<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><ternary><condition><expr><name>isInnerQuery</name></expr> ?</condition><then> <expr><name>METRICS_INNER_QUERY_DONE</name></expr> </then><else>: <expr><name>METRICS_QUERY_DONE</name></expr></else></ternary></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Reset queryDesc fields that no longer point to anything */</comment>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to ExecutorEnd end: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReportOOMConsumption</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorRewind
 *
 *		This routine may be called on an open queryDesc to rewind it
 *		to the start.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorRewind</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It's probably not sensible to rescan updating queries */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch into per-query memory context
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * rescan plan
	 */</comment>
	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecCheckRTPerms
 *		Check access permissions for all relations listed in a range table.
 *
 * Returns true if permissions are adequate.  Otherwise, throws an appropriate
 * error if ereport_on_violation is true, or simply returns false otherwise.
 *
 * Note that this does NOT address row level security policies (aka: RLS).  If
 * rows will be returned to the user as a result of this permission check
 * passing, then RLS also needs to be consulted (and check_enable_rls()).
 *
 * See rewrite/rowsecurity.c.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecCheckRTPerms</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTable</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ereport_on_violation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rangeTable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecCheckRTEPerms</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ereport_on_violation</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NO_PRIV</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>ExecutorCheckPerms_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>ExecutorCheckPerms_hook</name>) <argument_list>(<argument><expr><name>rangeTable</name></expr></argument>,
											 <argument><expr><name>ereport_on_violation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckRTEPerms
 *		Check access permissions for a single RTE.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecCheckRTEPerms</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>requiredPerms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>relPerms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>remainingPerms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only plain-relation RTEs need to be checked here.  Function RTEs are
	 * checked when the function is prepared for execution.  Join, subquery,
	 * and special RTEs need no checks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No work if requiredPerms is empty.
	 */</comment>
	<expr_stmt><expr><name>requiredPerms</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>requiredPerms</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relOid</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * userid to check as: current user unless we have a setuid indication.
	 *
	 * Note: GetUserId() is presently fast enough that there's no harm in
	 * calling it separately for each RTE.  If that stops being true, we could
	 * call it once in ExecCheckRTPerms and pass the userid down from there.
	 * But for now, no need for the extra clutter.
	 */</comment>
	<expr_stmt><expr><name>userid</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must have *all* the requiredPerms bits, but some of the bits can be
	 * satisfied from column-level rather than relation-level permissions.
	 * First, remove any bits that are satisfied by relation permissions.
	 */</comment>
	<expr_stmt><expr><name>relPerms</name> <operator>=</operator> <call><name>pg_class_aclmask</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>requiredPerms</name></expr></argument>, <argument><expr><name>ACLMASK_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remainingPerms</name> <operator>=</operator> <name>requiredPerms</name> <operator>&amp;</operator> <operator>~</operator><name>relPerms</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we lack any permissions that exist only as relation permissions,
		 * we can fail straight away.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>ACL_SELECT</name> <operator>|</operator> <name>ACL_INSERT</name> <operator>|</operator> <name>ACL_UPDATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check to see if we have the needed privileges at column level.
		 *
		 * Note: failures just report a table-level error; it would be nicer
		 * to report a column-level error if we have some but not all of the
		 * column privileges.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>&amp;</operator> <name>ACL_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When the query doesn't explicitly reference any columns (for
			 * example, SELECT COUNT(*) FROM table), allow the query if we
			 * have SELECT on any column of the rel, as per SQL spec.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck_all</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>,
											  <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<while>while <condition>(<expr><operator>(</operator><name>col</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* bit #s are offset by FirstLowInvalidHeapAttributeNumber */</comment>
				<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name>col</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Whole-row reference, must have priv on all cols */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck_all</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>,
												  <argument><expr><name>ACLMASK_ALL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>,
											  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Basically the same for the mod columns, for both INSERT and UPDATE
		 * privilege as specified by remainingPerms.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>&amp;</operator> <name>ACL_INSERT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecCheckRTEPermsModified</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>,
																	  <argument><expr><name>userid</name></expr></argument>,
																	  <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>,
																	  <argument><expr><name>ACL_INSERT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>&amp;</operator> <name>ACL_UPDATE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecCheckRTEPermsModified</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>,
																	  <argument><expr><name>userid</name></expr></argument>,
																	  <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>,
																	  <argument><expr><name>ACL_UPDATE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckRTEPermsModified
 *		Check INSERT or UPDATE access permissions for a single RTE (these
 *		are processed uniformly).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecCheckRTEPermsModified</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
						  <parameter><decl><type><name>AclMode</name></type> <name>requiredPerms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When the query doesn't explicitly update any columns, allow the query
	 * if we have permission on any column of the rel.  This is to handle
	 * SELECT FOR UPDATE as well as possible corner cases in UPDATE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>modifiedCols</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck_all</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>requiredPerms</name></expr></argument>,
									  <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>col</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>modifiedCols</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* bit #s are offset by FirstLowInvalidHeapAttributeNumber */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name>col</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* whole-row reference can't happen here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"whole-row update is not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>,
									  <argument><expr><name>requiredPerms</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check that the query does not imply any writes to non-temp tables;
 * unless we're in parallel mode, in which case don't even allow writes
 * to temp tables.
 *
 * This function is used to check if the current statement will perform any writes.
 * It is used to enforce:
 *  (1) read-only mode (both fts and transaction isolation level read only)
 *      as well as
 *  (2) to keep track of when a distributed transaction becomes
 *      "dirty" and will require 2pc.
 *
 * Note: in a Hot Standby this would need to reject writes to temp
 * tables just as we do in parallel mode; but an HS standby can't have created
 * any temp tables in the first place, so no need to check that.
 *
 * In GPDB, an important side-effect of this is to call
 * ExecutorMarkTransactionDoesWrites(), if the query is not read-only. That
 * ensures that we use two-phase commit for this transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckXactReadOnly</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>rti</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * CREATE TABLE AS or SELECT INTO?
	 *
	 * XXX should we allow this if the destination is temp?  Considering that
	 * it would still require catalog changes, probably not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>intoClause</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>intoClause</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecutorMarkTransactionDoesWrites</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plannedstmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Refresh matview will write xlog.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>refreshClause</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plannedstmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/*
	 * Fail if write permissions are requested in parallel mode for table
	 * (temp or non-temp), otherwise fail for any non-temp table.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>rti</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>ACL_SELECT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * External and foreign tables don't need two phase commit which is for
		 * local mpp tables
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>isTempNamespace</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecutorMarkTransactionDoesWrites</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/* CDB: Allow SELECT FOR SHARE/UPDATE *
         *
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>ACL_SELECT</name> <operator>|</operator> <name>ACL_SELECT_FOR_UPDATE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
        	<decl_stmt><decl><type><name>bool</name></type> <name>foundRTI</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>plannedstmt-&gt;rowMarks</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rmc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if<condition>( <expr><name><name>rmc</name><operator>-&gt;</operator><name>rti</name></name> <operator>==</operator> <name>rti</name></expr> )</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>foundRTI</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>foundRTI</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plannedstmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plannedstmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		InitPlan
 *
 *		Initializes the query plan: open files, allocate storage
 *		and start up the rule manager
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitPlan</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rangeTable</name> <init>= <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>intoPolicy</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>intoPolicy</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>intoPolicy</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to InitPlan start: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* do nothing */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do permissions checks
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator> <name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecCheckRTPerms</name><argument_list>(<argument><expr><name>rangeTable</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * initialize the node's execution state
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitRangeTable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rangeTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name> <operator>=</operator> <name>plannedstmt</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize ResultRelInfo data structures, and open the result rels.
	 *
	 * CDB: Note that we need this info even if we aren't the slice that will be doing
	 * the actual updating, since it's where we learn things, such as if the row needs to
	 * contain OIDs or not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>resultRelations</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resultRelations</name> <init>= <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numResultRelations</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name>numResultRelations</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;resultRelations</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type>		<name>resultRelationIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelation</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>resultRelation</name> <operator>=</operator> <call><name>ExecGetRangeTableRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
													   <argument><expr><name>resultRelationIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
							  <argument><expr><name>resultRelation</name></expr></argument>,
							  <argument><expr><name>resultRelationIndex</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <name>numResultRelations</name></expr>;</expr_stmt>

		<comment type="block">/* es_result_relation_info is NULL except when within ModifyTable */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In the partitioned result relation case, also build ResultRelInfos
		 * for all the partitioned table roots, because we will need them to
		 * fire statement-level triggers, if any.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rootResultRelations</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>num_roots</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rootResultRelations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><name>num_roots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;rootResultRelations</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Index</name></type>		<name>resultRelIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelDesc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>resultRelDesc</name> <operator>=</operator> <call><name>ExecGetRangeTableRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
														  <argument><expr><name>resultRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
								  <argument><expr><name>resultRelDesc</name></expr></argument>,
								  <argument><expr><name>resultRelIndex</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name> <operator>=</operator> <name>num_roots</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * if no result relation, then set state appropriately
		 */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Next, build the ExecRowMark array from the PlanRowMark(s), if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowmarks</name></name> <operator>=</operator> <operator>(</operator><name>ExecRowMark</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExecRowMark</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;rowMarks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name></decl>;</decl_stmt>

			<comment type="block">/* ignore "parent" rowmarks; they are irrelevant at runtime */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>isParent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* get relation's OID (will produce InvalidOid if subquery) */</comment>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>exec_rt_fetch</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relid</name></expr>;</expr_stmt>

			<comment type="block">/* open relation, if we need to access it for this mark type */</comment>
			<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Greenplum specific behavior:
				 * The implementation of select statement with locking clause
				 * (for update | no key update | share | key share) in postgres
				 * is to hold RowShareLock on tables during parsing stage, and
				 * generate a LockRows plan node for executor to lock the tuples.
				 * It is not easy to lock tuples in Greenplum database, since
				 * tuples may be fetched through motion nodes.
				 *
				 * But when Global Deadlock Detector is enabled, and the select
				 * statement with locking clause contains only one table, we are
				 * sure that there are no motions. For such simple cases, we could
				 * make the behavior just the same as Postgres.
				 */</comment>
				<case>case <expr><name>ROW_MARK_EXCLUSIVE</name></expr>:</case>
				<case>case <expr><name>ROW_MARK_NOKEYEXCLUSIVE</name></expr>:</case>
				<case>case <expr><name>ROW_MARK_SHARE</name></expr>:</case>
				<case>case <expr><name>ROW_MARK_KEYSHARE</name></expr>:</case>
				<case>case <expr><name>ROW_MARK_REFERENCE</name></expr>:</case>
					<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>ExecGetRangeTableRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>ROW_MARK_COPY</name></expr>:</case>
					<comment type="block">/* no physical table access is required */</comment>
					<expr_stmt><expr><name>relation</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized markType: %d"</literal></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>relation</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
					<break>break;</break>
			</block_content>}</block></switch>

			<comment type="block">/* Check that relation is a legal target for marking */</comment>
			<if_stmt><if>if <condition>(<expr><name>relation</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CheckValidRowMarkRel</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>erm</name> <operator>=</operator> <operator>(</operator><name>ExecRowMark</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExecRowMark</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>prti</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>prti</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>rowmarkId</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>ermActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>erm</name><operator>-&gt;</operator><name>curCtid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>ermExtra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>&lt;=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>&amp;&amp;</operator>
				   <name><name>estate</name><operator>-&gt;</operator><name>es_rowmarks</name><index>[<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowmarks</name><index>[<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>erm</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize the executor's tuple table to empty.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* mark EvalPlanQual not active */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize private state information for each SubPlan.  We must do this
	 * before running ExecInitNode on the main query tree, since
	 * ExecInitSubPlan expects to be able to find these entries.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>locallyExecutableSubplans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>start_plan_node</name> <init>= <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If eliminateAliens is true then we extract the local Motion node
	 * and subplans for our current slice. This enables us to call ExecInitNode
	 * for only a subset of the plan tree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eliminateAliens</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>findSenderMotion</name><argument_list>(<argument><expr><name>plannedstmt</name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We may not have any motion in the current slice, e.g., in insert query
		 * the root may not have any motion.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>m</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>start_plan_node</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>m</name></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>sendSlice</name> <init>= <expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>m</name><operator>-&gt;</operator><name>motionID</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name><name>sendSlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Compute SubPlans' root plan nodes for SubPlans reachable from this plan root */</comment>
		<expr_stmt><expr><name>locallyExecutableSubplans</name> <operator>=</operator> <call><name>getLocallyExecutableSubplans</name><argument_list>(<argument><expr><name>plannedstmt</name></expr></argument>, <argument><expr><name>start_plan_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>locallyExecutableSubplans</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>subplan_id</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;subplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sp_eflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Initialize only the subplans that are reachable from our local slice.
		 * If alien elimination is not turned on, then all subplans are considered
		 * reachable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>eliminateAliens</name></name> <operator>||</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name>subplan_id</name></expr></argument>, <argument><expr><name>locallyExecutableSubplans</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * A subplan will never need to do BACKWARD scan nor MARK/RESTORE.
			 *
			 * GPDB: We always set the REWIND flag, to delay eagerfree.
			 */</comment>
			<expr_stmt><expr><name>sp_eflags</name> <operator>=</operator> <name>eflags</name>
				<operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_EXPLAIN_ONLY</name> <operator>|</operator> <name>EXEC_FLAG_WITH_NO_DATA</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>sp_eflags</name> <operator>|=</operator> <name>EXEC_FLAG_REWIND</name></expr>;</expr_stmt>

			<comment type="block">/* set our global sliceid variable for elog. */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_currentSliceId</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>subplan_id</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>subplanstate</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>sp_eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name>save_currentSliceId</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name></expr></argument>, <argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>++</operator><name>subplan_id</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If this is a query that was dispatched from the QE, install precomputed
	 * parameter values from all init plans into our EState.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstallDispatchedExecParams</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize the private state information for all the nodes in the query
	 * tree.  This opens files, allocates storage and leaves us ready to start
	 * processing tuples.
	 */</comment>
	<expr_stmt><expr><name>planstate</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>start_plan_node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>planstate</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* GPDB hook for collecting query info */</comment>
	<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_PLAN_NODE_INITIALIZE</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the tuple descriptor describing the type of tuples to return.
	 */</comment>
	<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the junk filter if needed.  SELECT queries need a filter if
	 * there are any junk attrs in the top-level tlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>junk_filter_needed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>tlist</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>junk_filter_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>junk_filter_needed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
								   <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

			<comment type="block">/* Want to return the cleaned tuple type */</comment>
			<expr_stmt><expr><name>tupType</name> <operator>=</operator> <name><name>j</name><operator>-&gt;</operator><name>jf_cleanTupType</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>tupType</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB: Hack for CTAS/MatView:
	 *   Need to switch to IntoRelDest for CTAS.
	 *   Also need to create tables in advance.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>intorel_initplan</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>copyIntoClause</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <call><name>CreateCopyDestReceiver</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>DR_copy</name><operator>*</operator><operator>)</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name><operator>)</operator><operator>-&gt;</operator><name>queryDesc</name> <operator>=</operator> <name>queryDesc</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>refreshClause</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>transientrel_init</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
				<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="number">1</literal></expr>:</case>
					<case>case <expr><literal type="number">2</literal></expr>:</case>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to InitPlan end: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"func_init_plan_end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check that a proposed result relation is a legal target for the operation
 *
 * Generally the parser and/or planner should have noticed any such mistake
 * already, but let's make sure.
 *
 * Note: when changing this function, you probably also need to look at
 * CheckValidRowMarkRel.
 */</comment>
<function><type><name>void</name></type>
<name>CheckValidResultRel</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigDesc</name> <init>= <expr><name><name>resultRel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>resultRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>CheckCmdReplicaIdentity</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change sequence \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change TOAST relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>

			<comment type="block">/*
			 * Okay only if there's a suitable INSTEAD OF trigger.  Messages
			 * here should match rewriteHandler.c's rewriteTargetView, except
			 * that we omit errdetail because we haven't got the information
			 * handy (and given that we really shouldn't get here anyway, it's
			 * not worth great exertion to get).
			 */</comment>
			<comment type="block">/*
			 * GPDB_91_MERGE_FIXME: In Greenplum, views are treated as non
			 * partitioned relations, gp_distribution_policy contains no entry
			 * for views.  Consequently, flow of a ModifyTable node for a view
			 * is determined such that it is not dispatched to segments.
			 * Things get confused if the DML statement has a where clause that
			 * results in a direct dispatch to one segment.  Underlying scan
			 * nodes have direct dispatch set but when it's time to commit, the
			 * direct dispatch information is not passed on to the DTM and it
			 * sends PREPARE to all segments, causing "Distributed transaction
			 * ... not found" error.  Until this is fixed, INSTEAD OF triggers
			 * and DML on views need to be disabled.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_FEATURE_NOT_YET</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change view \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"changing views is not supported in Greenplum"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trigDesc</name> <operator>||</operator> <operator>!</operator><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert into view \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trigDesc</name> <operator>||</operator> <operator>!</operator><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_update_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update view \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_DELETE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trigDesc</name> <operator>||</operator> <operator>!</operator><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_delete_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete from view \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized CmdType: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MatViewIncrementalMaintenanceIsEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change materialized view \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<comment type="block">/* Okay only if the FDW supports it */</comment>
			<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExecForeignInsert</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert into foreign table \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_INSERT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not allow inserts"</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExecForeignUpdate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update foreign table \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_UPDATE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not allow updates"</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_DELETE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExecForeignDelete</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete from foreign table \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_DELETE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not allow deletes"</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized CmdType: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>

		<comment type="block">/* GPDB additions */</comment>
		<case>case <expr><name>RELKIND_AOSEGMENTS</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change AO segment listing relation \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_AOBLOCKDIR</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change AO block directory relation \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_AOVISIMAP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change AO visibility map relation \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Check that a proposed rowmark target relation is a legal target
 *
 * In most cases parser and/or planner should have noticed this already, but
 * they don't cover all cases.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckValidRowMarkRel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RowMarkType</name></type> <name>markType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<comment type="block">/* OK */</comment>
			<break>break;</break>
		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
			<comment type="block">/* Must disallow this because we don't vacuum sequences */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in sequence \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
			<comment type="block">/* We could allow this, but there seems no good reason to */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in TOAST relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
			<comment type="block">/* Should not get here; planner should have expanded the view */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in view \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<comment type="block">/* Allow referencing a matview, but not actual locking clauses */</comment>
			<if_stmt><if>if <condition>(<expr><name>markType</name> <operator>!=</operator> <name>ROW_MARK_REFERENCE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in materialized view \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<comment type="block">/* Okay only if the FDW supports it */</comment>
			<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>RefetchForeignRow</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in foreign table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize ResultRelInfo data for one result relation
 *
 * Caution: before Postgres 9.1, this function included the relkind checking
 * that's now in CheckValidResultRel, and it also did ExecOpenIndices if
 * appropriate.  Be sure callers cover those needs.
 */</comment>
<function><type><name>void</name></type>
<name>InitResultRelInfo</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>resultRelationDesc</name></decl></parameter>,
				  <parameter><decl><type><name>Index</name></type> <name>resultRelationIndex</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>partition_root</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>instrument_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partition_check</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_ResultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name> <operator>=</operator> <name>resultRelationIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name> <operator>=</operator> <name>resultRelationDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* make a copy so as not to depend on relcache info not changing... */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>=</operator> <call><name>CopyTriggerDesc</name><argument_list>(<argument><expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigWhenExprs</name></name> <operator>=</operator> <operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>instrument_options</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name> <operator>=</operator> <call><name>InstrAlloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigWhenExprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* The following fields are set later if needed */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_GeneratedExprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_segid_attno</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_action_attno</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ReturningSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigOldSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigNewSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Partition constraint, which also includes the partition constraint of
	 * all the ancestors that are partitions.  Note that it will be checked
	 * even in the case of tuple-routing where this table is the target leaf
	 * partition, if there any BR triggers defined on the table.  Although
	 * tuple-routing implicitly preserves the partition constraint of the
	 * target partition for a given row, the BR triggers may change the row
	 * such that the constraint is no longer satisfied, which we must fail for
	 * by checking it explicitly.
	 *
	 * If this is a partitioned table, the partition constraint (if any) of a
	 * given row will be checked just before performing tuple-routing.
	 */</comment>
	<expr_stmt><expr><name>partition_check</name> <operator>=</operator> <call><name>RelationGetPartitionQual</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name> <operator>=</operator> <name>partition_check</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name> <operator>=</operator> <name>partition_root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* may be set later */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_CopyMultiInsertBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ExecGetTriggerResultRel
 *		Get a ResultRelInfo for a trigger target relation.
 *
 * Most of the time, triggers are fired on one of the result relations of the
 * query, and so we can just return a member of the es_result_relations array,
 * or the es_root_result_relations array (if any), or the
 * es_tuple_routing_result_relations list (if any).  (Note: in self-join
 * situations there might be multiple members with the same OID; if so it
 * doesn't matter which one we pick.)
 *
 * However, it is sometimes necessary to fire triggers on other relations;
 * this happens mainly when an RI update trigger queues additional triggers
 * on other relations, which will be processed in the context of the outer
 * query.  For efficiency's sake, we want to have a ResultRelInfo for those
 * triggers too; that can avoid repeated re-opening of the relation.  (It
 * also provides a way for EXPLAIN ANALYZE to report the runtimes of such
 * triggers.)  So we make additional ResultRelInfo's as needed, and save them
 * in es_trig_target_relations.
 */</comment>
<function><type><name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>ExecGetTriggerResultRel</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* First, search through the query result relations */</comment>
	<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nr</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>nr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rInfo</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rInfo</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nr</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<comment type="block">/* Second, search through the root result relations, if any */</comment>
	<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nr</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>nr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rInfo</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rInfo</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nr</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Third, search through the result relations that were created during
	 * tuple routing, if any.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_tuple_routing_result_relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rInfo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Nope, but maybe we already made an extra ResultRelInfo for it */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_trig_target_relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rInfo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* Nope, so we need a new one */</comment>

	<comment type="block">/*
	 * Open the target relation's relcache entry.  We assume that an
	 * appropriate lock is still held by the backend from whenever the trigger
	 * event got queued, so we need take no new lock here.  Also, we need not
	 * recheck the relkind, so no need for CheckValidResultRel.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the new entry in the right context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>rInfo</name></expr></argument>,
					  <argument><expr><name>rel</name></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>,		<comment type="block">/* dummy rangetable index */</comment>
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_target_relations</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_target_relations</name></name></expr></argument>, <argument><expr><name>rInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently, we don't need any index information in ResultRelInfos used
	 * only for triggers, so no need to call ExecOpenIndices.
	 */</comment>

	<return>return <expr><name>rInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close any relations that have been opened by ExecGetTriggerResultRel().
 */</comment>
<function><type><name>void</name></type>
<name>ExecCleanUpTriggerState</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_trig_target_relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Assert this is a "dummy" ResultRelInfo, see above.  Otherwise we
		 * might be issuing a duplicate close against a Relation opened by
		 * ExecGetRangeTableRelation.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since ExecGetTriggerResultRel doesn't call ExecOpenIndices for
		 * these rels, we needn't call ExecCloseIndices either.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecPostprocessPlan
 *
 *		Give plan nodes a final chance to execute before shutdown
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecPostprocessPlan</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure nodes run forward.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run any secondary ModifyTable nodes to completion, in case the main
	 * query did not fetch all rows from them.  (We do this to ensure that
	 * such nodes have predictable results.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>estate-&gt;es_auxmodifytables</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ps</name> <init>= <expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

			<comment type="block">/* Reset the per-output-tuple exprcontext each time */</comment>
			<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndPlan
 *
 *		Cleans up the query plan -- closes files and frees up storage
 *
 * NOTE: we are no longer very worried about freeing storage per se
 * in this code; FreeExecutorState should be guaranteed to release all
 * memory that needs to be released.  What we are worried about doing
 * is closing relations and dropping buffer pins.  Thus, for example,
 * tuple tables must be cleared or dropped to ensure pins are released.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndPlan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>num_relations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * shut down the node-type-specific query processing
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * for subplans too
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_subplanstates</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name> <init>= <expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>subplanstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * destroy the executor's tuple table.  Actually we only care about
	 * releasing buffer pins and tupdesc refcounts; there's no need to pfree
	 * the TupleTableSlots, since the containing memory context is about to go
	 * away anyway.
	 */</comment>
	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust INSERT/UPDATE/DELETE count for replicated table ON QD */</comment>
	<expr_stmt><expr><call><name>AdjustReplicatedTableCounts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * close indexes of result relation(s) if any.  (Rels themselves get
	 * closed next.)
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * close whatever rangetable Relations have been opened.  We do not
	 * release any locks we might hold on those rels.
	 */</comment>
	<expr_stmt><expr><name>num_relations</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_relations</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* likewise close any trigger target relations */</comment>
	<expr_stmt><expr><call><name>ExecCleanUpTriggerState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecutePlan
 *
 *		Processes the query plan until we have retrieved 'numberTuples' tuples,
 *		moving in the specified direction.
 *
 *		Runs to completion if numberTuples is 0
 *
 * Note: the ctid attribute is a 'junk' attribute that is removed before the
 * user can see it
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecutePlan</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
			<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>use_parallel_mode</name></decl></parameter>,
			<parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>sendTuples</name></decl></parameter>,
			<parameter><decl><type><name>uint64</name></type> <name>numberTuples</name></decl></parameter>,
			<parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>,
			<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>current_tuple_count</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For holdable cursor, the plan is executed without rewinding on gpdb. We
	 * need to quit if the executor has already emitted all tuples.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_got_eos</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * initialize local variables
	 */</comment>
	<expr_stmt><expr><name>current_tuple_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the direction.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the plan might potentially be executed multiple times, we must force
	 * it to run without parallelism, because we might exit early.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>execute_once</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_parallel_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_use_parallel_mode</name></name> <operator>=</operator> <name>use_parallel_mode</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>use_parallel_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EnterParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<comment type="block">/* Inject a fault before tuple processing started */</comment>
	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"executor_pre_tuple_processed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FAULT_INJECTOR */</comment>

	<comment type="block">/*
	 * Loop until we've processed the proper number of tuples from the plan.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Reset the per-output-tuple exprcontext */</comment>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Execute the plan and obtain a tuple
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if the tuple is null, then we assume there is nothing more to
		 * process so we just end the loop...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We got end-of-stream. We need to mark it since with a cursor
			 * end-of-stream will only be received with the fetch that
			 * returns the last tuple. ExecutorEnd needs to know if EOS was
			 * received in order to do the right cleanup.
			 */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_got_eos</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* Allow nodes to release or shut down resources. */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ExecShutdownNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we have a junk filter, then project a new tuple with the junk
		 * removed.
		 *
		 * Store this new "clean" tuple in the junkfilter's resultSlot.
		 * (Formerly, we stored it back over the "dirty" tuple, which is WRONG
		 * because that tuple slot has the wrong descriptor.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Gp_is_writer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"INSERT/UPDATE/DELETE must be executed by a writer segworker group"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we are supposed to send the tuple somewhere, do so. (In
		 * practice, this is probably always the case at this point.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sendTuples</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we are not able to send the tuple, we assume the destination
			 * has closed and no more tuples can be sent. If that's the case,
			 * end the loop.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Count tuples processed, if this is a SELECT.  (For other operation
		 * types, the ModifyTable plan node must count the appropriate
		 * events.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<comment type="block">/*
			 * bump es_processed using the fault injector, but only if the number rows is in a certain range
			 * this avoids bumping the counter every time after we bumped it once
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>&gt;=</operator> <literal type="number">10000</literal> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>&lt;=</operator> <literal type="number">1000000</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(<argument><expr><literal type="string">"executor_run_high_processed"</literal></expr></argument>,
												   <argument><expr><name>DDLNotSpecified</name></expr></argument>,
												   <argument><expr><literal type="string">""</literal></expr></argument> <comment type="block">/* databaseName */</comment>,
												   <argument><expr><literal type="string">""</literal></expr></argument> <comment type="block">/* tableName */</comment>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * For testing purposes, pretend that we have already processed
					 * almost 2^32 rows.
					 */</comment>
					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name>UINT_MAX</name> <operator>-</operator> <literal type="number">10</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FAULT_INJECTOR */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * check our tuple count.. if we've processed the proper number then
		 * quit, else loop again and process more tuples.  Zero numberTuples
		 * means no limit.
		 */</comment>
		<expr_stmt><expr><name>current_tuple_count</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>numberTuples</name> <operator>&amp;&amp;</operator> <name>numberTuples</name> <operator>==</operator> <name>current_tuple_count</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we know we won't need to back up, we can release resources
			 * at this point.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_BACKWARD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ExecShutdownNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we know we won't need to back up, we can release resources at this
	 * point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_BACKWARD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ExecShutdownNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_parallel_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExitParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecRelCheck --- check that tuple meets constraints for result relation
 *
 * Returns NULL if OK, else name of failed check constraint
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExecRelCheck</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
			 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncheck</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>check</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If first time through for this result relation, build expression
	 * nodetrees for rel's constraint expressions.  Keep them in the per-query
	 * memory context so they'll survive throughout the query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name></name> <operator>=</operator>
			<operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncheck</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncheck</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>checkconstr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>checkconstr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>checkconstr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We will use the EState's per-tuple context for evaluating constraint
	 * expressions (creating it if it's not already there).
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* And evaluate the constraints */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncheck</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>checkconstr</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * NOTE: SQL specifies that a NULL result from a constraint expression
		 * is not to be treated as a failure.  Therefore, use ExecCheck not
		 * ExecQual.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>checkconstr</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* NULL result means no error */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPartitionCheck --- check that tuple meets the partition constraint.
 *
 * Returns true if it meets the partition constraint.  If the constraint
 * fails and we're asked to emit to error, do so and don't return; otherwise
 * return false.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecPartitionCheck</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
				   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>emitError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If first time through, build expression state tree for the partition
	 * check expression.  Keep it in the per-query memory context so they'll
	 * survive throughout the query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheckExpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheckExpr</name></name> <operator>=</operator> <call><name>ExecPrepareCheck</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We will use the EState's per-tuple context for evaluating constraint
	 * expressions (creating it if it's not already there).
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * As in case of the catalogued constraints, we treat a NULL result as
	 * success here, not a failure.
	 */</comment>
	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>ExecCheck</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheckExpr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if asked to emit error, don't actually return on failure */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name> <operator>&amp;&amp;</operator> <name>emitError</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecPartitionCheckEmitError</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPartitionCheckEmitError - Form and emit an error message after a failed
 * partition constraint check.
 */</comment>
<function><type><name>void</name></type>
<name>ExecPartitionCheckEmitError</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
							<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>root_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modifiedCols</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the tuple has been routed, it's been converted to the partition's
	 * rowtype, which might differ from the root table's.  We must convert it
	 * back to the root table's rowtype so that val_desc in the error message
	 * matches the input tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>old_tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>root_relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>old_tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* a reverse map */</comment>
		<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name_map_if_req</name><argument_list>(<argument><expr><name>old_tupdesc</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
												<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Partition-specific slot's tupdesc can't be changed, so allocate a
		 * new one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
										 <argument><expr><call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>root_relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>modifiedCols</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><call><name>GetInsertedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>GetUpdatedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotValueDescription</name><argument_list>(<argument><expr><name>root_relid</name></expr></argument>,
											 <argument><expr><name>slot</name></expr></argument>,
											 <argument><expr><name>tupdesc</name></expr></argument>,
											 <argument><expr><name>modifiedCols</name></expr></argument>,
											 <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row for relation \"%s\" violates partition constraint"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
			 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failing row contains %s."</literal></expr></argument>, <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecConstraints - check constraints of the tuple in 'slot'
 *
 * This checks the traditional NOT NULL and check constraints.
 *
 * The partition constraint is *NOT* checked.
 *
 * Note: 'slot' contains the tuple to check the constraints of, which may
 * have been converted from the original input tuple after tuple routing.
 * 'resultRelInfo' is the final result relation, after tuple routing.
 */</comment>
<function><type><name>void</name></type>
<name>ExecConstraints</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
				<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modifiedCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>insertedCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>constr</name> <operator>||</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attrChk</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>attrChk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrChk</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attrChk</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attrChk</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <call><name>slot_attisnull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attrChk</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>orig_rel</name> <init>= <expr><name>rel</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>orig_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the tuple has been routed, it's been converted to the
				 * partition's rowtype, which might differ from the root
				 * table's.  We must convert it back to the root table's
				 * rowtype so that val_desc shown error message matches the
				 * input tuple.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* a reverse map */</comment>
					<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name_map_if_req</name><argument_list>(<argument><expr><name>orig_tupdesc</name></expr></argument>,
															<argument><expr><name>tupdesc</name></expr></argument>,
															<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Partition-specific slot's tupdesc can't be changed, so
					 * allocate a new one.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
													 <argument><expr><call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>insertedCols</name> <operator>=</operator> <call><name>GetInsertedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>GetUpdatedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>modifiedCols</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotValueDescription</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name>slot</name></expr></argument>,
														 <argument><expr><name>tupdesc</name></expr></argument>,
														 <argument><expr><name>modifiedCols</name></expr></argument>,
														 <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null value in column \"%s\" violates not-null constraint"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failing row contains %s."</literal></expr></argument>, <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
						 <call><name>errtablecol</name><argument_list>(<argument><expr><name>orig_rel</name></expr></argument>, <argument><expr><name>attrChk</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>failed</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>failed</name> <operator>=</operator> <call><name>ExecRelCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>orig_rel</name> <init>= <expr><name>rel</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* See the comment above. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>old_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* a reverse map */</comment>
				<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name_map_if_req</name><argument_list>(<argument><expr><name>old_tupdesc</name></expr></argument>,
														<argument><expr><name>tupdesc</name></expr></argument>,
														<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Partition-specific slot's tupdesc can't be changed, so
				 * allocate a new one.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
												 <argument><expr><call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>insertedCols</name> <operator>=</operator> <call><name>GetInsertedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>GetUpdatedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>modifiedCols</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotValueDescription</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>slot</name></expr></argument>,
													 <argument><expr><name>tupdesc</name></expr></argument>,
													 <argument><expr><name>modifiedCols</name></expr></argument>,
													 <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row for relation \"%s\" violates check constraint \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>orig_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>failed</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failing row contains %s."</literal></expr></argument>, <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
					 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>orig_rel</name></expr></argument>, <argument><expr><name>failed</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecWithCheckOptions -- check that tuple satisfies any WITH CHECK OPTIONs
 * of the specified kind.
 *
 * Note that this needs to be called multiple times to ensure that all kinds of
 * WITH CHECK OPTIONs are handled (both those from views which have the WITH
 * CHECK OPTION set and from row level security policies).  See ExecInsert()
 * and ExecUpdate().
 */</comment>
<function><type><name>void</name></type>
<name>ExecWithCheckOptions</name><parameter_list>(<parameter><decl><type><name>WCOKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We will use the EState's per-tuple context for evaluating constraint
	 * expressions (creating it if it's not already there).
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Check each of the constraints */</comment>
	<macro><name>forboth</name><argument_list>(<argument>l1</argument>, <argument>resultRelInfo-&gt;ri_WithCheckOptions</argument>,
			<argument>l2</argument>, <argument>resultRelInfo-&gt;ri_WithCheckOptionExprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><operator>(</operator><name>WithCheckOption</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>wcoExpr</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip any WCOs which are not the kind we are looking for at this
		 * time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>kind</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * WITH CHECK OPTION checks are intended to ensure that the new tuple
		 * is visible (in the case of a view) or that it passes the
		 * 'with-check' policy (in the case of row security). If the qual
		 * evaluates to NULL or FALSE, then the new tuple won't be included in
		 * the view or doesn't pass the 'with-check' policy for the table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>wcoExpr</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modifiedCols</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>insertedCols</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
			<block>{<block_content>
					<comment type="block">/*
					 * For WITH CHECK OPTIONs coming from views, we might be
					 * able to provide the details on the row, depending on
					 * the permissions on the relation (that is, if the user
					 * could view it directly anyway).  For RLS violations, we
					 * don't include the data since we don't know if the user
					 * should be able to view the tuple as that depends on the
					 * USING policy.
					 */</comment>
				<case>case <expr><name>WCO_VIEW_CHECK</name></expr>:</case>
					<comment type="block">/* See the comment in ExecConstraints(). */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>old_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* a reverse map */</comment>
						<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name_map_if_req</name><argument_list>(<argument><expr><name>old_tupdesc</name></expr></argument>,
																<argument><expr><name>tupdesc</name></expr></argument>,
																<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Partition-specific slot's tupdesc can't be changed,
						 * so allocate a new one.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
														 <argument><expr><call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>insertedCols</name> <operator>=</operator> <call><name>GetInsertedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>GetUpdatedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>modifiedCols</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotValueDescription</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
															 <argument><expr><name>slot</name></expr></argument>,
															 <argument><expr><name>tupdesc</name></expr></argument>,
															 <argument><expr><name>modifiedCols</name></expr></argument>,
															 <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WITH_CHECK_OPTION_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates check option for view \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failing row contains %s."</literal></expr></argument>,
												  <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>WCO_RLS_INSERT_CHECK</name></expr>:</case>
				<case>case <expr><name>WCO_RLS_UPDATE_CHECK</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>polname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates row-level security policy \"%s\" for table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates row-level security policy for table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><name>WCO_RLS_CONFLICT_CHECK</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>polname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates row-level security policy \"%s\" (USING expression) for table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates row-level security policy (USING expression) for table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized WCO kind: %u"</literal></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ExecBuildSlotValueDescription -- construct a string representing a tuple
 *
 * This is intentionally very similar to BuildIndexValueDescription, but
 * unlike that function, we truncate long field values (to at most maxfieldlen
 * bytes).  That seems necessary here since heap field values could be very
 * long, whereas index entries typically aren't so wide.
 *
 * Also, unlike the case with index entries, we need to be prepared to ignore
 * dropped columns.  We used to use the slot's tuple descriptor to decode the
 * data, but the slot's descriptor doesn't identify dropped columns, so we
 * now need to be passed the relation's descriptor.
 *
 * Note that, like BuildIndexValueDescription, if the user does not have
 * permission to view any of the columns involved, a NULL is returned.  Unlike
 * BuildIndexValueDescription, if the user has access to view a subset of the
 * column involved, that subset will be returned with a key identifying which
 * columns they are.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExecBuildSlotValueDescription</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
							  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>collist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>write_comma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>write_comma_collist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>table_perm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>any_perm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check if RLS is enabled and should be active for the relation; if so,
	 * then don't return anything.  Otherwise, go through normal permission
	 * checks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check if the user has permissions to see the row.  Table-level SELECT
	 * allows access to all columns.  If the user does not have table-level
	 * SELECT then we check each column and include those the user has SELECT
	 * rights on.  Additionally, we always include columns the user provided
	 * data for.
	 */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up the buffer for the column list */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>table_perm</name> <operator>=</operator> <name>any_perm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Make sure the tuple is fully deconstructed */</comment>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>column_perm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>vallen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ignore dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>table_perm</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No table-level SELECT, so need to make sure they either have
			 * SELECT rights on the column or that they have provided the data
			 * for the column.  If not, omit this column from the error
			 * message.
			 */</comment>
			<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
											  <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
							  <argument><expr><name>modifiedCols</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>aclresult</name> <operator>==</operator> <name>ACLCHECK_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>column_perm</name> <operator>=</operator> <name>any_perm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>write_comma_collist</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>write_comma_collist</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>table_perm</name> <operator>||</operator> <name>column_perm</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>foutoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>foutoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>foutoid</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>write_comma</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>write_comma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* truncate if needed */</comment>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&lt;=</operator> <name>maxfieldlen</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>maxfieldlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If we end up with zero columns being returned, then return NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>any_perm</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>table_perm</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><literal type="string">") = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name><name>collist</name><operator>.</operator><name>data</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecUpdateLockMode -- find the appropriate UPDATE tuple lock mode for a
 * given ResultRelInfo
 */</comment>
<function><type><name>LockTupleMode</name></type>
<name>ExecUpdateLockMode</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>keyCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute lock mode to use.  If columns that are part of the key have not
	 * been modified, then we can use a weaker lock, allowing for better
	 * concurrency.
	 */</comment>
	<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>GetAllUpdatedColumns</name><argument_list>(<argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keyCols</name> <operator>=</operator> <call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
										 <argument><expr><name>INDEX_ATTR_BITMAP_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>keyCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>LockTupleExclusive</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>LockTupleNoKeyExclusive</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecFindRowMark -- find the ExecRowMark struct for given rangetable index
 *
 * If no such struct, either return NULL or throw error depending on missing_ok
 */</comment>
<function><type><name>ExecRowMark</name> <modifier>*</modifier></type>
<name>ExecFindRowMark</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>rti</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rti</name> <operator>&lt;=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>&amp;&amp;</operator>
		<name><name>estate</name><operator>-&gt;</operator><name>es_rowmarks</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowmarks</name><index>[<expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>erm</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>erm</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find ExecRowMark for rangetable index %u"</literal></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecBuildAuxRowMark -- create an ExecAuxRowMark struct
 *
 * Inputs are the underlying ExecRowMark struct and the targetlist of the
 * input plan node (not planstate node!).  We need the latter to find out
 * the column numbers of the resjunk columns.
 */</comment>
<function><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type>
<name>ExecBuildAuxRowMark</name><parameter_list>(<parameter><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name> <init>= <expr><operator>(</operator><name>ExecAuxRowMark</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExecAuxRowMark</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>resname</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>aerm</name><operator>-&gt;</operator><name>rowmark</name></name> <operator>=</operator> <name>erm</name></expr>;</expr_stmt>

	<comment type="block">/* Look up the resjunk columns associated with this rowmark */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>!=</operator> <name>ROW_MARK_COPY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* need ctid for all methods other than COPY */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"ctid%u"</literal></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aerm</name><operator>-&gt;</operator><name>ctidAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttributeInTlist</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>,
													   <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>ctidAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk %s column"</literal></expr></argument>, <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* need wholerow if COPY */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"wholerow%u"</literal></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aerm</name><operator>-&gt;</operator><name>wholeAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttributeInTlist</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>,
														<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>wholeAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk %s column"</literal></expr></argument>, <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* if child rel, need tableoid */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>!=</operator> <name><name>erm</name><operator>-&gt;</operator><name>prti</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"tableoid%u"</literal></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aerm</name><operator>-&gt;</operator><name>toidAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttributeInTlist</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>,
													   <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>toidAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk %s column"</literal></expr></argument>, <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>aerm</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EvalPlanQual logic --- recheck modified tuple(s) to see if we want to
 * process the updated version under READ COMMITTED rules.
 *
 * See backend/executor/README for some info about how this works.
 */</comment>


<comment type="block">/*
 * Check the updated version of a tuple to see if we want to process it under
 * READ COMMITTED rules.
 *
 *	estate - outer executor state data
 *	epqstate - state for EvalPlanQual rechecking
 *	relation - table containing tuple
 *	rti - rangetable index of table containing tuple
 *	inputslot - tuple for processing - this can be the slot from
 *		EvalPlanQualSlot(), for the increased efficiency.
 *
 * This tests whether the tuple in inputslot still matches the relevant
 * quals. For that result to be useful, typically the input tuple has to be
 * last row version (otherwise the result isn't particularly useful) and
 * locked (otherwise the result might be out of date). That's typically
 * achieved by using table_tuple_lock() with the
 * TUPLE_LOCK_FLAG_FIND_LAST_VERSION flag.
 *
 * Returns a slot containing the new candidate update/delete tuple, or
 * NULL if we determine we shouldn't process the row.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>EvalPlanQual</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
			 <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inputslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>testslot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rti</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need to run a recheck subquery.  Initialize or reinitialize EPQ state.
	 */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualBegin</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Callers will often use the EvalPlanQualSlot to store the tuple to avoid
	 * an unnecessary copy.
	 */</comment>
	<expr_stmt><expr><name>testslot</name> <operator>=</operator> <call><name>EvalPlanQualSlot</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>testslot</name> <operator>!=</operator> <name>inputslot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name>testslot</name></expr></argument>, <argument><expr><name>inputslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch any non-locked source rows
	 */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualFetchRowMarks</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run the EPQ query.  We assume it will return at most one tuple.
	 */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>EvalPlanQualNext</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we got a tuple, force the slot to materialize the tuple so that it
	 * is not dependent on any local state in the EPQ query (in particular,
	 * it's highly likely that the slot contains references to any pass-by-ref
	 * datums that may be present in copyTuple).  As with the next step, this
	 * is to guard against early re-use of the EPQ query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Clear out the test tuple.  This is needed in case the EPQ query is
	 * re-used to test a tuple for a different relation.  (Not clear that can
	 * really happen, but let's be safe.)
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>testslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EvalPlanQualInit -- initialize during creation of a plan state node
 * that might need to invoke EPQ processing.
 *
 * Note: subplan/auxrowmarks can be NULL/NIL if they will be set later
 * with EvalPlanQualSetPlan.
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualInit</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>auxrowmarks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Mark the EPQ state inactive */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* ... and remember data that EvalPlanQualBegin will need */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>arowMarks</name></name> <operator>=</operator> <name>auxrowmarks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EvalPlanQualSetPlan -- set or change subplan of an EPQState.
 *
 * We need this so that ModifyTable can deal with multiple subplans.
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualSetPlan</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>auxrowmarks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If we have a live EPQ query, shut it down */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualEnd</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And set/change the plan pointer */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<comment type="block">/* The rowmarks depend on the plan, too */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>arowMarks</name></name> <operator>=</operator> <name>auxrowmarks</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return, and create if necessary, a slot for an EPQ test tuple.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>EvalPlanQualSlot</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
				 <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rti</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rti</name> <operator>&lt;=</operator> <name><name>epqstate</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name><index>[<expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>relation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>slot</name> <operator>=</operator> <call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>,
									   <argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>*</operator><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the current row values for any non-locked relations that need
 * to be scanned by an EvalPlanQual operation.  origslot must have been set
 * to contain the current result row (top-level row) that we need to recheck.
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualFetchRowMarks</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>epqstate-&gt;arowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name> <init>= <expr><operator>(</operator><name>ExecAuxRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><name><name>aerm</name><operator>-&gt;</operator><name>rowmark</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RowMarkRequiresRowShareLock</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"EvalPlanQual doesn't support locking rowmarks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* clear any leftover test tuple for this rel */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>EvalPlanQualSlot</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if child rel, must check whether it produced this row */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>!=</operator> <name><name>erm</name><operator>-&gt;</operator><name>prti</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>tableoid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name></expr></argument>,
										 <argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>toidAttNo</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* non-locked rels could be on the inside of outer joins */</comment>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tableoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tableoid</name> <operator>!=</operator> <name><name>erm</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* this child is inactive right now */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>==</operator> <name>ROW_MARK_REFERENCE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* fetch the tuple's ctid */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name></expr></argument>,
										 <argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>ctidAttNo</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* non-locked rels could be on the inside of outer joins */</comment>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* fetch requests on foreign tables must be passed to their FDW */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>updated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* this should have been checked already, but let's be safe */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>RefetchForeignRow</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in foreign table \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>RefetchForeignRow</name></name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>,
											  <argument><expr><name>erm</name></expr></argument>,
											  <argument><expr><name>datum</name></expr></argument>,
											  <argument><expr><name>slot</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>updated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple for EvalPlanQual recheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Ideally we'd insist on updated == false here, but that
				 * assumes that FDWs can track that exactly, which they might
				 * not be able to.  So just ignore the flag.
				 */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* ordinary table, fetch the tuple */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
												   <argument><expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple for EvalPlanQual recheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>==</operator> <name>ROW_MARK_COPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* fetch the whole-row Var for the relation */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name></expr></argument>,
										 <argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>wholeAttNo</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* non-locked rels could be on the inside of outer joins */</comment>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ExecStoreHeapTupleDatum</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the next row (if any) from EvalPlanQual testing
 *
 * (In practice, there should never be more than one row...)
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>EvalPlanQualNext</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize or reset an EvalPlanQual state tree
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualBegin</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>parentestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>estate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, so create a child EState */</comment>
		<expr_stmt><expr><call><name>EvalPlanQualStart</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>parentestate</name></expr></argument>, <argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We already have a suitable child EPQ tree, so just reset it.
		 */</comment>
		<decl_stmt><decl><type><name>Index</name></type>		<name>rtsize</name> <init>= <expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_range_table_size</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name> <init>= <expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rtsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recopy current values of parent parameters */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Force evaluation of any InitPlan outputs that could be needed
			 * by the subplan, just in case they got reset since
			 * EvalPlanQualStart (see comments therein).
			 */</comment>
			<expr_stmt><expr><call><name>ExecSetParamPlanMulti</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>,
								  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>parentestate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* copy value if any, but not execPlan link */</comment>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator>
					<name><name>parentestate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator>
					<name><name>parentestate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Mark child plan tree as needing rescan at all scan nodes.  The
		 * first ExecProcNode will take care of actually doing the rescan.
		 */</comment>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>,
											 <argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>epqParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start execution of an EvalPlanQual plan tree.
 *
 * This is a cut-down version of ExecutorStart(): we copy some state from
 * the top-level estate rather than initializing it fresh.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EvalPlanQualStart</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>parentestate</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>planTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rtsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rtsize</name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_range_table_size</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Child EPQ EStates share the parent's copy of unchanging state such as
	 * the snapshot, rangetable, result-rel info, and external Param info.
	 * They need their own copies of local state, including a tuple table,
	 * es_param_exec_vals, etc.
	 *
	 * The ResultRelInfo array management is trickier than it looks.  We
	 * create fresh arrays for the child but copy all the content from the
	 * parent.  This is because it's okay for the child to share any
	 * per-relation state the parent has already created --- but if the child
	 * sets up any ResultRelInfo fields, such as its own junkfilter, that
	 * state must *not* propagate back to the parent.  (For one thing, the
	 * pointed-to data is in a memory context that won't last long enough.)
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_array</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_range_table_array</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_range_table_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_relations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowmarks</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_rowmarks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_junkFilter</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numResultRelations</name> <init>= <expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numRootResultRels</name> <init>= <expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name>numResultRelations</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>resultRelInfos</name></expr></argument>, <argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr></argument>,
			   <argument><expr><name>numResultRelations</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <name>numResultRelations</name></expr>;</expr_stmt>

		<comment type="block">/* Also transfer partitioned root result relations. */</comment>
		<if_stmt><if>if <condition>(<expr><name>numRootResultRels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><name>numRootResultRels</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>resultRelInfos</name></expr></argument>, <argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name></expr></argument>,
				   <argument><expr><name>numRootResultRels</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name> <operator>=</operator> <name>numRootResultRels</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* es_result_relation_info must NOT be copied */</comment>
	<comment type="block">/* es_trig_target_relations must NOT be copied */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_top_eflags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>;</expr_stmt>
	<comment type="block">/* es_auxmodifytables must NOT be copied */</comment>

	<comment type="block">/*
	 * The external param list is simply shared from parent.  The internal
	 * param workspace has to be local state, but we copy the initial values
	 * from the parent, so as to have access to any param values that were
	 * already set from other parts of the parent's plan tree.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Force evaluation of any InitPlan outputs that could be needed by
		 * the subplan.  (With more complexity, maybe we could postpone this
		 * till the subplan actually demands them, but it doesn't seem worth
		 * the trouble; this is a corner case already, since usually the
		 * InitPlans would have been evaluated before reaching EvalPlanQual.)
		 *
		 * This will not touch output params of InitPlans that occur somewhere
		 * within the subplan tree, only those that are attached to the
		 * ModifyTable node or above it and are referenced within the subplan.
		 * That's OK though, because the planner would only attach such
		 * InitPlans to a lower-level SubqueryScan node, and EPQ execution
		 * will not descend into a SubqueryScan.
		 *
		 * The EState's per-output-tuple econtext is sufficiently short-lived
		 * for this, since it should get reset before there is any chance of
		 * doing EvalPlanQual again.
		 */</comment>
		<expr_stmt><expr><call><name>ExecSetParamPlanMulti</name><argument_list>(<argument><expr><name><name>planTree</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>,
							  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>parentestate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now make the internal param workspace ... */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name> <operator>=</operator> <operator>(</operator><name>ParamExecData</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... and copy down all values, whether really needed or not */</comment>
		<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* copy value if any, but not execPlan link */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator>
				<name><name>parentestate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator>
				<name><name>parentestate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Each EState must have its own es_epqScanDone state, but if we have
	 * nested EPQ checks they should share es_epqTupleSlot arrays.  This
	 * allows sub-rechecks to inherit the values being examined by an outer
	 * recheck.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>rtsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name></name> <operator>=</operator> <operator>(</operator><name>TupleTableSlot</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>rtsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleTableSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Each estate also has its own tuple table.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize private state information for each SubPlan.  We must do this
	 * before running ExecInitNode on the main query tree, since
	 * ExecInitSubPlan expects to be able to find these entries. Some of the
	 * SubPlans might not be used in the part of the plan tree we intend to
	 * run, but since it's not easy to tell which, we just initialize them
	 * all.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parentestate-&gt;es_plannedstmt-&gt;subplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>subplanstate</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name></expr></argument>,
										   <argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Initialize the private state information for all the nodes in the part
	 * of the plan tree we need to run.  This opens files, allocates storage
	 * and leaves us ready to start processing tuples.
	 */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>planTree</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EvalPlanQualEnd -- shut down at termination of parent plan state node,
 * or if we are done with the current EPQ child.
 *
 * This is a cut-down version of ExecutorEnd(); basically we want to do most
 * of the normal cleanup, but *not* close result relations (which we are
 * just sharing from the outer query).  We do, however, have to close any
 * trigger target relations that got opened, since those are not shared.
 * (There probably shouldn't be any of the latter, but just in case...)
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualEnd</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>estate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* idle, so nothing to do */</comment>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_subplanstates</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name> <init>= <expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* throw away the per-estate tuple table */</comment>
	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* close any trigger target relations attached to this EState */</comment>
	<expr_stmt><expr><call><name>ExecCleanUpTriggerState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark EPQState idle */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Use the given attribute map to convert an attribute number in the
 * base relation to an attribute number in the other relation.  Forgive
 * out-of-range attributes by mapping them to zero.  Treat null as
 * the identity map.
 */</comment>
<function><type><name>AttrNumber</name></type>
<name>attrMap</name><parameter_list>(<parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>anum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>map</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>anum</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>anum</name> <operator>&amp;&amp;</operator> <name>anum</name> <operator>&lt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>indesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>outdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>anum</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* For attrMapExpr below.
 *
 * Mutate Var nodes in an expression using the given attribute map.
 * Insist the Var nodes have varno == 1 and the that the mapping
 * yields a live attribute number (non-zero).
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>apply_attrmap_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>( <expr><name>node</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr> )</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>anum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* in CHECK constraints */</comment>
		<expr_stmt><expr><name>anum</name> <operator>=</operator> <call><name>attrMap</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>anum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Should never happen, but best caught early. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute map discrepancy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>anum</name> <operator>!=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>anum</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>apply_attrmap_mutator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>map</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Apply attrMap over the Var nodes in an expression. */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>attrMapExpr</name><parameter_list>(<parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>apply_attrmap_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust INSERT/UPDATE/DELETE count for replicated table ON QD
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustReplicatedTableCounts</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>containReplicatedTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name> <init>=  <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check if result_relations contain replicated table*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>containReplicatedTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>containReplicatedTable</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If one is replicated table, error if other tables are not
			 * replicated table.
 			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mix of replicated and non-replicated tables in result_relation is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>containReplicatedTable</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>/</operator> <name>numsegments</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
