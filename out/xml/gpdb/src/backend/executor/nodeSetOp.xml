<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/nodeSetOp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeSetOp.c
 *	  Routines to handle INTERSECT and EXCEPT selection
 *
 * The input of a SetOp node consists of tuples from two relations,
 * which have been combined into one dataset, with a junk attribute added
 * that shows which relation each tuple came from.  In SETOP_SORTED mode,
 * the input has furthermore been sorted according to all the grouping
 * columns (ie, all the non-junk attributes).  The SetOp node scans each
 * group of identical tuples to determine how many came from each input
 * relation.  Then it is a simple matter to emit the output demanded by the
 * SQL spec for INTERSECT, INTERSECT ALL, EXCEPT, or EXCEPT ALL.
 *
 * In SETOP_HASHED mode, the input is delivered in no particular order,
 * except that we know all the tuples from one input relation will come before
 * all the tuples of the other.  The planner guarantees that the first input
 * relation is the left-hand one for EXCEPT, and tries to make the smaller
 * input relation come first for INTERSECT.  We build a hash table in memory
 * with one entry for each group of identical tuples, and count the number of
 * tuples in the group from each relation.  After seeing all the input, we
 * scan the hashtable and generate the correct output using those counts.
 * We can avoid making hashtable entries for any tuples appearing only in the
 * second input relation, since they cannot result in any output.
 *
 * This node type is not used for UNION or UNION ALL, since those can be
 * implemented more cheaply (there's no need for the junk attribute to
 * identify the source relation).
 *
 * Note that SetOp does no qual checking nor projection.  The delivered
 * output tuples are just copies of the first-to-arrive tuple in each
 * input group.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeSetOp.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSetOp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * SetOpStatePerGroupData - per-group working state
 *
 * These values are working state that is initialized at the start of
 * an input tuple group and updated for each input tuple.
 *
 * In SETOP_SORTED mode, we need only one of these structs, and it's kept in
 * the plan state node.  In SETOP_HASHED mode, the hash table contains one
 * of these for each tuple group.
 */</comment>
<typedef>typedef <type><struct>struct <name>SetOpStatePerGroupData</name>
<block>{
	<decl_stmt><decl><type><name>long</name></type>		<name>numLeft</name></decl>;</decl_stmt>		<comment type="block">/* number of left-input dups in group */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>numRight</name></decl>;</decl_stmt>		<comment type="block">/* number of right-input dups in group */</comment>
}</block></struct></type>			<name>SetOpStatePerGroupData</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>setop_retrieve_direct</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setop_fill_hash_table</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>setop_retrieve_hash_table</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Initialize state for a new group of input values.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>initialize_counts</name><parameter_list>(<parameter><decl><type><name>SetOpStatePerGroup</name></type> <name>pergroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>numLeft</name></name> <operator>=</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>numRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Advance the appropriate counter for one input tuple.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>advance_counts</name><parameter_list>(<parameter><decl><type><name>SetOpStatePerGroup</name></type> <name>pergroup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>numRight</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>numLeft</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the "flag" column from an input tuple.
 * This is an integer column with value 0 for left side, 1 for right side.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_tuple_flag</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inputslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOp</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>flag</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>inputslot</name></expr></argument>,
									  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>flagColIdx</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flag</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>flag</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>flag</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the hash table to empty.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_hash_table</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOp</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name> <init>= <expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>SETOP_HASHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <call><name>BuildTupleHashTableExt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
												   <argument><expr><name>desc</name></expr></argument>,
												   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
												   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupColIdx</name></name></expr></argument>,
												   <argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>eqfuncoids</name></name></expr></argument>,
												   <argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>hashfunctions</name></name></expr></argument>,
												   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupCollations</name></name></expr></argument>,
												   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
												   <argument><expr><literal type="number">0</literal></expr></argument>,
												   <argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
												   <argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>tableContext</name></name></expr></argument>,
												   <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * We've completed processing a tuple group.  Decide how many copies (if any)
 * of its representative row to emit, and store the count into numOutput.
 * This logic is straight from the SQL92 specification.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_output_count</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl></parameter>, <parameter><decl><type><name>SetOpStatePerGroup</name></type> <name>pergroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOp</name>	   <modifier>*</modifier></type><name>plannode</name> <init>= <expr><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>plannode</name><operator>-&gt;</operator><name>cmd</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SETOPCMD_INTERSECT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pergroup</name><operator>-&gt;</operator><name>numLeft</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>numRight</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SETOPCMD_INTERSECT_ALL</name></expr>:</case>
			<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>=</operator>
				<ternary><condition><expr><operator>(</operator><name><name>pergroup</name><operator>-&gt;</operator><name>numLeft</name></name> <operator>&lt;</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>numRight</name></name><operator>)</operator></expr> ?</condition><then>
				<expr><name><name>pergroup</name><operator>-&gt;</operator><name>numLeft</name></name></expr> </then><else>: <expr><name><name>pergroup</name><operator>-&gt;</operator><name>numRight</name></name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SETOPCMD_EXCEPT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pergroup</name><operator>-&gt;</operator><name>numLeft</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>numRight</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SETOPCMD_EXCEPT_ALL</name></expr>:</case>
			<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>=</operator>
				<ternary><condition><expr><operator>(</operator><name><name>pergroup</name><operator>-&gt;</operator><name>numLeft</name></name> <operator>&lt;</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>numRight</name></name><operator>)</operator></expr> ?</condition><then>
				<expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name><name>pergroup</name><operator>-&gt;</operator><name>numLeft</name></name> <operator>-</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>numRight</name></name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized set op: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>plannode</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecSetOp
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>			<comment type="block">/* return: a tuple or NULL */</comment>
<name>ExecSetOp</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SetOpState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOp</name>	   <modifier>*</modifier></type><name>plannode</name> <init>= <expr><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultTupleSlot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the previously-returned tuple needs to be returned more than once,
	 * keep returning it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numOutput</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>resultTupleSlot</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Otherwise, we're done if we are out of groups */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>setop_done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch the next tuple group according to the correct strategy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plannode</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>SETOP_HASHED</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>table_filled</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>setop_fill_hash_table</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name>setop_retrieve_hash_table</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>setop_retrieve_direct</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSetOp for non-hashed case
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>setop_retrieve_direct</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOpStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultTupleSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * get state info from node
	 */</comment>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pergroup</name> <operator>=</operator> <operator>(</operator><name>SetOpStatePerGroup</name><operator>)</operator> <name><name>setopstate</name><operator>-&gt;</operator><name>pergroup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultTupleSlot</name> <operator>=</operator> <name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We loop retrieving groups until we find one we should return
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><name><name>setopstate</name><operator>-&gt;</operator><name>setop_done</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we don't already have the first tuple of the new group, fetch it
		 * from the outer plan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>setopstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Make a copy of the first input tuple */</comment>
				<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* outer plan produced no tuples at all */</comment>
				<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>setop_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Store the copied first input tuple in the tuple table slot reserved
		 * for it.  The tuple will be deleted when it is cleared from the
		 * slot.
		 */</comment>
		<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name></expr></argument>,
						   <argument><expr><name>resultTupleSlot</name></expr></argument>,
						   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* don't keep two pointers */</comment>

		<comment type="block">/* Initialize working state for a new input tuple group */</comment>
		<expr_stmt><expr><call><name>initialize_counts</name><argument_list>(<argument><expr><name>pergroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Count the first input tuple */</comment>
		<expr_stmt><expr><call><name>advance_counts</name><argument_list>(<argument><expr><name>pergroup</name></expr></argument>,
					   <argument><expr><call><name>fetch_tuple_flag</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>, <argument><expr><name>resultTupleSlot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan the outer plan until we exhaust it or cross a group boundary.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no more outer-plan tuples available */</comment>
				<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>setop_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check whether we've crossed a group boundary.
			 */</comment>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>resultTupleSlot</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>outerslot</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQualAndReset</name><argument_list>(<argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>eqfunction</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Save the first input tuple of the next group.
				 */</comment>
				<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Still in same group, so count this tuple */</comment>
			<expr_stmt><expr><call><name>advance_counts</name><argument_list>(<argument><expr><name>pergroup</name></expr></argument>,
						   <argument><expr><call><name>fetch_tuple_flag</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>, <argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Done scanning input tuple group.  See if we should emit any copies
		 * of result tuple, and if so return the first copy.
		 */</comment>
		<expr_stmt><expr><call><name>set_output_count</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>, <argument><expr><name>pergroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name><operator>--</operator></expr>;</expr_stmt>
			<return>return <expr><name>resultTupleSlot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* No more groups */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>resultTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSetOp for hashed case: phase 1, read input and build hash table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setop_fill_hash_table</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOp</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstFlag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>		<name>in_first_rel</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * get state info from node
	 */</comment>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstFlag</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>firstFlag</name></name></expr>;</expr_stmt>
	<comment type="block">/* verify planner didn't mess up */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>firstFlag</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		   <operator>(</operator><name>firstFlag</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>cmd</name></name> <operator>==</operator> <name>SETOPCMD_INTERSECT</name> <operator>||</operator>
			 <name><name>node</name><operator>-&gt;</operator><name>cmd</name></name> <operator>==</operator> <name>SETOPCMD_INTERSECT_ALL</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process each outer-plan tuple, and then fetch the next one, until we
	 * exhaust the outer plan.
	 */</comment>
	<expr_stmt><expr><name>in_first_rel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleHashEntryData</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnew</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Identify whether it's left or right input */</comment>
		<expr_stmt><expr><name>flag</name> <operator>=</operator> <call><name>fetch_tuple_flag</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>, <argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>==</operator> <name>firstFlag</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* (still) in first input relation */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>in_first_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Find or build hashtable entry for this tuple's group */</comment>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>LookupTupleHashEntry</name><argument_list>(<argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><name>outerslot</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If new tuple group, initialize counts */</comment>
			<if_stmt><if>if <condition>(<expr><name>isnew</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name> <operator>=</operator> <operator>(</operator><name>SetOpStatePerGroup</name><operator>)</operator>
					<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>tablecxt</name></name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SetOpStatePerGroupData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>initialize_counts</name><argument_list>(<argument><expr><operator>(</operator><name>SetOpStatePerGroup</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Advance the counts */</comment>
			<expr_stmt><expr><call><name>advance_counts</name><argument_list>(<argument><expr><operator>(</operator><name>SetOpStatePerGroup</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* reached second relation */</comment>
			<expr_stmt><expr><name>in_first_rel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* For tuples not seen previously, do not make hashtable entry */</comment>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>LookupTupleHashEntry</name><argument_list>(<argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><name>outerslot</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Advance the counts if entry is already present */</comment>
			<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>advance_counts</name><argument_list>(<argument><expr><operator>(</operator><name>SetOpStatePerGroup</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Must reset expression context after each hashtable lookup */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* Initialize to walk the hash table */</comment>
	<expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>setopstate</name><operator>-&gt;</operator><name>hashiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSetOp for hashed case: phase 2, retrieving groups from hash table
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>setop_retrieve_hash_table</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleHashEntryData</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultTupleSlot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get state info from node
	 */</comment>
	<expr_stmt><expr><name>resultTupleSlot</name> <operator>=</operator> <name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We loop retrieving groups until we find one we should return
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><name><name>setopstate</name><operator>-&gt;</operator><name>setop_done</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find the next entry in the hash table
		 */</comment>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>ScanTupleHashTable</name><argument_list>(<argument><expr><name><name>setopstate</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>setopstate</name><operator>-&gt;</operator><name>hashiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No more entries in hashtable, so done */</comment>
			<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>setop_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * See if we should emit any copies of this tuple, and if so return
		 * the first copy.
		 */</comment>
		<expr_stmt><expr><call><name>set_output_count</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>, <argument><expr><operator>(</operator><name>SetOpStatePerGroup</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name><operator>--</operator></expr>;</expr_stmt>
			<return>return <expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name></name></expr></argument>,
										 <argument><expr><name>resultTupleSlot</name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* No more groups */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>resultTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitSetOp
 *
 *		This initializes the setop node state structures and
 *		the node's subplan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>SetOpState</name> <modifier>*</modifier></type>
<name>ExecInitSetOp</name><parameter_list>(<parameter><decl><type><name>SetOp</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>setopstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>outerDesc</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>setopstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SetOpState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecSetOp</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>eqfuncoids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>hashfunctions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>setop_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>pergroup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>tableContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * create expression context
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If hashing, we also need a longer-lived context to store the hash
	 * table.  The table can't just be kept in the per-query context because
	 * we want to be able to throw it away in ExecReScanSetOp.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>SETOP_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>tableContext</name></name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"SetOp hash table"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * initialize child nodes
	 *
	 * If we are hashing then the child plan does not need to handle REWIND
	 * efficiently; see ExecReScanSetOp.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>SETOP_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>&amp;=</operator> <operator>~</operator><name>EXEC_FLAG_REWIND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize result slot and type. Setop nodes do no projections, so
	 * initialize projection info for this node appropriately.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
							  <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>SETOP_HASHED</name></expr> ?</condition><then>
							  <expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr> </then><else>: <expr><operator>&amp;</operator><name>TTSOpsHeapTuple</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Precompute fmgr lookup data for inner loop. We need both equality and
	 * hashing functions to do it by hashing, but only equality if not
	 * hashing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>SETOP_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>execTuplesHashPrepare</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
							  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupOperators</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>setopstate</name><operator>-&gt;</operator><name>eqfuncoids</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>setopstate</name><operator>-&gt;</operator><name>hashfunctions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>eqfunction</name></name> <operator>=</operator>
			<call><name>execTuplesMatchPrepare</name><argument_list>(<argument><expr><name>outerDesc</name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupColIdx</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupOperators</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupCollations</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>setopstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>SETOP_HASHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>build_hash_table</name><argument_list>(<argument><expr><name>setopstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>setopstate</name><operator>-&gt;</operator><name>pergroup</name></name> <operator>=</operator>
			<operator>(</operator><name>SetOpStatePerGroup</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SetOpStatePerGroupData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>setopstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndSetOp
 *
 *		This shuts down the subplan and frees resources allocated
 *		to this node.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndSetOp</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* clean up tuple table */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free subsidiary stuff including hashtable */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tableContext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tableContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ExecReScanSetOp</name><parameter_list>(<parameter><decl><type><name>SetOpState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>setop_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numOutput</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>strategy</name> <operator>==</operator> <name>SETOP_HASHED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In the hashed case, if we haven't yet built the hash table then we
		 * can just return; nothing done yet, so nothing to undo. If subnode's
		 * chgParam is not NULL then it will be re-scanned by ExecProcNode,
		 * else no reason to re-scan it at all.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>table_filled</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we do have the hash table and the subplan does not have any
		 * parameter changes, then we can just rescan the existing hash table;
		 * no need to build it again.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>hashiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release first tuple of group, if we have made a copy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>grp_firstTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release any hashtable storage */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tableContext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tableContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And rebuild empty hashtable if needed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>strategy</name> <operator>==</operator> <name>SETOP_HASHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetTupleHashTable</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if chgParam of subnode is not null then plan will be re-scanned by
	 * first ExecProcNode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
