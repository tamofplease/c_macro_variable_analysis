<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/execCurrent.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execCurrent.c
 *	  executor support for WHERE CURRENT OF cursor
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *	src/backend/executor/execCurrent.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>fetch_cursor_param_value</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>paramId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ScanState</name> <modifier>*</modifier></type><name>search_plan_tree</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>pending_rescan</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * execCurrentOf
 *
 * Given a CURRENT OF expression and the OID of a table, determine which row
 * of the table is currently being scanned by the cursor named by CURRENT OF,
 * and return the row's TID into *current_tid.
 *
 * Returns true if a row was identified.  Returns false if the cursor is valid
 * for the table but is not currently scanning a row of the table (this is a
 * legal situation in inheritance cases).  Raises error if cursor is not a
 * valid updatable scan of the specified table.
 *
 * In GPDB, we also check that the tuple came from the current segment.
 */</comment>
<function><type><name>bool</name></type>
<name>execCurrentOf</name><parameter_list>(<parameter><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl></parameter>,
			  <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
			  <parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>,
			  <parameter><decl><type><name>ItemPointer</name></type> <name>current_tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>current_gp_segment_id</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>current_table_oid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In an executor node, the dispatcher should've included the current
	 * position of the cursor along with the query plan. Find and return it
	 * from there.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cursor_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Get the cursor name --- may have to look up a parameter reference */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cursor_name</name> <operator>=</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>cursor_name</name> <operator>=</operator> <call><name>fetch_cursor_param_value</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>econtext-&gt;ecxt_estate-&gt;es_cursorPositions</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CursorPosInfo</name> <modifier>*</modifier></type><name>cpos</name> <init>= <expr><operator>(</operator><name>CursorPosInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cpos</name><operator>-&gt;</operator><name>cursor_name</name></name></expr></argument>, <argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>current_gp_segment_id</name> <operator>=</operator> <name><name>cpos</name><operator>-&gt;</operator><name>gp_segment_id</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>current_table_oid</name> <operator>=</operator> <name><name>cpos</name><operator>-&gt;</operator><name>table_oid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpos</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>, <argument><expr><name>current_tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Not found. Odd, the dispatcher should've checked for this already. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no cursor position information found for cursor \"%s\""</literal></expr></argument>,
				 <argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>getCurrentOf</name><argument_list>(<argument><expr><name>cexpr</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>current_tid</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>current_gp_segment_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_table_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Found the cursor. Does the table and segment match?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>current_gp_segment_id</name> <operator>==</operator> <name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>current_table_oid</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name>current_table_oid</name> <operator>==</operator> <name>table_oid</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the current position of a cursor that a CURRENT OF expression
 * refers to.
 *
 * This checks that the cursor is valid for table specified by 'table_oid',
 * but it doesn't have to be scanning a row of that table (i.e. it can
 * be scanning a row of a different table in the same inheritance hierarchy).
 * The current table's oid is returned in *current_table_oid.
 *
 * GPDB calls it before dispatching to make QEs get the same current position
 * of the cursor.
 */</comment>
<function><type><name>void</name></type>
<name>getCurrentOf</name><parameter_list>(<parameter><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl></parameter>,
			 <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>,
			 <parameter><decl><type><name>ItemPointer</name></type> <name>current_tid</name></decl></parameter>,
			 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>current_gp_segment_id</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>current_table_oid</name></decl></parameter>,
			 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_cursor_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cursor_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>table_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>gp_segment_id_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>ctid_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>tableoid_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In an executor node, execCurrentOf() is supposed to use the cursor
	 * position information received from the dispatcher, and we shouldn't
	 * get here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"getCurrentOf called in executor node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the cursor name --- may have to look up a parameter reference */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cursor_name</name> <operator>=</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no cursor name information found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cursor_name</name> <operator>=</operator> <call><name>fetch_cursor_param_value</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Fetch table name for possible use in error messages */</comment>
	<expr_stmt><expr><name>table_name</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>table_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Find the cursor's portal */</comment>
	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We have to watch out for non-SELECT queries as well as held cursors,
	 * both of which may have null queryDesc.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PORTAL_ONE_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" is not a SELECT query"</literal></expr></argument>,
						<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>queryDesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" is held from a previous transaction"</literal></expr></argument>,
						<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The referenced cursor must be simply updatable. This has already
	 * been discerned by parse/analyze for the DECLARE CURSOR of the given
	 * cursor. This flag assures us that gp_segment_id, ctid, and tableoid (if necessary)
	 * will be available as junk metadata, courtesy of preprocess_targetlist.
	 *
	 * Apply simply updatable check to ordinary tables. Refer to the issue:
	 * https://github.com/greenplum-db/gpdb/issues/9838.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>simplyUpdatableRel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" is not a simply updatable scan of table \"%s\""</literal></expr></argument>,
								<argument><expr><name>cursor_name</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * gpdb partition table routine is different with upstream
	 * so we hold private updatable check method.
	 */</comment>
	<comment type="block">/* better hold a lock already since we're scanning it */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>relispartition</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		<name>relispartition</name> <operator>||</operator>
		<call><name>get_rel_persistence</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The target relation must directly match the cursor's relation. This throws out
		 * the simple case in which a cursor is declared against table X and the update is
		 * issued against Y. Moreover, this disallows some subtler inheritance cases where
		 * Y inherits from X. While such cases could be implemented, it seems wiser to
		 * simply error out cleanly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>table_oid</name> <operator>!=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>simplyUpdatableRel</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" is not a simply updatable scan of table \"%s\""</literal></expr></argument>,
					               <argument><expr><name>cursor_name</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanState</name>  <modifier>*</modifier></type><name>scanstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>pending_rescan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Without FOR UPDATE, we dig through the cursor's plan to find the
		 * scan node.  Fail if it's not there or buried underneath
		 * aggregation.
		 */</comment>
		<expr_stmt><expr><name>scanstate</name> <operator>=</operator> <call><name>search_plan_tree</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name>table_oid</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>pending_rescan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scanstate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" is not a simply updatable scan of table \"%s\""</literal></expr></argument>,
					               <argument><expr><name>cursor_name</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The cursor must have a current result row: per the SQL spec, it's an
	 * error if not.  We test this at the top level, rather than at the scan
	 * node level, because in inheritance cases any one table scan could
	 * easily not be on a row.	We want to return false, not raise error, if
	 * the passed-in table OID is for one of the inactive scans.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>||</operator> <name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" is not positioned on a row"</literal></expr></argument>,
						<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We have two different strategies depending on whether the cursor uses
	 * FOR UPDATE/SHARE or not.  The reason for supporting both is that the
	 * FOR UPDATE code is able to identify a target table in many cases where
	 * the other code can't, while the non-FOR-UPDATE case allows use of WHERE
	 * CURRENT OF with an insensitive cursor.
	 *
	 * GPDB: Neither of those methods work in GPDB, however, because the scan
	 * is most likely below a Motion node, and belongs to a different slice
	 * than the top node. The slot of the scan node is empty, and the tuple
	 * has been received by a Motion node higher up in the tree instead. So
	 * we use a different approach.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	if (queryDesc-&gt;estate-&gt;es_rowmarks)
	{
		ExecRowMark *erm;
		Index		i;

		<comment type="block">/*
		 * Here, the query must have exactly one FOR UPDATE/SHARE reference to
		 * the target table, and we dig the ctid info out of that.
		 */</comment>
		erm = NULL;
		for (i = 0; i &lt; queryDesc-&gt;estate-&gt;es_range_table_size; i++)
		{
			ExecRowMark *thiserm = queryDesc-&gt;estate-&gt;es_rowmarks[i];

			if (thiserm == NULL ||
				!RowMarkRequiresRowShareLock(thiserm-&gt;markType))
				continue;		<comment type="block">/* ignore non-FOR UPDATE/SHARE items */</comment>

			if (thiserm-&gt;relid == table_oid)
			{
				if (erm)
					ereport(ERROR,
							(errcode(ERRCODE_INVALID_CURSOR_STATE),
							 errmsg("cursor \"%s\" has multiple FOR UPDATE/SHARE references to table \"%s\"",
									cursor_name, table_name)));
				erm = thiserm;
			}
		}

		if (erm == NULL)
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_CURSOR_STATE),
					 errmsg("cursor \"%s\" does not have a FOR UPDATE/SHARE reference to table \"%s\"",
							cursor_name, table_name)));

		<comment type="block">/*
		 * The cursor must have a current result row: per the SQL spec, it's
		 * an error if not.
		 */</comment>
		if (portal-&gt;atStart || portal-&gt;atEnd)
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_CURSOR_STATE),
					 errmsg("cursor \"%s\" is not positioned on a row",
							cursor_name)));

		<comment type="block">/* Return the currently scanned TID, if there is one */</comment>
		if (ItemPointerIsValid(&amp;(erm-&gt;curCtid)))
		{
			*current_tid = erm-&gt;curCtid;
			return true;
		}

		<comment type="block">/*
		 * This table didn't produce the cursor's current row; some other
		 * inheritance child of the same parent must have.  Signal caller to
		 * do nothing on this table.
		 */</comment>
		return false;
	}
	else
	{
		<comment type="block">/*
		 * Without FOR UPDATE, we dig through the cursor's plan to find the
		 * scan node.  Fail if it's not there or buried underneath
		 * aggregation.
		 */</comment>
		ScanState  *scanstate;
		bool		pending_rescan = false;

		scanstate = search_plan_tree(queryDesc-&gt;planstate, table_oid,
									 &amp;pending_rescan);
		if (!scanstate)
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_CURSOR_STATE),
					 errmsg("cursor \"%s\" is not a simply updatable scan of table \"%s\"",
							cursor_name, table_name)));

		<comment type="block">/*
		 * The cursor must have a current result row: per the SQL spec, it's
		 * an error if not.  We test this at the top level, rather than at the
		 * scan node level, because in inheritance cases any one table scan
		 * could easily not be on a row. We want to return false, not raise
		 * error, if the passed-in table OID is for one of the inactive scans.
		 */</comment>
		if (portal-&gt;atStart || portal-&gt;atEnd)
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_CURSOR_STATE),
					 errmsg("cursor \"%s\" is not positioned on a row",
							cursor_name)));

		<comment type="block">/*
		 * Now OK to return false if we found an inactive scan.  It is
		 * inactive either if it's not positioned on a row, or there's a
		 * rescan pending for it.
		 */</comment>
		if (TupIsNull(scanstate-&gt;ss_ScanTupleSlot) || pending_rescan)
			return false;

		<comment type="block">/*
		 * Extract TID of the scan's current row.  The mechanism for this is
		 * in principle scan-type-dependent, but for most scan types, we can
		 * just dig the TID out of the physical scan tuple.
		 */</comment>
		if (IsA(scanstate, IndexOnlyScanState))
		{
			<comment type="block">/*
			 * For IndexOnlyScan, the tuple stored in ss_ScanTupleSlot may be
			 * a virtual tuple that does not have the ctid column, so we have
			 * to get the TID from xs_ctup.t_self.
			 */</comment>
			IndexScanDesc scan = ((IndexOnlyScanState *) scanstate)-&gt;ioss_ScanDesc;

			*current_tid = scan-&gt;xs_heaptid;
		}
		else
		{
			<comment type="block">/*
			 * Default case: try to fetch TID from the scan node's current
			 * tuple.  As an extra cross-check, verify tableoid in the current
			 * tuple.  If the scan hasn't provided a physical tuple, we have
			 * to fail.
			 */</comment>
			Datum		ldatum;
			bool		lisnull;
			ItemPointer tuple_tid;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
			ldatum = slot_getsysattr(scanstate-&gt;ss_ScanTupleSlot,
									 TableOidAttributeNumber,
									 &amp;lisnull);
			if (lisnull)
				ereport(ERROR,
						(errcode(ERRCODE_INVALID_CURSOR_STATE),
						 errmsg("cursor \"%s\" is not a simply updatable scan of table \"%s\"",
								cursor_name, table_name)));
			Assert(DatumGetObjectId(ldatum) == table_oid);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			ldatum = slot_getsysattr(scanstate-&gt;ss_ScanTupleSlot,
									 SelfItemPointerAttributeNumber,
									 &amp;lisnull);
			if (lisnull)
				ereport(ERROR,
						(errcode(ERRCODE_INVALID_CURSOR_STATE),
						 errmsg("cursor \"%s\" is not a simply updatable scan of table \"%s\"",
								cursor_name, table_name)));
			tuple_tid = (ItemPointer) DatumGetPointer(ldatum);

			*current_tid = *tuple_tid;
		}

		Assert(ItemPointerIsValid(current_tid));

		return true;
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<comment type="block">/*
		 * GPDB method:
		 *
		 * The planner should've made the gp_segment_id, ctid, and tableoid
		 * available as junk columns at the top of the plan. To retrieve this
		 * junk metadata, we leverage the EState's junkfilter against the raw
		 * tuple yielded by the top node in the plan.
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"TupleTableslot is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* extract gp_segment_id metadata */</comment>
		<expr_stmt><expr><name>gp_segment_id_attno</name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name></expr></argument>, <argument><expr><literal type="string">"gp_segment_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>gp_segment_id_attno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk gp_segment_id column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>gp_segment_id_attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"gp_segment_id is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>current_gp_segment_id</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* extract ctid metadata */</comment>
		<expr_stmt><expr><name>ctid_attno</name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>ctid_attno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk ctid column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>ctid_attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ctid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><call><name>DatumGetItemPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>current_tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * extract tableoid metadata
		 *
		 * DECLARE CURSOR planning only includes tableoid metadata when
		 * scrolling a partitioned table. Otherwise gp_segment_id and ctid alone
		 * are sufficient to uniquely identify a tuple.
		 */</comment>
		<expr_stmt><expr><name>tableoid_attno</name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name></expr></argument>,
											   <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>tableoid_attno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tableoid_attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tableoid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>current_table_oid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * This is our last opportunity to verify that the physical table given
			 * by tableoid is, indeed, simply updatable.
			 */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>isSimplyUpdatableRelation</name><argument_list>(<argument><expr><operator>*</operator><name>current_table_oid</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* noerror */</comment>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>p_cursor_name</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>p_cursor_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * fetch_cursor_param_value
 *
 * Fetch the string value of a param, verifying it is of type REFCURSOR.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>fetch_cursor_param_value</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>paramId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramInfo</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>paramInfo</name> <operator>&amp;&amp;</operator>
		<name>paramId</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>paramId</name> <operator>&lt;=</operator> <name><name>paramInfo</name><operator>-&gt;</operator><name>numParams</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExternData</name></type> <name>prmdata</name></decl>;</decl_stmt>

		<comment type="block">/* give hook a chance in case parameter is dynamic */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>paramInfo</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name><name>paramInfo</name><operator>-&gt;</operator><name>paramFetch</name></name><argument_list>(<argument><expr><name>paramInfo</name></expr></argument>, <argument><expr><name>paramId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prmdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><name><name>paramInfo</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* safety check in case hook did something unexpected */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name>REFCURSOROID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type of parameter %d (%s) does not match that when preparing the plan (%s)"</literal></expr></argument>,
								<argument><expr><name>paramId</name></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>REFCURSOROID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* We know that refcursor uses text's I/O routines */</comment>
			<return>return <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no value found for parameter %d"</literal></expr></argument>, <argument><expr><name>paramId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * search_plan_tree
 *
 * Search through a PlanState tree for a scan node on the specified table.
 * Return NULL if not found or multiple candidates.
 *
 * If a candidate is found, set *pending_rescan to true if that candidate
 * or any node above it has a pending rescan action, i.e. chgParam != NULL.
 * That indicates that we shouldn't consider the node to be positioned on a
 * valid tuple, even if its own state would indicate that it is.  (Caller
 * must initialize *pending_rescan to false, and should not trust its state
 * if multiple candidates are found.)
 */</comment>
<function><type><specifier>static</specifier> <name>ScanState</name> <modifier>*</modifier></type>
<name>search_plan_tree</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>pending_rescan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanState</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Relation scan nodes can all be treated alike
		 */</comment>
		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
		<case>case <expr><name>T_SampleScanState</name></expr>:</case>
		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
		<case>case <expr><name>T_TidScanState</name></expr>:</case>
		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScanState</name>  <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>(</operator><name>ScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>sstate</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>table_oid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>sstate</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/*
			 * For Append, we must look through the members; watch out for
			 * multiple matches (possible if it was from UNION ALL)
			 */</comment>
		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>astate</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ScanState</name>  <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>search_plan_tree</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
														<argument><expr><name>table_oid</name></expr></argument>,
														<argument><expr><name>pending_rescan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>elem</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* multiple matches */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>
				</block_content>}</block></for>
				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/*
			 * Similarly for MergeAppend
			 */</comment>
		<case>case <expr><name>T_MergeAppendState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>mstate</name> <init>= <expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mstate</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ScanState</name>  <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>search_plan_tree</name><argument_list>(<argument><expr><name><name>mstate</name><operator>-&gt;</operator><name>mergeplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
														<argument><expr><name>table_oid</name></expr></argument>,
														<argument><expr><name>pending_rescan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>elem</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* multiple matches */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>
				</block_content>}</block></for>
				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/*
			 * Result and Limit can be descended through (these are safe
			 * because they always return their input's current row)
			 */</comment>
		<case>case <expr><name>T_ResultState</name></expr>:</case>
		<case>case <expr><name>T_LimitState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>search_plan_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>,
									  <argument><expr><name>table_oid</name></expr></argument>,
									  <argument><expr><name>pending_rescan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * SubqueryScan too, but it keeps the child in a different place
			 */</comment>
		<case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>search_plan_tree</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>,
									  <argument><expr><name>table_oid</name></expr></argument>,
									  <argument><expr><name>pending_rescan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MotionState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>search_plan_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>pending_rescan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* Otherwise, assume we can't descend through it */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If we found a candidate at or below this node, then this node's
	 * chgParam indicates a pending rescan that will affect the candidate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>pending_rescan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
