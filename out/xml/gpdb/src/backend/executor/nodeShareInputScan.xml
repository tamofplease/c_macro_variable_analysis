<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/nodeShareInputScan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeShareInputScan.c
 *
 * A Share Input Scan node is used to share the result of an operation in
 * two different branches in the plan tree.
 *
 * These come in two variants: local, and cross-slice.
 *
 * Local shares
 * ------------
 *
 * In local mode, all the consumers are in the same slice as the producer.
 * In that case, there's no need to communicate across processes, so we
 * rely entirely on data structures in backend-private memory to track the
 * state.
 *
 * In local mode, there is no difference between producer and consumer
 * nodes. In ExecInitShareInputScan(), the producer node stores the
 * PlanState of the shared child node where all the nodes can find it.
 * The first ExecShareInputScan() call initializes the store.
 *
 * A local-mode ShareInputScan is quite similar to PostgreSQL's CteScan,
 * but there are some implementation differences. CteScan uses a special
 * PARAM_EXEC entry to hold the shared state, while ShareInputScan uses
 * an entry in es_sharenode instead.
 *
 * Cross-slice shares
 * ------------------
 *
 * A cross-slice share works basically the same as a local one, except
 * that the producing slice makes the underlying tuplestore available to
 * other processes, by forcing it to be written to a file on disk. The
 * first ExecShareInputScan() call in the producing slice materializes
 * the whole tuplestore, and advertises that it's ready in shared memory.
 * Consumer slices wait for that before trying to read the store.
 *
 * The producer and the consumers communicate the status of the scan using
 * shared memory. There's a hash table in shared memory, containing a
 * 'shareinput_Xslice_state' struct for each shared scan. The producer uses
 * a condition variable to wake up consumers, when the tuplestore is fully
 * materialized, and the consumers use the same condition variable to inform
 * the producer when they're done reading it. The producer slice keeps the
 * underlying tuplestore open, until all the consumers have finished.
 *
 *
 * Portions Copyright (c) 2007-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	    src/backend/executor/nodeShareInputScan.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeShareInputScan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/condition_variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>

<comment type="block">/*
 * In a cross-slice ShareinputScan, the producer and consumer processes
 * communicate using shared memory. There's a hash table containing one
 * 'shareinput_share_state' for each in-progress shared input scan.
 *
 * The hash table itself,, and the fields within every entry, are protected
 * by ShareInputScanLock. (Although some operations get away without the
 * lock, when the field is atomic and/or there's only one possible writer.)
 *
 * All producers and consumers that participate in a shared scan hold
 * a reference to the 'shareinput_Xslice_state' entry of the scan, for
 * the whole lifecycle of the node from ExecInitShareInputScan() to
 * ExecEndShareInputScan() (although it can be released early by
 * ExecSquelchShareInputScan(). The entry in the hash table is created by
 * the first participant that initializes, which is not necessarily the
 * producer! When the last participant releases the entry, it is removed
 * from the hash table.
 */</comment>
<typedef>typedef <type><struct>struct <name>shareinput_tag</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type>		<name>session_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>command_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>share_id</name></decl>;</decl_stmt>
}</block></struct></type> <name>shareinput_tag</name>;</typedef>

<typedef>typedef <type><struct>struct <name>shareinput_Xslice_state</name>
<block>{
	<decl_stmt><decl><type><name>shareinput_tag</name></type> <name>tag</name></decl>;</decl_stmt>			<comment type="block">/* hash key */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>refcount</name></decl>;</decl_stmt>		<comment type="block">/* reference count of this entry */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type>	<name>ready</name></decl>;</decl_stmt>	<comment type="block">/* is the input fully materialized and ready to be read? */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type>	<name>ndone</name></decl>;</decl_stmt>	<comment type="block">/* # of consumers that have finished the scan */</comment>

	<comment type="block">/*
	 * ready_done_cv is used for signaling when the scan becomes "ready", and
	 * when it becomes "done". The producer wakes up everyone waiting on this
	 * condition variable when it sets ready = true. Also, when the last
	 * consumer finishes the scan (ndone reaches nconsumers), it wakes up the
	 * producer using this same condition variable.
	 */</comment>
	<decl_stmt><decl><type><name>ConditionVariable</name></type> <name>ready_done_cv</name></decl>;</decl_stmt>

}</block></struct></type> <name>shareinput_Xslice_state</name>;</typedef>

<comment type="block">/* shared memory hash table holding 'shareinput_Xslice_state' entries */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>shareinput_Xslice_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * The tuplestore files for all share input scans are held in one SharedFileSet.
 * The SharedFileSet is attached to a single DSM segment that persists until
 * postmaster shutdown. When the reference count of the SharedFileSet reaches
 * zero, the SharedFileSet is automatically destroyed, but it is re-initialized
 * the next time it's needed.
 *
 * The SharedFileSet deletes any remaining files when the reference count
 * reaches zero, but we don't rely on that mechanism. All the files are
 * held in the same SharedFileSet, so it cannot be recycled until all
 * ShareInputScans in the system have finished, which might never happen if
 * new queries are started continuously. The shareinput_Xslice_state entries
 * are reference counted separately, and we clean up the files backing each
 * individual ShareInputScan whenever its reference count reaches zero.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>dsm_handle</name> <modifier>*</modifier></type><name>shareinput_Xslice_dsm_handle_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedFileSet</name> <modifier>*</modifier></type><name>shareinput_Xslice_fileset</name></decl>;</decl_stmt>

<comment type="block">/*
 * 'shareinput_reference' represents a reference or "lease" to an entry
 * in the shared memory hash table. It is used for garbage collection of
 * the entries, on transaction abort.
 *
 * These are allocated in TopMemoryContext, and held in the
 * 'shareinput_Xslice_refs' list.
 */</comment>
<typedef>typedef <type><struct>struct <name>shareinput_Xslice_reference</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>share_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shareinput_Xslice_state</name> <modifier>*</modifier></type><name>xslice_state</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>node</name></decl>;</decl_stmt>
}</block></struct></type> <name>shareinput_Xslice_reference</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>shareinput_Xslice_refs</name> <init>= <expr><call><name>DLIST_STATIC_INIT</name><argument_list>(<argument><expr><name>shareinput_Xslice_refs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>shareinput_resowner_callback_registered</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * For local (i.e. intra-slice) variants, we use a 'shareinput_local_state'
 * to track the status. It is analogous to 'shareinput_share_state' used for
 * cross-slice scans, but we don't need to keep it in shared memory. These
 * are held in estate-&gt;es_sharenode, indexed by share_id.
 */</comment>
<typedef>typedef <type><struct>struct <name>shareinput_local_state</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>ready</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>closed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nsharers</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This points to the child node that's being shared. Set by
	 * ExecInitShareInputScan() of the instance that has the child.
	 */</comment>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>childState</name></decl>;</decl_stmt>

	<comment type="block">/* Tuplestore that holds the result */</comment>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>ts_state</name></decl>;</decl_stmt>
}</block></struct></type> <name>shareinput_local_state</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>get_shareinput_reference</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>share_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>release_shareinput_reference</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shareinput_release_callback</name><parameter_list>(<parameter><decl><type><name>ResourceReleasePhase</name></type> <name>phase</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
										<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shareinput_writer_notifyready</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shareinput_reader_waitready</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shareinput_reader_notifydone</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nconsumers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shareinput_writer_waitdone</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nconsumers</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecShareInputScanExplainEnd</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>StringInfoData</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * init_tuplestore_state
 *    Initialize the tuplestore state for the Shared node if the state
 *    is not initialized.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_tuplestore_state</name><parameter_list>(<parameter><decl><type><name>ShareInputScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shareinput_local_state</name> <modifier>*</modifier></type><name>local_state</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>local_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tsptrno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>isready</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ts_pos</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot execute ShareInputScan that was not initialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>local_state</name><operator>-&gt;</operator><name>ready</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>currentSliceId</name> <operator>==</operator> <name><name>sisc</name><operator>-&gt;</operator><name>producer_slice_id</name></name> <operator>||</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We are the producer */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>rwfile_prefix</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SISC writer (shareid=%d, slice=%d): No tuplestore yet, creating tuplestore"</literal></expr></argument>,
					 <argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <comment type="block">/* randomAccess */</comment>
										   <argument><expr><name>false</name></expr></argument>, <comment type="block">/* interXact */</comment>
										   <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* maxKBytes FIXME */</comment>

				<expr_stmt><expr><call><name>shareinput_create_bufname_prefix</name><argument_list>(<argument><expr><name>rwfile_prefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rwfile_prefix</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuplestore_make_shared</name><argument_list>(<argument><expr><name>ts</name></expr></argument>,
									   <argument><expr><call><name>get_shareinput_fileset</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><name>rwfile_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"sisc_xslice_temp_files"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>tuplestore_get_buffilename</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sisc_xslice: buffilename is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"base/"</literal> <name>PG_TEMP_FILES_DIR</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>filename</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sisc_xslice: Use default tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>filename</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sisc_xslice: Use temp tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sisc_xslice: Unexpected prefix of the tablespace path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* intra-slice */</comment>
				<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <comment type="block">/* randomAccess */</comment>
										   <argument><expr><name>false</name></expr></argument>, <comment type="block">/* interXact */</comment>
										   <argument><expr><call><name>PlanStateOperatorMemKB</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Offer extra memory usage info for EXPLAIN ANALYZE.
				 *
				 * If this is a cross-slice share, the tuplestore uses very
				 * little memory, because it has to materialize the result on
				 * a file anyway, so that it can be shared across processes.
				 * In that case, reporting memory usage doesn't make much
				 * sense. The "work_mem wanted" value would particularly
				 * non-sensical, as we we would write to a file regardless of
				 * work_mem. So only track memory usage in the non-cross-slice
				 * case.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name><operator>-&gt;</operator><name>need_cdb</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Let the tuplestore share our Instrumentation object. */</comment>
					<expr_stmt><expr><call><name>tuplestore_set_instrument</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Request a callback at end of query. */</comment>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>cdbexplainfun</name></name> <operator>=</operator> <name>ExecShareInputScanExplainEnd</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name><name>local_state</name><operator>-&gt;</operator><name>childState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>tuplestore_freeze</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shareinput_writer_notifyready</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We are a consumer slice. Wait for the producer to create the
			 * tuplestore.
			 */</comment>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>rwfile_prefix</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>shareinput_reader_waitready</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>shareinput_create_bufname_prefix</name><argument_list>(<argument><expr><name>rwfile_prefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rwfile_prefix</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>tuplestore_open_shared</name><argument_list>(<argument><expr><call><name>get_shareinput_fileset</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rwfile_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>ready</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tsptrno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Another local reader */</comment>
		<expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>local_state</name><operator>-&gt;</operator><name>ts_state</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tsptrno</name> <operator>=</operator> <call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_REWIND</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tsptrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ts_pos</name></name> <operator>=</operator> <name>tsptrno</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>isready</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------
 * 	ExecShareInputScan
 * 	Retrieve a tuple from the ShareInputScan
 * ------------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecShareInputScan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShareInputScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ShareInputScanState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>forward</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get state info from node
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dir</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>forward</name> <operator>=</operator> <call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sisc</name><operator>-&gt;</operator><name>this_slice_id</name></name> <operator>!=</operator> <name>currentSliceId</name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot execute alien Share Input Scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if first time call, need to initialize the tuplestore state.  */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>isready</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>init_tuplestore_state</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<comment type="block">/*
	 * Return NULL when necessary.
	 * This could help improve performance, especially when tuplestore is huge, because ShareInputScan 
	 * do not need to read tuple from tuplestore when discard_output is true, which means current 
	 * ShareInputScan is one but not the last one of Sequence's subplans.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sisc</name><operator>-&gt;</operator><name>discard_output</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>local_state</name><operator>-&gt;</operator><name>closed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ts_state</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ts_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>gotOK</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>gotOK</name> <operator>=</operator> <call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ts_state</name></name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gotOK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"execshare_input_next"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>slot</name></expr>;</return>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"should not be here"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*  ------------------------------------------------------------------
 * 	ExecInitShareInputScan
 * ------------------------------------------------------------------
 */</comment>
<function><type><name>ShareInputScanState</name> <modifier>*</modifier></type>
<name>ExecInitShareInputScan</name><parameter_list>(<parameter><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShareInputScanState</name> <modifier>*</modifier></type><name>sisstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>childState</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create state data structure */</comment>
	<expr_stmt><expr><name>sisstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ShareInputScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecShareInputScan</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>ts_pos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * init child node.
	 * if outerPlan is NULL, this is no-op (so that the ShareInput node will be
	 * only init-ed once).
	 */</comment>

	<comment type="block">/*
	 * initialize child nodes
	 *
	 * Like a Material node, we shield the child node from the need to support
	 * BACKWARD, or MARK/RESTORE.
	 */</comment>
	<expr_stmt><expr><name>eflags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>childState</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>sisstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>childState</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Misc initialization 
	 * 
	 * Create expression context 
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sisstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Initialize result slot and type.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sisstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * When doing EXPLAIN only, we won't actually execute anything, so don't
	 * bother initializing the state. This isn't merely an optimization:
	 * closing a cross-slice ShareInputScan waits for the consumers to finish,
	 * but if we don't execute anything, it will hang forever.
	 *
	 * We could also exit here immediately if this is an "alien" node, i.e.
	 * a node that doesn't execute in this slice, but we can't easily
	 * detect that here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>sisstate</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>shareinput_local_state</name> <modifier>*</modifier></type><name>local_state</name></decl>;</decl_stmt>

	<comment type="block">/* expand the list if necessary */</comment>
	<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sharenode</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>share_id</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>local_state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>shareinput_local_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>ready</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sharenode</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sharenode</name></name></expr></argument>, <argument><expr><name>local_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>local_state</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sharenode</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To accumulate the number of CTE consumers executed in this slice.
	 * This variable will be used by the last finishing CTE consumer
	 * in current slice, to wake the corresponding CTE producer up for
	 * cleaning the materialized tuplestore, during squelching.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>currentSliceId</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>this_slice_id</name></name> <operator>&amp;&amp;</operator>
		<name>currentSliceId</name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>producer_slice_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>nsharers</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>childState</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>childState</name></name> <operator>=</operator> <name>childState</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>local_state</name></name> <operator>=</operator> <name>local_state</name></expr>;</expr_stmt>

	<comment type="block">/* Get a lease on the shared state */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>cross_slice</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <call><name>get_shareinput_reference</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sisstate</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>sisstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecShareInputScanExplainEnd
 *      Called before ExecutorEnd to finish EXPLAIN ANALYZE reporting.
 *
 * Some of the cleanup that ordinarily would occur during ExecEndShareInputScan()
 * needs to be done earlier in order to report statistics to EXPLAIN ANALYZE.
 * Note that ExecEndShareInputScan() will still be during ExecutorEnd().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecShareInputScanExplainEnd</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>StringInfoData</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shareinput_local_state</name> <modifier>*</modifier></type><name>local_state</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ShareInputScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>local_state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Release tuplestore resources
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name> <operator>&amp;&amp;</operator> <name>local_state</name> <operator>&amp;&amp;</operator> <name><name>local_state</name><operator>-&gt;</operator><name>ts_state</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>local_state</name><operator>-&gt;</operator><name>ts_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------
 * 	ExecEndShareInputScan
 * ------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndShareInputScan</name><parameter_list>(<parameter><decl><type><name>ShareInputScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shareinput_local_state</name> <modifier>*</modifier></type><name>local_state</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>local_state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* clean up tuple table */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sisc</name><operator>-&gt;</operator><name>this_slice_id</name></name> <operator>==</operator> <name>currentSliceId</name> <operator>||</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The producer needs to wait for all the consumers to finish.
			 * Consumers signal the producer that they're done reading,
			 * but are free to exit immediately after that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>currentSliceId</name> <operator>==</operator> <name><name>sisc</name><operator>-&gt;</operator><name>producer_slice_id</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>local_state</name><operator>-&gt;</operator><name>ready</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>init_tuplestore_state</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>shareinput_writer_waitdone</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>local_state</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>shareinput_reader_notifydone</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>release_shareinput_reference</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>local_state</name> <operator>&amp;&amp;</operator> <name><name>local_state</name><operator>-&gt;</operator><name>ts_state</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>local_state</name><operator>-&gt;</operator><name>ts_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * shutdown subplan.  First scanner of underlying share input will
	 * do the shutdown, all other scanners are no-op because outerPlanState
	 * is NULL
	 */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------
 * 	ExecReScanShareInputScan
 * ------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanShareInputScan</name><parameter_list>(<parameter><decl><type><name>ShareInputScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* On first call, initialize the tuplestore state */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>isready</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>init_tuplestore_state</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ts_pos</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ts_state</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ts_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ts_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is called when the node above us has finished and will not need any more
 * rows from us.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSquelchShareInputScan</name><parameter_list>(<parameter><decl><type><name>ShareInputScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shareinput_local_state</name> <modifier>*</modifier></type><name>local_state</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>local_state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* clean up tuple table */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this SharedInputScan is shared within the same slice then its
	 * subtree may still need to be executed and the motions in the subtree
	 * cannot yet be stopped. Thus, don't recurse in this case.
	 *
	 * In squelching a cross-slice SharedInputScan writer, we need to ensure
	 * we don't block any reader on other slices as a result of not
	 * materializing the shared plan.
	 *
	 * Note that we emphatically can't "fake" an empty tuple store and just
	 * go ahead waking up the readers because that can lead to wrong results.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>currentSliceId</name> <operator>==</operator> <name><name>sisc</name><operator>-&gt;</operator><name>producer_slice_id</name></name> <operator>||</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We are the producer. If we haven't materialized the tuplestore
			 * yet, we need to do it now, even though we won't need the data
			 * for anything. There might be other consumers that need it, and
			 * they will hang waiting for us forever otherwise.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>local_state</name><operator>-&gt;</operator><name>ready</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SISC WRITER (shareid=%d, slice=%d): initializing because squelched"</literal></expr></argument>,
					 <argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>init_tuplestore_state</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We are a consumer. Let the producer know that we're done. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>local_state</name><operator>-&gt;</operator><name>closed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>ndone</name></name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>local_state</name><operator>-&gt;</operator><name>ndone</name></name> <operator>==</operator> <name><name>local_state</name><operator>-&gt;</operator><name>nsharers</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_reader_notifydone</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>local_state</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>release_shareinput_reference</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************************************
 * IPC, for cross-slice variants.
 **************************************************************************/</comment>

<comment type="block">/*
 * When creating a tuplestore file that will be accessed by
 * multiple processes, shareinput_create_bufname_prefix() is used to
 * construct the name for it.
 */</comment>
<function><type><name>void</name></type>
<name>shareinput_create_bufname_prefix</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>share_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"SIRW_%d_%d_%d"</literal></expr></argument>,
			 <argument><expr><name>gp_session_id</name></expr></argument>, <argument><expr><name>gp_command_count</name></expr></argument>, <argument><expr><name>share_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialization of the shared hash table for cross-slice communication.
 *
 * XXX: Use MaxBackends to size it, on the assumption that max_connections
 * will scale accordingly to query complexity. This is quite fuzzy, you could
 * create a query with tons of cross-slice ShareInputScans but only a few
 * slice, but that ought to be rare enough in practice. This isn't a hard
 * limit anyway, the hash table will use up any "slop" in shared memory if
 * needed.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_SHAREINPUT_SLOTS</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(MaxBackends * 5)</cpp:value></cpp:define>

<function><type><name>Size</name></type>
<name>ShareInputShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>hash_estimate_size</name><argument_list>(<argument><expr><call><name>N_SHAREINPUT_SLOTS</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>shareinput_Xslice_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ShareInputShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>shareinput_Xslice_dsm_handle_ptr</name> <operator>=</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"ShareInputScan DSM handle"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsm_handle</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>

		<comment type="block">/* GPDB_12_MERGE_FIXME: would be nicer to store this hash in the DSM segment or DSA */</comment>
		<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>shareinput_tag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>shareinput_Xslice_state</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><name>shareinput_Xslice_hash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"ShareInputScan notifications"</literal></expr></argument>,
											   <argument><expr><call><name>N_SHAREINPUT_SLOTS</name><argument_list>()</argument_list></call></expr></argument>,
											   <argument><expr><call><name>N_SHAREINPUT_SLOTS</name><argument_list>()</argument_list></call></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
											   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get reference to the SharedFileSet used to hold all the tuplestore files.
 *
 * This is exported so that it can also be used by the INITPLAN function
 * tuplestores.
 */</comment>
<function><type><name>SharedFileSet</name> <modifier>*</modifier></type>
<name>get_shareinput_fileset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsm_handle</name></type>		<name>handle</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shareinput_Xslice_fileset</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShareInputScanLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>*</operator><name>shareinput_Xslice_dsm_handle_ptr</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>handle</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>dsm_attach</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>seg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not attach to ShareInputScan DSM segment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>dsm_pin_mapping</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>shareinput_Xslice_fileset</name> <operator>=</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedFileSet</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dsm_pin_segment</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>shareinput_Xslice_dsm_handle_ptr</name> <operator>=</operator> <call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dsm_pin_mapping</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>shareinput_Xslice_fileset</name> <operator>=</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shareinput_Xslice_fileset</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SharedFileSetInit</name><argument_list>(<argument><expr><name>shareinput_Xslice_fileset</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SharedFileSetAttach</name><argument_list>(<argument><expr><name>shareinput_Xslice_fileset</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShareInputScanLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>shareinput_Xslice_fileset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get a reference to slot in shared memory for this shared scan.
 *
 * If the slot doesn't exist yet, it is created and initialized into
 * "not ready" state.
 *
 * The reference is tracked by the current ResourceOwner, and will be
 * automatically released on abort.
 */</comment>
<function><type><specifier>static</specifier> <name>shareinput_Xslice_reference</name> <modifier>*</modifier></type>
<name>get_shareinput_reference</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>share_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shareinput_tag</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shareinput_Xslice_state</name> <modifier>*</modifier></type><name>xslice_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

	<comment type="block">/* Register our resource owner callback to clean up on first call. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shareinput_resowner_callback_registered</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RegisterResourceReleaseCallback</name><argument_list>(<argument><expr><name>shareinput_release_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>shareinput_resowner_callback_registered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
								 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>shareinput_Xslice_reference</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShareInputScanLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>session_id</name></name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>command_count</name></name> <operator>=</operator> <name>gp_command_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>share_id</name></name> <operator>=</operator> <name>share_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xslice_state</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>shareinput_Xslice_hash</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
							   <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>xslice_state</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of cross-slice ShareInputScan slots"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>xslice_state</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xslice_state</name><operator>-&gt;</operator><name>ready</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xslice_state</name><operator>-&gt;</operator><name>ndone</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xslice_state</name><operator>-&gt;</operator><name>ready_done_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>xslice_state</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>share_id</name></name> <operator>=</operator> <name>share_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>xslice_state</name></name> <operator>=</operator> <name>xslice_state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shareinput_Xslice_refs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShareInputScanLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ref</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release reference to a shared scan.
 *
 * The reference count in the shared memory slot is decreased, and if
 * it reaches zero, it is destroyed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>release_shareinput_reference</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shareinput_Xslice_state</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>xslice_state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShareInputScanLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>shareinput_Xslice_hash</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
						   <argument><expr><name>HASH_REMOVE</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShareInputScanLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback to release references on transaction abort.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_release_callback</name><parameter_list>(<parameter><decl><type><name>ResourceReleasePhase</name></type> <name>phase</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
							<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>miter</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>phase</name> <operator>!=</operator> <name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>miter</argument>, <argument>&amp;shareinput_Xslice_refs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>shareinput_Xslice_reference</name></expr></argument>,
							<argument><expr><name>node</name></expr></argument>,
							<argument><expr><name><name>miter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>owner</name></name> <operator>==</operator> <name>CurrentResourceOwner</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"shareinput lease reference leak: lease %p still referenced"</literal></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>release_shareinput_reference</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * shareinput_reader_waitready
 *
 *  Called by the reader (consumer) to wait for the writer (producer) to produce
 *  all the tuples and write them to disk.
 *
 *  This is a blocking operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_reader_waitready</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shareinput_Xslice_state</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>xslice_state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SISC READER (shareid=%d, slice=%d): Waiting for producer"</literal></expr></argument>,
		 <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait until the the producer sets 'ready' to true. The producer will
	 * use the condition variable to wake us up.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * set state-&gt;ready via pg_atomic_exchange_u32() in shareinput_writer_notifyready()
		 * it acts as a memory barrier, so always get the latest value here
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>ready</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ready</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>ready</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ready_done_cv</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_SHAREINPUT_SCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* it's ready now */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SISC READER (shareid=%d, slice=%d): Wait ready got writer's handshake"</literal></expr></argument>,
		 <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shareinput_writer_notifyready
 *
 *  Called by the writer (producer) once it is done producing all tuples and
 *  writing them to disk. It notifies all the readers (consumers) that tuples
 *  are ready to be read from disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_writer_notifyready</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shareinput_Xslice_state</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>xslice_state</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name> <name>old_ready</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>pg_atomic_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ready</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>old_ready</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"shareinput_writer_notifyready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ready_done_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SISC WRITER (shareid=%d, slice=%d): wrote notify_ready"</literal></expr></argument>,
		 <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shareinput_reader_notifydone
 *
 *  Called by the reader (consumer) to notify the writer (producer) that
 *  it is done reading tuples from disk.
 *
 *  This is a non-blocking operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_reader_notifydone</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nconsumers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shareinput_Xslice_state</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>xslice_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ndone</name> <init>= <expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ndone</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If we were the last consumer, wake up the producer. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndone</name> <operator>&gt;=</operator> <name>nconsumers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ready_done_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SISC READER (shareid=%d, slice=%d): wrote notify_done"</literal></expr></argument>,
		 <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shareinput_writer_waitdone
 *
 *  Called by the writer (producer) to wait for the "done" notification from
 *  all readers (consumers).
 *
 *  This is a blocking operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_writer_waitdone</name><parameter_list>(<parameter><decl><type><name>shareinput_Xslice_reference</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nconsumers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shareinput_Xslice_state</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>xslice_state</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>ready</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ready</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ready</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shareinput_writer_waitdone() called without creating the tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ConditionVariablePrepareToSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ready_done_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * set state-&gt;ndone via pg_atomic_add_fetch_u32() in shareinput_reader_notifydone()
		 * it acts as a memory barrier, so always get the latest value here
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>	<name>ndone</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ndone</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>ndone</name> <operator>&lt;</operator> <name>nconsumers</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SISC WRITER (shareid=%d, slice=%d): waiting for DONE message from %d / %d readers"</literal></expr></argument>,
				 <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><name>nconsumers</name> <operator>-</operator> <name>ndone</name></expr></argument>, <argument><expr><name>nconsumers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ready_done_cv</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_SHAREINPUT_SCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ndone</name> <operator>&gt;</operator> <name>nconsumers</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"%d sharers of ShareInputScan reported to be done, but only %d were expected"</literal></expr></argument>,
				 <argument><expr><name>ndone</name></expr></argument>, <argument><expr><name>nconsumers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<break>break;</break>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SISC WRITER (shareid=%d, slice=%d): got DONE message from %d readers"</literal></expr></argument>,
		 <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><name>nconsumers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* it's all done now */</comment>
</block_content>}</block></function>
</unit>
