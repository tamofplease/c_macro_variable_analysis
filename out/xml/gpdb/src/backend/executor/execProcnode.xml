<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/execProcnode.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execProcnode.c
 *	 contains dispatch functions which call the appropriate "initialize",
 *	 "get a tuple", and "cleanup" routines for the given node type.
 *	 If the node has children, then it will presumably call ExecInitNode,
 *	 ExecProcNode, or ExecEndNode on its subnodes and do the appropriate
 *	 processing.
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/execProcnode.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 *	 NOTES
 *		This used to be three files.  It is now all combined into
 *		one file so that it is easier to keep the dispatch routines
 *		in sync when new nodes are added.
 *
 *	 EXAMPLE
 *		Suppose we want the age of the manager of the shoe department and
 *		the number of employees in that department.  So we have the query:
 *
 *				select DEPT.no_emps, EMP.age
 *				from DEPT, EMP
 *				where EMP.name = DEPT.mgr and
 *					  DEPT.name = "shoe"
 *
 *		Suppose the planner gives us the following plan:
 *
 *						Nest Loop (DEPT.mgr = EMP.name)
 *						/		\
 *					   /		 \
 *				   Seq Scan		Seq Scan
 *					DEPT		  EMP
 *				(name = "shoe")
 *
 *		ExecutorStart() is called first.
 *		It calls InitPlan() which calls ExecInitNode() on
 *		the root of the plan -- the nest loop node.
 *
 *	  * ExecInitNode() notices that it is looking at a nest loop and
 *		as the code below demonstrates, it calls ExecInitNestLoop().
 *		Eventually this calls ExecInitNode() on the right and left subplans
 *		and so forth until the entire plan is initialized.  The result
 *		of ExecInitNode() is a plan state tree built with the same structure
 *		as the underlying plan tree.
 *
 *	  * Then when ExecutorRun() is called, it calls ExecutePlan() which calls
 *		ExecProcNode() repeatedly on the top node of the plan state tree.
 *		Each time this happens, ExecProcNode() will end up calling
 *		ExecNestLoop(), which calls ExecProcNode() on its subplans.
 *		Each of these subplans is a sequential scan so ExecSeqScan() is
 *		called.  The slots returned by ExecSeqScan() may contain
 *		tuples which contain the attributes ExecNestLoop() uses to
 *		form the tuples it returns.
 *
 *	  * Eventually ExecSeqScan() stops returning tuples and the nest
 *		loop join ends.  Lastly, ExecutorEnd() calls ExecEndNode() which
 *		calls ExecEndNestLoop() which in turn calls ExecEndNode() on
 *		its subplans which result in ExecEndSeqScan().
 *
 *		This should show how the executor works by having
 *		ExecInitNode(), ExecProcNode() and ExecEndNode() dispatch
 *		their work to the appropriate node support routines which may
 *		in turn call these routines themselves on their subplans.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapAnd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeDynamicBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeDynamicBitmapIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapOr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCtescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCustom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeForeignscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeFunctionscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGather.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGatherMerge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexonlyscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLimit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLockRows.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMaterial.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergejoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNamedtuplestorescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNestloop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeProjectSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeRecursiveunion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeResult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSamplescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSeqscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSetOp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubqueryscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTableFuncscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTidscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTupleSplit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeUnique.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeValuesscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWindowAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWorktablescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/ml_ipc.h"</cpp:file></cpp:include>			<comment type="block">/* interconnect context */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAssertOp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeDynamicIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeDynamicSeqscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMotion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodePartitionSelector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeShareInputScan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSplitUpdate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTableFunction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/metrics_utils.h"</cpp:file></cpp:include>

 <comment type="block">/* flags bits for planstate walker */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSW_IGNORE_INITPLAN</name></cpp:macro>    <cpp:value>0x01</cpp:value></cpp:define>

 <comment type="block" format="doxygen">/**
  * Forward declarations of static functions
  */</comment>
<function_decl><type><specifier>static</specifier> <name>CdbVisitOpt</name></type> <name>planstate_walk_node_extended</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>CdbVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>CdbVisitOpt</name></type> <name>planstate_walk_array</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>planstates</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>nplanstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>CdbVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>CdbVisitOpt</name></type> <name>planstate_walk_kids</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>CdbVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
					<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecProcNodeFirst</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static TupleTableSlot *ExecProcNodeInstr(PlanState *node);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecProcNodeGPDB</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ------------------------------------------------------------------------
 *		ExecInitNode
 *
 *		Recursively initializes all the nodes in the plan tree rooted
 *		at 'node'.
 *
 *		Inputs:
 *		  'node' is the current node of the plan produced by the query planner
 *		  'estate' is the shared execution state for the plan tree
 *		  'eflags' is a bitwise OR of flag bits described in executor.h
 *
 *		Returns a PlanState node corresponding to the given Plan node.
 * ------------------------------------------------------------------------
 */</comment>
<function><type><name>PlanState</name> <modifier>*</modifier></type>
<name>ExecInitNode</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>nodecxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * do nothing when we get to the end of a leaf on tree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure there's enough stack available. Need to check here, in
	 * addition to ExecProcNode() (via ExecProcNodeFirst()), to ensure the
	 * stack isn't overrun while initializing the node tree.
	 */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If per-node memory usage was requested
	 * (explain_memory_verbosity=detail), create a separate memory context
	 * for every node, so that we can attribute memory usage to each node.
	 * Otherwise, everything is allocated in the per-query ExecutorState
	 * context. The extra memory contexts consume some memory on their
	 * own, and prevent reusing memory allocated in one node in another
	 * node, so we only want to do this if the level of detail is needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>&amp;</operator> <name>INSTRUMENT_MEMORY_DETAIL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nodecxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										<argument><expr><literal type="string">"executor node"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDeclareAccountingRoot</name><argument_list>(<argument><expr><name>nodecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>nodecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * control nodes
			 */</comment>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitResult</name><argument_list>(<argument><expr><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ProjectSet</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitProjectSet</name><argument_list>(<argument><expr><operator>(</operator><name>ProjectSet</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitModifyTable</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Append</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitAppend</name><argument_list>(<argument><expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Sequence</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSequence</name><argument_list>(<argument><expr><operator>(</operator><name>Sequence</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMergeAppend</name><argument_list>(<argument><expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitRecursiveUnion</name><argument_list>(<argument><expr><operator>(</operator><name>RecursiveUnion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * scan nodes
			 */</comment>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicSeqScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitDynamicSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicSeqScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSampleScan</name><argument_list>(<argument><expr><operator>(</operator><name>SampleScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicIndexScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitDynamicIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicIndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitIndexOnlyScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicBitmapIndexScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitDynamicBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicBitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
																  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicBitmapHeapScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitDynamicBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicBitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
																 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitTidScan</name><argument_list>(<argument><expr><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSubqueryScan</name><argument_list>(<argument><expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitFunctionScan</name><argument_list>(<argument><expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitTableFunction</name><argument_list>(<argument><expr><operator>(</operator><name>TableFunctionScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitTableFuncScan</name><argument_list>(<argument><expr><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitValuesScan</name><argument_list>(<argument><expr><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CteScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitCteScan</name><argument_list>(<argument><expr><operator>(</operator><name>CteScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitNamedTuplestoreScan</name><argument_list>(<argument><expr><operator>(</operator><name>NamedTuplestoreScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
															   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitWorkTableScan</name><argument_list>(<argument><expr><operator>(</operator><name>WorkTableScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * join nodes
			 */</comment>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitNestLoop</name><argument_list>(<argument><expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMergeJoin</name><argument_list>(<argument><expr><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * share input nodes
			 */</comment>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitShareInputScan</name><argument_list>(<argument><expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * materialization nodes
			 */</comment>
		<case>case <expr><name>T_Material</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMaterial</name><argument_list>(<argument><expr><operator>(</operator><name>Material</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Sort</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSort</name><argument_list>(<argument><expr><operator>(</operator><name>Sort</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Agg</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitAgg</name><argument_list>(<argument><expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TupleSplit</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitTupleSplit</name><argument_list>(<argument><expr><operator>(</operator><name>TupleSplit</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitWindowAgg</name><argument_list>(<argument><expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Unique</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Unique</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Gather</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitGather</name><argument_list>(<argument><expr><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GatherMerge</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMerge</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Hash</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitHash</name><argument_list>(<argument><expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SetOp</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSetOp</name><argument_list>(<argument><expr><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockRows</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitLockRows</name><argument_list>(<argument><expr><operator>(</operator><name>LockRows</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Limit</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitLimit</name><argument_list>(<argument><expr><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Motion</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMotion</name><argument_list>(<argument><expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSplitUpdate</name><argument_list>(<argument><expr><operator>(</operator><name>SplitUpdate</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AssertOp</name></expr>:</case>
 			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitAssertOp</name><argument_list>(<argument><expr><operator>(</operator><name>AssertOp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
 												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitPartitionSelector</name><argument_list>(<argument><expr><operator>(</operator><name>PartitionSelector</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
															<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ExecSetExecProcNode</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>ExecProcNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>&amp;</operator> <name>INSTRUMENT_MEMORY_DETAIL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name>nodecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>node_context</name></name> <operator>=</operator> <name>nodecxt</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize any initPlans present in this node.  The planner put them in
	 * a separate list for us.
	 */</comment>
	<expr_stmt><expr><name>subps</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;initPlan</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>origSliceId</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>ExecInitSubPlan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subps</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subps</name></expr></argument>, <argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name>origSliceId</name></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name>subps</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up instrumentation for this node if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>instrument</name></name> <operator>=</operator> <call><name>GpInstrAlloc</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If a node wants to change its ExecProcNode function after ExecInitNode()
 * has finished, it should do so with this function.  That way any wrapper
 * functions can be reinstalled, without the node having to know how that
 * works.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetExecProcNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExecProcNodeMtd</name></type> <name>function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Add a wrapper around the ExecProcNode callback that checks stack depth
	 * during the first execution and maybe adds an instrumentation wrapper.
	 * When the callback is changed after execution has already begun that
	 * means we'll superfluously execute ExecProcNodeFirst, but that seems ok.
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ExecProcNodeReal</name></name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecProcNodeFirst</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecProcNode wrapper that performs some one-time checks, before calling
 * the relevant node method (possibly via an instrumentation wrapper).
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecProcNodeFirst</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Perform stack depth check during the first execution of the node.  We
	 * only do so the first time round because it turns out to not be cheap on
	 * some common architectures (eg. x86).  This relies on the assumption
	 * that ExecProcNode calls for a given plan node will always be made at
	 * roughly the same stack depth.
	 */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If instrumentation is required, change the wrapper to one that just
	 * does instrumentation.  Otherwise we can dispense with all wrappers and
	 * have ExecProcNode() directly call the relevant function from now on.
	 *
	 * GPDB: Unfortunately, GPDB has a bunch of extra stuff that we need
	 * to do on every node, so we cannot make use of this upstream optimization.
	 * ExecProcNodeGPDB() is a wrapper that does all the Greenplum-specific
	 * extra stuff.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	if (node-&gt;instrument)
		node-&gt;ExecProcNode = ExecProcNodeInstr;
	else
		node-&gt;ExecProcNode = node-&gt;ExecProcNodeReal;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecProcNodeGPDB</name></expr>;</expr_stmt>

	<return>return <expr><call><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecProcNodeGPDB</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Even if we are requested to finish query, Motion has to do its work
	 * to tell End of Stream message to upper slice.  He will probably get
	 * NULL tuple from underlying operator by calling another ExecProcNode,
	 * so one additional operator execution should not be a big hit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>QueryFinishPending</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_EXECPROCNODE_ENTER</name><argument_list>(<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>squelched</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot execute squelched plan node of type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>fHadSentNodeStart</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* GPDB hook for collecting query info */</comment>
		<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_PLAN_NODE_EXECUTING</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fHadSentNodeStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>&amp;</operator> <name>INSTRUMENT_MEMORY_DETAIL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>node_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>node</name><operator>-&gt;</operator><name>ExecProcNodeReal</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>&amp;</operator> <name>INSTRUMENT_MEMORY_DETAIL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>node_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0.0</literal></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_EXECPROCNODE_EXIT</name><argument_list>(<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecProcNode wrapper that performs instrumentation calls.  By keeping
 * this a separate function, we avoid overhead in the normal case where
 * no instrumentation is wanted.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static TupleTableSlot *
ExecProcNodeInstr(PlanState *node)
{
	TupleTableSlot *result;

	InstrStartNode(node-&gt;instrument);

	result = node-&gt;ExecProcNodeReal(node);

	InstrStopNode(node-&gt;instrument, TupIsNull(result) ? 0.0 : 1.0);

	return result;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------------------------------------------
 *		MultiExecProcNode
 *
 *		Execute a node that doesn't return individual tuples
 *		(it might return a hashtable, bitmap, etc).  Caller should
 *		check it got back the expected kind of Node.
 *
 * This has essentially the same responsibilities as ExecProcNode,
 * but it does not do InstrStartNode/InstrStopNode (mainly because
 * it can't tell how many returned tuples to count).  Each per-node
 * function must provide its own instrumentation support.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>MultiExecProcNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_EXECPROCNODE_ENTER</name><argument_list>(<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>fHadSentNodeStart</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* GPDB hook for collecting query info */</comment>
		<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_PLAN_NODE_EXECUTING</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fHadSentNodeStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* something changed */</comment>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* let ReScan handle this */</comment>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Only node types that actually support multiexec will be listed
			 */</comment>

		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScanState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicBitmapIndexScanState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecDynamicBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicBitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAndState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOrState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_EXECPROCNODE_EXIT</name><argument_list>(<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndNode
 *
 *		Recursively cleans up all the nodes in the plan rooted
 *		at 'node'.
 *
 *		After this operation, the query plan will not be able to be
 *		processed any further.  This should be called only after
 *		the query plan has been fully executed.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * do nothing when we get to the end of a leaf on tree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure there's enough stack available. Need to check here, in
	 * addition to ExecProcNode() (via ExecProcNodeFirst()), because it's not
	 * guaranteed that ExecProcNode() is reached for all nodes.
	 */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free EXPLAIN ANALYZE buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>cdbexplainbuf</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>cdbexplainbuf</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cdbexplainbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cdbexplainbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cdbexplainbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * control nodes
			 */</comment>
		<case>case <expr><name>T_ResultState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndResult</name><argument_list>(<argument><expr><operator>(</operator><name>ResultState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ProjectSetState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndProjectSet</name><argument_list>(<argument><expr><operator>(</operator><name>ProjectSetState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTableState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndModifyTable</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndAppend</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppendState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndMergeAppend</name><argument_list>(<argument><expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RecursiveUnionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndRecursiveUnion</name><argument_list>(<argument><expr><operator>(</operator><name>RecursiveUnionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SequenceState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSequence</name><argument_list>(<argument><expr><operator>(</operator><name>SequenceState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAndState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOrState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * scan nodes
			 */</comment>
		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicSeqScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndDynamicSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicSeqScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SampleScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSampleScan</name><argument_list>(<argument><expr><operator>(</operator><name>SampleScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GatherState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndGather</name><argument_list>(<argument><expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GatherMergeState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicIndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndDynamicIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndIndexOnlyScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicBitmapIndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndDynamicBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicBitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicBitmapHeapScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndDynamicBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicBitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TidScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndTidScan</name><argument_list>(<argument><expr><operator>(</operator><name>TidScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSubqueryScan</name><argument_list>(<argument><expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndFunctionScan</name><argument_list>(<argument><expr><operator>(</operator><name>FunctionScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFunctionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndTableFunction</name><argument_list>(<argument><expr><operator>(</operator><name>TableFunctionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndTableFuncScan</name><argument_list>(<argument><expr><operator>(</operator><name>TableFuncScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndValuesScan</name><argument_list>(<argument><expr><operator>(</operator><name>ValuesScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CteScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndCteScan</name><argument_list>(<argument><expr><operator>(</operator><name>CteScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedTuplestoreScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndNamedTuplestoreScan</name><argument_list>(<argument><expr><operator>(</operator><name>NamedTuplestoreScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WorkTableScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndWorkTableScan</name><argument_list>(<argument><expr><operator>(</operator><name>WorkTableScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * join nodes
			 */</comment>
		<case>case <expr><name>T_NestLoopState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndNestLoop</name><argument_list>(<argument><expr><operator>(</operator><name>NestLoopState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeJoinState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndMergeJoin</name><argument_list>(<argument><expr><operator>(</operator><name>MergeJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * ShareInput nodes
			 */</comment>
		<case>case <expr><name>T_ShareInputScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndShareInputScan</name><argument_list>(<argument><expr><operator>(</operator><name>ShareInputScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * materialization nodes
			 */</comment>
		<case>case <expr><name>T_MaterialState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndMaterial</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SortState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSort</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AggState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndAgg</name><argument_list>(<argument><expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TupleSplitState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndTupleSplit</name><argument_list>(<argument><expr><operator>(</operator><name>TupleSplitState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WindowAggState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndWindowAgg</name><argument_list>(<argument><expr><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UniqueState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndUnique</name><argument_list>(<argument><expr><operator>(</operator><name>UniqueState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SetOpState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSetOp</name><argument_list>(<argument><expr><operator>(</operator><name>SetOpState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockRowsState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndLockRows</name><argument_list>(<argument><expr><operator>(</operator><name>LockRowsState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LimitState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndLimit</name><argument_list>(<argument><expr><operator>(</operator><name>LimitState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MotionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndMotion</name><argument_list>(<argument><expr><operator>(</operator><name>MotionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * DML nodes
			 */</comment>
		<case>case <expr><name>T_SplitUpdateState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSplitUpdate</name><argument_list>(<argument><expr><operator>(</operator><name>SplitUpdateState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AssertOpState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndAssertOp</name><argument_list>(<argument><expr><operator>(</operator><name>AssertOpState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionSelectorState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndPartitionSelector</name><argument_list>(<argument><expr><operator>(</operator><name>PartitionSelectorState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<comment type="block">/* GPDB hook for collecting query info */</comment>
	<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_PLAN_NODE_FINISHED</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<comment type="block">/* -----------------------------------------------------------------------
 *						PlanState Tree Walking Functions
 * -----------------------------------------------------------------------
 *
 * planstate_walk_node
 *	  Calls a 'walker' function for the given PlanState node; or returns
 *	  CdbVisit_Walk if 'planstate' is NULL.
 *
 *	  If 'walker' returns CdbVisit_Walk, then this function calls
 *	  planstate_walk_kids() to visit the node's children, and returns
 *	  the result.
 *
 *	  If 'walker' returns CdbVisit_Skip, then this function immediately
 *	  returns CdbVisit_Walk and does not visit the node's children.
 *
 *	  If 'walker' returns CdbVisit_Stop or another value, then this function
 *	  immediately returns that value and does not visit the node's children.
 *
 * planstate_walk_array
 *	  Calls planstate_walk_node() for each non-NULL PlanState ptr in
 *	  the given array of pointers to PlanState objects.
 *
 *	  Quits if the result of planstate_walk_node() is CdbVisit_Stop or another
 *	  value other than CdbVisit_Walk, and returns that result without visiting
 *	  any more nodes.
 *
 *	  Returns CdbVisit_Walk if 'planstates' is NULL, or if all of the
 *	  subtrees return CdbVisit_Walk.
 *
 *	  Note that this function never returns CdbVisit_Skip to its caller.
 *	  Only the caller's 'walker' function can return CdbVisit_Skip.
 *
 * planstate_walk_list
 *	  Calls planstate_walk_node() for each PlanState node in the given List.
 *
 *	  Quits if the result of planstate_walk_node() is CdbVisit_Stop or another
 *	  value other than CdbVisit_Walk, and returns that result without visiting
 *	  any more nodes.
 *
 *	  Returns CdbVisit_Walk if all of the subtrees return CdbVisit_Walk, or
 *	  if the list is empty.
 *
 *	  Note that this function never returns CdbVisit_Skip to its caller.
 *	  Only the caller's 'walker' function can return CdbVisit_Skip.
 *
 * planstate_walk_kids
 *	  Calls planstate_walk_node() for each child of the given PlanState node.
 *
 *	  Quits if the result of planstate_walk_node() is CdbVisit_Stop or another
 *	  value other than CdbVisit_Walk, and returns that result without visiting
 *	  any more nodes.
 *
 *	  Returns CdbVisit_Walk if the given planstate node ptr is NULL, or if
 *	  all of the children return CdbVisit_Walk, or if there are no children.
 *
 *	  Note that this function never returns CdbVisit_Skip to its caller.
 *	  Only the 'walker' can return CdbVisit_Skip.
 *
 * NB: All CdbVisitOpt values other than CdbVisit_Walk or CdbVisit_Skip are
 * treated as equivalent to CdbVisit_Stop.  Thus the walker can break out
 * of a traversal and at the same time return a smidgen of information to the
 * caller, perhaps to indicate the reason for termination.  For convenience,
 * a couple of alternative stopping codes are predefined for walkers to use at
 * their discretion: CdbVisit_Failure and CdbVisit_Success.
 *
 * NB: We do not visit the left subtree of a NestLoopState node (NJ) whose
 * 'shared_outer' flag is set.  This occurs when the NJ is the left child of
 * an AdaptiveNestLoopState (AJ); the AJ's right child is a HashJoinState (HJ);
 * and both the NJ and HJ point to the same left subtree.  This way we avoid
 * visiting the common subtree twice when descending through the AJ node.
 * The caller's walker function can handle the NJ as a special case to
 * override this behavior if there is a need to always visit both subtrees.
 *
 * NB: Use PSW_* flags to skip walking certain parts of the planstate tree.
 * -----------------------------------------------------------------------
 */</comment>


<comment type="block" format="doxygen">/**
 * Version of walker that uses no flags.
 */</comment>
<function><type><name>CdbVisitOpt</name></type>
<name>planstate_walk_node</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>CdbVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
					<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Workhorse walker that uses flags.
 */</comment>
<function><type><name>CdbVisitOpt</name></type>
<name>planstate_walk_node_extended</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>CdbVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbVisitOpt</name></type> <name>whatnext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <name>CdbVisit_Walk</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <call><name>walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>whatnext</name> <operator>==</operator> <name>CdbVisit_Walk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <call><name>planstate_walk_kids</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>whatnext</name> <operator>==</operator> <name>CdbVisit_Skip</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <name>CdbVisit_Walk</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>whatnext</name> <operator>!=</operator> <name>CdbVisit_Skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>whatnext</name></expr>;</return>
</block_content>}</block></function>	<comment type="block">/* planstate_walk_node */</comment>

<function><type><name>CdbVisitOpt</name></type>
<name>planstate_walk_array</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>planstates</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>nplanstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>CdbVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbVisitOpt</name></type> <name>whatnext</name> <init>= <expr><name>CdbVisit_Walk</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>planstates</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CdbVisit_Walk</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nplanstate</name> <operator>&amp;&amp;</operator> <name>whatnext</name> <operator>==</operator> <name>CdbVisit_Walk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>whatnext</name></expr>;</return>
</block_content>}</block></function>	<comment type="block">/* planstate_walk_array */</comment>

<function><type><name>CdbVisitOpt</name></type>
<name>planstate_walk_kids</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>CdbVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
					<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbVisitOpt</name></type> <name>v</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CdbVisit_Walk</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_NestLoopState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NestLoopState</name> <modifier>*</modifier></type><name>nls</name> <init>= <expr><operator>(</operator><name>NestLoopState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Don't visit left subtree of NJ if it is shared with brother
				 * HJ
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>nls</name><operator>-&gt;</operator><name>shared_outer</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>v</name> <operator>=</operator> <name>CdbVisit_Walk</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* Right subtree */</comment>
				<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>CdbVisit_Walk</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>as_nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_MergeAppendState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>ms</name> <init>= <expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>mergeplans</name></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_ModifyTableState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mts</name> <init>= <expr><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>mts</name><operator>-&gt;</operator><name>mt_plans</name></name></expr></argument>, <argument><expr><name><name>mts</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_SequenceState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SequenceState</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><operator>(</operator><name>SequenceState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>numSubplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_BitmapAndState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapAndState</name> <modifier>*</modifier></type><name>bas</name> <init>= <expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>bas</name><operator>-&gt;</operator><name>bitmapplans</name></name></expr></argument>, <argument><expr><name><name>bas</name><operator>-&gt;</operator><name>nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_BitmapOrState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapOrState</name> <modifier>*</modifier></type><name>bos</name> <init>= <expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>bos</name><operator>-&gt;</operator><name>bitmapplans</name></name></expr></argument>, <argument><expr><name><name>bos</name><operator>-&gt;</operator><name>nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
			<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* Left subtree */</comment>
			<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Right subtree */</comment>
			<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>CdbVisit_Walk</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Init plan subtree */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PSW_IGNORE_INITPLAN</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <operator>(</operator><name>v</name> <operator>==</operator> <name>CdbVisit_Walk</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbVisitOpt</name></type> <name>v1</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>planstate-&gt;initPlan</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ips</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ips</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>CdbVisit_Walk</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name>ips</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Sub plan subtree */</comment>
	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>CdbVisit_Walk</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbVisitOpt</name></type> <name>v1</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>planstate-&gt;subPlan</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ips</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ips</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subplan has no planstate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>CdbVisit_Walk</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name>ips</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>	<comment type="block">/* planstate_walk_kids */</comment>

<comment type="block">/*
 * ExecShutdownNode
 *
 * Give execution nodes a chance to stop asynchronous resource consumption
 * and release any resources still held.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecShutdownNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ExecShutdownNode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Treat the node as running while we shut it down, but only if it's run
	 * at least once already.  We don't expect much CPU consumption during
	 * node shutdown, but in the case of Gather or Gather Merge, we may shut
	 * down workers at this stage.  If so, their buffer usage will get
	 * propagated into pgBufferUsage at this point, and we want to make sure
	 * that it gets associated with the Gather node.  We skip this if the node
	 * has never been executed, so as to avoid incorrectly making it appear
	 * that it has.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>running</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_GatherState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownGather</name><argument_list>(<argument><expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GatherMergeState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Stop the node if we started it above, reporting 0 tuples. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>running</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSetTupleBound
 *
 * Set a tuple bound for a planstate node.  This lets child plan nodes
 * optimize based on the knowledge that the maximum number of tuples that
 * their parent will demand is limited.  The tuple bound for a node may
 * only be changed between scans (i.e., after node initialization or just
 * before an ExecReScan call).
 *
 * Any negative tuples_needed value means "no limit", which should be the
 * default assumption when this is not called at all for a particular node.
 *
 * Note: if this is called repeatedly on a plan tree, the exact same set
 * of nodes must be updated with the new limit each time; be careful that
 * only unchanging conditions are tested here.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetTupleBound</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>tuples_needed</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>child_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Since this function recurses, in principle we should check stack depth
	 * here.  In practice, it's probably pointless since the earlier node
	 * initialization tree traversal would surely have consumed more stack.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>SortState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it is a Sort node, notify it that it can use bounded sort.
		 *
		 * Note: it is the responsibility of nodeSort.c to react properly to
		 * changes of these parameters.  If we ever redesign this, it'd be a
		 * good idea to integrate this signaling with the parameter-change
		 * mechanism.
		 */</comment>
		<decl_stmt><decl><type><name>SortState</name>  <modifier>*</modifier></type><name>sortState</name> <init>= <expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>tuples_needed</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* make sure flag gets reset if needed upon rescan */</comment>
			<expr_stmt><expr><name><name>sortState</name><operator>-&gt;</operator><name>bounded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>sortState</name><operator>-&gt;</operator><name>bounded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortState</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>tuples_needed</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>AppendState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it is an Append, we can apply the bound to any nodes that are
		 * children of the Append, since the Append surely need read no more
		 * than that many tuples from any one input.
		 */</comment>
		<decl_stmt><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>aState</name> <init>= <expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>aState</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><name><name>aState</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>MergeAppendState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it is a MergeAppend, we can apply the bound to any nodes that
		 * are children of the MergeAppend, since the MergeAppend surely need
		 * read no more than that many tuples from any one input.
		 */</comment>
		<decl_stmt><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>maState</name> <init>= <expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>maState</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><name><name>maState</name><operator>-&gt;</operator><name>mergeplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>ResultState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Similarly, for a projecting Result, we can apply the bound to its
		 * child node.
		 *
		 * If Result supported qual checking, we'd have to punt on seeing a
		 * qual.  Note that having a resconstantqual is not a showstopper: if
		 * that condition succeeds it affects nothing, while if it fails, no
		 * rows will be demanded from the Result child anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>SubqueryScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can also descend through SubqueryScan, but only if it has no
		 * qual (otherwise it might discard rows).
		 */</comment>
		<decl_stmt><decl><type><name>SubqueryScanState</name> <modifier>*</modifier></type><name>subqueryState</name> <init>= <expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subqueryState</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><name><name>subqueryState</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>GatherState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A Gather node can propagate the bound to its workers.  As with
		 * MergeAppend, no one worker could possibly need to return more
		 * tuples than the Gather itself needs to.
		 *
		 * Note: As with Sort, the Gather node is responsible for reacting
		 * properly to changes to this parameter.
		 */</comment>
		<decl_stmt><decl><type><name>GatherState</name> <modifier>*</modifier></type><name>gstate</name> <init>= <expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>gstate</name><operator>-&gt;</operator><name>tuples_needed</name></name> <operator>=</operator> <name>tuples_needed</name></expr>;</expr_stmt>

		<comment type="block">/* Also pass down the bound to our own copy of the child plan */</comment>
		<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>GatherMergeState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Same comments as for Gather */</comment>
		<decl_stmt><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gstate</name> <init>= <expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>gstate</name><operator>-&gt;</operator><name>tuples_needed</name></name> <operator>=</operator> <name>tuples_needed</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In principle we could descend through any plan node type that is
	 * certain not to discard or combine input rows; but on seeing a node that
	 * can do that, we can't propagate the bound any further.  For the moment
	 * it's unclear that any other cases are worth checking here.
	 */</comment>
</block_content>}</block></function>
</unit>
