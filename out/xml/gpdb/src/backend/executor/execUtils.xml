<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/execUtils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execUtils.c
 *	  miscellaneous executor utility routines
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/execUtils.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *		CreateExecutorState		Create/delete executor working state
 *		FreeExecutorState
 *		CreateExprContext
 *		CreateStandaloneExprContext
 *		FreeExprContext
 *		ReScanExprContext
 *
 *		ExecAssignExprContext	Common code for plan node init routines.
 *		etc
 *
 *		ExecOpenScanRelation	Common code for scan node init routines.
 *
 *		ExecInitRangeTable		Set up executor's range-table-related data.
 *
 *		ExecGetRangeTableRelation		Fetch Relation for a rangetable entry.
 *
 *		executor_errposition	Report syntactic position of an error.
 *
 *		RegisterExprContextCallback    Register function shutdown callback
 *		UnregisterExprContextCallback  Deregister function shutdown callback
 *
 *		GetAttributeByName		Runtime extraction of columns from tuples.
 *		GetAttributeByNum
 *
 *	 NOTES
 *		This file has traditionally been the place to stick misc.
 *		executor support stuff that doesn't really go anyplace else.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/ml_ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmotion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbllize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/workfile_mgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/metrics_utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tlist_matches_tupdesc</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShutdownExprContext</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>flatten_logic_exprs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *				 Executor state and memory management functions
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		CreateExecutorState
 *
 *		Create and initialize an EState node, which is the root of
 *		working storage for an entire Executor invocation.
 *
 * Principally, this creates the per-query memory context that will be
 * used to hold all working data that lives till the end of the query.
 * Note that the per-query context will become a child of the caller's
 * CurrentMemoryContext.
 * ----------------
 */</comment>
<function><type><name>EState</name> <modifier>*</modifier></type>
<name>CreateExecutorState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>qcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create the per-query context for this Executor run.
	 */</comment>
	<expr_stmt><expr><name>qcontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									 <argument><expr><literal type="string">"ExecutorState"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDeclareAccountingRoot</name><argument_list>(<argument><expr><name>qcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the EState node within the per-query context.  This way, we don't
	 * need a separate pfree() operation for it at shutdown.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>qcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>EState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize all fields of the Executor State structure
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <name>InvalidSnapshot</name></expr>;</expr_stmt>	<comment type="block">/* caller must initialize this */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name> <operator>=</operator> <name>InvalidSnapshot</name></expr>;</expr_stmt>	<comment type="block">/* no crosscheck */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_array</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowmarks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <operator>(</operator><name>CommandId</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tuple_routing_result_relations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_target_relations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_queryEnv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name> <operator>=</operator> <name>qcontext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_auxmodifytables</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_use_parallel_mode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>active_recv_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_got_eos</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cancelUnfinished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eliminateAliens</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>gp_bypass_unique_check</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return the executor state structure
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>estate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		FreeExecutorState
 *
 *		Release an EState along with all remaining working storage.
 *
 * Note: this is not responsible for releasing non-memory resources, such as
 * open relations or buffer pins.  But it will shut down any still-active
 * ExprContexts within the EState and deallocate associated JITed expressions.
 * That is sufficient cleanup for situations where the EState has only been
 * used for expression evaluation, and not to run a complete Plan.
 *
 * This can be called in any memory context ... so long as it's not one
 * of the ones to be freed.
 *
 * In Greenplum, this also clears the PartitionState, even though that's a
 * non-memory resource, as that can be allocated for expression evaluation even
 * when there is no Plan.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>FreeExecutorState</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Shut down and free any remaining ExprContexts.  We do this explicitly
	 * to ensure that any remaining shutdown callbacks get called (since they
	 * might need to release resources that aren't simply memory within the
	 * per-query memory context).
	 */</comment>
	<while>while <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * XXX: seems there ought to be a faster way to implement this than
		 * repeated list_delete(), no?
		 */</comment>
		<expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><operator>(</operator><name>ExprContext</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* FreeExprContext removed the list link for us */</comment>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* release JIT context, if allocated */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>jit_release_context</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* release partition directory, if allocated */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_partition_directory</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DestroyPartitionDirectory</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_partition_directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_partition_directory</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Free the per-query memory context, thereby releasing all working
	 * memory, including the EState node itself.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal implementation for CreateExprContext() and CreateWorkExprContext()
 * that allows control over the AllocSet parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>ExprContext</name> <modifier>*</modifier></type>
<name>CreateExprContextInternal</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>minContextSize</name></decl></parameter>,
						  <parameter><decl><type><name>Size</name></type> <name>initBlockSize</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>maxBlockSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Create the ExprContext node within the per-query memory context */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize fields of ExprContext */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create working memory for expression evaluation in this context.
	 */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
							  <argument><expr><literal type="string">"ExprContext"</literal></expr></argument>,
							  <argument><expr><name>minContextSize</name></expr></argument>,
							  <argument><expr><name>initBlockSize</name></expr></argument>,
							  <argument><expr><name>maxBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_datum</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_datum</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Link the ExprContext into the EState to ensure it is shut down when the
	 * EState is freed.  Because we use lcons(), shutdowns will occur in
	 * reverse order of creation, which may not be essential but can't hurt.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>econtext</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		CreateExprContext
 *
 *		Create a context for expression evaluation within an EState.
 *
 * An executor run may require multiple ExprContexts (we usually make one
 * for each Plan node, and a separate one for per-output-tuple processing
 * such as constraint checking).  Each ExprContext has its own "per-tuple"
 * memory context.
 *
 * Note we make no assumption about the caller's memory context.
 * ----------------
 */</comment>
<function><type><name>ExprContext</name> <modifier>*</modifier></type>
<name>CreateExprContext</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CreateExprContextInternal</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------
 *		CreateWorkExprContext
 *
 * Like CreateExprContext, but specifies the AllocSet sizes to be reasonable
 * in proportion to work_mem. If the maximum block allocation size is too
 * large, it's easy to skip right past work_mem with a single allocation.
 * ----------------
 */</comment>
<function><type><name>ExprContext</name> <modifier>*</modifier></type>
<name>CreateWorkExprContext</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>minContextSize</name> <init>= <expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>initBlockSize</name> <init>= <expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>maxBlockSize</name> <init>= <expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* choose the maxBlockSize to be no larger than 1/16 of work_mem */</comment>
	<while>while <condition>(<expr><literal type="number">16</literal> <operator>*</operator> <name>maxBlockSize</name> <operator>&gt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxBlockSize</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><name>maxBlockSize</name> <operator>&lt;</operator> <name>ALLOCSET_DEFAULT_INITSIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxBlockSize</name> <operator>=</operator> <name>ALLOCSET_DEFAULT_INITSIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>CreateExprContextInternal</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>minContextSize</name></expr></argument>,
									 <argument><expr><name>initBlockSize</name></expr></argument>, <argument><expr><name>maxBlockSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		CreateStandaloneExprContext
 *
 *		Create a context for standalone expression evaluation.
 *
 * An ExprContext made this way can be used for evaluation of expressions
 * that contain no Params, subplans, or Var references (it might work to
 * put tuple references into the scantuple field, but it seems unwise).
 *
 * The ExprContext struct is allocated in the caller's current memory
 * context, which also becomes its "per query" context.
 *
 * It is caller's responsibility to free the ExprContext when done,
 * or at least ensure that any shutdown callbacks have been called
 * (ReScanExprContext() is suitable).  Otherwise, non-memory resources
 * might be leaked.
 * ----------------
 */</comment>
<function><type><name>ExprContext</name> <modifier>*</modifier></type>
<name>CreateStandaloneExprContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

	<comment type="block">/* Create the ExprContext node within the caller's memory context */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize fields of ExprContext */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create working memory for expression evaluation in this context.
	 */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							  <argument><expr><literal type="string">"ExprContext"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_datum</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_datum</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>econtext</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		FreeExprContext
 *
 *		Free an expression context, including calling any remaining
 *		shutdown callbacks.
 *
 * Since we free the temporary context used for expression evaluation,
 * any previously computed pass-by-reference expression result will go away!
 *
 * If isCommit is false, we are being called in error cleanup, and should
 * not call callbacks but only release memory.  (It might be better to call
 * the callbacks and pass the isCommit flag to them, but that would require
 * more invasive code changes than currently seems justified.)
 *
 * Note we make no assumption about the caller's memory context.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>FreeExprContext</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>

	<comment type="block">/* Call any registered callbacks */</comment>
	<expr_stmt><expr><call><name>ShutdownExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And clean up the memory used */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Unlink self from owning EState, if any */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_estate</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>estate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name></expr></argument>,
												  <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* And delete the ExprContext node */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReScanExprContext
 *
 *		Reset an expression context in preparation for a rescan of its
 *		plan node.  This requires calling any registered shutdown callbacks,
 *		since any partially complete set-returning-functions must be canceled.
 *
 * Note we make no assumption about the caller's memory context.
 */</comment>
<function><type><name>void</name></type>
<name>ReScanExprContext</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Call any registered callbacks */</comment>
	<expr_stmt><expr><call><name>ShutdownExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And clean up the memory used */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a per-output-tuple ExprContext for an EState.
 *
 * This is normally invoked via GetPerTupleExprContext() macro,
 * not directly.
 */</comment>
<function><type><name>ExprContext</name> <modifier>*</modifier></type>
<name>MakePerTupleExprContext</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name></name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *				 miscellaneous node-init support functions
 *
 * Note: all of these are expected to be called with CurrentMemoryContext
 * equal to the per-query memory context.
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		ExecAssignExprContext
 *
 *		This initializes the ps_ExprContext field.  It is only necessary
 *		to do this for nodes which use ExecQual or ExecProject
 *		because those routines require an econtext. Other nodes that
 *		don't have to evaluate expressions don't need to do this.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignExprContext</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		ExecGetResultType
 * ----------------
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ExecGetResultType</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleDesc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecGetResultSlotOps - information about node's type of result slot
 */</comment>
<function><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type>
<name>ExecGetResultSlotOps</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isfixed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>resultopsset</name></name> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>resultops</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isfixed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>isfixed</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>resultopsfixed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name><name>planstate</name><operator>-&gt;</operator><name>resultops</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isfixed</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>resultopsset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>isfixed</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>resultopsfixed</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>isfixed</name> <operator>=</operator> <call><name>TTS_FIXED</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>isfixed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name><operator>-&gt;</operator><name>tts_ops</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------
 *		ExecAssignProjectionInfo
 *
 * forms the projection information from the node's targetlist
 *
 * Notes for inputDesc are same as for ExecBuildProjectionInfo: supply it
 * for a relation-scan node, can pass NULL for upper-level nodes
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignProjectionInfo</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						 <parameter><decl><type><name>TupleDesc</name></type> <name>inputDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ProjInfo</name></name> <operator>=</operator>
		<call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
								<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>,
								<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr></argument>,
								<argument><expr><name>planstate</name></expr></argument>,
								<argument><expr><name>inputDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------
 *		ExecConditionalAssignProjectionInfo
 *
 * as ExecAssignProjectionInfo, but store NULL rather than building projection
 * info if no projection is required
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecConditionalAssignProjectionInfo</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>inputDesc</name></decl></parameter>,
									<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>tlist_matches_tupdesc</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>,
							  <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
							  <argument><expr><name>varno</name></expr></argument>,
							  <argument><expr><name>inputDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>resultopsset</name></name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>scanopsset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>resultopsfixed</name></name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>scanopsfixed</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>resultops</name></name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>scanops</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecInitResultSlot</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>resultops</name></name> <operator>=</operator> <operator>&amp;</operator><name>TTSOpsVirtual</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>resultopsfixed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>resultopsset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>inputDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tlist_matches_tupdesc</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numattrs</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlist_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check the tlist attributes */</comment>
	<for>for <control>(<init><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrno</name> <operator>&lt;=</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>attrno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>tlist_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* tlist too short */</comment>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlist_item</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* tlist item not a Var */</comment>
		<comment type="block">/* if these Asserts fail, planner messed up */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>attrno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* out of order */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* table contains dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* table contains cols with missing values */</comment>

		<comment type="block">/*
		 * Note: usually the Var's type should match the tupdesc exactly, but
		 * in situations involving unions of columns that have different
		 * typmods, the Var may have come from above the union and hence have
		 * typmod -1.  This is a legitimate situation since the Var still
		 * describes the column, just not as exactly as the tupdesc does. We
		 * could change the planner to prevent it, but it'd then insert
		 * projection steps just to convert from specific typmod to typmod -1,
		 * which is pretty silly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
			<operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>!=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>&amp;&amp;</operator>
			 <name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* type mismatch */</comment>

		<expr_stmt><expr><name>tlist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>tlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>tlist_item</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* tlist too long */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		ExecFreeExprContext
 *
 * A plan node's ExprContext should be freed explicitly during executor
 * shutdown because there may be shutdown callbacks to call.  (Other resources
 * made by the above routines, such as projection info, don't need to be freed
 * explicitly because they're just memory in the per-query memory context.)
 *
 * However ... there is no particular need to do it during ExecEndNode,
 * because FreeExecutorState will free any remaining ExprContexts within
 * the EState.  Letting FreeExecutorState do it allows the ExprContexts to
 * be freed in reverse order of creation, rather than order of creation as
 * will happen if we delete them here, which saves O(N^2) work in the list
 * cleanup inside FreeExprContext.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecFreeExprContext</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Per above discussion, don't actually delete the ExprContext. We do
	 * unlink it from the plan node, though.
	 */</comment>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *				  Scan node support
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		ExecAssignScanType
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignScanType</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		ExecCreateScanSlotFromOuterPlan
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecCreateScanSlotFromOuterPlan</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>scanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanstate</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>tts_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecRelationIsTargetRelation
 *
 *		Detect whether a relation (identified by rangetable index)
 *		is one of the target relations of the query.
 *
 * Note: This is currently no longer used in core.  We keep it around
 * because FDWs may wish to use it to determine if their foreign table
 * is a target relation.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>bool</name></type>
<name>ExecRelationIsTargetRelation</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ri_RangeTableIndex</name> <operator>==</operator> <name>scanrelid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecOpenScanRelation
 *
 *		Open the heap relation to be scanned by a base-level scan plan node.
 *		This should be called during the node's ExecInit routine.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Relation</name></type>
<name>ExecOpenScanRelation</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/* Open the relation. */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>ExecGetRangeTableRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Complain if we're attempting a scan of an unscannable relation, except
	 * when the query won't actually be run.  This is a slightly klugy place
	 * to do this, perhaps, but there is no better place.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_EXPLAIN_ONLY</name> <operator>|</operator> <name>EXEC_FLAG_WITH_NO_DATA</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>RelationIsScannable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized view \"%s\" has not been populated"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the REFRESH MATERIALIZED VIEW command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitRangeTable
 *		Set up executor's range-table-related data
 *
 * We build an array from the range table list to allow faster lookup by RTI.
 * (The es_range_table field is now somewhat redundant, but we keep it to
 * avoid breaking external code unnecessarily.)
 * This is also a convenient place to set up the parallel es_relations array.
 */</comment>
<function><type><name>void</name></type>
<name>ExecInitRangeTable</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Remember the range table List as-is */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name> <operator>=</operator> <name>rangeTable</name></expr>;</expr_stmt>

	<comment type="block">/* Set up the equivalent array representation */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rangeTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_array</name></name> <operator>=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RangeTblEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rangeTable</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_array</name><index>[<expr><name>rti</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Allocate an array to store an open Relation corresponding to each
	 * rangetable entry, and initialize entries to NULL.  Relations are opened
	 * and stored here as needed.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name></name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * es_rowmarks is also parallel to the es_range_table_array, but it's
	 * allocated only if needed.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowmarks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecGetRangeTableRelation
 *		Open the Relation for a range table entry, if not already done
 *
 * The Relations will be closed again in ExecEndPlan().
 */</comment>
<function><type><name>Relation</name></type>
<name>ExecGetRangeTableRelation</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rti</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rti</name> <operator>&lt;=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_relations</name><index>[<expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, so open the relation */</comment>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>exec_rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* GPDB: a QE process is not holding the locks yet, same as a parallel worker. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In a normal query, we should already have the appropriate lock,
			 * but verify that through an Assert.  Since there's already an
			 * Assert inside table_open that insists on holding some lock, it
			 * seems sufficient to check this only when rellockmode is higher
			 * than the minimum.
			 */</comment>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>==</operator> <name>AccessShareLock</name> <operator>||</operator>
				   <call><name>CheckRelationLockedByMe</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If we are a parallel worker, we need to obtain our own local
			 * lock on the relation.  This ensures sane behavior in case the
			 * parent process exits before we do.
			 */</comment>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name><index>[<expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * UpdateChangedParamSet
 *		Add changed parameters to a plan node's chgParam set
 */</comment>
<function><type><name>void</name></type>
<name>UpdateChangedParamSet</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>newchg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>parmset</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The plan node only depends on params listed in its allParam set. Don't
	 * include anything else into its chgParam set.
	 */</comment>
	<expr_stmt><expr><name>parmset</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>, <argument><expr><name>newchg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Keep node-&gt;chgParam == NULL if there's not actually any members; this
	 * allows the simplest possible tests in executor node files.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>parmset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>, <argument><expr><name>parmset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>parmset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * executor_errposition
 *		Report an execution-time cursor position, if possible.
 *
 * This is expected to be used within an ereport() call.  The return value
 * is a dummy (always 0, in fact).
 *
 * The locations stored in parsetrees are byte offsets into the source string.
 * We have to convert them to 1-based character indexes for reporting to
 * clients.  (We do things this way to avoid unnecessary overhead in the
 * normal non-error case: computing character indexes would be much more
 * expensive than storing token offsets.)
 */</comment>
<function><type><name>void</name></type>
<name>executor_errposition</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>

	<comment type="block">/* No-op if location was not provided */</comment>
	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Can't do anything if source text is not available */</comment>
	<if_stmt><if>if <condition>(<expr><name>estate</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Convert offset to character number */</comment>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* And pass it to the ereport mechanism */</comment>
	<expr_stmt><expr><call><name>errposition</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a shutdown callback in an ExprContext.
 *
 * Shutdown callbacks will be called (in reverse order of registration)
 * when the ExprContext is deleted or rescanned.  This provides a hook
 * for functions called in the context to do any cleanup needed --- it's
 * particularly useful for functions returning sets.  Note that the
 * callback will *not* be called in the event that execution is aborted
 * by an error.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterExprContextCallback</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
							<parameter><decl><type><name>ExprContextCallbackFunction</name></type> <name>function</name></decl></parameter>,
							<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext_CB</name> <modifier>*</modifier></type><name>ecxt_callback</name></decl>;</decl_stmt>

	<comment type="block">/* Save the info in appropriate memory context */</comment>
	<expr_stmt><expr><name>ecxt_callback</name> <operator>=</operator> <operator>(</operator><name>ExprContext_CB</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprContext_CB</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>function</name></name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

	<comment type="block">/* link to front of list for appropriate execution order */</comment>
	<expr_stmt><expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>=</operator> <name>ecxt_callback</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deregister a shutdown callback in an ExprContext.
 *
 * Any list entries matching the function and arg will be removed.
 * This can be used if it's no longer necessary to call the callback.
 */</comment>
<function><type><name>void</name></type>
<name>UnregisterExprContextCallback</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
							  <parameter><decl><type><name>ExprContextCallbackFunction</name></type> <name>function</name></decl></parameter>,
							  <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext_CB</name> <modifier>*</modifier><modifier>*</modifier></type><name>prev_callback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext_CB</name> <modifier>*</modifier></type><name>ecxt_callback</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prev_callback</name> <operator>=</operator> <operator>&amp;</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>ecxt_callback</name> <operator>=</operator> <operator>*</operator><name>prev_callback</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>function</name></name> <operator>==</operator> <name>function</name> <operator>&amp;&amp;</operator> <name><name>ecxt_callback</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>arg</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>prev_callback</name> <operator>=</operator> <name><name>ecxt_callback</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ecxt_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prev_callback</name> <operator>=</operator> <operator>&amp;</operator><name><name>ecxt_callback</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Call all the shutdown callbacks registered in an ExprContext.
 *
 * The callback list is emptied (important in case this is only a rescan
 * reset, and not deletion of the ExprContext).
 *
 * If isCommit is false, just clean the callback list but don't call 'em.
 * (See comment for FreeExprContext.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShutdownExprContext</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext_CB</name> <modifier>*</modifier></type><name>ecxt_callback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Fast path in normal case where there's nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Call the callbacks in econtext's per-tuple context.  This ensures that
	 * any memory they might leak will get cleaned up.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call each callback function in reverse registration order.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>ecxt_callback</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>=</operator> <name><name>ecxt_callback</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>ecxt_callback</name><operator>-&gt;</operator><name>function</name></name><argument_list>(<argument><expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ecxt_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * flatten_logic_exprs
 * This function is only used by ExecPrefetchJoinQual.
 * ExecPrefetchJoinQual need to prefetch subplan in join
 * qual that contains motion to materialize it to avoid
 * motion deadlock. This function is going to flatten
 * the bool exprs to avoid shortcut of bool logic.
 * An example is:
 * (a and b or c) or (d or e and f or g) and (h and i or j)
 * will be transformed to
 * (a, b, c, d, e, f, g, h, i, j).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>flatten_logic_exprs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>be</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>flatten_logic_exprs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>be</name><operator>-&gt;</operator><name>args</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>     <modifier>*</modifier></type><name>es</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>     <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>es</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
								 <argument><expr><call><name>flatten_logic_exprs</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fake_outer_params
 *   helper function to fake the nestloop's nestParams
 *   so that prefetch inner or prefetch joinqual will
 *   not encounter NULL pointer reference issue. It is
 *   only invoked in ExecNestLoop and ExecPrefetchJoinQual
 *   when the join is a nestloop join.
 */</comment>
<function><type><name>void</name></type>
<name>fake_outer_params</name><parameter_list>(<parameter><decl><type><name>JoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name>    <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>      <modifier>*</modifier></type><name>inner</name> <init>= <expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NestLoop</name>       <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>       <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* only nestloop contains nestParams */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* econtext-&gt;ecxt_outertuple must have been set fakely. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outerTupleSlot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * fetch the values of any outer Vars that must be passed to the
	 * inner scan, and store them in the appropriate PARAM_EXEC slots.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nl-&gt;nestParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name> <init>= <expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* Param value should be an OUTER_VAR var */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>,
								  <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flag parameter value as changed */</comment>
		<expr_stmt><expr><name><name>inner</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>inner</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>,
										 <argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Prefetch JoinQual or NonJoinQual to prevent motion hazard.
 *
 * A motion hazard is a deadlock between motions, a classic motion hazard in a
 * join executor is formed by its inner and outer motions, it can be prevented
 * by prefetching the inner plan, refer to motion_sanity_check() for details.
 *
 * A similar motion hazard can be formed by the outer motion and the join qual
 * motion(or non join qual motion).  A join executor fetches a outer tuple,
 * filters it with the qual, then repeat the process on all the outer tuples.
 * When there are motions in both outer plan and the join qual then below state
 * is possible:
 *
 * 0. processes A and B belong to the join slice, process C belongs to the
 *    outer slice, process D belongs to the JoinQual(NonJoinQual) slice;
 * 1. A has read the first outer tuple and is fetching tuples from D;
 * 2. D is waiting for ACK from B;
 * 3. B is fetching the first outer tuple from C;
 * 4. C is waiting for ACK from A;
 *
 * So a deadlock is formed A-&gt;D-&gt;B-&gt;C-&gt;A.  We can prevent it also by
 * prefetching the join qual or non join qual
 *
 * An example is demonstrated and explained in test case
 * src/test/regress/sql/deadlock2.sql.
 *
 * Return true if the JoinQual or NonJoinQual is prefetched.
 */</comment>
<function><type><name>void</name></type>
<name>ExecPrefetchQual</name><parameter_list>(<parameter><decl><type><name>JoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isJoinQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>inner</name> <init>= <expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outer</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>innertuple</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isJoinQual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>qual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>joinqual</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>qual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Outer tuples should not be fetched before us */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build fake inner &amp; outer tuples */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
													  <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>inner</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
													  <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>outer</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NestLoop</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>nl</name><operator>-&gt;</operator><name>nestParams</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fake_outer_params</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>flatten_logic_exprs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch subplan with the fake inner &amp; outer tuples */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>quals</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Force every qual is prefech because
		 * our target is to materialize motion node.
		 */</comment>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Restore previous state */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>innertuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		CDB Slice Table utilities
 * ----------------------------------------------------------------
 */</comment>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>FillSliceGangInfo</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>, <parameter><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>numsegments</name> <init>= <expr><name><name>ps</name><operator>-&gt;</operator><name>numsegments</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DirectDispatchInfo</name> <modifier>*</modifier></type><name>dd</name> <init>= <expr><operator>&amp;</operator><name><name>ps</name><operator>-&gt;</operator><name>directDispatch</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GANGTYPE_UNALLOCATED</name></expr>:</case>
			<comment type="block">/*
			 * It's either the root slice or an InitPlan slice that runs in
			 * the QD process, or really unused slice.
			 */</comment>
			<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr>:</case>
		<case>case <expr><name>GANGTYPE_PRIMARY_READER</name></expr>:</case>
			<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>isDirectDispatch</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>dd</name><operator>-&gt;</operator><name>contentIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numsegments</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>i</name> <operator>%</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_ENTRYDB_READER</name></expr>:</case>
			<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_SINGLETON_READER</name></expr>:</case>
			<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected gang type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Create the executor slice table.
 *
 * The planner constructed a slice table, in plannedstmt-&gt;slices. Turn that
 * into an "executor slice table", with slightly more information. The gangs
 * to execute the slices will be set up later.
 */</comment>
<function><type><name>SliceTable</name> <modifier>*</modifier></type>
<name>InitSliceTable</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numSlices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numSlices</name> <operator>=</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numSlices</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_max_slices</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numSlices</name> <operator>&gt;</operator> <name>gp_max_slices</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"at most %d slices are allowed in a query, current number: %d"</literal></expr></argument>,
						<argument><expr><name>gp_max_slices</name></expr></argument>, <argument><expr><name>numSlices</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"rewrite your query or adjust GUC gp_max_slices"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SliceTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name>INSTRUMENT_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>hasMotions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the executor slice table.
	 *
	 * We have most of the information in the planner slice table. In addition to that,
	 * we set up the parent-child relationships.
	 */</comment>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExecSlice</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numSlices</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>currExecSlice</name> <init>= <expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>currPlanSlice</name> <init>= <expr><operator>&amp;</operator><name><name>plannedstmt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>parentIndex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rootIndex</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <name><name>currPlanSlice</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>parentIndex</name> <operator>=</operator> <name><name>currPlanSlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>parentIndex</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>parentIndex</name> <operator>&gt;=</operator> <name>numSlices</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid parent slice index %d"</literal></expr></argument>, <argument><expr><name><name>currPlanSlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>parentIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>parentExecSlice</name> <init>= <expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>parentIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>counter</name></decl>;</decl_stmt>

			<comment type="block">/* Sending slice is a child of recv slice */</comment>
			<expr_stmt><expr><name><name>parentExecSlice</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>parentExecSlice</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name><name>currPlanSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Find the root slice */</comment>
			<expr_stmt><expr><name>rootIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>counter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>rootIndex</name></expr>]</index></name><operator>.</operator><name>parentIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rootIndex</name> <operator>=</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>rootIndex</name></expr>]</index></name><operator>.</operator><name>parentIndex</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>counter</name><operator>++</operator> <operator>&gt;</operator> <name>numSlices</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"circular parent-child relationship in slice table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>hasMotions</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rootIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* find root of this slice. All the parents should be initialized already */</comment>

		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>=</operator> <name>parentIndex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>rootIndex</name></name> <operator>=</operator> <name>rootIndex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name><name>currPlanSlice</name><operator>-&gt;</operator><name>gangType</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FillSliceGangInfo</name><argument_list>(<argument><expr><name>currExecSlice</name></expr></argument>, <argument><expr><name>currPlanSlice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>=</operator> <name>numSlices</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For CTAS although the data is distributed on part of the
	 * segments, the catalog changes must be dispatched to all the
	 * segments, so a full gang is required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>plannedstmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>copyIntoClause</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>refreshClause</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gangType</name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name> <init>= <expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>segments</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numsegments</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>segments</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>segments</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>table</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A forgiving slice table indexer that returns the indexed Slice* or NULL
 */</comment>
<function><type><name>ExecSlice</name> <modifier>*</modifier></type>
<name>getCurrentSlice</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>sliceTable</name> <operator>&amp;&amp;</operator>
		<name>sliceIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>sliceIndex</name> <operator>&lt;</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Should the slice run on the QD?
 *
 * N.B. Not the same as !sliceRunsOnQE(slice), when slice is NULL.
 */</comment>
<function><type><name>bool</name></type>
<name>sliceRunsOnQD</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>slice</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Should the slice run on a QE?
 *
 * N.B. Not the same as !sliceRunsOnQD(slice), when slice is NULL.
 */</comment>
<function><type><name>bool</name></type>
<name>sliceRunsOnQE</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>slice</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>!=</operator> <name>GANGTYPE_UNALLOCATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AssignWriterGangFirst</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InventorySliceTree</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Function AssignGangs runs on the QD and finishes construction of the
 * global slice table for a plan by assigning gangs allocated by the
 * executor factory to the slices of the slice table.
 *
 * On entry, the executor slice table (at queryDesc-&gt;estate-&gt;es_sliceTable)
 * has been initialized and has correct (by InitSliceTable function)
 *
 * Gang assignment involves taking an inventory of the requirements of
 * each slice tree in the slice table, asking the executor factory to
 * allocate a minimal set of gangs that can satisfy any of the slice trees,
 * and associating the allocated gangs with slices in the slice table.
 *
 * On successful exit, the CDBProcess lists (primaryProcesses, mirrorProcesses)
 * and the Gang pointers (primaryGang, mirrorGang) are set correctly in each
 * slice in the slice table.
 */</comment>
<function><type><name>void</name></type>
<name>AssignGangs</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceTable</name>	<modifier>*</modifier></type><name>sliceTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>		<modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rootIdx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sliceTable</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rootIdx</name> <operator>=</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cleanup processMap because initPlan and main Plan share the same slice table */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>processesMap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>AssignWriterGangFirst</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>rootIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InventorySliceTree</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>rootIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AssignWriterGangFirst() - Try to assign writer gang first.
 *
 * For the gang allocation, our current implementation required the first
 * allocated gang must be the writer gang.
 * This has several reasons:
 * - For lock holding, Because of our MPP structure, we assign a LockHolder
 *   for each segment when executing a query. lockHolder is the gang member that
 *   should hold and manage locks for this transaction. On the QEs, it should
 *   normally be the Writer gang member. More details please refer to
 *   lockHolderProcPtr in lock.c.
 * - For SharedSnapshot among session's gang processes on a particular segment.
 *   During initPostgres(), reader QE will try to lookup the shared slot written
 *   by writer QE. More details please reger to sharedsnapshot.c.
 *
 * Normally, the writer slice will be assign writer gang first when iterate the
 * slice table. But this is not true for writable CTE (with only one writer gang).
 * For below statement:
 *
 * WITH updated AS (update tbl set rank = 6 where id = 5 returning rank)
 * select * from tbl where rank in (select rank from updated);
 *                                           QUERY PLAN
 * ----------------------------------------------------------------------------------------------
 *  Gather Motion 3:1  (slice1; segments: 3)
 *    -&gt;  Seq Scan on tbl
 *          Filter: (hashed SubPlan 1)
 *          SubPlan 1
 *            -&gt;  Broadcast Motion 1:3  (slice2; segments: 1)
 *                  -&gt;  Update on tbl
 *                        -&gt;  Seq Scan on tbl
 *                              Filter: (id = 5)
 *  Slice 0: Dispatcher; root 0; parent -1; gang size 0
 *  Slice 1: Reader; root 0; parent 0; gang size 3
 *  Slice 2: Primary Writer; root 0; parent 1; gang size 1
 *
 * If we sill assign writer gang to Slice 1 here, the writer process will execute
 * on reader gang. So, find the writer slice and assign writer gang first.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AssignWriterGangFirst</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecSlice</name>	   <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>=</operator> <call><name>AllocateGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setupCdbProcessList</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>slice-&gt;children</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>childIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>AssignWriterGangFirst</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>childIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for AssignGangs takes a simple inventory of the gangs required
 * by a slice tree.  Recursive.  Closely coupled with AssignGangs.	Not
 * generally useful.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InventorySliceTree</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name></name> <operator>=</operator> <call><name>getCdbProcessesForQD</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>=</operator> <call><name>AllocateGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setupCdbProcessList</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>slice-&gt;children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>childIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InventorySliceTree</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>childIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Choose the execution identity (who does this executor serve?).
 * There are types:
 *
 * 1. No-Op (ignore) -- this occurs when the specified direction is
 *	 NoMovementScanDirection or when Gp_role is GP_ROLE_DISPATCH
 *	 and the current slice belongs to a QE.
 *
 * 2. Executor serves a Root Slice -- this occurs when Gp_role is
 *   GP_ROLE_UTILITY or the current slice is a root.  It corresponds
 *   to the "normal" path through the executor in that we enter the plan
 *   at the top and count on the motion nodes at the fringe of the top
 *   slice to return without ever calling nodes below them.
 *
 * 3. Executor serves a Non-Root Slice on a QE -- this occurs when
 *   Gp_role is GP_ROLE_EXECUTE and the current slice is not a root
 *   slice. It corresponds to a QE running a slice with a motion node on
 *	 top.  The call, thus, returns no tuples (since they all go out
 *	 on the interconnect to the receiver version of the motion node),
 *	 but it does execute the indicated slice down to any fringe
 *	 motion nodes (as in case 2).
 */</comment>
<function><type><name>GpExecIdentity</name></type>
<name>getGpExecIdentity</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
				  <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>,
				  <parameter><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>currentSlice</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>currentSlice</name> <operator>=</operator> <call><name>getCurrentSlice</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currentSlice</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator>
            <call><name>sliceRunsOnQD</name><argument_list>(<argument><expr><name>currentSlice</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <name><name>currentSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* select the strategy */</comment>
	<if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <name>NoMovementScanDirection</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>GP_IGNORE</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <call><name>sliceRunsOnQE</name><argument_list>(<argument><expr><name>currentSlice</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>GP_IGNORE</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>GP_NON_ROOT_ON_QE</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>GP_ROOT_SLICE</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * End the gp-specific part of the executor.
 *
 * In here we collect the dispatch results if there are any, tear
 * down the interconnect if it is set-up.
 */</comment>
<function><type><name>void</name></type> <name>mppExecutorFinishup</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>currentSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>primaryWriterSliceIndex</name></decl>;</decl_stmt>

	<comment type="block">/* caller must have switched into per-query memory context already */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>currentSlice</name> <operator>=</operator> <call><name>getCurrentSlice</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>primaryWriterSliceIndex</name> <operator>=</operator> <call><name>PrimaryWriterSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Teardown the Interconnect */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TeardownInterconnect</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are finishing a query before all the tuples of the query
	 * plan were fetched we must call ExecSquelchNode before checking
	 * the dispatch results in order to tell we no longer
	 * need any more tuples.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_got_eos</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If QD, wait for QEs to finish and check their results.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name><operator>-&gt;</operator><name>primaryResults</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>pr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name> <init>= <expr><name>DISPATCH_WAIT_NONE</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>qeError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Wait for completion of all QEs.  We send a "graceful" query
		 * finish, not cancel signal.  Since the query has succeeded,
		 * don't confuse QEs by sending erroneous message.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>cancelUnfinished</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>waitMode</name> <operator>=</operator> <name>DISPATCH_WAIT_FINISH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>cdbdisp_checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>waitMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pr</name> <operator>=</operator> <call><name>cdbdisp_getDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>qeError</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>qeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* collect pgstat from QEs for current transaction level */</comment>
		<expr_stmt><expr><call><name>pgstat_combine_from_qe</name><argument_list>(<argument><expr><name>pr</name></expr></argument>, <argument><expr><name>primaryWriterSliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* get num of rows processed from writer QEs. */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>+=</operator>
			<call><name>cdbdisp_sumCmdTuples</name><argument_list>(<argument><expr><name>pr</name></expr></argument>, <argument><expr><name>primaryWriterSliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* sum up rejected rows if any (single row error handling only) */</comment>
		<expr_stmt><expr><call><name>cdbdisp_sumRejectedRows</name><argument_list>(<argument><expr><name>pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check and free the results of all gangs. If any QE had an
		 * error, report it and exit to our error handler via PG_THROW.
		 * NB: This call doesn't wait, because we already waited above.
		 */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbdisp_destroyDispatcherState</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup the gp-specific parts of the query executor.
 *
 * Will normally be called after an error from within a CATCH block.
 */</comment>
<function><type><name>void</name></type> <name>mppExecutorCleanup</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>

	<comment type="block">/* caller must have switched into per-query memory context already */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ds</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr>;</expr_stmt>

	<comment type="block">/* GPDB hook for collecting query info */</comment>
	<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name> <operator>&amp;&amp;</operator> <name>QueryCancelCleanup</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_QUERY_CANCELING</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Clean up the interconnect. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TeardownInterconnect</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Request any commands still executing on qExecs to stop.
	 * Wait for them to finish and clean up the dispatching structures.
	 * Replace current error info with QE error info if more interesting.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ds</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbDispatchHandleError</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* GPDB hook for collecting query info */</comment>
	<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><ternary><condition><expr><name>QueryCancelCleanup</name></expr> ?</condition><then> <expr><name>METRICS_QUERY_CANCELED</name></expr> </then><else>: <expr><name>METRICS_QUERY_ERROR</name></expr></else></ternary></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><call><name>ReportOOMConsumption</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/**
	 * Since there was an error, clean up the function scan stack.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SPI_InitMemoryReservation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * This method is used to determine how much memory a specific operator
 * is supposed to use (in KB). 
 */</comment>
<function><type><name>uint64</name></type> <name>PlanStateOperatorMemKB</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ps</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>operatorMemKB</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block" format="doxygen">/**
		 * There are some statements that do not go through the resource queue and these
		 * plans dont get decorated with the operatorMemKB. Someday, we should fix resource queues.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>work_mem</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>ps</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>operatorMemKB</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Methods to find motionstate object within a planstate tree given a motion id (which is the same as slice index)
 */</comment>
<typedef>typedef <type><struct>struct <name>MotionStateFinderContext</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>motionId</name></decl>;</decl_stmt> <comment type="block">/* Input */</comment>
	<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>motionState</name></decl>;</decl_stmt> <comment type="block">/* Output */</comment>
}</block></struct></type> <name>MotionStateFinderContext</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Walker method that finds motion state node within a planstate tree.
 */</comment>
<function><type><specifier>static</specifier> <name>CdbVisitOpt</name></type>
<name>MotionStateFinderWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>MotionStateFinderContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>MotionStateFinderContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>ms</name> <init>= <expr><operator>(</operator><name>MotionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>ms</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>motionID</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>motionId</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>motionState</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>motionState</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
			<return>return <expr><name>CdbVisit_Skip</name></expr>;</return>	<comment type="block">/* don't visit subtree */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Continue walking */</comment>
	<return>return <expr><name>CdbVisit_Walk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Given a slice index, find the motionstate that corresponds to this slice index. This will iterate over the planstate tree
 * to get the right node.
 */</comment>
<function><type><name>MotionState</name> <modifier>*</modifier></type>
<name>getMotionState</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlanState</name></name> <modifier>*</modifier></type><name>ps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceIndex</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MotionStateFinderContext</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>motionId</name></name> <operator>=</operator> <name>sliceIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>motionState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>planstate_walk_node</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>MotionStateFinderWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>motionState</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find MotionState for slice %d in executor tree"</literal></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>ctx</name><operator>.</operator><name>motionState</name></name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>MotionFinderContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>motionId</name></decl>;</decl_stmt> <comment type="block">/* Input */</comment>
	<decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt> <comment type="block">/* Output */</comment>
}</block></struct></type> <name>MotionFinderContext</name>;</typedef>

<comment type="block">/*
 * Walker to find a motion node that matches a particular motionID
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MotionFinderWalker</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>MotionFinderContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>MotionFinderContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>motionID</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>motionId</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>motion</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>	<comment type="block">/* found our node; no more visit */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Continue walking */</comment>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>node</name></expr></argument>, <argument><expr><name>MotionFinderWalker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given the Plan and a Slice index, find the motion node that is the root of the slice's subtree.
 */</comment>
<function><type><name>Motion</name> <modifier>*</modifier></type><name>findSenderMotion</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceIndex</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>planTree</name> <init>= <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionFinderContext</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>plannedstmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>motionId</name></name> <operator>=</operator> <name>sliceIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>motion</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MotionFinderWalker</name><argument_list>(<argument><expr><name>planTree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ctx</name><operator>.</operator><name>motion</name></name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SubPlanFinderContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bms_subplans</name></decl>;</decl_stmt> <comment type="block">/* Bitmapset for relevant subplans in current slice */</comment>
}</block></struct></type> <name>SubPlanFinderContext</name>;</typedef>

<comment type="block">/*
 * Walker to find all the subplans in a PlanTree between 'node' and the next motion node
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SubPlanFinderWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlanFinderContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>SubPlanFinderContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* don't recurse into other slices */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>plan_id</name> <init>= <expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_id</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>plan_id</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>bms_subplans</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>bms_subplans</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>bms_subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Continue walking */</comment>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlanFinderWalker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a plan and a root motion node find all the subplans
 * between 'root' and the next motion node in the tree
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>getLocallyExecutableSubplans</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>root_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlanFinderContext</name></type> <name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plannedstmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>bms_subplans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that we begin with plan_tree_walker(root_plan), not
	 * SubPlanFinderWalker(root_plan). SubPlanFinderWalker() will stop
	 * at a Motion, but a slice typically has a Motion at the top. We want
	 * to recurse into the children of the top Motion, as well as any
	 * initPlans, targetlist, and other fields on the Motion itself. They
	 * are all considered part of the sending slice.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>root_plan</name></expr></argument>, <argument><expr><name>SubPlanFinderWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ctx</name><operator>.</operator><name>bms_subplans</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy PARAM_EXEC parameter values that were received from the QD into
 * our EState.
 */</comment>
<function><type><name>void</name></type>
<name>InstallDispatchedExecParams</name><parameter_list>(<parameter><decl><type><name>QueryDispatchDesc</name> <modifier>*</modifier></type><name>ddesc</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ddesc</name><operator>-&gt;</operator><name>paramInfo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ddesc</name><operator>-&gt;</operator><name>paramInfo</name><operator>-&gt;</operator><name>nExecParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SerializedParamExecData</name> <modifier>*</modifier></type><name>sprm</name> <init>= <expr><operator>&amp;</operator><name><name>ddesc</name><operator>-&gt;</operator><name>paramInfo</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prmExec</name> <init>= <expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sprm</name><operator>-&gt;</operator><name>isvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* not dispatched */</comment>

		<expr_stmt><expr><name><name>prmExec</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prmExec</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prmExec</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Provide index of locally executing slice
 */</comment>
<function><type><name>int</name></type> <name>LocallyExecutingSliceIndex</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><ternary><condition><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Provide index of slice being executed on the primary writer gang
 */</comment>
<function><type><name>int</name></type>
<name>PrimaryWriterSliceIndex</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Provide root slice of locally executing slice.
 */</comment>
<function><type><name>int</name></type>
<name>RootSliceIndex</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>localSlice</name> <init>= <expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>localSlice</name><operator>-&gt;</operator><name>rootIndex</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block" format="doxygen">/**
 * Assert that slicetable is valid. Must be called after ExecInitMotion, which sets up the slice table
 */</comment>
<function><type><name>void</name></type> <name>AssertSliceTableIsValid</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>st</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* The n-th slice entry has sliceIndex of n */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>==</operator> <name>i</name> <operator>&amp;&amp;</operator> <literal type="string">"slice index incorrect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * FIXME: Sometimes the planner produces a plan with unused SubPlans, which
		 * might contain Motion nodes. We remove unused SubPlans as part cdbllize(), but
		 * there is a scenario with Append nodes where they still occur.
		 * adjust_appendrel_attrs() makes copies of any SubPlans it encounters, which
		 * happens early in the planning, leaving any SubPlans in target list of the
		 * Append node to point to the original plan_id. The scan in cdbllize() doesn't
		 * eliminate such SubPlans. But set_plan_references() will replace any SubPlans
		 * in the Append's targetlist with references to the outputs of the child nodes,
		 * leaving the original SubPlan unused.
		 *
		 * For now, just tolerate unused slices.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>rootIndex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Parent slice index */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>rootIndex</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Current slice is a root slice. It will have parent index -1.*/</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <literal type="string">"expecting parent index of -1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* All other slices must have a valid parent index */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>&amp;&amp;</operator> <literal type="string">"slice's parent index out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Current slice's children must consider it the parent */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc1</argument>, <argument>s-&gt;children</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>childIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>childIndex</name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>&amp;&amp;</operator> <literal type="string">"invalid child slice"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>childIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sc</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>&amp;&amp;</operator> <literal type="string">"slice's child does not consider it the parent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Current slice must be in its parent's children list */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>parentIndex</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lc1</argument>, <argument>sp-&gt;children</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>childIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>childIndex</name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>&amp;&amp;</operator> <literal type="string">"invalid child slice"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>childIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sc</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name> <operator>&amp;&amp;</operator> <literal type="string">"slice's parent does not consider it a child"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 *		GetAttributeByName
 *		GetAttributeByNum
 *
 *		These functions return the value of the requested attribute
 *		out of the given tuple Datum.
 *		C functions which take a tuple as an argument are expected
 *		to use these.  Ex: overpaid(EMP) might call GetAttributeByNum().
 *		Note: these are actually rather slow because they do a typcache
 *		lookup on each call.
 */</comment>
<function><type><name>Datum</name></type>
<name>GetAttributeByName</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attrno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>attname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isNull</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"a NULL isNull pointer was passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Kinda bogus but compatible with old behavior... */</comment>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attrno</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>attrno</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>attrno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * heap_getattr needs a HeapTuple not a bare HeapTupleHeader.  We set all
	 * the fields in the struct just in case user tries to inspect system
	 * columns.
	 */</comment>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>,
						  <argument><expr><name>attrno</name></expr></argument>,
						  <argument><expr><name>tupDesc</name></expr></argument>,
						  <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>GetAttributeByNum</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>,
				  <parameter><decl><type><name>AttrNumber</name></type> <name>attrno</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute number %d"</literal></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isNull</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"a NULL isNull pointer was passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Kinda bogus but compatible with old behavior... */</comment>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * heap_getattr needs a HeapTuple not a bare HeapTupleHeader.  We set all
	 * the fields in the struct just in case user tries to inspect system
	 * columns.
	 */</comment>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>,
						  <argument><expr><name>attrno</name></expr></argument>,
						  <argument><expr><name>tupDesc</name></expr></argument>,
						  <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Number of items in a tlist (including any resjunk items!)
 */</comment>
<function><type><name>int</name></type>
<name>ExecTargetListLength</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This used to be more complex, but fjoins are dead */</comment>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Number of items in a tlist, not including any resjunk items
 */</comment>
<function><type><name>int</name></type>
<name>ExecCleanTargetListLength</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>curTle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>curTle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a relInfo's tuple slot for a trigger's OLD tuples.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecGetTriggerOldSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_TrigOldSlot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_TrigOldSlot</name></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
								   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_TrigOldSlot</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a relInfo's tuple slot for a trigger's NEW tuples.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecGetTriggerNewSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_TrigNewSlot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_TrigNewSlot</name></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
								   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_TrigNewSlot</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a relInfo's tuple slot for processing returning tuples.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecGetReturningSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_ReturningSlot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_ReturningSlot</name></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
								   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_ReturningSlot</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * During attribute re-mapping for heterogeneous partitions, we use
 * this struct to identify which varno's attributes will be re-mapped.
 * Using this struct as a *context* during expression tree walking, we
 * can skip varattnos that do not belong to a given varno.
 */</comment>
<typedef>typedef <type><struct>struct <name>AttrMapContext</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>newattno</name></decl>;</decl_stmt> <comment type="block">/* The mapping table to remap the varattno */</comment>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name></decl>;</decl_stmt>			<comment type="block">/* Which rte's varattno to re-map */</comment>
}</block></struct></type> <name>AttrMapContext</name>;</typedef>

<comment type="block">/*
 * Remaps the varattno of a varattno in a Var node using an attribute map.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>change_varattnos_varno_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttrMapContext</name> <modifier>*</modifier></type><name>attrMapCxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>attrMapCxt</name><operator>-&gt;</operator><name>varno</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ??? the following may be a problem when the node is multiply
			 * referenced though stringToNode() doesn't create such a node
			 * currently.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>attrMapCxt</name><operator>-&gt;</operator><name>newattno</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name><name>attrMapCxt</name><operator>-&gt;</operator><name>newattno</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>change_varattnos_varno_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>attrMapCxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replace varattno values for a given varno RTE index in an expression
 * tree according to the given map array, that is, varattno N is replaced
 * by newattno[N-1].  It is caller's responsibility to ensure that the array
 * is long enough to define values for all user varattnos present in the tree.
 * System column attnos remain unchanged.
 *
 * Note that the passed node tree is modified in-place!
 */</comment>
<function><type><name>void</name></type>
<name>change_varattnos_of_a_varno</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>newattno</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrMapContext</name></type> <name>attrMapCxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>attrMapCxt</name><operator>.</operator><name>newattno</name></name> <operator>=</operator> <name>newattno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attrMapCxt</name><operator>.</operator><name>varno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>change_varattnos_varno_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrMapCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
