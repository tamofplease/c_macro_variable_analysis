<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/nodeMotion.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeMotion.c
 *	  Routines to handle moving tuples around in Greenplum Database.
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/executor/nodeMotion.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>	<comment type="block">/* Slice, SliceTable */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmotion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMotion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/binaryheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/* #define MEASURE_MOTION_TIME */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEASURE_MOTION_TIME</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>				<comment type="block">/* gettimeofday */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* #define CDB_MOTION_DEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>	<comment type="block">/* getTypeOutputInfo */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>		<comment type="block">/* StringInfo */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*=========================================================================
 * FUNCTIONS PROTOTYPES
 */</comment>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>execMotionSender</name><parameter_list>(<parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>execMotionUnsortedReceiver</name><parameter_list>(<parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>execMotionSortedReceiver</name><parameter_list>(<parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CdbMergeComparator</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>evalHashKey</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashkeys</name></decl></parameter>, <parameter><decl><type><name>CdbHash</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doSendEndOfStream</name><parameter_list>(<parameter><decl><type><name>Motion</name> <modifier>*</modifier></type><name>motion</name></decl></parameter>, <parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doSendTuple</name><parameter_list>(<parameter><decl><type><name>Motion</name> <modifier>*</modifier></type><name>motion</name></decl></parameter>, <parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*=========================================================================
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>formatTuple</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>outputFunArray</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name><name>outputFunArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  %s=\"%.30s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  \"%.30s\""</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecMotion
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecMotion</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>MotionState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check for interrupts. Without this we've seen the scenario before that
	 * it could be quite slow to cancel a query that selects all the tuples
	 * from a big distributed table because the motion node on QD has no chance
	 * of checking the cancel signal.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sanity check */</comment>
 	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>stopRequested</name></name></expr>)</condition><block type="pseudo"><block_content>
 		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
 				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
 				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected internal error"</literal></expr></argument>)</argument_list></call><operator>,</operator>
 				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Already stopped motion node is executed again, data will lost"</literal></expr></argument>)</argument_list></call><operator>,</operator>
 				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Likely motion node is incorrectly squelched earlier"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * at the top here we basically decide: -- SENDER vs. RECEIVER and --
	 * SORTED vs. UNSORTED
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mstype</name></name> <operator>==</operator> <name>MOTIONSTATE_RECV</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEASURE_MOTION_TIME</name></cpp:ifdef>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>startTime</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>stopTime</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startTime</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>active_recv_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>active_recv_id</name></name> <operator>!=</operator> <name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * See motion_sanity_walker() for details on how a deadlock
				 * may occur.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DEADLOCK HAZARD: Updating active_motion_id from %d to %d"</literal></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>active_recv_id</name></name></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>active_recv_id</name></name> <operator>=</operator> <name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>active_recv_id</name></name> <operator>=</operator> <name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>motion</name><operator>-&gt;</operator><name>sendSorted</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>execMotionSortedReceiver</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>execMotionUnsortedReceiver</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * We tell the upper node as if this was the end of tuple stream if
		 * query-finish is requested.  Unlike other nodes, we skipped this
		 * check in ExecProc because this node in sender mode should send EoS
		 * to the receiver side, but the receiver side can simply stop
		 * processing the stream.  The sender side of this stream could still
		 * be sending more tuples, but this slice will eventually clean up the
		 * executor and eventually Stop message will be delivered to the
		 * sender side.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>QueryFinishPending</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>active_recv_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEASURE_MOTION_TIME</name></cpp:ifdef>
		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stopTime</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_sec</name></name> <operator>+=</operator> <name><name>stopTime</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>startTime</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <name><name>stopTime</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>startTime</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>&gt;=</operator> <literal type="number">1000000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>-=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_sec</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><name>tuple</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mstype</name></name> <operator>==</operator> <name>MOTIONSTATE_SEND</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>execMotionSender</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot execute inactive Motion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>execMotionSender</name><parameter_list>(<parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* SENDER LOGIC */</comment>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEASURE_MOTION_TIME</name></cpp:ifdef>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>time1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>time2</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER</name> <operator>||</operator>
				<name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER_SINGLE</name> <operator>||</operator>
				<name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_HASH</name> <operator>||</operator>
				<name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_BROADCAST</name> <operator>||</operator>
				<operator>(</operator><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_EXPLICIT</name> <operator>&amp;&amp;</operator> <name><name>motion</name><operator>-&gt;</operator><name>segidColIdx</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* grab TupleTableSlot from our child. */</comment>
		<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEASURE_MOTION_TIME</name></cpp:ifdef>
		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_sec</name></name> <operator>+=</operator> <name><name>time2</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>time1</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <name><name>time2</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>time1</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_usec</name></name> <operator>&gt;=</operator> <literal type="number">1000000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_usec</name></name> <operator>-=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_sec</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>done</name> <operator>||</operator> <call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>doSendEndOfStream</name><argument_list>(<argument><expr><name>motion</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER_SINGLE</name> <operator>&amp;&amp;</operator>
				 <name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name> <operator>!=</operator> <operator>(</operator><name>gp_session_id</name> <operator>%</operator> <name><name>node</name><operator>-&gt;</operator><name>numInputSegs</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For explicit gather motion, receiver gets data from one
			 * segment only. The others execute the subplan normally, but
			 * throw away the resulting tuples.
			 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>doSendTuple</name><argument_list>(<argument><expr><name>motion</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* doSendTuple() may have set node-&gt;stopRequested as a side-effect */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>stopRequested</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>gp_workfile_caching_loglevel</name></expr></argument>, <argument><expr><literal type="string">"Motion calling Squelch on child node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* propagate stop notification to our children */</comment>
				<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEASURE_MOTION_TIME</name></cpp:ifdef>
		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_sec</name></name> <operator>+=</operator> <name><name>time1</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>time2</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <name><name>time1</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>time2</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>&gt;=</operator> <literal type="number">1000000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>-=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_sec</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>numTuplesFromChild</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>numTuplesToAMS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* nothing else to send out, so we return NULL up the tree. */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>execMotionUnsortedReceiver</name><parameter_list>(<parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* RECEIVER LOGIC */</comment>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER</name> <operator>||</operator>
				<name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER_SINGLE</name> <operator>||</operator>
				<name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_HASH</name> <operator>||</operator>
				<name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_BROADCAST</name> <operator>||</operator>
				<operator>(</operator><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_EXPLICIT</name> <operator>&amp;&amp;</operator> <name><name>motion</name><operator>-&gt;</operator><name>segidColIdx</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>stopRequested</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendStopMessage</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
						<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>,
						<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_got_eos</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We could only possibly get here in the following scenario:
			 * 1. We are QD gracefully aborting a transaction.
			 * 2. We have torn down the interconnect of the current slice.
			 * 3. Since an error has happened, we no longer need to finish fetching
			 * all the tuples, hence squelching the executor subtree.
			 * 4. We are in the process of ExecSquelchShareInputScan(), and the
			 * Shared Scan has this Motion below it.
			 *
			 * NB: if you need to change this, see also execMotionSortedReceiver()
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"An ERROR must have happened. Stopping a Shared Scan."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect is down unexpectedly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>RecvTupleFrom</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
						  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>,
						  <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>, <argument><expr><name>ANY_ROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuple</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"motionID=%d saw end of stream"</literal></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromChild</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToAMS</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* store it in our result slot and return this. */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* shouldFree */</comment> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name> <operator>&lt;=</operator> <literal type="number">20</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"   motion%-3d rcv      %5d."</literal></expr></argument>,
						 <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formatTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>outputFunArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * General background on Sorted Motion:
 * -----------------------------------
 * NOTE: This function is only used for order-preserving motion.  There are
 * only 2 types of motion that order-preserving makes sense for: FIXED and
 * BROADCAST (HASH does not make sense). so we have:
 *
 * CASE 1:	 broadcast order-preserving fixed motion.  This should only be
 *			 called for SENDERs.
 *
 * CASE 2:	 single-destination order-preserving fixed motion.	The SENDER
 *			 side will act like Unsorted motion and won't call this. So only
 *			 the RECEIVER should be called for this case.
 *
 *
 * Sorted Receive Notes:
 * --------------------
 *
 * The 1st time we execute, we need to pull a tuple from each of our source
 * and store them in our tupleheap.  Once that is done, we can pick the lowest
 * (or whatever the criterion is) value from amongst all the sources.  This
 * works since each stream is sorted itself.
 *
 * We keep track of which one was selected, this will be slot we will need
 * to fill during the next call.
 *
 * Subsequent calls to this function (after the 1st time) will start by
 * trying to receive a tuple for the slot that was emptied the previous call.
 * Then we again select the lowest value and return that tuple.
 */</comment>

<comment type="block">/* Sorted receiver using binary heap */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>execMotionSortedReceiver</name><parameter_list>(<parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>binaryheap</name> <modifier>*</modifier></type><name>hp</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>tupleheap</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>inputTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER</name> <operator>&amp;&amp;</operator>
				<name><name>motion</name><operator>-&gt;</operator><name>sendSorted</name></name> <operator>&amp;&amp;</operator>
				<name>hp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Notify senders and return EOS if caller doesn't want any more data. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>stopRequested</name></name></expr>)</condition>
	<block>{<block_content>

		<expr_stmt><expr><call><name>SendStopMessage</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
						<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>,
						<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_got_eos</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We could only possibly get here in the following scenario:
			 * 1. We are QD gracefully aborting a transaction.
			 * 2. We have torn down the interconnect of the current slice.
			 * 3. Since an error has happened, we no longer need to finish fetching
			 * all the tuples, hence squelching the executor subtree.
			 * 4. We are in the process of ExecSquelchShareInputScan(), and the
			 * Shared Scan has this Motion below it.
			 *
			 * NB: if you need to change this, see also execMotionUnsortedReceiver()
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"An ERROR must have happened. Stopping a Shared Scan."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect is down unexpectedly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * On first call, fill the priority queue with each sender's first tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>tupleheapReady</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>inputTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>binaryheap</name> <modifier>*</modifier></type><name>hp</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>tupleheap</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>iSegIdx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcProcess</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>sendSlice</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>==</operator> <name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach_with_count</name><argument_list>(<argument>lcProcess</argument>, <argument>sendSlice-&gt;primaryProcesses</argument>, <argument>iSegIdx</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcProcess</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* skip this one: we are not receiving from it */</comment>

			<expr_stmt><expr><name>inputTuple</name> <operator>=</operator> <call><name>RecvTupleFrom</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
									   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>,
									   <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>, <argument><expr><name>iSegIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inputTuple</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* skip this one: received nothing */</comment>

			<comment type="block">/*
			 * Make a slot to hold this tuple. We will reuse it to hold any
			 * future tuples from the same sender. We initialized the result
			 * tuple slot with the correct type earlier, so make the new slot
			 * have the same type.
			 */</comment>
			<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>iSegIdx</name></expr>]</index></name> <operator>=</operator> <call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Store the tuple in the slot, and add it to the heap.
			 *
			 * Use slot_getsomeattrs() to materialize the columns we need for
			 * the comparisons in the tts_values/isnull arrays. The comparator
			 * can then peek directly into the arrays, which is cheaper than
			 * calling slot_getattr() all the time.
			 */</comment>
			<expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>inputTuple</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>iSegIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>iSegIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>lastSortColIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>binaryheap_add_unordered</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><name>iSegIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name> <operator>&lt;=</operator> <literal type="number">20</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"   motion%-3d rcv&lt;-%-3d %5d."</literal></expr></argument>,
								 <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
								 <argument><expr><name>iSegIdx</name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>formatTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>iSegIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>outputFunArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>iSegIdx</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>numInputSegs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Done adding the elements, now arrange the heap to satisfy the heap
		 * property. This is quicker than inserting the initial elements one by
		 * one.
		 */</comment>
		<expr_stmt><expr><call><name>binaryheap_build</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tupleheapReady</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Delete from the priority queue the element that we fetched last time.
	 * Receive and insert the next tuple from that same sender.
	 */</comment>
	<else>else
	<block>{<block_content>
		<comment type="block">/* sanity check */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>binaryheap_empty</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"sorted Gather Motion called again after already receiving all data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Old element is still at the head of the pq. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>binaryheap_first</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Receive the successor of the tuple that we returned last time. */</comment>
		<expr_stmt><expr><name>inputTuple</name> <operator>=</operator> <call><name>RecvTupleFrom</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>,
								   <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Substitute it in the pq for its predecessor. */</comment>
		<if_stmt><if>if <condition>(<expr><name>inputTuple</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>inputTuple</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>lastSortColIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>binaryheap_replace_first</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name> <operator>&lt;=</operator> <literal type="number">20</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"   motion%-3d rcv&lt;-%-3d %5d."</literal></expr></argument>,
								 <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>formatTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>outputFunArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* At EOS, drop this sender from the priority queue. */</comment>
			<expr_stmt><expr><call><name>binaryheap_remove_first</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Finished if all senders have returned EOS. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>binaryheap_empty</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromChild</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToAMS</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Our next result tuple, with lowest key among all senders, is now at the
	 * head of the priority queue.  Get it from there.
	 *
	 * We transfer ownership of the tuple from the pq element to our caller,
	 * but the pq element itself will remain in place until the next time we
	 * are called, to avoid an unnecessary rearrangement of the priority
	 * queue.
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name> <operator>=</operator> <call><name>binaryheap_first</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Update counters. */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name> <operator>&lt;=</operator> <literal type="number">20</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"   motion%-3d mrg&lt;-%-3d %5d."</literal></expr></argument>,
						 <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>routeIdNext</name></name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formatTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>outputFunArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Return result slot. */</comment>
	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* execMotionSortedReceiver */</comment>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitMotion
 *
 * NOTE: have to be a bit careful, estate-&gt;es_cur_slice_idx is not the
 *		 ultimate correct value that it should be on the QE. this happens
 *		 after this call in mppexec.c.	This is ok since we don't need it,
 *		 but just be aware before you try and use it here.
 * ----------------------------------------------------------------
 */</comment>

<function><type><name>MotionState</name> <modifier>*</modifier></type>
<name>ExecInitMotion</name><parameter_list>(<parameter><decl><type><name>Motion</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>motionstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>sendSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>recvSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parentIndex</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If GDD is enabled, the lock of table may downgrade to RowExclusiveLock,
	 * (see CdbTryOpenRelation function), then EPQ would be triggered, EPQ will
	 * execute the subplan in the executor, so it will create a new EState,
	 * but there are no slice tables in the new EState and we can not AssignGangs
	 * on the QE. In this case, we raise an error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EvalPlanQual can not handle subPlan with Motion node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>motionID</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>motionID</name></name> <operator>&lt;</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_HASH</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numHashSegments</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>parentIndex</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>motionID</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>motionstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecMotion</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>mstype</name></name> <operator>=</operator> <name>MOTIONSTATE_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>hashExprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>cdbhash</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Look up the sending and receiving gang's slice table entries. */</comment>
	<expr_stmt><expr><name>sendSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>motionID</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recvSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>parentIndex</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parentIndex</name> <operator>==</operator> <name><name>sendSlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* QD must fill in the global slice table. */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER</name> <operator>||</operator>
			<name><name>node</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER_SINGLE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Sending to a single receiving process on the entry db? */</comment>
			<comment type="block">/* Is receiving slice a root slice that runs here in the qDisp? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>==</operator> <name><name>recvSlice</name><operator>-&gt;</operator><name>rootIndex</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>mstype</name></name> <operator>=</operator> <name>MOTIONSTATE_RECV</name></expr>;</expr_stmt>
				<comment type="block">/* For parallel retrieve cursor, the motion's gang type could be set as
				 * GANGTYPE_ENTRYDB_READER explicitly*/</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>recvSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name> <operator>||</operator>
					   <name><name>recvSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_ENTRYDB_READER</name> <operator>||</operator>
					   <name><name>recvSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name> <operator>||</operator>
					   <name><name>recvSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_READER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* sanity checks */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>recvSlice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected gang size: %d"</literal></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>recvSlice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/* QE must fill in map from motionID to MotionState node. */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* this is recv */</comment>
			<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>mstype</name></name> <operator>=</operator> <name>MOTIONSTATE_RECV</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* this is send */</comment>
			<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>mstype</name></name> <operator>=</operator> <name>MOTIONSTATE_SEND</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* TODO: If neither sending nor receiving, don't bother to initialize. */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>tupleheapReady</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>sentEndOfStream</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>numTuplesFromChild</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>numTuplesToAMS</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>numTuplesToParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>numInputSegs</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>motionstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initializes child nodes. If alien elimination is on, we skip children
	 * of receiver motion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>eliminateAliens</name></name> <operator>||</operator> <name><name>motionstate</name><operator>-&gt;</operator><name>mstype</name></name> <operator>==</operator> <name>MOTIONSTATE_SEND</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>motionstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * initialize tuple type.  no need to initialize projection info because
	 * this node doesn't do projections.
	 */</comment>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>motionstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize result type and slot
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>motionstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>motionstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>numHashSegments</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>numHashSegments</name></name></expr>;</expr_stmt>

	<comment type="block">/* Set up motion send data structures */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>motionstate</name><operator>-&gt;</operator><name>mstype</name></name> <operator>==</operator> <name>MOTIONSTATE_SEND</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_HASH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numHashSegments</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numHashSegments</name></name> <operator>&lt;=</operator> <name><name>recvSlice</name><operator>-&gt;</operator><name>planNumSegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nkeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>hashExprs</name></name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashExprs</name></name></expr></argument>,
													  <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>motionstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Create hash API reference
		 */</comment>
		<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>cdbhash</name></name> <operator>=</operator> <call><name>makeCdbHash</name><argument_list>(<argument><expr><name><name>motionstate</name><operator>-&gt;</operator><name>numHashSegments</name></name></expr></argument>,
										   <argument><expr><name>nkeys</name></expr></argument>,
										   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Merge Receive: Set up the key comparator and priority queue.
	 *
	 * This is very similar to a Merge Append.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sendSorted</name></name> <operator>&amp;&amp;</operator> <name><name>motionstate</name><operator>-&gt;</operator><name>mstype</name></name> <operator>==</operator> <name>MOTIONSTATE_RECV</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numInputSegs</name> <init>= <expr><name><name>motionstate</name><operator>-&gt;</operator><name>numInputSegs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>lastSortColIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Allocate array to slots for the next tuple from each sender */</comment>
		<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>slots</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numInputSegs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleTableSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare SortSupport data for each column */</comment>
		<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>=</operator> <operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><operator>&amp;</operator><name><name>motionstate</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_collation</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PrepareSortSupportFromOrderingOp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Also make note of the last column used in the sort key */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>lastSortColIdx</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lastSortColIdx</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>lastSortColIdx</name></name> <operator>=</operator> <name>lastSortColIdx</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>tupleheap</name></name> <operator>=</operator>
			<call><name>binaryheap_allocate</name><argument_list>(<argument><expr><name><name>motionstate</name><operator>-&gt;</operator><name>numInputSegs</name></name></expr></argument>,
								<argument><expr><name>CdbMergeComparator</name></expr></argument>,
								<argument><expr><name>motionstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Perform per-node initialization in the motion layer.
	 */</comment>
	<expr_stmt><expr><call><name>UpdateMotionLayerNode</name><argument_list>(<argument><expr><name><name>motionstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
						  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
						  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sendSorted</name></name></expr></argument>,
						  <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><name><name>motionstate</name><operator>-&gt;</operator><name>outputFunArray</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>motionstate</name><operator>-&gt;</operator><name>outputFunArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name>parentIndex</name></expr>;</expr_stmt>

	<return>return <expr><name>motionstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndMotion(node)
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndMotion</name><parameter_list>(<parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEASURE_MOTION_TIME</name></cpp:ifdef>
	<decl_stmt><decl><type><name>double</name></type>		<name>otherTimeSec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>motionTimeSec</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean out the tuple table
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the slice no for the nodes under this motion.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * shut down the subplan
	 */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEASURE_MOTION_TIME</name></cpp:ifdef>
	<expr_stmt><expr><name>motionTimeSec</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>motionTime</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mstype</name></name> <operator>==</operator> <name>MOTIONSTATE_RECV</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"Motion Node %d (RECEIVER) Statistics:\n"</literal>
			 <literal type="string">"Timing:  \n"</literal>
			 <literal type="string">"\t Time receiving the tuple: %f sec\n"</literal>
			 <literal type="string">"Counters: \n"</literal>
			 <literal type="string">"\tnumTuplesFromChild: %d\n"</literal>
			 <literal type="string">"\tnumTuplesFromAMS: %d\n"</literal>
			 <literal type="string">"\tnumTuplesToAMS: %d\n"</literal>
			 <literal type="string">"\tnumTuplesToParent: %d\n"</literal></expr></argument>,
			 <argument><expr><name>motNodeID</name></expr></argument>,
			 <argument><expr><name>motionTimeSec</name></expr></argument>,
			 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromChild</name></name></expr></argument>,
			 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromAMS</name></name></expr></argument>,
			 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToAMS</name></name></expr></argument>,
			 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mstype</name></name> <operator>==</operator> <name>MOTIONSTATE_SEND</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>otherTimeSec</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>otherTime</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"Motion Node %d (SENDER) Statistics:\n"</literal>
			 <literal type="string">"Timing:  \n"</literal>
			 <literal type="string">"\t Time getting next tuple to send: %f sec \n"</literal>
			 <literal type="string">"\t Time sending the tuple:          %f  sec\n"</literal>
			 <literal type="string">"\t Percentage of time sending:      %2.2f%% \n"</literal>
			 <literal type="string">"Counters: \n"</literal>
			 <literal type="string">"\tnumTuplesFromChild: %d\n"</literal>
			 <literal type="string">"\tnumTuplesToAMS: %d\n"</literal></expr></argument>,
			 <argument><expr><name>motNodeID</name></expr></argument>,
			 <argument><expr><name>otherTimeSec</name></expr></argument>,
			 <argument><expr><name>motionTimeSec</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>motionTimeSec</name> <operator>/</operator> <operator>(</operator><name>otherTimeSec</name> <operator>+</operator> <name>motionTimeSec</name><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">100</literal></expr></argument>,
			 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromChild</name></name></expr></argument>,
			 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToAMS</name></name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* MEASURE_MOTION_TIME */</comment>

	<comment type="block">/* Merge Receive: Free the priority queue and associated structures. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tupleheap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>binaryheap_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tupleheap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tupleheap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free the slices and routes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>cdbhash</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cdbhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cdbhash</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Free up this motion node's resources in the Motion Layer.
	 *
	 * TODO: For now, we don't flush the comm-layer.  NO ERRORS DURING AMS!!!
	 */</comment>
	<expr_stmt><expr><call><name>EndMotionLayerNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
					   <comment type="block">/* flush-comm-layer */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>outputFunArray</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>outputFunArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>



<comment type="block">/*=========================================================================
 * HELPER FUNCTIONS
 */</comment>

<comment type="block">/*
 * CdbMergeComparator:
 * Used to compare tuples for a sorted motion node.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CdbMergeComparator</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>MotionState</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lSegIdx</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rSegIdx</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>lslot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>lSegIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>rslot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>rSegIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortSupport</name></type>	<name>sortKeys</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compare</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lslot</name> <operator>&amp;&amp;</operator> <name>rslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>nkey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nkey</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr>;</condition> <incr><expr><name>nkey</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>&amp;</operator><name><name>sortKeys</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_attno</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum1</name></decl>,
					<decl><type ref="prev"/><name>datum2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>,
					<decl><type ref="prev"/><name>isnull2</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The caller has called slot_getsomeattrs() to ensure
		 * that all the columns we need are available directly in
		 * the values/isnull arrays.
		 */</comment>
		<expr_stmt><expr><name>datum1</name> <operator>=</operator> <name><name>lslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull1</name> <operator>=</operator> <name><name>lslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum2</name> <operator>=</operator> <name><name>rslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull2</name> <operator>=</operator> <name><name>rslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>datum1</name></expr></argument>, <argument><expr><name>isnull1</name></expr></argument>,
									  <argument><expr><name>datum2</name></expr></argument>, <argument><expr><name>isnull2</name></expr></argument>,
									  <argument><expr><name>ssup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INVERT_COMPARE_RESULT</name><argument_list>(<argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>compare</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* CdbMergeComparator */</comment>

<comment type="block">/*
 * Experimental code that will be replaced later with new hashing mechanism
 */</comment>
<function><type><name>uint32</name></type>
<name>evalHashKey</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashkeys</name></decl></parameter>, <parameter><decl><type><name>CdbHash</name> <modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>hk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>target_seg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have 1 or more distribution keys for this relation, hash them.
	 * However, If this happens to be a relation with an empty policy
	 * (partitioning policy with a NULL distribution key list) then we have no
	 * hash key value to feed in, so use cdbhashrandomseg() to pick a segment
	 * at random.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>hashkeys</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cdbhashinit</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>hk</argument>, <argument>hashkeys</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>keyexpr</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>keyval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Get the attribute value of the tuple
			 */</comment>
			<expr_stmt><expr><name>keyval</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>keyexpr</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Compute the hash function
			 */</comment>
			<expr_stmt><expr><call><name>cdbhash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>keyval</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>target_seg</name> <operator>=</operator> <call><name>cdbhashreduce</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>target_seg</name> <operator>=</operator> <call><name>cdbhashrandomseg</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>numsegs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>target_seg</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>doSendEndOfStream</name><parameter_list>(<parameter><decl><type><name>Motion</name> <modifier>*</modifier></type><name>motion</name></decl></parameter>, <parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We have no more child tuples, but we have not successfully sent an
	 * End-of-Stream token yet.
	 */</comment>
	<expr_stmt><expr><call><name>SendEndOfStream</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
					<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>,
					<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sentEndOfStream</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A crufty confusing part of the current code is how contentId is used within
 * the motion structures and then how that gets translated to targetRoutes by
 * this motion nodes.
 *
 * WARNING: There are ALOT of assumptions in here about how the motion node
 *			instructions are encoded into motion and stuff.
 *
 * There are 3 types of sending that can happen here:
 *
 *	FIXED - sending to a single process.  the value in node-&gt;fixedSegIdxMask[0]
 *			is the contentId of who to send to.  But we can actually ignore that
 *			since now with slice tables, we should only have a single CdbProcess
 *			that we could send to for this motion node.
 *
 *
 *	BROADCAST - actually a subcase of FIXED, but handling is simple. send to all
 *				of our routes.
 *
 *	HASH -	maps hash values to segid.	this mapping is 1-&gt;1 such that a hash
 *			value of 2 maps to contentid of 2 (for now).  Since we can't ever
 *			use Hash to send to the QD, the QD's contentid of -1 is not an issue.
 *			Also, the contentid maps directly to the routeid.
 *
 */</comment>
<function><type><name>void</name></type>
<name>doSendTuple</name><parameter_list>(<parameter><decl><type><name>Motion</name> <modifier>*</modifier></type><name>motion</name></decl></parameter>, <parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>targetRoute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SendReturnCode</name></type> <name>sendRC</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We got a tuple from the child-plan. */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesFromChild</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER</name> <operator>||</operator>
		<name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER_SINGLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Actually, since we can only send to a single output segment
		 * here, we are guaranteed that we only have a single targetRoute
		 * setup that we could possibly send to.  So we can cheat and just
		 * fix the targetRoute to 0 (the 1st route).
		 */</comment>
		<expr_stmt><expr><name>targetRoute</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_BROADCAST</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>targetRoute</name> <operator>=</operator> <name>BROADCAST_SEGIDX</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_HASH</name></expr>)</condition> <comment type="block">/* Redistribute */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>hval</name> <operator>=</operator> <call><name>evalHashKey</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashExprs</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cdbhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hval</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numHashSegments</name></name> <operator>&amp;&amp;</operator>
			   <literal type="string">"redistribute destination outside segment array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ASSERT_CHECKING */</comment>

		<comment type="block">/*
		 * hashSegIdx takes our uint32 and maps it to an int, and here we
		 * assign it to an int16. See below.
		 */</comment>
		<expr_stmt><expr><name>targetRoute</name> <operator>=</operator> <name>hval</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * see MPP-2099, let's not run into this one again! NOTE: the
		 * definition of BROADCAST_SEGIDX is key here, it *cannot* be a valid
		 * route which our map (above) will *ever* return.
		 *
		 * Note the "mapping" is generated at *planning* time in
		 * makeDefaultSegIdxArray() in cdbmutate.c (it is the trivial map, and
		 * is passed around our system a fair amount!).
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetRoute</name> <operator>!=</operator> <name>BROADCAST_SEGIDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_EXPLICIT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>segidColIdxDatum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>segidColIdx</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>motion</name><operator>-&gt;</operator><name>segidColIdx</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><name><name>motion</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>.</operator><name>targetlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>segidColIdxDatum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>segidColIdx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetRoute</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>segidColIdxDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown motion type %d"</literal></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>CheckAndSendRecordCache</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
							<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>,
							<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
							<argument><expr><name>targetRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* send the tuple out. */</comment>
	<expr_stmt><expr><name>sendRC</name> <operator>=</operator> <call><name>SendTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
					   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>,
					   <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
					   <argument><expr><name>outerTupleSlot</name></expr></argument>,
					   <argument><expr><name>targetRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sendRC</name> <operator>==</operator> <name>SEND_COMPLETE</name> <operator>||</operator> <name>sendRC</name> <operator>==</operator> <name>STOP_SENDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sendRC</name> <operator>==</operator> <name>SEND_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToAMS</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CDB_MOTION_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>sendRC</name> <operator>==</operator> <name>SEND_COMPLETE</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>numTuplesToAMS</name></name> <operator>&lt;=</operator> <literal type="number">20</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"   motion%-3d snd-&gt;%-3d, %5d."</literal></expr></argument>,
						 <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>,
						 <argument><expr><name>targetRoute</name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numTuplesToAMS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formatTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>outerTupleSlot</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>outputFunArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * ExecReScanMotion
 *
 * Motion nodes do not allow rescan after a tuple has been fetched.
 *
 * When the planner knows that a NestLoop cannot have more than one outer
 * tuple, it can omit the usual Materialize operator atop the inner subplan,
 * which can lead to invocation of ExecReScanMotion before the motion node's
 * first tuple is fetched.  Rescan can be implemented as a no-op in this case.
 * (After ExecNestLoop fetches an outer tuple, it invokes rescan on the inner
 * subplan before fetching the first inner tuple.  That doesn't bother us,
 * provided there is only one outer tuple.)
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanMotion</name><parameter_list>(<parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mstype</name></name> <operator>!=</operator> <name>MOTIONSTATE_RECV</name> <operator>||</operator>
		<name><name>node</name><operator>-&gt;</operator><name>numTuplesToParent</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"illegal rescan of motion node: invalid plan"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Likely caused by bad NL-join, try setting enable_nestloop to off"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Mark this node as "stopped." When ExecProcNode() is called on a
 * stopped motion node it should behave as if there are no tuples
 * available.
 *
 * ExecProcNode() on a stopped motion node should also notify the
 * "other end" of the motion node of the stoppage.
 *
 * Note: once this is called, it is possible that the motion node will
 * never be called again, so we *must* send the stop message now.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSquelchMotion</name><parameter_list>(<parameter><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>motion</name> <operator>=</operator> <operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>active_recv_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* pass down */</comment>
	<expr_stmt><expr><call><name>SendStopMessage</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>,
					<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>,
					<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
