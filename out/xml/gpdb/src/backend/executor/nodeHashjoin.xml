<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/nodeHashjoin.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeHashjoin.c
 *	  Routines to handle hash join nodes
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeHashjoin.c
 *
 * PARALLELISM
 *
 * Hash joins can participate in parallel query execution in several ways.  A
 * parallel-oblivious hash join is one where the node is unaware that it is
 * part of a parallel plan.  In this case, a copy of the inner plan is used to
 * build a copy of the hash table in every backend, and the outer plan could
 * either be built from a partial or complete path, so that the results of the
 * hash join are correspondingly either partial or complete.  A parallel-aware
 * hash join is one that behaves differently, coordinating work between
 * backends, and appears as Parallel Hash Join in EXPLAIN output.  A Parallel
 * Hash Join always appears with a Parallel Hash node.
 *
 * Parallel-aware hash joins use the same per-backend state machine to track
 * progress through the hash join algorithm as parallel-oblivious hash joins.
 * In a parallel-aware hash join, there is also a shared state machine that
 * co-operating backends use to synchronize their local state machines and
 * program counters.  The shared state machine is managed with a Barrier IPC
 * primitive.  When all attached participants arrive at a barrier, the phase
 * advances and all waiting participants are released.
 *
 * When a participant begins working on a parallel hash join, it must first
 * figure out how much progress has already been made, because participants
 * don't wait for each other to begin.  For this reason there are switch
 * statements at key points in the code where we have to synchronize our local
 * state machine with the phase, and then jump to the correct part of the
 * algorithm so that we can get started.
 *
 * One barrier called build_barrier is used to coordinate the hashing phases.
 * The phase is represented by an integer which begins at zero and increments
 * one by one, but in the code it is referred to by symbolic names as follows:
 *
 *   PHJ_BUILD_ELECTING              -- initial state
 *   PHJ_BUILD_ALLOCATING            -- one sets up the batches and table 0
 *   PHJ_BUILD_HASHING_INNER         -- all hash the inner rel
 *   PHJ_BUILD_HASHING_OUTER         -- (multi-batch only) all hash the outer
 *   PHJ_BUILD_DONE                  -- building done, probing can begin
 *
 * While in the phase PHJ_BUILD_HASHING_INNER a separate pair of barriers may
 * be used repeatedly as required to coordinate expansions in the number of
 * batches or buckets.  Their phases are as follows:
 *
 *   PHJ_GROW_BATCHES_ELECTING       -- initial state
 *   PHJ_GROW_BATCHES_ALLOCATING     -- one allocates new batches
 *   PHJ_GROW_BATCHES_REPARTITIONING -- all repartition
 *   PHJ_GROW_BATCHES_FINISHING      -- one cleans up, detects skew
 *
 *   PHJ_GROW_BUCKETS_ELECTING       -- initial state
 *   PHJ_GROW_BUCKETS_ALLOCATING     -- one allocates new buckets
 *   PHJ_GROW_BUCKETS_REINSERTING    -- all insert tuples
 *
 * If the planner got the number of batches and buckets right, those won't be
 * necessary, but on the other hand we might finish up needing to expand the
 * buckets or batches multiple times while hashing the inner relation to stay
 * within our memory budget and load factor target.  For that reason it's a
 * separate pair of barriers using circular phases.
 *
 * The PHJ_BUILD_HASHING_OUTER phase is required only for multi-batch joins,
 * because we need to divide the outer relation into batches up front in order
 * to be able to process batches entirely independently.  In contrast, the
 * parallel-oblivious algorithm simply throws tuples 'forward' to 'later'
 * batches whenever it encounters them while scanning and probing, which it
 * can do because it processes batches in serial order.
 *
 * Once PHJ_BUILD_DONE is reached, backends then split up and process
 * different batches, or gang up and work together on probing batches if there
 * aren't enough to go around.  For each batch there is a separate barrier
 * with the following phases:
 *
 *  PHJ_BATCH_ELECTING       -- initial state
 *  PHJ_BATCH_ALLOCATING     -- one allocates buckets
 *  PHJ_BATCH_LOADING        -- all load the hash table from disk
 *  PHJ_BATCH_PROBING        -- all probe
 *  PHJ_BATCH_DONE           -- end
 *
 * Batch 0 is a special case, because it starts out in phase
 * PHJ_BATCH_PROBING; populating batch 0's hash table is done during
 * PHJ_BUILD_HASHING_INNER so we can skip loading.
 *
 * Initially we try to plan for a single-batch hash join using the combined
 * work_mem of all participants to create a large shared hash table.  If that
 * turns out either at planning or execution time to be impossible then we
 * fall back to regular work_mem sized hash tables.
 *
 * To avoid deadlocks, we never wait for any barrier unless it is known that
 * all other backends attached to it are actively executing the node or have
 * already arrived.  Practically, that means that we never return a tuple
 * while attached to a barrier, unless the barrier has reached its final
 * state.  In the slightly special case of the per-batch barrier, we return
 * tuples while in PHJ_BATCH_PROBING phase, but that's OK because we use
 * BarrierArriveAndDetach() to advance it to PHJ_BATCH_DONE without waiting.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/hashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>	<comment type="block">/* Instrumentation */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sharedtuplestore.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>			<comment type="block">/* work_mem */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<comment type="block">/*
 * States of the ExecHashJoin state machine
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_BUILD_HASHTABLE</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_NEED_NEW_OUTER</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_SCAN_BUCKET</name></cpp:macro>			<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_FILL_OUTER_TUPLE</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_FILL_INNER_TUPLES</name></cpp:macro>	<cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_NEED_NEW_BATCH</name></cpp:macro>		<cpp:value>6</cpp:value></cpp:define>

<comment type="block">/* Returns true if doing null-fill on outer relation */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_FILL_OUTER</name><parameter_list>(<parameter><type><name>hjstate</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((hjstate)-&gt;hj_NullInnerTupleSlot != NULL)</cpp:value></cpp:define>
<comment type="block">/* Returns true if doing null-fill on inner relation */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_FILL_INNER</name><parameter_list>(<parameter><type><name>hjstate</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((hjstate)-&gt;hj_NullOuterTupleSlot != NULL)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>Test_print_prefetch_joinqual</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecHashJoinOuterGetTuple</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>outerNode</name></decl></parameter>,
												 <parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
												 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecParallelHashJoinOuterGetTuple</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>outerNode</name></decl></parameter>,
														 <parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
														 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecHashJoinGetSavedTuple</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
												 <parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
												 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>,
												 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecHashJoinNewBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isNotDistinctJoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qualList</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelHashJoinNewBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecParallelHashJoinPartitionOuter</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseHashTable</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SpillCurrentBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecHashJoinReloadHashTable</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecEagerFreeHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecHashJoinImpl
 *
 *		This function implements the Hybrid Hashjoin algorithm.  It is marked
 *		with an always-inline attribute so that ExecHashJoin() and
 *		ExecParallelHashJoin() can inline it.  Compilers that respect the
 *		attribute should create versions specialized for parallel == true and
 *		parallel == false with unnecessary branches removed.
 *
 *		Note: the relation we build hash table on is the "inner"
 *			  the other one is "outer".
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>pg_attribute_always_inline</name> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecHashJoinImpl</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parallel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>HashJoinState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>joinqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>otherqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>batchno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallel_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get information from HashJoin node
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>joinqual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>joinqual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>otherqual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashNode</name> <operator>=</operator> <operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parallel_state</name> <operator>=</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>parallel_state</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset per-tuple memory context to free any expression evaluation
	 * storage allocated in the previous tuple cycle.
	 */</comment>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * run the hash join state machine
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* We must never use an eagerly released hash table */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hashtable</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>hashtable</name><operator>-&gt;</operator><name>eagerlyReleased</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * It's possible to iterate this loop many times before returning a
		 * tuple, in some pathological cases such as needing to move much of
		 * the current batch to a later batch.  So let's check for interrupts
		 * each time through.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HJ_BUILD_HASHTABLE</name></expr>:</case>

				<comment type="block">/*
				 * First time through: build hash table for inner relation.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hashtable</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * MPP-4165: My fix for MPP-3300 was correct in that we avoided
				 * the *deadlock* but had very unexpected (and painful)
				 * performance characteristics: we basically de-pipeline and
				 * de-parallelize execution of any query which has motion below
				 * us.
				 *
				 * So now prefetch_inner is set (see createplan.c) if we have *any* motion
				 * below us. If we don't have any motion, it doesn't matter.
				 *
				 * See motion_sanity_walker() for details on how a deadlock may occur.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>prefetch_inner</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If the outer relation is completely empty, and it's not
					 * right/full join, we can quit without building the hash
					 * table.  However, for an inner join it is only a win to
					 * check this when the outer relation's startup cost is less
					 * than the projected cost of building the hash table.
					 * Otherwise it's best to build the hash table first and see
					 * if the inner relation is empty.  (When it's a left join, we
					 * should always make this check, since we aren't going to be
					 * able to skip the join on the strength of an empty inner
					 * relation anyway.)
					 *
					 * If we are rescanning the join, we make use of information
					 * gained on the previous scan: don't bother to try the
					 * prefetch if the previous scan found the outer relation
					 * nonempty. This is not 100% reliable since with new
					 * parameters the outer relation might yield different
					 * results, but it's a good heuristic.
					 *
					 * The only way to make the check is to try to fetch a tuple
					 * from the outer plan node.  If we succeed, we have to stash
					 * it away for later consumption by ExecHashJoinOuterGetTuple.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* no chance to not build the hash table */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>parallel</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The empty-outer optimization is not implemented for
						 * shared hash tables, because no one participant can
						 * determine that there are no outer tuples, and it's not
						 * yet clear that it's worth the synchronization overhead
						 * of reaching consensus to figure that out.  So we have
						 * to build the hash table.
						 */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator>
						 <operator>(</operator><name><name>outerNode</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&lt;</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&amp;&amp;</operator>
						  <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<return>return <expr><name>NULL</name></expr>;</return>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* see MPP-989 comment above, for now we assume that we have
					* at least one row on the outer. */</comment>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * Create the hash table.  If using Parallel Hash, then
				 * whoever gets here first will create the hash table and any
				 * later arrivals will merely attach to it.
				 */</comment>
				<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <call><name>ExecHashTableCreate</name><argument_list>(<argument><expr><name>hashNode</name></expr></argument>,
												<argument><expr><name>node</name></expr></argument>,
												<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashOperators</name></name></expr></argument>,
												<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_Collations</name></name></expr></argument>,
				<comment type="block">/*
				 * hashNode-&gt;hs_keepnull is required to support using IS NOT DISTINCT FROM as hash condition
				 * For example, in ORCA, `explain SELECT t2.a FROM t2 INTERSECT (SELECT t1.a FROM t1);`
				 */</comment>
												<argument><expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>hs_keepnull</name></name></expr></argument>,
												<argument><expr><call><name>PlanStateOperatorMemKB</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hashNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * CDB: Offer extra info for EXPLAIN ANALYZE.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>&amp;</operator> <name>INSTRUMENT_CDB</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecHashTableExplainInit</name><argument_list>(<argument><expr><name>hashNode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Only if doing a LASJ_NOTIN join, we want to quit as soon as we find
				 * a NULL key on the inner side
				 */</comment>
				<expr_stmt><expr><name><name>hashNode</name><operator>-&gt;</operator><name>hs_quit_if_hashkeys_null</name></name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LASJ_NOTIN</name><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * Execute the Hash node, to build the hash table.  If using
				 * Parallel Hash, then we'll try to help hashing unless we
				 * arrived too late.
				 */</comment>
				<expr_stmt><expr><name><name>hashNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MultiExecProcNode</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hashNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>gp_workfile_caching_loglevel</name></expr></argument>, <argument><expr><literal type="string">"HashJoin built table with %.1f tuples by executing subplan for batch 0"</literal></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<comment type="block" format="doxygen">/**
				 * If LASJ_NOTIN and a null was found on the inner side, then clean out.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LASJ_NOTIN</name> <operator>&amp;&amp;</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>hs_hashkeys_null</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If the inner relation is completely empty, and we're not
				 * doing a left outer join, we can quit without scanning the
				 * outer relation.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Prefetch JoinQual or NonJoinQual to prevent motion hazard.
				 *
				 * See ExecPrefetchQual() for details.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_joinqual</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExecPrefetchQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>js</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_joinqual</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_qual</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExecPrefetchQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>js</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_qual</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We just scanned the entire inner side and built the hashtable
				 * (and its overflow batches). Check here and remember if the inner
				 * side is empty.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_InnerEmpty</name></name> <operator>=</operator> <operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * need to remember whether nbatch has increased since we
				 * began scanning the outer relation
				 */</comment>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_outstart</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Reset OuterNotEmpty for scan.  (It's OK if we fetched a
				 * tuple above, because ExecHashJoinOuterGetTuple will
				 * immediately set it again.)
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Barrier</name>    <modifier>*</modifier></type><name>build_barrier</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>build_barrier</name> <operator>=</operator> <operator>&amp;</operator><name><name>parallel_state</name><operator>-&gt;</operator><name>build_barrier</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BarrierPhase</name><argument_list>(<argument><expr><name>build_barrier</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PHJ_BUILD_HASHING_OUTER</name> <operator>||</operator>
						   <call><name>BarrierPhase</name><argument_list>(<argument><expr><name>build_barrier</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PHJ_BUILD_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>BarrierPhase</name><argument_list>(<argument><expr><name>build_barrier</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PHJ_BUILD_HASHING_OUTER</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * If multi-batch, we need to hash the outer relation
						 * up front.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ExecParallelHashJoinPartitionOuter</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>BarrierArriveAndWait</name><argument_list>(<argument><expr><name>build_barrier</name></expr></argument>,
											 <argument><expr><name>WAIT_EVENT_HASH_BUILD_HASHING_OUTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BarrierPhase</name><argument_list>(<argument><expr><name>build_barrier</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PHJ_BUILD_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Each backend should now select a batch to work on. */</comment>
					<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_BATCH</name></expr>;</expr_stmt>

					<continue>continue;</continue>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>HJ_NEED_NEW_OUTER</name></expr>:</case>

				<comment type="block">/* For a rescannable hash table we might need to reload batch 0 during rescan */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>hashtable</name><operator>-&gt;</operator><name>first_pass</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecHashJoinReloadHashTable</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We don't have an outer tuple, try to get the next one
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator>
						<call><name>ExecParallelHashJoinOuterGetTuple</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator>
						<call><name>ExecHashJoinOuterGetTuple</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* end of batch, or maybe whole join */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* set up to scan for unmatched inner tuples */</comment>
						<expr_stmt><expr><call><name>ExecPrepHashTableForUnmatched</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_FILL_INNER_TUPLES</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_BATCH</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Find the corresponding bucket for this tuple in the main
				 * hash table or skew hash table.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurHashValue</name></name> <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecHashGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>=</operator> <call><name>ExecHashGetSkewBucket</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
																 <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * The tuple might not belong to the current batch (where
				 * "current batch" includes the skew buckets if any).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>batchno</name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>&amp;&amp;</operator>
					<name><name>node</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>==</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>mintuple</name> <init>= <expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>,
																	  <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Need to postpone this outer tuple to a later batch.
					 * Save it in the corresponding outer-batch file.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_state</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>batchno</name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecHashJoinSaveTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>mintuple</name></expr></argument>,
										  <argument><expr><name>hashvalue</name></expr></argument>,
										  <argument><expr><name>hashtable</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>batchno</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>bfCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mintuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Loop around, staying in HJ_NEED_NEW_OUTER state */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* OK, let's scan the bucket for matches */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_SCAN_BUCKET</name></expr>;</expr_stmt>

				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>HJ_SCAN_BUCKET</name></expr>:</case>

				<comment type="block">/*
				 * OPT-3325: Handle NULLs in the outer side of LASJ_NOTIN
				 *  - if tuple is NULL and inner is not empty, drop outer tuple
				 *  - if tuple is NULL and inner is empty, keep going as we'll
				 *    find no match for this tuple in the inner side
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LASJ_NOTIN</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_InnerEmpty</name></name> <operator>&amp;&amp;</operator>
					<call><name>isJoinExprNull</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterHashKeys</name></name></expr></argument>,<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Scan the selected hash bucket for matches to current outer
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecParallelScanHashBucket</name><argument_list>(<argument><expr><name>hashNode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* out of matches; check for possible outer-join fill */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_FILL_OUTER_TUPLE</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecScanHashBucket</name><argument_list>(<argument><expr><name>hashNode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* out of matches; check for possible outer-join fill */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_FILL_OUTER_TUPLE</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * We've got a match, but still need to test non-hashed quals.
				 * ExecScanHashBucket already set up all the state needed to
				 * call ExecQual.
				 *
				 * If we pass the qual, then save state for next call and have
				 * ExecProject form the projection, store it in the tuple
				 * table, and return the slot.
				 *
				 * Only the joinquals determine tuple match status, but all
				 * quals must pass to actually return the tuple.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>joinqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>joinqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>HeapTupleHeaderSetMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurTuple</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* In an antijoin, we never return a matched tuple */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>||</operator>
						<name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LASJ_NOTIN</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If we only need to join to the first matching inner
					 * tuple, then consider returning this one, but after that
					 * continue with next outer tuple.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>single_match</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>otherqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>HJ_FILL_OUTER_TUPLE</name></expr>:</case>

				<comment type="block">/*
				 * The current outer tuple has run out of matches, so check
				 * whether to emit a dummy outer-join tuple.  Whether we emit
				 * one or not, the next state is NEED_NEW_OUTER.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>&amp;&amp;</operator>
					<call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Generate a fake join tuple with nulls for the inner
					 * tuple, and return it if it passes the non-join quals.
					 */</comment>
					<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_NullInnerTupleSlot</name></name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>otherqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>HJ_FILL_INNER_TUPLES</name></expr>:</case>

				<comment type="block">/*
				 * We have finished a batch, but we are doing right/full join,
				 * so any unmatched inner tuples in the hashtable have to be
				 * emitted before we continue to the next batch.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecScanHashTableForUnmatched</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* no more unmatched tuples */</comment>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_BATCH</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Generate a fake join tuple with nulls for the outer tuple,
				 * and return it if it passes the non-join quals.
				 */</comment>
				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_NullOuterTupleSlot</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>otherqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>HJ_NEED_NEW_BATCH</name></expr>:</case>

				<comment type="block">/*
				 * Try to advance to next batch.  Done if there are no more.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecParallelHashJoinNewBatch</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* end of parallel-aware join */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecHashJoinNewBatch</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* end of parallel-oblivious join */</comment>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized hashjoin state: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecHashJoin
 *
 *		Parallel-oblivious version.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>			<comment type="block">/* return: a tuple or NULL */</comment>
<name>ExecHashJoin</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On sufficiently smart compilers this should be inlined with the
	 * parallel-aware branches removed.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecHashJoinImpl</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>reuse_hashtable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * CDB: We'll read no more from inner subtree. To keep our
		 * sibling QEs from being starved, tell source QEs not to
		 * clog up the pipeline with our never-to-be-consumed
		 * data.
		 */</comment>
		<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecParallelHashJoin
 *
 *		Parallel-aware version.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>			<comment type="block">/* return: a tuple or NULL */</comment>
<name>ExecParallelHashJoin</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On sufficiently smart compilers this should be inlined with the
	 * parallel-oblivious branches removed.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecHashJoinImpl</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>reuse_hashtable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * CDB: We'll read no more from inner subtree. To keep our
		 * sibling QEs from being starved, tell source QEs not to
		 * clog up the pipeline with our never-to-be-consumed
		 * data.
		 */</comment>
		<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitHashJoin
 *
 *		Init routine for HashJoin node.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>HashJoinState</name> <modifier>*</modifier></type>
<name>ExecInitHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoin</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hash</name>	   <modifier>*</modifier></type><name>hashNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rhclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hoperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hcollations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>outerDesc</name></decl>,
				<decl><type ref="prev"/><name>innerDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>ops</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>hjstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>HashJoinState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>reuse_hashtable</name></name> <operator>=</operator> <operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_REWIND</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * See ExecHashJoinInitializeDSM() and ExecHashJoinInitializeWorker()
	 * where this function may be replaced with a parallel version, if we
	 * managed to launch a parallel query.
	 */</comment>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecHashJoin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashqualclauses</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CDB: This must be an IS NOT DISTINCT join!  */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>isNotDistinctJoin</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashqualclauses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_nonequijoin</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_nonequijoin</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * MPP-3300, we only pre-build hashtable if we need to (this is relaxing
	 * the fix to MPP-989)
	 */</comment>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>prefetch_inner</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>prefetch_joinqual</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_joinqual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>prefetch_qual</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_qual</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Test_print_prefetch_joinqual</name> <operator>&amp;&amp;</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>prefetch_joinqual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			 <argument><expr><literal type="string">"prefetch join qual in slice %d of plannode %d"</literal></expr></argument>,
			 <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * reuse GUC Test_print_prefetch_joinqual to output debug information for
	 * prefetching non join qual
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Test_print_prefetch_joinqual</name> <operator>&amp;&amp;</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>prefetch_qual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			 <argument><expr><literal type="string">"prefetch non join qual in slice %d of plannode %d"</literal></expr></argument>,
			 <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * initialize child nodes
	 *
	 * Note: we could suppress the REWIND flag for the inner input, which
	 * would amount to betting that the hash will be a single batch.  Not
	 * clear if this would be a win or not.
	 */</comment>
	<expr_stmt><expr><name>hashNode</name> <operator>=</operator> <operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <call><name>innerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX The following order are significant.  We init Hash first, then the outerNode
	 * this is the same order as we execute (in the sense of the first exec called).
	 * Until we have a better way to uncouple, share input needs this to be true.  If the
	 * order is wrong, when both hash and outer node have share input and (both ?) have 
	 * a subquery node, share input will fail because the estate of the nodes can not be
	 * set up correctly.
	 */</comment>
    <expr_stmt><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>hashNode</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>innerDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>hs_keepnull</name> <operator>=</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_nonequijoin</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize result slot, type and projection.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * tuple table initialization
	 */</comment>
	<expr_stmt><expr><name>ops</name> <operator>=</operator> <call><name>ExecGetResultSlotOps</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>outerDesc</name></expr></argument>,
														<argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * detect whether we need only consider the first matching inner tuple
	 */</comment>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>single_match</name></name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>inner_unique</name></name> <operator>||</operator>
								<name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* set up null tuples for outer joins, if needed */</comment>
	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
		<case>case <expr><name>JOIN_LASJ_NOTIN</name></expr>:</case>
			<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_NullInnerTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>innerDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
			<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_NullOuterTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>outerDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_NullOuterTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>outerDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_NullInnerTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>innerDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * now for some voodoo.  our temporary tuple slot is actually the result
	 * tuple slot of the Hash node (which is our inner plan).  we can do this
	 * because Hash nodes don't return tuples via ExecProcNode() -- instead
	 * the hash join node uses ExecScanHashBucket() to get at the contents of
	 * the hash table.  -cim 6/9/91
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashstate</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * initialize child expressions
	 */</comment>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hashclauses</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashqualclauses</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hashqualclauses</name></name> <operator>=</operator>
			<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashqualclauses</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hashqualclauses</name></name> <operator>=</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hashclauses</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * initialize hash-specific info
	 */</comment>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurHashValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deconstruct the hash clauses into outer and inner argument values, so
	 * that we can evaluate those subexpressions separately.  Also make a list
	 * of the hash operator OIDs, in preparation for looking up the hash
	 * functions to use.
	 */</comment>
	<expr_stmt><expr><name>lclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rhclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hoperators</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hcollations</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;hashclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>hclause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>lclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lclauses</name></expr></argument>, <argument><expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rclauses</name></expr></argument>, <argument><expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rhclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rhclauses</name></expr></argument>, <argument><expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hoperators</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>hoperators</name></expr></argument>, <argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>hcollations</name></expr></argument>, <argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterHashKeys</name></name> <operator>=</operator> <name>lclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_InnerHashKeys</name></name> <operator>=</operator> <name>rclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashOperators</name></name> <operator>=</operator> <name>hoperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_Collations</name></name> <operator>=</operator> <name>hcollations</name></expr>;</expr_stmt>
	<comment type="block">/* child Hash node needs to evaluate inner hash keys, too */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>hashkeys</name> <operator>=</operator> <name>rhclauses</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_BUILD_HASHTABLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>hjstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndHashJoin
 *
 *		clean up routine for HashJoin node
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Free hash table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>eagerlyReleased</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashState</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ExecHashTableDestroy</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Free the exprcontext
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean out the tuple table
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean up subtrees
	 */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashJoinOuterGetTuple
 *
 *		get the next outer tuple for a parallel oblivious hashjoin: either by
 *		executing the outer plan node in the first pass, or from the temp
 *		files for the hashjoin batches.
 *
 * Returns a null slot if no more outer tuples (within the current batch).
 *
 * On success, the tuple's hash value is stored at *hashvalue --- this is
 * either originally computed, or re-read from the temp file.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecHashJoinOuterGetTuple</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>outerNode</name></decl></parameter>,
						  <parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
						  <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curbatch</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashState</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Read tuples from outer relation only if it's the first batch */</comment>
	<if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check to see if first outer tuple was already fetched by
		 * ExecHashJoin() and not used yet.
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have to compute the tuple's hash value.
			 */</comment>
			<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>hashkeys_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>keep_nulls</name> <init>= <expr><call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<name><name>hjstate</name><operator>-&gt;</operator><name>hj_nonequijoin</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ExecHashGetHashValue</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>, <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
									 <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterHashKeys</name></name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* outer tuple */</comment>
									 <argument><expr><name>keep_nulls</name></expr></argument>,
									 <argument><expr><name>hashvalue</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>hashkeys_null</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* remember outer relation is not empty for possible rescan */</comment>
				<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<return>return <expr><name>slot</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * That tuple couldn't match because of a NULL, so discard it and
			 * continue with the next one.
			 */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>gp_workfile_caching_loglevel</name></expr></argument>, <argument><expr><literal type="string">"HashJoin built table with %.1f tuples for batch %d"</literal></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name></expr></argument>, <argument><expr><name>curbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>curbatch</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufFile</name>	   <modifier>*</modifier></type><name>file</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In outer-join cases, we could get here even though the batch file
		 * is empty.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For batches &gt; 0, we can be reading many many outer tuples from disk
		 * and probing them against the hashtable. If we don't find any
		 * matches, we'll keep coming back here to read tuples from disk and
		 * returning them (MPP-23213). Break this long tight loop here.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>QueryFinishPending</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecHashJoinGetSavedTuple</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>,
										 <argument><expr><name>file</name></expr></argument>,
										 <argument><expr><name>hashvalue</name></expr></argument>,
										 <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>gp_workfile_caching_loglevel</name></expr></argument>, <argument><expr><literal type="string">"HashJoin built table with %.1f tuples for batch %d"</literal></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name></expr></argument>, <argument><expr><name>curbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* End of this batch */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashJoinOuterGetTuple variant for the parallel case.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecParallelHashJoinOuterGetTuple</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>outerNode</name></decl></parameter>,
								  <parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
								  <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curbatch</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashState</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In the Parallel Hash case we only run the outer plan directly for
	 * single-batch hash joins.  Otherwise we have to go to batch files, even
	 * for batch 0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>hashkeys_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>keep_nulls</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>keep_nulls</name> <operator>=</operator> <call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<name><name>hjstate</name><operator>-&gt;</operator><name>hj_nonequijoin</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ExecHashGetHashValue</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>,
									 <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
									 <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterHashKeys</name></name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* outer tuple */</comment>
									 <argument><expr><name>keep_nulls</name></expr></argument>,
									 <argument><expr><name>hashvalue</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>hashkeys_null</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * That tuple couldn't match because of a NULL, so discard it and
			 * continue with the next one.
			 */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>curbatch</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>sts_parallel_scan_next</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batches</name><index>[<expr><name>curbatch</name></expr>]</index></name><operator>.</operator><name>outer_tuples</name></expr></argument>,
									   <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecForceStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
									   <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name></expr>;</expr_stmt>
			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* End of this batch */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashJoinNewBatch
 *		switch to a new hashjoin batch
 *
 * Returns true if successful, false if there are no more batches.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecHashJoinNewBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curbatch</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"exec_hashjoin_new_batch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashState</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>nbatch</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>curbatch</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>&gt;=</operator> <name>nbatch</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>stats</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecHashTableExplainBatchEnd</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>, <argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We no longer need the previous outer batch file; close it right
		 * away to free disk space.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else	<comment type="block">/* we just finished the first batch */</comment>
	<block>{<block_content>
		<comment type="block">/*
		 * Reset some of the skew optimization state variables, since we no
		 * longer need to consider skew tuples after the first batch. The
		 * memory context reset we are about to do will release the skew
		 * hashtable itself.
		 */</comment>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we want to keep the hash table around, for re-scan, then write
	 * the current batch's state to disk before moving to the next one.
	 * It's possible that we increase the number of batches later, so that
	 * by the time we reload this file, some of the tuples we wrote here
	 * will logically belong to a later file. ExecHashJoinReloadHashTable
	 * will move such tuples when the file is reloaded.
	 *
	 * If we have already re-scanned, we might still have the old file
	 * around, in which case there's no need to write it again.
	 * XXX: Currently, we actually always re-create it, see comments in
	 * ExecHashJoinReloadHashTable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>reuse_hashtable</name></name> <operator>&amp;&amp;</operator>
		<name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpillCurrentBatch</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can always skip over any batches that are completely empty on both
	 * sides.  We can sometimes skip over batches that are empty on only one
	 * side, but there are exceptions:
	 *
	 * 1. In a left/full outer join, we have to process outer batches even if
	 * the inner batch is empty.  Similarly, in a right/full outer join, we
	 * have to process inner batches even if the outer batch is empty.
	 *
	 * 2. If we have increased nbatch since the initial estimate, we have to
	 * scan inner batches since they might contain tuples that need to be
	 * reassigned to later inner batches.
	 *
	 * 3. Similarly, if we have increased nbatch since starting the outer
	 * scan, we have to rescan outer batches in case they contain tuples that
	 * need to be reassigned.
	 */</comment>
	<expr_stmt><expr><name>curbatch</name><operator>++</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>curbatch</name> <operator>&lt;</operator> <name>nbatch</name> <operator>&amp;&amp;</operator>
		   <operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>

	<block>{<block_content>
		<comment type="block">/*
		 * For rescannable we must complete respilling on first batch
		 *
		 * Consider case 2: the inner workfile is not null. We are on the first pass
		 * (before ReScan was called). I.e., we are processing a join for the base
		 * case of a recursive CTE. If the base case does not have tuples for batch
		 * k (i.e., the outer workfile for batch k is null), and we never increased
		 * the initial number of batches, then we will skip the inner batchfile (case 2).
		 *
		 * However, one iteration of recursive CTE is no guarantee that the future outer
		 * batch will also not match batch k on the inner. Therefore, we may have a
		 * non-null outer batch k on some future iteration.
		 *
		 * If during loading batch k inner workfile for future iteration triggers a re-spill
		 * we will be forced to increase number of batches. This will result in wrong result
		 * as we will not write any inner tuples (we consider inner workfiles read-only after
		 * a rescan call).
		 *
		 * So, to produce wrong result, without this guard, the following conditions have
		 * to be true:
		 *
		 * 1. Outer batchfile for batch k is null
		 * 2. Inner batchfile for batch k not null
		 * 3. No resizing of nbatch for batch (0...(k-1))
		 * 4. Inner batchfile for batch k is too big to fit in memory
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hjstate</name><operator>-&gt;</operator><name>reuse_hashtable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>&amp;&amp;</operator>
			<call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* must process due to rule 1 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>&amp;&amp;</operator>
			<call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* must process due to rule 1 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name>nbatch</name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_original</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* must process due to rule 2 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name>nbatch</name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_outstart</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* must process due to rule 3 */</comment>
		<comment type="block">/* We can ignore this batch. */</comment>
		<comment type="block">/* Release associated temp files right away. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>hjstate</name><operator>-&gt;</operator><name>reuse_hashtable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>curbatch</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <name>curbatch</name></expr>;</expr_stmt>		<comment type="block">/* CDB: upd before return, even if no
										 * more data, so stats logic can see
										 * whether join was run to completion */</comment>

	<if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>&gt;=</operator> <name>nbatch</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no more batches */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecHashJoinReloadHashTable</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We no longer continue as we couldn't load the batch */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Rewind outer batch file (if present), so that we can start reading it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Choose a batch to work on, and attach to it.  Returns true if successful,
 * false if there are no more batches.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelHashJoinNewBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>start_batchno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>batchno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we started up so late that the batch tracking array has been freed
	 * already by ExecHashTableDetach(), then we are finished.  See also
	 * ExecParallelHashEnsureBatchAccessors().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>batches</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we were already attached to a batch, remember not to bother checking
	 * it again, and detach from it (possibly freeing the hash table if we are
	 * last to detach).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batches</name><index>[<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>]</index></name><operator>.</operator><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecHashTableDetachBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Search for a batch that isn't done.  We use an atomic counter to start
	 * our search at a different batch in every participant when there are
	 * more batches than participants.
	 */</comment>
	<expr_stmt><expr><name>batchno</name> <operator>=</operator> <name>start_batchno</name> <operator>=</operator>
		<call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>parallel_state</name><operator>-&gt;</operator><name>distributor</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>%</operator>
		<name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hashvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashtable</name><operator>-&gt;</operator><name>batches</name><index>[<expr><name>batchno</name></expr>]</index></name><operator>.</operator><name>done</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>inner_tuples</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Barrier</name>    <modifier>*</modifier></type><name>batch_barrier</name> <init>=
			<expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>batches</name><index>[<expr><name>batchno</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>batch_barrier</name></name></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><call><name>BarrierAttach</name><argument_list>(<argument><expr><name>batch_barrier</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PHJ_BATCH_ELECTING</name></expr>:</case>

					<comment type="block">/* One backend allocates the hash table. */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>BarrierArriveAndWait</name><argument_list>(<argument><expr><name>batch_barrier</name></expr></argument>,
											 <argument><expr><name>WAIT_EVENT_HASH_BATCH_ELECTING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ExecParallelHashTableAlloc</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* Fall through. */</comment>

				<case>case <expr><name>PHJ_BATCH_ALLOCATING</name></expr>:</case>
					<comment type="block">/* Wait for allocation to complete. */</comment>
					<expr_stmt><expr><call><name>BarrierArriveAndWait</name><argument_list>(<argument><expr><name>batch_barrier</name></expr></argument>,
										 <argument><expr><name>WAIT_EVENT_HASH_BATCH_ALLOCATING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Fall through. */</comment>

				<case>case <expr><name>PHJ_BATCH_LOADING</name></expr>:</case>
					<comment type="block">/* Start (or join in) loading tuples. */</comment>
					<expr_stmt><expr><call><name>ExecParallelHashTableSetCurrentBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>inner_tuples</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>batches</name><index>[<expr><name>batchno</name></expr>]</index></name><operator>.</operator><name>inner_tuples</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>sts_begin_parallel_scan</name><argument_list>(<argument><expr><name>inner_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>sts_parallel_scan_next</name><argument_list>(<argument><expr><name>inner_tuples</name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ExecForceStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
												   <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExecParallelHashTableInsertCurrentBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
																<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></while>
					<expr_stmt><expr><call><name>sts_end_parallel_scan</name><argument_list>(<argument><expr><name>inner_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>BarrierArriveAndWait</name><argument_list>(<argument><expr><name>batch_barrier</name></expr></argument>,
										 <argument><expr><name>WAIT_EVENT_HASH_BATCH_LOADING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Fall through. */</comment>

				<case>case <expr><name>PHJ_BATCH_PROBING</name></expr>:</case>

					<comment type="block">/*
					 * This batch is ready to probe.  Return control to
					 * caller. We stay attached to batch_barrier so that the
					 * hash table stays alive until everyone's finished
					 * probing it, but no participant is allowed to wait at
					 * this barrier again (or else a deadlock could occur).
					 * All attached participants must eventually call
					 * BarrierArriveAndDetach() so that the final phase
					 * PHJ_BATCH_DONE can be reached.
					 */</comment>
					<expr_stmt><expr><call><name>ExecParallelHashTableSetCurrentBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>sts_begin_parallel_scan</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batches</name><index>[<expr><name>batchno</name></expr>]</index></name><operator>.</operator><name>outer_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>

				<case>case <expr><name>PHJ_BATCH_DONE</name></expr>:</case>

					<comment type="block">/*
					 * Already done.  Detach and go around again (if any
					 * remain).
					 */</comment>
					<expr_stmt><expr><call><name>BarrierDetach</name><argument_list>(<argument><expr><name>batch_barrier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batches</name><index>[<expr><name>batchno</name></expr>]</index></name><operator>.</operator><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected batch phase %d"</literal></expr></argument>,
						 <argument><expr><call><name>BarrierPhase</name><argument_list>(<argument><expr><name>batch_barrier</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>batchno</name> <operator>=</operator> <operator>(</operator><name>batchno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>batchno</name> <operator>!=</operator> <name>start_batchno</name></expr>)</condition>;</do>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashJoinSaveTuple
 *		save a tuple to a batch file.
 *
 * The data recorded in the file for each tuple is its hash value,
 * then the tuple in MinimalTuple format.
 *
 * Note: it is important always to call this in the regular executor
 * context, not in a shorter-lived context; else the temp file buffers
 * will get messed up.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashJoinSaveTuple</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>, <parameter><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
					  <parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>BufFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>fileptr</name></decl></parameter>,
					  <parameter><decl><type><name>MemoryContext</name></type> <name>bfCxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufFile</name>	   <modifier>*</modifier></type><name>file</name> <init>= <expr><operator>*</operator><name>fileptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>written</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>work_set</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First time spilling.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name><operator>-&gt;</operator><name>workfileCreated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>bfCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>work_set</name></name> <operator>=</operator> <call><name>workfile_mgr_create_set</name><argument_list>(<argument><expr><literal type="string">"HashJoin"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* hold pin */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>bfCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* First write to this batch file, so create it */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>work_set</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>BufFileCreateTempInSet</name><argument_list>(<argument><expr><literal type="string">"HashJoin"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* interXact */</comment>,
									  <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>work_set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BufFilePledgeSequential</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* allow compression */</comment>
		<expr_stmt><expr><operator>*</operator><name>fileptr</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>gp_workfile_caching_loglevel</name></expr></argument>, <argument><expr><literal type="string">"create batch file %s"</literal></expr></argument>,
			 <argument><expr><call><name>BufFileGetFilename</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>BufFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>hashvalue</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>BufFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashJoinGetSavedTuple
 *		read the next tuple from a batch file.  Return NULL if no more.
 *
 * On success, *hashvalue is set to the tuple's hash value, and the tuple
 * itself is stored in the given slot.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecHashJoinGetSavedTuple</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
						  <parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
						  <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name><name>header</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nread</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We check for interrupts here because this is typically taken as an
	 * alternative code path to an ExecProcNode() call, which would include
	 * such a check.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since both the hash value and the MinimalTuple length word are uint32,
	 * we can read them both in one BufFileRead() call without any type
	 * cheating.
	 */</comment>
	<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>				<comment type="block">/* end of file */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>hashvalue</name> <operator>=</operator> <name><name>header</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>,
						<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>,
						<argument><expr><name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecForceStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleSlot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tupleSlot</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ExecReScanHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * In a multi-batch join, we currently have to do rescans the hard way,
	 * primarily because batch temp files may have already been released. But
	 * if it's a single-batch join, and there is no parameter change for the
	 * inner subnode, then we can just re-use the existing hash table without
	 * rebuilding it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>first_pass</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>righttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>eagerlyReleased</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Okay to reuse the hash table; needn't rescan inner, either.
			 *
			 * However, if it's a right/full join, we'd better reset the
			 * inner-tuple match flags contained in the table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecHashTableResetMatchFlags</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Also, we need to reset our state about the emptiness of the
			 * outer relation, so that the new scan of the outer will update
			 * it correctly if it turns out to be empty this time. (There's no
			 * harm in clearing it now because ExecHashJoin won't need the
			 * info.  In the other cases, where the hash table doesn't exist
			 * or we are destroying it, we leave this state alone because
			 * ExecHashJoin will need it the first time through.)
			 */</comment>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* ExecHashJoin can skip the BUILD_HASHTABLE step */</comment>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Force reloading batch 0 upon next ExecHashJoin */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* MPP-1600: reset the batch number */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* must destroy and rebuild hash table */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>eagerlyReleased</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashState</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecHashTableDestroy</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_BUILD_HASHTABLE</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * if chgParam of subnode is not null then plan will be re-scanned
			 * by first ExecProcNode.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>righttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Always reset intra-tuple state */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurHashValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * if chgParam of subnode is not null then plan will be re-scanned by
	 * first ExecProcNode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * This method releases the hash table's memory. It maintains some of the other
 * aspects of the hash table like memory usage statistics. These may be required
 * during an explain analyze. A hash table that has been released cannot perform
 * any useful function anymore.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseHashTable</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HashState</name> <modifier>*</modifier></type><name>hashState</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* This hashtable should not have been released already! */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>eagerlyReleased</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>stats</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Report on batch in progress. */</comment>
			<expr_stmt><expr><call><name>ExecHashTableExplainBatchEnd</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ExecHashTableDestroy</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>eagerlyReleased</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Always reset intra-tuple state */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurHashValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block">/* Is this an IS-NOT-DISTINCT-join qual list (as opposed the an equijoin)?
 *
 * XXX We perform an abbreviated test based on the assumptions that 
 *     these are the only possibilities and that all conjuncts are 
 *     alike in this regard.
 */</comment>
<function><type><name>bool</name></type>
<name>isNotDistinctJoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qualList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qualList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>bex</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>dex</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bex</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><name><name>bex</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>NOT_EXPR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dex</name> <operator>=</operator> <operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>bex</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>dex</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* We assume the rest follow suit! */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecEagerFreeHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>eagerlyReleased</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseHashTable</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecSquelchHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecEagerFreeHashJoin</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * In our hybrid hash join we either spill when we increase number of batches
 * or when we re-spill. As we go, we normally destroy the batch file of the
 * batch that we have already processed. But if we need to support re-scanning
 * of the outer tuples, without also re-scanning the inner side, we need to
 * save the current hash for the next re-scan, instead.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SpillCurrentBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curbatch</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* don't need to consider parallel hashjoins which use shared tuplestores instead of raw files */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecHashJoinSaveTuple</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
								  <argument><expr><name>hashtable</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>bfCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecHashJoinReloadHashTable</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashState</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curbatch</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmoved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	int			orignbatch = hashtable-&gt;nbatch;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Reload the hash table with the new inner batch (which could be empty)
	 */</comment>
	<expr_stmt><expr><call><name>ExecHashTableReset</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>, <argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Rewind batch file */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access temporary file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>QueryFinishPending</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecHashJoinGetSavedTuple</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>,
											 <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>,
											 <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slot</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * NOTE: some tuples may be sent to future batches.  Also, it is
			 * possible for hashtable-&gt;nbatch to be increased here!
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecHashTableInsert</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>, <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nmoved</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * after we build the hash table, the inner batch file is no longer
		 * needed
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name><operator>-&gt;</operator><name>need_cdb</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>batchstats</name><index>[<expr><name>curbatch</name></expr>]</index></name><operator>.</operator><name>innerfilesize</name> <operator>=</operator>
				<call><name>BufFileGetSize</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"workfile_hashjoin_failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we want to re-use the hash table after a re-scan, don't
		 * delete it yet. But if we did not load the batch file into memory as is,
		 * because some tuples were sent to later batches, then delete it now, so
		 * that it will be recreated with just the remaining tuples, after processing
		 * this batch.
		 *
		 * XXX: Currently, we actually always close the file, and recreate it
		 * afterwards, even if there are no changes. That's because the workfile
		 * API doesn't support appending to a file that's already been read from.
		 * FIXME: could fix that now
		 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
		if (!hjstate-&gt;reuse_hashtable || nmoved &gt; 0 || hashtable-&gt;nbatch != orignbatch)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecShutdownHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Detach from shared state before DSM memory goes away.  This makes
		 * sure that we don't have any pointers into DSM memory by the time
		 * ExecEndHashJoin runs.
		 */</comment>
		<expr_stmt><expr><call><name>ExecHashTableDetachBatch</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecHashTableDetach</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecParallelHashJoinPartitionOuter</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerState</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashState</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute outer plan, writing all tuples to shared tuplestores. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type>		<name>hashkeys_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>keep_nulls</name> <init>= <expr><call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>hjstate</name><operator>-&gt;</operator><name>hj_nonequijoin</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ExecHashGetHashValue</name><argument_list>(<argument><expr><name>hashState</name></expr></argument>, <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
								 <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterHashKeys</name></name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* outer tuple */</comment>
								 <argument><expr><name>keep_nulls</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>hashkeys_null</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>batchno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>bucketno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>mintup</name> <init>= <expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ExecHashGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bucketno</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sts_puttuple</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batches</name><index>[<expr><name>batchno</name></expr>]</index></name><operator>.</operator><name>outer_tuples</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>, <argument><expr><name>mintup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name>mintup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Make sure all outer partitions are readable by any backend. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sts_end_write</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batches</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>outer_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecHashJoinEstimate</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelHashJoinState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecHashJoinInitializeDSM</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>plan_node_id</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Disable shared hash table mode if we failed to create a real DSM
	 * segment, because that means that we don't have a DSA area to work with.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecSetExecProcNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>ExecParallelHashJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the state needed to coordinate access to the shared hash
	 * table(s), using the plan node ID as the toc key.
	 */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelHashJoinState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the shared hash join state with no batches initially.
	 * ExecHashTableCreate() will prepare at least one later and set nbatch
	 * and space_allowed.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>space_allowed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>batches</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>old_batches</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>growth</name></name> <operator>=</operator> <name>PHJ_GROWTH_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>chunk_work_queue</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>distributor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>nparticipants</name></name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>total_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>,
					 <argument><expr><name>LWTRANCHE_PARALLEL_HASH_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BarrierInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>build_barrier</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BarrierInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>grow_batches_barrier</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BarrierInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>grow_buckets_barrier</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up the space we'll use for shared temporary files. */</comment>
	<expr_stmt><expr><call><name>SharedFileSetInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>fileset</name></name></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the shared state in the hash node. */</comment>
	<expr_stmt><expr><name>hashNode</name> <operator>=</operator> <operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashNode</name><operator>-&gt;</operator><name>parallel_state</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecHashJoinReInitializeDSM
 *
 *		Reset shared state before beginning a fresh scan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashJoinReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>plan_node_id</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>pstate</name> <init>=
	<expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * It would be possible to reuse the shared hash table in single-batch
	 * cases by resetting and then fast-forwarding build_barrier to
	 * PHJ_BUILD_DONE and batch 0's batch_barrier to PHJ_BATCH_PROBING, but
	 * currently shared hash tables are already freed by now (by the last
	 * participant to detach from the batch).  We could consider keeping it
	 * around for single-batch joins.  We'd also need to adjust
	 * finalize_plan() so that it doesn't record a dummy dependency for
	 * Parallel Hash nodes, preventing the rescan optimization.  For now we
	 * don't try.
	 */</comment>

	<comment type="block">/* Detach, freeing any remaining shared memory. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecHashTableDetachBatch</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecHashTableDetach</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clear any shared batch files. */</comment>
	<expr_stmt><expr><call><name>SharedFileSetDeleteAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>fileset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset build_barrier to PHJ_BUILD_ELECTING so we can go around again. */</comment>
	<expr_stmt><expr><call><name>BarrierInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>build_barrier</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecHashJoinInitializeWorker</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
							 <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>plan_node_id</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>pstate</name> <init>=
	<expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Attach to the space for shared temporary files. */</comment>
	<expr_stmt><expr><call><name>SharedFileSetAttach</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>fileset</name></name></expr></argument>, <argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Attach to the shared state in the hash node. */</comment>
	<expr_stmt><expr><name>hashNode</name> <operator>=</operator> <operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashNode</name><operator>-&gt;</operator><name>parallel_state</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecSetExecProcNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>ExecParallelHashJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
