<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/nodeModifyTable.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeModifyTable.c
 *	  routines to handle ModifyTable nodes.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeModifyTable.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/* INTERFACE ROUTINES
 *		ExecInitModifyTable - initialize the ModifyTable node
 *		ExecModifyTable		- retrieve the next tuple from the node
 *		ExecEndModifyTable	- shut down the ModifyTable node
 *		ExecReScanModifyTable - rescan the ModifyTable node
 *
 *	 NOTES
 *		Each ModifyTable node contains a list of one or more subplans,
 *		much like an Append node.  There is one subplan per result relation.
 *		The key reason for this is that in an inherited UPDATE command, each
 *		result relation could have a different schema (more or different
 *		columns) requiring a different plan tree to produce it.  In an
 *		inherited DELETE, all the subplans should produce the same output
 *		rowtype, but we might still find that different plans are appropriate
 *		for different child relations.
 *
 *		If the query specifies RETURNING, then the ModifyTable returns a
 *		RETURNING tuple after completing each row insert, update, or delete.
 *		It must be called again to continue the operation.  Without RETURNING,
 *		we just loop within the node until all the work is done, then
 *		return NULL.  This avoids useless call/return overhead.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/aocatalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbaocsam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecOnConflictUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
								 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
								 <parameter><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl></parameter>,
								 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
								 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>excludedSlot</name></decl></parameter>,
								 <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
								 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>returning</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecPrepareTupleRouting</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
											   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
											   <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
											   <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>targetRelInfo</name></decl></parameter>,
											   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type><name>getTargetResultRelInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecSetupChildParentMapForSubplan</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupconv_map_for_subplan</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
												   <parameter><decl><type><name>int</name></type> <name>whichplan</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Verify that the tuples to be produced by INSERT or UPDATE match the
 * target relation's rowtype
 *
 * We do this to guard against stale plans.  If plan invalidation is
 * functioning properly then we should never get a failure here, but better
 * safe than sorry.  Note that this is called after we have obtained lock
 * on the target rel, so the rowtype can't change underneath us.
 *
 * The plan output is represented by its targetlist, because that makes
 * handling the dropped-column case easier.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckPlanOutput</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>resultRel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>resultDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk tlist items */</comment>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&gt;=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query has too many columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Normal case: demand type match */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table has type %s at ordinal position %d, but query expects %s."</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>attno</name></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For a dropped column, we can't check atttypid (it's likely 0).
			 * In any case the planner has most likely inserted an INT4 null.
			 * What we insist on is just *some* NULL constant.
			 */</comment>
			<comment type="block">/* GPDB_96_MERGE_FIXME: the subplan can be a Motion, so that the NULLs
			 * are transferred through the Motion node.
			 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
			if (!IsA(tle-&gt;expr, Const) ||
				!((Const *) tle-&gt;expr)-&gt;constisnull)
				ereport(ERROR,
						(errcode(ERRCODE_DATATYPE_MISMATCH),
						 errmsg("table row type and query-specified row type do not match"),
						 errdetail("Query provides a value for a dropped column at ordinal position %d.",
								   attno)));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>!=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query has too few columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecProcessReturning --- evaluate a RETURNING list
 *
 * resultRelInfo: current result rel
 * tupleSlot: slot holding tuple actually inserted/updated/deleted
 * planSlot: slot holding tuple returned by top subplan node
 *
 * Note: If tupleSlot is NULL, the FDW should have already provided econtext's
 * scan tuple.
 *
 * Returns a slot holding the result tuple
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecProcessReturning</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projectReturning</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>projectReturning</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make tuple and any needed join variables available to ExecProject */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleSlot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>tupleSlot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>planSlot</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * RETURNING expressions might reference the tableoid column, so
	 * reinitialize tts_tableOid before evaluating them.
	 */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator>
		<call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute the RETURNING expressions */</comment>
	<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name>projectReturning</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckTupleVisible -- verify tuple is visible
 *
 * It would not be consistent with guarantees of the higher isolation levels to
 * proceed with avoiding insertion (taking speculative insertion's alternative
 * path) on the basis of another tuple that is not visible to MVCC snapshot.
 * Check for the need to raise a serialization failure, and do so as necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckTupleVisible</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_satisfies_snapshot</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>xminDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>xminDatum</name> <operator>=</operator> <call><name>slot_getsysattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>MinTransactionIdAttributeNumber</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>DatumGetTransactionId</name><argument_list>(<argument><expr><name>xminDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We should not raise a serialization failure if the conflict is
		 * against a tuple inserted by our own transaction, even if it's not
		 * visible to our snapshot.  (This would happen, for example, if
		 * conflicting keys are proposed for insertion in a single command.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckTIDVisible -- convenience variant of ExecCheckTupleVisible()
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckTIDVisible</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					<parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
					<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tempSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Redundantly check isolation level */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><name>tempSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch conflicting tuple for ON CONFLICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecCheckTupleVisible</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tempSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tempSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute stored generated columns for a tuple
 */</comment>
<function><type><name>void</name></type>
<name>ExecComputeStoredGenerated</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If first time through for this result relation, build expression
	 * nodetrees for rel's stored generation expressions.  Keep them in the
	 * per-query memory context so they'll survive throughout the query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_GeneratedExprs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_GeneratedExprs</name></name> <operator>=</operator>
			<operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no generation expression found for column number %d of table \"%s\""</literal></expr></argument>,
						 <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_GeneratedExprs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>values</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nulls</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nulls</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_GeneratedExprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>values</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nulls</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInsert
 *
 *		For INSERT, we have to insert the tuple into the target relation
 *		and insert appropriate tuples into the index relations.
 *
 *		Returns RETURNING result if any, otherwise NULL.
 *
 * If the target table is partitioned, the input tuple in 'parentslot'
 * is in the shape required for the parent table. This function will
 * look up the ResultRelInfo of the target partition, and form a
 * tuple suitable for the target partition. (It can be different, if
 * there are dropped columns in the parent, but not the partition,
 * for example.)
 *
 * In GPDB, the INSERT can be part of an update operation when
 * there is a preceding SplitUpdate node. 'splitUpdate' is true in
 * that case.
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecInsert</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
		   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>splitUpdate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>recheckIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>ar_insert_trig_tcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OnConflictAction</name></type> <name>onconflict</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get information on the (current) result relation
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * BEFORE ROW INSERT Triggers.
	 *
	 * Note: We fire BEFORE ROW TRIGGERS for every attempted insertion in an
	 * INSERT ... ON CONFLICT statement.  We cannot check for constraint
	 * violations before firing these triggers, because they can change the
	 * values to insert.  Also, they can run arbitrary user-defined code with
	 * side-effects that we can't cancel by just not inserting the tuple.
	 *
	 * Considering that the original command is UPDATE for a SplitUpdate, fire
	 * insert triggers may lead to the wrong action to be enforced. And the
	 * triggers in GPDB may require cross segments data changes, disallow the
	 * INSERT triggers on a SplitUpdate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>splitUpdate</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecBRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* "do nothing" */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INSTEAD OF ROW INSERT Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecIRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* "do nothing" */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Compute stored generated columns
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecComputeStoredGenerated</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * insert into foreign table: let the FDW do it
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignInsert</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
															   <argument><expr><name>resultRelInfo</name></expr></argument>,
															   <argument><expr><name>slot</name></expr></argument>,
															   <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * AFTER ROW Triggers or RETURNING expressions might reference the
		 * tableoid column, so (re-)initialize tts_tableOid before evaluating
		 * them.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>WCOKind</name></type>		<name>wco_kind</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Constraints might reference the tableoid column, so (re-)initialize
		 * tts_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute stored generated columns
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecComputeStoredGenerated</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check any RLS WITH CHECK policies.
		 *
		 * Normally we should check INSERT policies. But if the insert is the
		 * result of a partition key update that moved the tuple to a new
		 * partition, we should instead check UPDATE policies, because we are
		 * executing policies defined on the target table, and not those
		 * defined on the child partitions.
		 */</comment>
		<expr_stmt><expr><name>wco_kind</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator></expr> ?</condition><then>
			<expr><name>WCO_RLS_UPDATE_CHECK</name></expr> </then><else>: <expr><name>WCO_RLS_INSERT_CHECK</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * ExecWithCheckOptions() will skip any WCOs which are not of the kind
		 * we are looking for at this point.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>wco_kind</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check the constraints of the tuple.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also check the tuple against the partition constraint, if there is
		 * one; except that if we got here via tuple-routing, we don't need to
		 * if there's no BR trigger defined on the partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			 <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
			  <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>onconflict</name> <operator>!=</operator> <name>ONCONFLICT_NONE</name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Perform a speculative insertion. */</comment>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>specToken</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>conflictTid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>specConflict</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arbiterIndexes</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>arbiterIndexes</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Do a non-conclusive check for conflicts first.
			 *
			 * We're not holding any locks yet, so this doesn't guarantee that
			 * the later insert won't conflict.  But it avoids leaving behind
			 * a lot of canceled speculative insertions, if you run a lot of
			 * INSERT ON CONFLICT statements that do conflict.
			 *
			 * We loop back here if we find a conflict below, either during
			 * the pre-check, or when we re-check after inserting the tuple
			 * speculatively.
			 */</comment>
	<label><name>vlock</name>:</label>
			<expr_stmt><expr><name>specConflict</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheckIndexConstraints</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conflictTid</name></expr></argument>,
										   <argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* committed conflict tuple found */</comment>
				<if_stmt><if>if <condition>(<expr><name>onconflict</name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * In case of ON CONFLICT DO UPDATE, execute the UPDATE
					 * part.  Be prepared to retry if the UPDATE fails because
					 * of another concurrent UPDATE/DELETE to the conflict
					 * tuple.
					 */</comment>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>returning</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>ExecOnConflictUpdate</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>conflictTid</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
											 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>canSetTag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>returning</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>InstrCountTuples2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>returning</name></expr>;</return>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<goto>goto <name>vlock</name>;</goto></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * In case of ON CONFLICT DO NOTHING, do nothing. However,
					 * verify that the tuple is visible to the executor's MVCC
					 * snapshot at higher isolation levels.
					 *
					 * Using ExecGetReturningSlot() to store the tuple for the
					 * recheck isn't that pretty, but we can't trivially use
					 * the input slot, because it might not be of a compatible
					 * type. As there's no conflicting usage of
					 * ExecGetReturningSlot() in the DO NOTHING case...
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>onconflict</name> <operator>==</operator> <name>ONCONFLICT_NOTHING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecCheckTIDVisible</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conflictTid</name></expr></argument>,
										<argument><expr><call><name>ExecGetReturningSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>InstrCountTuples2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Before we start insertion proper, acquire our "speculative
			 * insertion lock".  Others can use that to wait for us to decide
			 * if we're going to go ahead with the insertion, instead of
			 * waiting for the whole transaction to complete.
			 */</comment>
			<expr_stmt><expr><name>specToken</name> <operator>=</operator> <call><name>SpeculativeInsertionLockAcquire</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert the tuple, with the speculative token */</comment>
			<expr_stmt><expr><call><name>table_tuple_insert_speculative</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
										   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>specToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert index entries for tuple */</comment>
			<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>specConflict</name></expr></argument>,
												   <argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* adjust the tuple's state accordingly */</comment>
			<expr_stmt><expr><call><name>table_tuple_complete_speculative</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
											 <argument><expr><name>specToken</name></expr></argument>, <argument><expr><operator>!</operator><name>specConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Wake up anyone waiting for our decision.  They will re-check
			 * the tuple, see that it's no longer speculative, and wait on our
			 * XID as if this was a regularly inserted tuple all along.  Or if
			 * we killed the tuple, they will see it's dead, and proceed as if
			 * the tuple never existed.
			 */</comment>
			<expr_stmt><expr><call><name>SpeculativeInsertionLockRelease</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If there was a conflict, start from the beginning.  We'll do
			 * the pre-check again, which will now find the conflicting tuple
			 * (unless it aborts before we get there).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>specConflict</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>vlock</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Since there was no insertion conflict, we're done */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* insert the tuple normally */</comment>
			<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
							   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert index entries for tuple */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
													   <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setLastTid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this insert is the result of a partition key update that moved the
	 * tuple to a new partition, put this row into the transition NEW TABLE,
	 * if there is one. We need to do this separately for DELETE and INSERT
	 * because they happen on different tables.
	 */</comment>
	<expr_stmt><expr><name>ar_insert_trig_tcs</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name>
		<operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_update_new_table</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecARUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>slot</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We've already captured the NEW TABLE row, so make sure any AR
		 * INSERT trigger fired below doesn't capture it again.
		 */</comment>
		<expr_stmt><expr><name>ar_insert_trig_tcs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* AFTER ROW INSERT Triggers */</comment>
	<comment type="block">/*
	 * GPDB: Disallow INSERT triggers on a split UPDATE. See comments in
	 * BEFORE ROW INSERT Triggers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>splitUpdate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>recheckIndexes</name></expr></argument>,
						 <argument><expr><name>ar_insert_trig_tcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check any WITH CHECK OPTION constraints from parent views.  We are
	 * required to do this after testing all constraints and uniqueness
	 * violations per the SQL spec, so we do it after actually inserting the
	 * record into the heap and all indexes.
	 *
	 * ExecWithCheckOptions will elog(ERROR) if a violation is found, so the
	 * tuple will never be seen, if it violates the WITH CHECK OPTION.
	 *
	 * ExecWithCheckOptions() will skip any WCOs which are not of the kind we
	 * are looking for at this point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_VIEW_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Process RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecDelete
 *
 *		DELETE is like UPDATE, except that we delete the tuple and no
 *		index modifications are needed.
 *
 *		When deleting from a table, tupleid identifies the tuple to
 *		delete and oldtuple is NULL.  When deleting from a view,
 *		oldtuple is passed to the INSTEAD OF triggers and identifies
 *		what to delete, and tupleid is invalid.  When deleting from a
 *		foreign table, tupleid is invalid; the FDW has to figure out
 *		which row to delete using data from the planSlot.  oldtuple is
 *		passed to foreign table triggers; it is NULL when the foreign
 *		table has no relevant triggers.  We use tupleDeleted to indicate
 *		whether the tuple is actually deleted, callers can use it to
 *		decide whether to continue the operation.  When this DELETE is a
 *		part of an UPDATE of partition-key, then the slot returned by
 *		EvalPlanQual() is passed back using output parameter epqslot.
 *
 *		In GPDB, DELETE can be part of an update operation when
 *		there is a preceding SplitUpdate node.
 *
 *		Returns RETURNING result if any, otherwise NULL.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecDelete</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
		   <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
		   <parameter><decl><type><name>int32</name></type> <name>segid</name></decl></parameter>,
		   <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
		   <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
		   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>processReturning</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>splitUpdate</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>tupleDeleted</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>epqreturnslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>tmfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>ar_delete_trig_tcs</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tupleDeleted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tupleDeleted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Sanity check the distribution of the tuple to prevent
	 * potential data corruption in case users manipulate data
	 * incorrectly (e.g. insert data on incorrect segment through
	 * utility mode) or there is bug in code, etc.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>segid</name> <operator>!=</operator> <name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"distribution key of the tuple (%u, %u) doesn't belong to "</literal>
			 <literal type="string">"current segment (actually from seg%d)"</literal></expr></argument>,
			 <argument><expr><call><name>BlockIdGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tupleid</name><operator>-&gt;</operator><name>ip_blkid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name><name>tupleid</name><operator>-&gt;</operator><name>ip_posid</name></name></expr></argument>,
			 <argument><expr><name>segid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * get information on the (current) result relation
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* BEFORE ROW DELETE Triggers */</comment>
	<comment type="block">/*
	 * Disallow DELETE triggers on a split UPDATE. See comments in ExecInsert().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_delete_before_row</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>splitUpdate</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dodelete</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dodelete</name> <operator>=</operator> <call><name>ExecBRDeleteTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
										<argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>epqreturnslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dodelete</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INSTEAD OF ROW DELETE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_delete_instead_row</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dodelete</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldtuple</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dodelete</name> <operator>=</operator> <call><name>ExecIRDeleteTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dodelete</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * delete from foreign table: let the FDW do it
		 *
		 * We offer the returning slot as a place to store RETURNING data,
		 * although the FDW can return some other slot if it wants.
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecGetReturningSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignDelete</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
															   <argument><expr><name>resultRelInfo</name></expr></argument>,
															   <argument><expr><name>slot</name></expr></argument>,
															   <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * RETURNING expressions might reference the tableoid column, so
		 * (re)initialize tts_tableOid before evaluating them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * delete the tuple
		 *
		 * Note: if es_crosscheck_snapshot isn't InvalidSnapshot, we check
		 * that the row to be deleted is visible to that snapshot, and throw a
		 * can't-serialize error if not. This is a special-case behavior
		 * needed for referential integrity updates in transaction-snapshot
		 * mode transactions.
		 */</comment>
<label><name>ldelete</name>:</label><empty_stmt>;</empty_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_delete</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument> <comment type="block">/* wait for commit */</comment> ,
									<argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>,
									<argument><expr><name>changingPart</name> <operator>||</operator> <name>splitUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TM_SelfModified</name></expr>:</case>

				<comment type="block">/*
				 * The target tuple was already updated or deleted by the
				 * current command, or by a later command in the current
				 * transaction.  The former case is possible in a join DELETE
				 * where multiple tuples join to the same target tuple. This
				 * is somewhat questionable, but Postgres has always allowed
				 * it: we just ignore additional deletion attempts.
				 *
				 * The latter case arises if the tuple is modified by a
				 * command in a BEFORE trigger, or perhaps by a command in a
				 * volatile function used in the query.  In such situations we
				 * should not ignore the deletion, but it is equally unsafe to
				 * proceed.  We don't want to discard the original DELETE
				 * while keeping the triggered actions based on its deletion;
				 * and it would be no better to allow the original DELETE
				 * while discarding updates that it triggered.  The row update
				 * carries some information that might be important according
				 * to business rules; so throwing an error is the only safe
				 * course.
				 *
				 * If a trigger actually intends this type of interaction, it
				 * can re-execute the DELETE and then return NULL to cancel
				 * the outer delete.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tmfd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be deleted was already modified by an operation triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Else, already deleted by self; nothing to do */</comment>

				<comment type="block">/*-------
				 * In an scenario in which R(a,b) and S(a,b) have
				 *        R               S
				 *    ________         ________
				 *     (1, 1)           (1, 2)
				 *                      (1, 7)
				 *
				 *  An update query such as:
				 *   UPDATE R SET a = S.b  FROM S WHERE R.b = S.a;
				 *
				 *  will have an non-deterministic output. The tuple in R
				 * can be updated to (2,1) or (7,1).
				 * Since the introduction of SplitUpdate, these queries will
				 * send multiple requests to delete the same tuple. One of them
				 * will pass, but others will not. But there will also be
				 * multiple requests to insert a new version of the tuple, and
				 * we cannot cancel out those if the Delete cannot be
				 * performed. An error is reported in such scenario; otherwise
				 * you end up with multiple copies of the same row.
				 *-------
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>splitUpdate</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument> )</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple updates to a row by the same query is not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>

			<case>case <expr><name>TM_Ok</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>TM_Updated</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inputslot</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Already know that we're going to need to do EPQ, so
					 * fetch tuple directly into the right slot.
					 */</comment>
					<expr_stmt><expr><call><name>EvalPlanQualBegin</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>inputslot</name> <operator>=</operator> <call><name>EvalPlanQualSlot</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>resultRelationDesc</name></expr></argument>,
												 <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_lock</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>,
											  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
											  <argument><expr><name>inputslot</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
											  <argument><expr><name>LockTupleExclusive</name></expr></argument>, <argument><expr><name>LockWaitBlock</name></expr></argument>,
											  <argument><expr><name>TUPLE_LOCK_FLAG_FIND_LAST_VERSION</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>TM_Ok</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmfd</name><operator>.</operator><name>traversed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>epqslot</name> <operator>=</operator> <call><name>EvalPlanQual</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
												   <argument><expr><name>epqstate</name></expr></argument>,
												   <argument><expr><name>resultRelationDesc</name></expr></argument>,
												   <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
												   <argument><expr><name>inputslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<comment type="block">/* Tuple not passing quals anymore, exiting... */</comment>
								<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

							<comment type="block">/*
							 * If requested, skip delete and pass back the
							 * updated row.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name>epqreturnslot</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><operator>*</operator><name>epqreturnslot</name> <operator>=</operator> <name>epqslot</name></expr>;</expr_stmt>
								<return>return <expr><name>NULL</name></expr>;</return>
							</block_content>}</block></if>
							<else>else<block type="pseudo"><block_content>
								<goto>goto <name>ldelete</name>;</goto></block_content></block></else></if_stmt>

						<case>case <expr><name>TM_SelfModified</name></expr>:</case>

							<comment type="block">/*
							 * This can be reached when following an update
							 * chain from a tuple updated by another session,
							 * reaching a tuple that was already updated in
							 * this transaction. If previously updated by this
							 * command, ignore the delete, otherwise error
							 * out.
							 *
							 * See also TM_SelfModified response to
							 * table_tuple_delete() above.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name><name>tmfd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be deleted was already modified by an operation triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<return>return <expr><name>NULL</name></expr>;</return>

						<case>case <expr><name>TM_Deleted</name></expr>:</case>
							<comment type="block">/* tuple already deleted; nothing to do */</comment>
							<return>return <expr><name>NULL</name></expr>;</return>

						<default>default:</default>

							<comment type="block">/*
							 * TM_Invisible should be impossible because we're
							 * waiting for updated row versions, and would
							 * already have errored out if the first version
							 * is invisible.
							 *
							 * TM_Updated should be impossible, because we're
							 * locking the latest version via
							 * TUPLE_LOCK_FLAG_FIND_LAST_VERSION.
							 */</comment>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected table_tuple_lock status: %u"</literal></expr></argument>,
								 <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>NULL</name></expr>;</return>
					</block_content>}</block></switch>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>TM_Deleted</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent delete"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* tuple already deleted; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized table_tuple_delete status: %u"</literal></expr></argument>,
					 <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Note: Normally one would think that we have to delete index tuples
		 * associated with the heap tuple now...
		 *
		 * ... but in POSTGRES, we have no need to do this because VACUUM will
		 * take care of it later.  We can't delete index tuples immediately
		 * anyway, since the tuple is still visible to other transactions.
		 */</comment>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Tell caller that the delete actually happened. */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleDeleted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tupleDeleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this delete is the result of a partition key update that moved the
	 * tuple to a new partition, put this row into the transition OLD TABLE,
	 * if there is one. We need to do this separately for DELETE and INSERT
	 * because they happen on different tables.
	 */</comment>
	<expr_stmt><expr><name>ar_delete_trig_tcs</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name>
		<operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_update_old_table</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecARUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
							 <argument><expr><name>tupleid</name></expr></argument>,
							 <argument><expr><name>oldtuple</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We've already captured the NEW TABLE row, so make sure any AR
		 * DELETE trigger fired below doesn't capture it again.
		 */</comment>
		<expr_stmt><expr><name>ar_delete_trig_tcs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* AFTER ROW DELETE Triggers */</comment>
	<comment type="block">/*
	 * Disallow DELETE triggers on a split UPDATE. See comments in ExecInsert().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>splitUpdate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecARDeleteTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>,
							 <argument><expr><name>ar_delete_trig_tcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process RETURNING if present and if requested */</comment>
	<comment type="block">/*
	 * In a split update, the processed rows are returned by the INSERT
	 * of the new row, not the DELETE of the old one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>processReturning</name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have to put the target tuple into a slot, which means first we
		 * gotta fetch it.  We can use the trigger tuple slot.
		 */</comment>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>rslot</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* FDW must have provided a slot containing the deleted row */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecGetReturningSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>oldtuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>,
												   <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch deleted tuple for DELETE RETURNING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>rslot</name> <operator>=</operator> <call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Before releasing the target tuple again, make sure rslot has a
		 * local copy of any pass-by-reference values.
		 */</comment>
		<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>rslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>rslot</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecUpdate
 *
 *		note: we can't run UPDATE queries with transactions
 *		off because UPDATEs are actually INSERTs and our
 *		scan will mistakenly loop forever, updating the tuple
 *		it just inserted..  This should be fixed but until it
 *		is, we don't want to get stuck in an infinite loop
 *		which corrupts your database..
 *
 *		When updating a table, tupleid identifies the tuple to
 *		update and oldtuple is NULL.  When updating a view, oldtuple
 *		is passed to the INSTEAD OF triggers and identifies what to
 *		update, and tupleid is invalid.  When updating a foreign table,
 *		tupleid is invalid; the FDW has to figure out which row to
 *		update using data from the planSlot.  oldtuple is passed to
 *		foreign table triggers; it is NULL when the foreign table has
 *		no relevant triggers.
 *
 *		Returns RETURNING result if any, otherwise NULL.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
		   <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
		   <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
		   <parameter><decl><type><name>int32</name></type> <name>segid</name></decl></parameter>, <comment type="block">/* gpdb specific parameter, check if tuple to update is from local */</comment>
		   <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
		   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>tmfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>recheckIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>saved_tcs_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * abort the operation if not running transactions
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot UPDATE during bootstrap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Sanity check the distribution of the tuple to prevent
	 * potential data corruption in case users manipulate data
	 * incorrectly (e.g. insert data on incorrect segment through
	 * utility mode) or there is bug in code, etc.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>segid</name> <operator>!=</operator> <name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"distribution key of the tuple (%u, %u) doesn't belong to "</literal>
			 <literal type="string">"current segment (actually from seg%d)"</literal></expr></argument>,
			 <argument><expr><call><name>BlockIdGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tupleid</name><operator>-&gt;</operator><name>ip_blkid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name><name>tupleid</name><operator>-&gt;</operator><name>ip_posid</name></name></expr></argument>,
			 <argument><expr><name>segid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get information on the (current) result relation
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* BEFORE ROW UPDATE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecBRUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								  <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* "do nothing" */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INSTEAD OF ROW UPDATE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_update_instead_row</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecIRUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								  <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* "do nothing" */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Compute stored generated columns
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecComputeStoredGenerated</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * update in foreign table: let the FDW do it
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignUpdate</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
															   <argument><expr><name>resultRelInfo</name></expr></argument>,
															   <argument><expr><name>slot</name></expr></argument>,
															   <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * AFTER ROW Triggers or RETURNING expressions might reference the
		 * tableoid column, so (re-)initialize tts_tableOid before evaluating
		 * them.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>partition_constraint_failed</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>update_indexes</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Constraints might reference the tableoid column, so (re-)initialize
		 * tts_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute stored generated columns
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecComputeStoredGenerated</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check any RLS UPDATE WITH CHECK policies
		 *
		 * If we generate a new candidate tuple after EvalPlanQual testing, we
		 * must loop back here and recheck any RLS policies and constraints.
		 * (We don't need to redo triggers, however.  If there are any BEFORE
		 * triggers then trigger.c will have done table_tuple_lock to lock the
		 * correct tuple, so there's no need to do them again.)
		 */</comment>
<label><name>lreplace</name>:</label><empty_stmt>;</empty_stmt>

		<comment type="block">/* ensure slot is independent, consider e.g. EPQ */</comment>
		<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If partition constraint fails, this row might get moved to another
		 * partition, in which case we should check the RLS CHECK policy just
		 * before inserting into the new partition, rather than doing it here.
		 * This is because a trigger on that partition might again change the
		 * row.  So skip the WCO checks if the partition constraint fails.
		 */</comment>
		<expr_stmt><expr><name>partition_constraint_failed</name> <operator>=</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partition_constraint_failed</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ExecWithCheckOptions() will skip any WCOs which are not of the
			 * kind we are looking for at this point.
			 */</comment>
			<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_RLS_UPDATE_CHECK</name></expr></argument>,
								 <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If a partition check failed, try to move the row into the right
		 * partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>partition_constraint_failed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>tuple_deleted</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>ret_slot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>map_index</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupconv_map</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Disallow an INSERT ON CONFLICT DO UPDATE that causes the
			 * original row to migrate to a different partition.  Maybe this
			 * can be implemented some day, but it seems a fringe feature with
			 * little redeeming value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>onConflictAction</name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid ON UPDATE specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The result tuple would appear in a different partition than the original tuple."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * When an UPDATE is run on a leaf partition, we will not have
			 * partition tuple routing set up. In that case, fail with
			 * partition constraint violation error.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>proute</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecPartitionCheckEmitError</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Row movement, part 1.  Delete the tuple, but skip RETURNING
			 * processing. We want to return rows from INSERT.
			 */</comment>
			<expr_stmt><expr><call><name>ExecDelete</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>segid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>, <argument><expr><name>epqstate</name></expr></argument>,
					   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* canSetTag */</comment> ,
					   <argument><expr><name>true</name></expr></argument> <comment type="block">/* changingPart */</comment> ,
					   <argument><expr><name>false</name></expr></argument> <comment type="block">/* splitUpdate */</comment> ,
					   <argument><expr><operator>&amp;</operator><name>tuple_deleted</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epqslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * For some reason if DELETE didn't happen (e.g. trigger prevented
			 * it, or it was already deleted by self, or it was concurrently
			 * deleted by another transaction), then we should skip the insert
			 * as well; otherwise, an UPDATE could cause an increase in the
			 * total number of rows across all partitions, which is clearly
			 * wrong.
			 *
			 * For a normal UPDATE, the case where the tuple has been the
			 * subject of a concurrent UPDATE or DELETE would be handled by
			 * the EvalPlanQual machinery, but for an UPDATE that we've
			 * translated into a DELETE from this partition and an INSERT into
			 * some other partition, that's not available, because CTID chains
			 * can't span relation boundaries.  We mimic the semantics to a
			 * limited extent by skipping the INSERT if the DELETE fails to
			 * find a tuple. This ensures that two concurrent attempts to
			 * UPDATE the same tuple at the same time can't turn one tuple
			 * into two, and that an UPDATE of a just-deleted tuple can't
			 * resurrect it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuple_deleted</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * epqslot will be typically NULL.  But when ExecDelete()
				 * finds that another transaction has concurrently updated the
				 * same row, it re-fetches the row, skips the delete, and
				 * epqslot is set to the re-fetched tuple slot. In that case,
				 * we need to do all the checks again.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr></argument>, <argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>lreplace</name>;</goto>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Updates set the transition capture map only when a new subplan
			 * is chosen.  But for inserts, it is set for each row. So after
			 * INSERT, we need to revert back to the map created for UPDATE;
			 * otherwise the next UPDATE will incorrectly use the one created
			 * for INSERT.  So first save the one created for UPDATE.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>saved_tcs_map</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * resultRelInfo is one of the per-subplan resultRelInfos.  So we
			 * should convert the tuple into root's tuple descriptor, since
			 * ExecInsert() starts the search from root.  The tuple conversion
			 * map list is in the order of mtstate-&gt;resultRelInfo[], so to
			 * retrieve the one for this resultRel, we need to know the
			 * position of the resultRel in mtstate-&gt;resultRelInfo[].
			 */</comment>
			<expr_stmt><expr><name>map_index</name> <operator>=</operator> <name>resultRelInfo</name> <operator>-</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>map_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>map_index</name> <operator>&lt;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tupconv_map</name> <operator>=</operator> <call><name>tupconv_map_for_subplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>map_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tupconv_map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>tupconv_map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>,
											 <argument><expr><name>slot</name></expr></argument>,
											 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_root_tuple_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Prepare for tuple routing, making it look like we're inserting
			 * into the root.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecPrepareTupleRouting</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>,
										   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret_slot</name> <operator>=</operator> <call><name>ExecInsert</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
								  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>canSetTag</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* splitUpdate */</comment>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Revert ExecPrepareTupleRouting's node change. */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator> <name>saved_tcs_map</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>ret_slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check the constraints of the tuple.  We've already checked the
		 * partition constraint above; however, we must still ensure the tuple
		 * passes all other constraints, so we will call ExecConstraints() and
		 * have it validate all remaining checks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * replace the heap tuple
		 *
		 * Note: if es_crosscheck_snapshot isn't InvalidSnapshot, we check
		 * that the row to be updated is visible to that snapshot, and throw a
		 * can't-serialize error if not. This is a special-case behavior
		 * needed for referential integrity updates in transaction-snapshot
		 * mode transactions.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_update</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument> <comment type="block">/* wait for commit */</comment> ,
									<argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lockmode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>update_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TM_SelfModified</name></expr>:</case>

				<comment type="block">/*
				 * The target tuple was already updated or deleted by the
				 * current command, or by a later command in the current
				 * transaction.  The former case is possible in a join UPDATE
				 * where multiple tuples join to the same target tuple. This
				 * is pretty questionable, but Postgres has always allowed it:
				 * we just execute the first update action and ignore
				 * additional update attempts.
				 *
				 * The latter case arises if the tuple is modified by a
				 * command in a BEFORE trigger, or perhaps by a command in a
				 * volatile function used in the query.  In such situations we
				 * should not ignore the update, but it is equally unsafe to
				 * proceed.  We don't want to discard the original UPDATE
				 * while keeping the triggered actions based on it; and we
				 * have no principled way to merge this update with the
				 * previous ones.  So throwing an error is the only safe
				 * course.
				 *
				 * If a trigger actually intends this type of interaction, it
				 * can re-execute the UPDATE (assuming it can figure out how)
				 * and then return NULL to cancel the outer update.
				 *
				 * In GPDB, for AO tables TM_SelfModified is returned only
				 * in case of same command tuple update based on visimap dirty
				 * list checking. Also, tmfd is not initialized and can't be for
				 * AO case, as visimap update within same command happens at end
				 * of command.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>tmfd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be updated was already modified by an operation triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Else, already updated by self; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<case>case <expr><name>TM_Ok</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>TM_Updated</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inputslot</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Already know that we're going to need to do EPQ, so
					 * fetch tuple directly into the right slot.
					 */</comment>
					<expr_stmt><expr><call><name>EvalPlanQualBegin</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>inputslot</name> <operator>=</operator> <call><name>EvalPlanQualSlot</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>resultRelationDesc</name></expr></argument>,
												 <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_lock</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>,
											  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
											  <argument><expr><name>inputslot</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
											  <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>LockWaitBlock</name></expr></argument>,
											  <argument><expr><name>TUPLE_LOCK_FLAG_FIND_LAST_VERSION</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>TM_Ok</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmfd</name><operator>.</operator><name>traversed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><name>epqslot</name> <operator>=</operator> <call><name>EvalPlanQual</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
												   <argument><expr><name>epqstate</name></expr></argument>,
												   <argument><expr><name>resultRelationDesc</name></expr></argument>,
												   <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
												   <argument><expr><name>inputslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<comment type="block">/* Tuple not passing quals anymore, exiting... */</comment>
								<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

							<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr></argument>, <argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>lreplace</name>;</goto>

						<case>case <expr><name>TM_Deleted</name></expr>:</case>
							<comment type="block">/* tuple already deleted; nothing to do */</comment>
							<return>return <expr><name>NULL</name></expr>;</return>

						<case>case <expr><name>TM_SelfModified</name></expr>:</case>

							<comment type="block">/*
							 * This can be reached when following an update
							 * chain from a tuple updated by another session,
							 * reaching a tuple that was already updated in
							 * this transaction. If previously modified by
							 * this command, ignore the redundant update,
							 * otherwise error out.
							 *
							 * See also TM_SelfModified response to
							 * table_tuple_update() above.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name><name>tmfd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be updated was already modified by an operation triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<return>return <expr><name>NULL</name></expr>;</return>

						<default>default:</default>
							<comment type="block">/* see table_tuple_lock call in ExecDelete() */</comment>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected table_tuple_lock status: %u"</literal></expr></argument>,
								 <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>NULL</name></expr>;</return>
					</block_content>}</block></switch>
				</block_content>}</block>

				<break>break;</break>

			<case>case <expr><name>TM_Deleted</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent delete"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* tuple already deleted; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized table_tuple_update status: %u"</literal></expr></argument>,
					 <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></switch>

		<comment type="block">/* insert index entries for tuple if necessary */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>update_indexes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* AFTER ROW UPDATE Triggers */</comment>
	<comment type="block">/* GPDB: AO and AOCO tables don't support triggers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecARUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
						 <argument><expr><name>recheckIndexes</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr> ?</condition><then>
						 <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name></expr> </then><else>:
						 <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check any WITH CHECK OPTION constraints from parent views.  We are
	 * required to do this after testing all constraints and uniqueness
	 * violations per the SQL spec, so we do it after actually updating the
	 * record in the heap and all indexes.
	 *
	 * ExecWithCheckOptions() will skip any WCOs which are not of the kind we
	 * are looking for at this point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_VIEW_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Process RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert the new tuple version of a Split Update
 *
 * We have to check if this UPDATE also moves the row to
 * a different partition, much like ExecUpdate() does.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecSplitUpdate_Insert</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
					   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
					   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partition_constraint_failed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>saved_tcs_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>map_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupconv_map</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get information on the (current) result relation
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* ensure slot is independent, consider e.g. EPQ */</comment>
	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If partition constraint fails, this row might get moved to another
	 * partition, in which case we should check the RLS CHECK policy just
	 * before inserting into the new partition, rather than doing it here.
	 * This is because a trigger on that partition might again change the
	 * row.  So skip the WCO checks if the partition constraint fails.
	 */</comment>
	<expr_stmt><expr><name>partition_constraint_failed</name> <operator>=</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partition_constraint_failed</name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * ExecWithCheckOptions() will skip any WCOs which are not of the
		 * kind we are looking for at this point.
		 */</comment>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_RLS_UPDATE_CHECK</name></expr></argument>,
							 <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Updates set the transition capture map only when a new subplan
	 * is chosen.  But for inserts, it is set for each row. So after
	 * INSERT, we need to revert back to the map created for UPDATE;
	 * otherwise the next UPDATE will incorrectly use the one created
	 * for INSERT.  So first save the one created for UPDATE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>saved_tcs_map</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>partition_constraint_failed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When an UPDATE is run on a leaf partition, we will not have
		 * partition tuple routing set up. In that case, fail with
		 * partition constraint violation error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>proute</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecPartitionCheckEmitError</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * resultRelInfo is one of the per-subplan resultRelInfos.  So we
		 * should convert the tuple into root's tuple descriptor, since
		 * ExecInsert() starts the search from root.  The tuple conversion
		 * map list is in the order of mtstate-&gt;resultRelInfo[], so to
		 * retrieve the one for this resultRel, we need to know the
		 * position of the resultRel in mtstate-&gt;resultRelInfo[].
		 */</comment>
		<expr_stmt><expr><name>map_index</name> <operator>=</operator> <name>resultRelInfo</name> <operator>-</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>map_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>map_index</name> <operator>&lt;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupconv_map</name> <operator>=</operator> <call><name>tupconv_map_for_subplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>map_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tupconv_map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>tupconv_map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>,
										 <argument><expr><name>slot</name></expr></argument>,
										 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_root_tuple_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Prepare for tuple routing, making it look like we're inserting
		 * into the root.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecPrepareTupleRouting</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>,
									   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInsert</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
						  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
						  <argument><expr><name>true</name></expr></argument> <comment type="block">/* splitUpdate */</comment>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Revert ExecPrepareTupleRouting's node change. */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator> <name>saved_tcs_map</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInsert</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
						  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
						  <argument><expr><name>true</name></expr></argument> <comment type="block">/* splitUpdate */</comment>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecOnConflictUpdate --- execute UPDATE of INSERT ON CONFLICT DO UPDATE
 *
 * Try to lock tuple for update as part of speculative insertion.  If
 * a qual originating from ON CONFLICT DO UPDATE is satisfied, update
 * (but still lock row, even though it may not satisfy estate's
 * snapshot).
 *
 * Returns true if we're done (with or without an update), or false if
 * the caller must retry the INSERT from scratch.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecOnConflictUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
					 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					 <parameter><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>excludedSlot</name></decl></parameter>,
					 <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>returning</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>onConflictSetWhere</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_WhereClause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>existing</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_Existing</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>tmfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>test</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>xminDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/* Determine lock mode to use */</comment>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <call><name>ExecUpdateLockMode</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock tuple for update.  Don't follow updates when tuple cannot be
	 * locked without doing so.  A row locking conflict here means our
	 * previous conclusion that the tuple is conclusively committed is not
	 * true anymore.
	 */</comment>
	<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>table_tuple_lock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>conflictTid</name></expr></argument>,
							<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
							<argument><expr><name>existing</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
							<argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>LockWaitBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>test</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TM_Ok</name></expr>:</case>
			<comment type="block">/* success! */</comment>
			<break>break;</break>

		<case>case <expr><name>TM_Invisible</name></expr>:</case>

			<comment type="block">/*
			 * This can occur when a just inserted tuple is updated again in
			 * the same command. E.g. because multiple rows with the same
			 * conflicting key values are inserted.
			 *
			 * This is somewhat similar to the ExecUpdate() TM_SelfModified
			 * case.  We do not want to proceed because it would lead to the
			 * same row being updated a second time in some unspecified order,
			 * and in contrast to plain UPDATEs there's no historical behavior
			 * to break.
			 *
			 * It is the user's responsibility to prevent this situation from
			 * occurring.  These problems are why SQL-2003 similarly specifies
			 * that for SQL MERGE, an exception must be raised in the event of
			 * an attempt to update the same row twice.
			 */</comment>
			<expr_stmt><expr><name>xminDatum</name> <operator>=</operator> <call><name>slot_getsysattr</name><argument_list>(<argument><expr><name>existing</name></expr></argument>,
										<argument><expr><name>MinTransactionIdAttributeNumber</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>DatumGetTransactionId</name><argument_list>(<argument><expr><name>xminDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON CONFLICT DO UPDATE command cannot affect row a second time"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Ensure that no rows proposed for insertion within the same command have duplicate constrained values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* This shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempted to lock invisible tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TM_SelfModified</name></expr>:</case>

			<comment type="block">/*
			 * This state should never be reached. As a dirty snapshot is used
			 * to find conflicting tuples, speculative insertion wouldn't have
			 * seen this row to conflict with.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected self-updated tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TM_Updated</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * As long as we don't support an UPDATE of INSERT ON CONFLICT for
			 * a partitioned table we shouldn't reach to a case where tuple to
			 * be lock is moved to another partition due to concurrent update
			 * of the partition key.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmfd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Tell caller to try again from the very start.
			 *
			 * It does not make sense to use the usual EvalPlanQual() style
			 * loop here, as the new version of the row might not conflict
			 * anymore, or the conflicting tuple has actually been deleted.
			 */</comment>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>TM_Deleted</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent delete"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* see TM_Updated case */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmfd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized table_tuple_lock status: %u"</literal></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* Success, the tuple is locked. */</comment>

	<comment type="block">/*
	 * Verify that the tuple is visible to our MVCC snapshot if the current
	 * isolation level mandates that.
	 *
	 * It's not sufficient to rely on the check within ExecUpdate() as e.g.
	 * CONFLICT ... WHERE clause may prevent us from reaching that.
	 *
	 * This means we only ever continue when a new command in the current
	 * transaction could see the row, even though in READ COMMITTED mode the
	 * tuple will not be visible according to the current statement's
	 * snapshot.  This is in line with the way UPDATE deals with newer tuple
	 * versions.
	 */</comment>
	<expr_stmt><expr><call><name>ExecCheckTupleVisible</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make tuple and any needed join variables available to ExecQual and
	 * ExecProject.  The EXCLUDED tuple is installed in ecxt_innertuple, while
	 * the target's existing tuple is installed in the scantuple.  EXCLUDED
	 * has been made to reference INNER_VAR in setrefs.c, but there is no
	 * other redirection.
	 */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>existing</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>excludedSlot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>onConflictSetWhere</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* see return below */</comment>
		<expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* done with the tuple */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check target's existing tuple against UPDATE-applicable USING
		 * security barrier quals (if any), enforced here as RLS checks/WCOs.
		 *
		 * The rewriter creates UPDATE RLS checks/WCOs for UPDATE security
		 * quals, and stores them as WCOs of "kind" WCO_RLS_CONFLICT_CHECK,
		 * but that's almost the extent of its special handling for ON
		 * CONFLICT DO UPDATE.
		 *
		 * The rewriter will also have associated UPDATE applicable straight
		 * RLS checks/WCOs for the benefit of the ExecUpdate() call that
		 * follows.  INSERTs and UPDATEs naturally have mutually exclusive WCO
		 * kinds, so there is no danger of spurious over-enforcement in the
		 * INSERT or UPDATE path.
		 */</comment>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_RLS_CONFLICT_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
							 <argument><expr><name>existing</name></expr></argument>,
							 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Project the new tuple version */</comment>
	<expr_stmt><expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that it is possible that the target tuple has been modified in
	 * this session, after the above table_tuple_lock. We choose to not error
	 * out in that case, in line with ExecUpdate's treatment of similar cases.
	 * This can happen if an UPDATE is triggered from within ExecQual(),
	 * ExecWithCheckOptions() or ExecProject() above, e.g. by selecting from a
	 * wCTE in the ON CONFLICT's SET.
	 */</comment>

	<comment type="block">/* Execute UPDATE with projection */</comment>
	<expr_stmt><expr><operator>*</operator><name>returning</name> <operator>=</operator> <call><name>ExecUpdate</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>conflictTid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name></expr></argument>,
							<argument><expr><name>planSlot</name></expr></argument>,
							<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
							<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clear out existing tuple, as there might not be another conflict among
	 * the next input rows. Don't want to hold resources till the end of the
	 * query.
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Process BEFORE EACH STATEMENT triggers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fireBSTriggers</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the node modifies a partitioned table, we must fire its triggers.
	 * Note that in that case, node-&gt;resultRelInfo points to the first leaf
	 * partition, not the root table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecBSInsertTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecBSUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
									 <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecBSUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecBSDeleteTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Return the target rel ResultRelInfo.
 *
 * This relation is the same as :
 * - the relation for which we will fire AFTER STATEMENT triggers.
 * - the relation into whose tuple format all captured transition tuples must
 *   be converted.
 * - the root partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>getTargetResultRelInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Note that if the node modifies a partitioned table, node-&gt;resultRelInfo
	 * points to the first leaf partition, not the root table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process AFTER EACH STATEMENT triggers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fireASTriggers</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><call><name>getTargetResultRelInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecASUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
									 <argument><expr><name>resultRelInfo</name></expr></argument>,
									 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ExecASInsertTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecASUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecASDeleteTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Set up the state needed for collecting transition tuples for AFTER
 * triggers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecSetupTransitionCaptureState</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>targetRelInfo</name> <init>= <expr><call><name>getTargetResultRelInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check for transition tables on the directly targeted relation. */</comment>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>=</operator>
		<call><name>MakeTransitionCaptureState</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
		<name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name> <operator>=</operator>
			<call><name>MakeTransitionCaptureState</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></argument>,
									   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>CMD_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we found that we need to collect transition tuples then we may also
	 * need tuple conversion maps for any children that have TupleDescs that
	 * aren't compatible with the tuplestores.  (We can share these maps
	 * between the regular and ON CONFLICT cases.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
		<name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecSetupChildParentMapForSubplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Install the conversion map for the first plan for UPDATE and DELETE
		 * operations.  It will be advanced each time we switch to the next
		 * plan.  (INSERT operations set it every time, so we need not update
		 * mtstate-&gt;mt_oc_transition_capture here.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>!=</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
				<call><name>tupconv_map_for_subplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPrepareTupleRouting --- prepare for routing one tuple
 *
 * Determine the partition in which the tuple in slot is to be inserted,
 * and modify mtstate and estate to prepare for it.
 *
 * Caller must revert the estate changes after executing the insertion!
 * In mtstate, transition capture changes may also need to be reverted.
 *
 * Returns a slot holding the tuple of the partition rowtype.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecPrepareTupleRouting</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
						<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
						<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>targetRelInfo</name></decl></parameter>,
						<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>partrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRoutingInfo</name> <modifier>*</modifier></type><name>partrouteinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Lookup the target partition's ResultRelInfo.  If ExecFindPartition does
	 * not find a valid partition for the tuple in 'slot' then an error is
	 * raised.  An error may also be raised if the found partition is not a
	 * valid target for INSERTs.  This is required since a partitioned table
	 * UPDATE to another partition becomes a DELETE+INSERT.
	 */</comment>
	<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>ExecFindPartition</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>targetRelInfo</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partrouteinfo</name> <operator>=</operator> <name><name>partrel</name><operator>-&gt;</operator><name>ri_PartitionInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partrouteinfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make it look like we are inserting into the partition.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>partrel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're capturing transition tuples, we might need to convert from the
	 * partition rowtype to root partitioned table's rowtype.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>partrel</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
			<name><name>partrel</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there are any BEFORE triggers on the partition, we'll have
			 * to be ready to convert their result back to tuplestore format.
			 */</comment>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
				<name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_PartitionToRootMap</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, just remember the original unconverted tuple, to
			 * avoid a needless round trip conversion.
			 */</comment>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
			<name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_PartitionToRootMap</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Convert the tuple, if necessary.
	 */</comment>
	<expr_stmt><expr><name>map</name> <operator>=</operator> <name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_RootToPartitionMap</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>new_slot</name> <init>= <expr><name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_PartitionTupleSlot</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>new_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the child-to-root tuple conversion map array for UPDATE subplans.
 *
 * This map array is required to convert the tuple from the subplan result rel
 * to the target table descriptor. This requirement arises for two independent
 * scenarios:
 * 1. For update-tuple-routing.
 * 2. For capturing tuples in transition tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecSetupChildParentMapForSubplan</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>targetRelInfo</name> <init>= <expr><call><name>getTargetResultRelInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>outdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numResultRelInfos</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build array of conversion maps from each child's TupleDesc to the one
	 * used in the target relation.  The map pointers may be NULL when no
	 * conversion is necessary, which is hopefully a common case.
	 */</comment>

	<comment type="block">/* Get tuple descriptor of the target rel. */</comment>
	<expr_stmt><expr><name>outdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name></name> <operator>=</operator> <operator>(</operator><name>TupleConversionMap</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConversionMap</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numResultRelInfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numResultRelInfos</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
			<call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>outdesc</name></expr></argument>,
								   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * For a given subplan index, get the tuple conversion map.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleConversionMap</name> <modifier>*</modifier></type>
<name>tupconv_map_for_subplan</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whichplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If nobody else set the per-subplan array of maps, do so ourselves. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecSetupChildParentMapForSubplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>whichplan</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>whichplan</name> <operator>&lt;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name><index>[<expr><name>whichplan</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *	   ExecModifyTable
 *
 *		Perform table modifications as required, and return RETURNING results
 *		if needed.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecModifyTable</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>saved_resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>junkfilter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>  <name>action_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>  <name>segid_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tuple_ctid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>oldtupdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This should NOT get called during EvalPlanQual; we should have passed a
	 * subplan tree to EvalPlanQual, instead.  Use a runtime test not just
	 * Assert because this condition is easy to miss in testing.  (Note:
	 * although ModifyTable should not get executed within an EvalPlanQual
	 * operation, we do have to allow it to be initialized and shut down in
	 * case it is within a CTE subplan.  Hence this test must be here, not in
	 * ExecInitModifyTable.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ModifyTable should not be called during EvalPlanQual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we've already completed processing, don't try to do more.  We need
	 * this test because ExecPostprocessPlan might call us an extra time, and
	 * our subplan's nodes aren't necessarily robust against being called
	 * extra times.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Gp_is_writer</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Current Greenplum MPP architecture only support one writer gang, and
		 * only writer gang can execute DML nodes. There is no code path to reach
		 * here. For writable CTE case as below:
		 *
		 *   create table t(a int);
		 *   with wcte as (delete from t returning a)
		 *     insert into t select * from wcte;
		 *
		 * The above query will error out during parse-analyze so not reach here.
		 * If reaching here, some bugs must happen.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Reader Gang execute ModifyTable node, some bugs must happen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * On first call, fire BEFORE STATEMENT triggers before proceeding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>fireBSTriggers</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fireBSTriggers</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fireBSTriggers</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Preload local variables */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplanstate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>junkfilter</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>action_attno</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_action_attno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>segid_attno</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_segid_attno</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * es_result_relation_info must point to the currently active result
	 * relation while we are within this ModifyTable node.  Even though
	 * ModifyTable nodes can't be nested statically, they can be nested
	 * dynamically (since our subplan could include a reference to a modifying
	 * CTE).  So we have to save and restore the caller's value.
	 */</comment>
	<expr_stmt><expr><name>saved_resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch rows from subplan(s), and execute the required table modification
	 * for each row.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Reset the per-output-tuple exprcontext.  This is needed because
		 * triggers expect to use that context as workspace.  It's a bit ugly
		 * to do this below the top level of the plan, however.  We might need
		 * to rethink this later.
		 */</comment>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset per-tuple memory context used for processing on conflict and
		 * returning clauses, to free any expression evaluation storage
		 * allocated in the previous cycle.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>planSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* advance to next subplan if any */</comment>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>subplanstate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>junkfilter</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>action_attno</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_action_attno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>segid_attno</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_segid_attno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EvalPlanQualSetPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name><name>subplanstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
									<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_arowmarks</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Prepare to convert transition tuples from this child. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
						<call><name>tupconv_map_for_subplan</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
						<call><name>tupconv_map_for_subplan</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Ensure input tuple is the right format for the target relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_scans</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>]</index></name><operator>-&gt;</operator><name>tts_ops</name> <operator>!=</operator> <name><name>planSlot</name><operator>-&gt;</operator><name>tts_ops</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_scans</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>planSlot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_scans</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If resultRelInfo-&gt;ri_usesFdwDirectModify is true, all we need to do
		 * here is compute the RETURNING expressions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * A scan slot containing the data that was actually inserted,
			 * updated or deleted has already been made available to
			 * ExecProcessReturning by IterateDirectModify, so no need to
			 * provide it here.
			 */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>
			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>EvalPlanQualSetSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name>planSlot</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int32</name></type> <name>segid</name> <init>= <expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>action</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>tupleid</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>junkfilter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * extract the 'ctid' or 'wholerow' junk attribute.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
					<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
					<call><name>IsAppendonlyMetadataRelkind</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
												 <argument><expr><name><name>junkfilter</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* shouldn't ever get a null result... */</comment>
					<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ctid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>tupleid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tuple_ctid</name> <operator>=</operator> <operator>*</operator><name>tupleid</name></expr>;</expr_stmt>	<comment type="block">/* be sure we don't free ctid!! */</comment>
					<expr_stmt><expr><name>tupleid</name> <operator>=</operator> <operator>&amp;</operator><name>tuple_ctid</name></expr>;</expr_stmt>
				</block_content>}</block></if>

				<comment type="block">/*
				 * Use the wholerow attribute, when available, to reconstruct
				 * the old relation tuple.
				 *
				 * Foreign table updates have a wholerow attribute when the
				 * relation has a row-level trigger.  Note that the wholerow
				 * attribute does not carry system columns.  Foreign table
				 * triggers miss seeing those, except that we know enough here
				 * to set t_tableOid.  Quite separately from this, the FDW may
				 * fetch its own junk attrs to identify the row.
				 *
				 * Other relevant relkinds, currently limited to views, always
				 * have a wholerow attribute.
				 */</comment>
				<if type="elseif">else if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>junkfilter</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
												 <argument><expr><name><name>junkfilter</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* shouldn't ever get a null result... */</comment>
					<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wholerow is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>oldtupdata</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>oldtupdata</name><operator>.</operator><name>t_len</name></name> <operator>=</operator>
						<call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name><name>oldtupdata</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtupdata</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Historically, view triggers see invalid t_tableOid. */</comment>
					<expr_stmt><expr><name><name>oldtupdata</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator>
						<ternary><condition><expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>:
						<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <operator>&amp;</operator><name>oldtupdata</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/*
				 * Extract GPDB-specific junk attributes.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>segid_attno</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
												 <argument><expr><name>segid_attno</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* shouldn't ever get a null result... */</comment>
					<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"gp_segment_id is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>segid</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>action_attno</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
												 <argument><expr><name>action_attno</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* shouldn't ever get a null result... */</comment>
					<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"action is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * apply the junkfilter if needed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name>junkfilter</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CMD_INSERT</name></expr>:</case>
				<comment type="block">/* Prepare for tuple routing if needed. */</comment>
				<if_stmt><if>if <condition>(<expr><name>proute</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecPrepareTupleRouting</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>,
												   <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInsert</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
								  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* splitUpdate */</comment>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Revert ExecPrepareTupleRouting's state change. */</comment>
				<if_stmt><if>if <condition>(<expr><name>proute</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
				<comment type="block">/* Prepare for tuple routing if needed. */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>forceTupleRouting</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecPrepareTupleRouting</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>,
												   <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>action_attno</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* normal non-split UPDATE */</comment>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecUpdate</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
									  <argument><expr><name>segid</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>DML_INSERT</name> <operator>==</operator> <name>action</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecSplitUpdate_Insert</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else <comment type="block">/* DML_DELETE */</comment>
				<block>{<block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecDelete</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>segid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument> <comment type="block">/* canSetTag */</comment>,
									  <argument><expr><name>true</name></expr></argument> <comment type="block">/* changingPart */</comment> ,
									  <argument><expr><name>true</name></expr></argument> <comment type="block">/* splitUpdate */</comment> ,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<comment type="block">/* Revert ExecPrepareTupleRouting's state change. */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>forceTupleRouting</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_DELETE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>forceTupleRouting</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>planSlot</name> <operator>=</operator> <call><name>ExecPrepareTupleRouting</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>,
												   <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecDelete</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>segid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument> <comment type="block">/* changingPart */</comment> ,
								  <argument><expr><name>false</name></expr></argument> <comment type="block">/* splitUpdate */</comment> ,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>forceTupleRouting</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * If the target is a partitioned table, ExecInsert / ExecUpdate /
		 * ExecDelete might have changed es_result_relation_info to point to
		 * a partition, instead of the top-level table. Reset it. (It would
		 * be more tidy if those functions cleaned up after themselves, but
		 * it's more robust to do it here just once.)
		 */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we got a RETURNING result, return it to caller.  We'll continue
		 * the work on next call.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>slot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>
			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Restore es_result_relation_info before exiting */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We're done, but fire AFTER STATEMENT triggers before exiting.
	 */</comment>
	<comment type="block">/* In GPDB, don't fire statement triggers in reader processes */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator> <name>Gp_is_writer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fireASTriggers</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mt_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitModifyTable
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>ModifyTableState</name> <modifier>*</modifier></type>
<name>ExecInitModifyTable</name><parameter_list>(<parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nplans</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>saved_resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>update_tuple_routing_needed</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>partColsUpdated</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>mtstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecModifyTable</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>operation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name></name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>resultRelIndex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_scans</name></name> <operator>=</operator> <operator>(</operator><name>TupleTableSlot</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleTableSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If modifying a partitioned table, initialize the root table info */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelIndex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>+</operator>
			<name><name>node</name><operator>-&gt;</operator><name>rootResultRelIndex</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_arowmarks</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name> <operator>=</operator> <name>nplans</name></expr>;</expr_stmt>

	<comment type="block">/* set up epqstate with dummy subplan data for the moment */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>epqParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>CMD_UPDATE</name> <operator>==</operator> <name>operation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_isSplitUpdates</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nplans</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>isSplitUpdates</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>isSplitUpdates</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nplans</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ModifyTable node is missing is-split-update information"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;isSplitUpdates</argument>)</argument_list></macro>
				<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_isSplitUpdates</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* GPDB: Don't fire statement-triggers in QE reader processes */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator> <name>Gp_is_writer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>fireBSTriggers</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * call ExecInitNode on each of the plans to be executed and save the
	 * results into the array "mt_plans".  This is also a convenient place to
	 * verify that the proposed target relations are valid and open their
	 * indexes for insertion of new index entries.  Note we *must* set
	 * estate-&gt;es_result_relation_info correctly while we initialize each
	 * sub-plan; external modules such as FDWs may depend on that (see
	 * contrib/postgres_fdw/postgres_fdw.c: postgresBeginDirectModify() as one
	 * example).
	 */</comment>
	<expr_stmt><expr><name>saved_resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;plans</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize the usesFdwDirectModify flag */</comment>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>,
															  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>fdwDirectModifyPlans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Verify result relation is a valid target for the current operation
		 */</comment>
		<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB: We don't support SERIALIZABLE transaction isolation for
		 * UPDATES/DELETES on AO/CO tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updates on append-only tables are not "</literal>
								   <literal type="string">"supported in serializable transactions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"deletes on append-only tables are not "</literal>
								   <literal type="string">"supported in serializable transactions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there are indices on the result relation, open them and save
		 * descriptors in the result relation info, so that we can add new
		 * index entries for the tuples we add/update.  We need not do this
		 * for a DELETE, however, since deletion doesn't affect indexes. Also,
		 * inside an EvalPlanQual operation, the indexes might be open
		 * already, since we share the resultrel state with the original
		 * query.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator>
			<name>operation</name> <operator>!=</operator> <name>CMD_DELETE</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
							<argument><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this is an UPDATE and a BEFORE UPDATE trigger is present, the
		 * trigger itself might modify the partition-key values. So arrange
		 * for tuple routing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name> <operator>&amp;&amp;</operator>
			<name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>update_tuple_routing_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Now init the plan for this result rel */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_scans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_tableam</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>table_dml_init</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Also let FDWs init themselves for foreign-table result rels */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignModify</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_private</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fdwPrivLists</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignModify</name></name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
															 <argument><expr><name>resultRelInfo</name></expr></argument>,
															 <argument><expr><name>fdw_private</name></expr></argument>,
															 <argument><expr><name>i</name></expr></argument>,
															 <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/* Get the target relation */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <operator>(</operator><call><name>getTargetResultRelInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>ri_RelationDesc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB dynamic scan nodes optimize memory usage by avoiding the need to
	 * maintain a data structure for every partition node. In the plan tree
	 * this is represented as a single dynamic scan node as opposed to an
	 * append over many leaf partitions. The different plan representations
	 * require different execution paths in modify table.
	 *
	 * In the case of append, a basic scan on a leaf partition requires no
	 * tuple routing unless an update to the partition key causes the tuple to
	 * be routed to another relation.
	 *
	 * In the case of dynamic scan, the node hierarchy always requires tuple
	 * routing to find the corresponding relation. If update to a partition key
	 * causes the tuple to be routed, then we must perform tuple routing a
	 * second time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>forceTupleRouting</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>update_tuple_routing_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's not a partitioned table after all, UPDATE tuple routing should
	 * not be attempted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>update_tuple_routing_needed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build state for tuple routing if it's an INSERT or if it's an UPDATE of
	 * partition key.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>update_tuple_routing_needed</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name> <operator>=</operator>
			<call><name>ExecSetupPartitionTupleRouting</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build state for collecting transition tuples.  This requires having a
	 * valid trigger query context, so skip it in explain-only mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecSetupTransitionCaptureState</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Construct mapping from each of the per-subplan partition attnos to the
	 * root attno.  This is required when during update row movement the tuple
	 * descriptor of a source partition does not match the root partitioned
	 * table descriptor.  In such a case we need to convert tuples to the root
	 * tuple descriptor, because the search for destination partition starts
	 * from the root.  We'll also need a slot to store these converted tuples.
	 * We can skip this setup if it's not a partition key update.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_tuple_routing_needed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecSetupChildParentMapForSubplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_root_tuple_slot</name></name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize any WITH CHECK OPTION constraints if needed.
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;withCheckOptionLists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoExprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ll</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>ll</argument>, <argument>wcoList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><operator>(</operator><name>WithCheckOption</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>wcoExpr</name> <init>= <expr><call><name>ExecInitQual</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>wcoExprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>wcoExprs</name></expr></argument>, <argument><expr><name>wcoExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>=</operator> <name>wcoList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptionExprs</name></name> <operator>=</operator> <name>wcoExprs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Initialize RETURNING projections if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Initialize result tuple slot and assign its rowtype using the first
		 * RETURNING list.  We assume the rest will look the same.
		 */</comment>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up a slot for the output of the RETURNING projection(s) */</comment>
		<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>

		<comment type="block">/* Need an econtext too */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build a projection for each result rel.
		 */</comment>
		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;returningLists</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rlist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_returningList</name></name> <operator>=</operator> <name>rlist</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>=</operator>
				<call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>rlist</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
										<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We still must construct a dummy result tuple type, because InitPlan
		 * expects one (maybe should change that?).
		 */</comment>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecInitResultTypeTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Set the list of arbiter indexes if needed for ON CONFLICT */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>arbiterIndexes</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If needed, Initialize target list, projection and qual for ON CONFLICT
	 * DO UPDATE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>relationDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

		<comment type="block">/* insert may only have one plan, inheritance is not expanded */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nplans</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* already exists if created by RETURNING processing above */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

		<comment type="block">/* carried forward solely for the benefit of explain */</comment>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_excludedtlist</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr>;</expr_stmt>

		<comment type="block">/* create state for DO UPDATE SET operation */</comment>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>OnConflictSetState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* initialize slot for the existing tuple */</comment>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_Existing</name></name> <operator>=</operator>
			<call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* create the tuple slot for the UPDATE SET projection */</comment>
		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build UPDATE SET projection state */</comment>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name> <operator>=</operator>
			<call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
									<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
									<argument><expr><name>relationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* initialize state to evaluate the WHERE clause, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>qualexpr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>qualexpr</name> <operator>=</operator> <call><name>ExecInitQual</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_WhereClause</name></name> <operator>=</operator> <name>qualexpr</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have any secondary relations in an UPDATE or DELETE, they need to
	 * be treated like non-locked relations in SELECT FOR UPDATE, ie, the
	 * EvalPlanQual mechanism needs to be told about them.  Locate the
	 * relevant ExecRowMarks.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name></decl>;</decl_stmt>

		<comment type="block">/* ignore "parent" rowmarks; they are irrelevant at runtime */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>isParent</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Like in preprocess_targetlist, ignore distributed tables.
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name> <init>= <expr><call><name>GpPolicyFetch</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In the executor, we don't have information on which tables are
			 * distributed. Assume that everything is; we wouldn't be running this
			 * slice on an entry table otherwise.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* find ExecRowMark (same for all subplans) */</comment>
		<expr_stmt><expr><name>erm</name> <operator>=</operator> <call><name>ExecFindRowMark</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build ExecAuxRowMark for each subplan */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nplans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plan</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>aerm</name> <operator>=</operator> <call><name>ExecBuildAuxRowMark</name><argument_list>(<argument><expr><name>erm</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_arowmarks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_arowmarks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>aerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/* select first subplan */</comment>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_whichplan</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EvalPlanQualSetPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>,
						<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_arowmarks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the junk filter(s) if needed.  INSERT queries need a filter
	 * if there are any junk attrs in the tlist.  UPDATE and DELETE always
	 * need a filter, since there's always at least one junk attribute present
	 * --- no need to look first.  Typically, this will be a 'ctid' or
	 * 'wholerow' attribute, but in the case of a foreign data wrapper it
	 * might be a set of junk attributes sufficient to identify the remote
	 * row.
	 *
	 * If there are multiple result relations, each one needs its own junk
	 * filter.  Note multiple rels are only possible for UPDATE/DELETE, so we
	 * can't be fooled by some needing a filter and some not.
	 *
	 * This section of code is also a convenient place to verify that the
	 * output of an INSERT or UPDATE matches the target table(s).
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>junk_filter_needed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CMD_INSERT</name></expr>:</case>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subplan-&gt;targetlist</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>junk_filter_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<case>case <expr><name>CMD_DELETE</name></expr>:</case>
				<expr_stmt><expr><name>junk_filter_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>junk_filter_needed</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nplans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>junkresslot</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plan</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecCheckPlanOutput</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
										<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>junkresslot</name> <operator>=</operator>
					<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
									   <argument><expr><name>junkresslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* For UPDATE/DELETE, find the appropriate junk attr now */</comment>
					<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
						<name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
						<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
						<call><name>IsAppendonlyMetadataRelkind</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk ctid column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/* Extra GPDB junk columns */</comment>
						<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_segid_attno</name></name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"gp_segment_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_segid_attno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk gp_segment_id column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_isSplitUpdates</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_action_attno</name></name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"DMLAction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_action_attno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk action column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * When there is a row-level trigger, there should be
						 * a wholerow attribute.
						 */</comment>
						<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"wholerow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"wholerow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk wholerow column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecCheckPlanOutput</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
									<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Lastly, if this is not the primary (canSetTag) ModifyTable node, add it
	 * to estate-&gt;es_auxmodifytables so that it will be run to completion by
	 * ExecPostprocessPlan.  (It'd actually work fine to add the primary
	 * ModifyTable node too, but there's no need.)  Note the use of lcons not
	 * lappend: we need later-initialized ModifyTable nodes to be shut down
	 * before earlier ones.  This ensures that we don't throw away RETURNING
	 * rows that need to be seen by a later CTE subplan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We do not need this unless in executor or with utility role. Note
		 * This was added for the data modifying CTE feature but there are other
		 * cases could run into this also.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mtstate</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_auxmodifytables</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
											   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_auxmodifytables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>mtstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndModifyTable
 *
 *		Shuts down the plan.
 *
 *		Returns nothing of interest.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndModifyTable</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allow any FDWs to shut down
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignModify</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignModify</name></name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
														   <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_tableam</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>table_dml_finish</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Close all the partitioned tables, leaf partitions, and their indices
	 * and release the slot used for tuple routing, if set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecCleanupTupleRouting</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_root_tuple_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_root_tuple_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Free the exprcontext
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean out the tuple table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Terminate EPQ execution if active
	 */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * shut down subplans
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanModifyTable</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Currently, we don't need to support rescan on ModifyTable nodes. The
	 * semantics of that would be a bit debatable anyway.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ExecReScanModifyTable is not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecSquelchModifyTable</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * ModifyTable nodes must run to completion when asked to Squelch so
	 * that we don't risk losing modifications which should be performed
	 * regardless of any LIMIT's or other forms for projections which could
	 * end up causing a squelch to happen.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecModifyTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
