<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/functions.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * functions.c
 *	  Execution of SQL-language functions
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/functions.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>          <comment type="block">/* ExecutorStart, ExecutorRun, etc */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/functions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/metrics_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autostats.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Specialized DestReceiver for collecting query output in a SQL function
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>DestReceiver</name></type> <name>pub</name></decl>;</decl_stmt>			<comment type="block">/* publicly-known function pointers */</comment>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tstore</name></decl>;</decl_stmt>	<comment type="block">/* where to put result tuples */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>			<comment type="block">/* context containing tstore */</comment>
	<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>filter</name></decl>;</decl_stmt>			<comment type="block">/* filter to convert tuple type */</comment>
}</block></struct></type> <name>DR_sqlfunction</name>;</typedef>

<comment type="block">/*
 * We have an execution_state record for each query in a function.  Each
 * record contains a plantree for its query.  If the query is currently in
 * F_EXEC_RUN state then there's a QueryDesc too.
 *
 * The "next" fields chain together all the execution_state records generated
 * from a single original parsetree.  (There will only be more than one in
 * case of rule expansion of the original parsetree.)
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>F_EXEC_START</name></decl>, <decl><name>F_EXEC_RUN</name></decl>, <decl><name>F_EXEC_DONE</name></decl>
}</block></enum></type> <name>ExecStatus</name>;</typedef>

<typedef>typedef <type><struct>struct <name>execution_state</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>execution_state</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecStatus</name></type>	<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>setsResult</name></decl>;</decl_stmt>		<comment type="block">/* true if this query produces func's result */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lazyEval</name></decl>;</decl_stmt>		<comment type="block">/* true if should fetch one row at a time */</comment>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>			<comment type="block">/* plan for this query */</comment>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>qd</name></decl>;</decl_stmt>				<comment type="block">/* null unless status == RUN */</comment>
}</block></struct></type> <name>execution_state</name>;</typedef>


<comment type="block">/*
 * An SQLFunctionCache record is built during the first call,
 * and linked to from the fn_extra field of the FmgrInfo struct.
 *
 * Note that currently this has only the lifespan of the calling query.
 * Someday we should rewrite this code to use plancache.c to save parse/plan
 * results for longer than that.
 *
 * Physically, though, the data has the lifespan of the FmgrInfo that's used
 * to call the function, and there are cases (particularly with indexes)
 * where the FmgrInfo might survive across transactions.  We cannot assume
 * that the parse/plan trees are good for longer than the (sub)transaction in
 * which parsing was done, so we must mark the record with the LXID/subxid of
 * its creation time, and regenerate everything if that's obsolete.  To avoid
 * memory leakage when we do have to regenerate things, all the data is kept
 * in a sub-context of the FmgrInfo's fn_mcxt.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>			<comment type="block">/* function name (for error msgs) */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>			<comment type="block">/* function body text (for error msgs) */</comment>

	<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl>;</decl_stmt>	<comment type="block">/* data for parser callback hooks */</comment>

	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>		<comment type="block">/* actual return type */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>			<comment type="block">/* length of the return type */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>		<comment type="block">/* true if return type is pass by value */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>returnsSet</name></decl>;</decl_stmt>		<comment type="block">/* true if returning multiple rows */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>returnsTuple</name></decl>;</decl_stmt>	<comment type="block">/* true if returning whole tuple result */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shutdown_reg</name></decl>;</decl_stmt>	<comment type="block">/* true if registered shutdown callback */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>readonly_func</name></decl>;</decl_stmt>	<comment type="block">/* true to run in "read only" mode */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lazyEval</name></decl>;</decl_stmt>		<comment type="block">/* true if using lazyEval for result query */</comment>

	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>		<comment type="block">/* Param list representing current args */</comment>

	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tstore</name></decl>;</decl_stmt>	<comment type="block">/* where we accumulate result tuples */</comment>

	<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>junkFilter</name></decl>;</decl_stmt>		<comment type="block">/* will be NULL if function returns VOID */</comment>

	<comment type="block">/*
	 * func_state is a List of execution_state records, each of which is the
	 * first for its original parsetree, with any additional records chained
	 * to it via the "next" fields.  This sublist structure is needed to keep
	 * track of where the original query boundaries are.
	 */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>func_state</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fcontext</name></decl>;</decl_stmt>		<comment type="block">/* memory context holding this struct and all
								 * subsidiary data */</comment>

	<decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>lxid</name></decl>;</decl_stmt>	<comment type="block">/* lxid in which cache was made */</comment>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>subxid</name></decl>;</decl_stmt>	<comment type="block">/* subxid in which cache was made */</comment>
}</block></struct></type> <name>SQLFunctionCache</name>;</typedef>

<typedef>typedef <type><name>SQLFunctionCache</name> <modifier>*</modifier></type><name>SQLFunctionCachePtr</name>;</typedef>

<comment type="block">/*
 * Data structure needed by the parser callback hooks to resolve parameter
 * references during parsing of a SQL function's body.  This is separate from
 * SQLFunctionCache since we sometimes do parsing separately from execution.
 */</comment>
<typedef>typedef <type><struct>struct <name>SQLFunctionParseInfo</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>			<comment type="block">/* function's name */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>			<comment type="block">/* number of input arguments */</comment>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>		<comment type="block">/* resolved types of input arguments */</comment>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>		<comment type="block">/* names of input arguments; NULL if none */</comment>
	<comment type="block">/* Note that argnames[i] can be NULL, if some args are unnamed */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>		<comment type="block">/* function's input collation, if known */</comment>
}</block></struct></type>			<name>SQLFunctionParseInfo</name>;</typedef>


<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>sql_fn_param_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParamRef</name> <modifier>*</modifier></type><name>pref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>sql_fn_post_column_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
									<parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>sql_fn_make_param</name><parameter_list>(<parameter><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>paramno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>sql_fn_resolve_param_name</name><parameter_list>(<parameter><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>paramname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>init_execution_state</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>queryTree_list</name></decl></parameter>,
								  <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>lazyEvalOK</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_sql_fcache</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lazyEvalOK</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postquel_start</name><parameter_list>(<parameter><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>postquel_getnext</name><parameter_list>(<parameter><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postquel_end</name><parameter_list>(<parameter><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postquel_sub_params</name><parameter_list>(<parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>,
								<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>postquel_get_single_result</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
										<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
										<parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>,
										<parameter><decl><type><name>MemoryContext</name></type> <name>resultcontext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sql_exec_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShutdownSQLFunction</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>querytree_safe_for_qe_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sqlfunction_startup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>sqlfunction_receive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sqlfunction_shutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sqlfunction_destroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>querytree_safe_for_qe_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block" format="doxygen">/**
		 * Do not end recursion just because we have reached one leaf node.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_segment_DML</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name>
					 <operator>||</operator> <operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					     <call><name>IsA</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call><operator>)</operator>
					 <operator>||</operator> <name><name>q</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function cannot execute on a QE slice because it issues a non-SELECT statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> <name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<macro><name>foreach</name><argument_list>(<argument>f</argument>,<argument>q-&gt;rtable</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						
						<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>namespaceId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						
						<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsCatalogNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>||</operator>
									<call><name>IsToastNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>||</operator>
									<call><name>IsAoSegmentNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>||</operator>
									<call><name>IsReplicatedTable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function cannot execute on a QE slice because it accesses relation \"%s.%s\""</literal></expr></argument>,
											<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>querytree_safe_for_qe_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>querytree_safe_for_qe_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * This function determines if the query tree is safe to be planned and
 * executed on a QE. The checks it performs are:
 * 1. The query cannot access any non-catalog relation except it's a replicated table.
 * 2. The query must be select only.
 * In case of a problem, the method spits out an error.
 */</comment>
<function><type><name>void</name></type>
<name>querytree_safe_for_qe</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>querytree_safe_for_qe_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare the SQLFunctionParseInfo struct for parsing a SQL function body
 *
 * This includes resolving actual types of polymorphic arguments.
 *
 * call_expr can be passed as NULL, but then we will fail if there are any
 * polymorphic arguments.
 */</comment>
<function><type><name>SQLFunctionParseInfoPtr</name></type>
<name>prepare_sql_fn_parse_info</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>,
						  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>call_expr</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>inputCollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pinfo</name> <operator>=</operator> <operator>(</operator><name>SQLFunctionParseInfoPtr</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SQLFunctionParseInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Function's name (only) can be used to qualify argument names */</comment>
	<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>fname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save the function's input collation */</comment>
	<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>inputCollation</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy input argument types from the pg_proc entry, then resolve any
	 * polymorphic types.
	 */</comment>
	<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argOidVect</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>argnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>argOidVect</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>argOidVect</name></expr></argument>,
			   <argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></argument>,
			   <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>argnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>argnum</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>argnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><name><name>argOidVect</name><index>[<expr><name>argnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>argtype</name> <operator>=</operator> <call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>argnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>argtype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine actual type of argument declared %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>argOidVect</name><index>[<expr><name>argnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>argOidVect</name><index>[<expr><name>argnum</name></expr>]</index></name> <operator>=</operator> <name>argtype</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <name>argOidVect</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Collect names of arguments, too, if any
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>proargnames</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>proargmodes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n_arg_names</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>proargnames</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>,
									  <argument><expr><name>Anum_pg_proc_proargnames</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>proargnames</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* just to be sure */</comment>

		<expr_stmt><expr><name>proargmodes</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>,
									  <argument><expr><name>Anum_pg_proc_proargmodes</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>proargmodes</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* just to be sure */</comment>

		<expr_stmt><expr><name>n_arg_names</name> <operator>=</operator> <call><name>get_func_input_arg_names</name><argument_list>(<argument><expr><name>proargnames</name></expr></argument>, <argument><expr><name>proargmodes</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>pinfo</name><operator>-&gt;</operator><name>argnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Paranoia: ignore the result if too few array entries */</comment>
		<if_stmt><if>if <condition>(<expr><name>n_arg_names</name> <operator>&lt;</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>argnames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>argnames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>pinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parser setup hook for parsing a SQL function body.
 */</comment>
<function><type><name>void</name></type>
<name>sql_fn_parser_setup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ParseState</name></name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name> <operator>=</operator> <name>sql_fn_post_column_ref</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_paramref_hook</name></name> <operator>=</operator> <name>sql_fn_param_ref</name></expr>;</expr_stmt>
	<comment type="block">/* no need to use p_coerce_param_hook */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pinfo</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sql_fn_post_column_ref		parser callback for ColumnRefs
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>sql_fn_post_column_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name> <init>= <expr><operator>(</operator><name>SQLFunctionParseInfoPtr</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>subfield</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Never override a table-column reference.  This corresponds to
	 * considering the parameter names to appear in a scope outside the
	 * individual SQL commands, which is what we want.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*----------
	 * The allowed syntaxes are:
	 *
	 * A		A = parameter name
	 * A.B		A = function name, B = parameter name
	 *			OR: A = record-typed parameter name, B = field name
	 *			(the first possibility takes precedence)
	 * A.B.C	A = function name, B = record-typed parameter name,
	 *			C = field name
	 * A.*		Whole-row reference to composite parameter A.
	 * A.B.*	Same, with A = function name, B = parameter name
	 *
	 * Here, it's sufficient to ignore the "*" in the last two cases --- the
	 * main parser will take care of expanding the whole-row reference.
	 *----------
	 */</comment>
	<expr_stmt><expr><name>nnames</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nnames</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nnames</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>field1</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>name1</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nnames</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>subfield</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subfield</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>name2</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>subfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nnames</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Three-part name: if the first part doesn't match the function name,
		 * we can fail immediately. Otherwise, look up the second part, and
		 * take the third part to be a field reference.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name1</name></expr></argument>, <argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>sql_fn_resolve_param_name</name><argument_list>(<argument><expr><name>pinfo</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>subfield</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lthird</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subfield</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nnames</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name1</name></expr></argument>, <argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Two-part name with first part matching function name: first see if
		 * second part matches any parameter name.
		 */</comment>
		<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>sql_fn_resolve_param_name</name><argument_list>(<argument><expr><name>pinfo</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>param</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Yes, so this is a parameter reference, no subfield */</comment>
			<expr_stmt><expr><name>subfield</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No, so try to match as parameter name and subfield */</comment>
			<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>sql_fn_resolve_param_name</name><argument_list>(<argument><expr><name>pinfo</name></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Single name, or parameter name followed by subfield */</comment>
		<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>sql_fn_resolve_param_name</name><argument_list>(<argument><expr><name>pinfo</name></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>param</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* No match */</comment>

	<if_stmt><if>if <condition>(<expr><name>subfield</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Must be a reference to a field of a composite parameter; otherwise
		 * ParseFuncOrColumn will return NULL, and we'll fail back at the
		 * caller.
		 */</comment>
		<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>subfield</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>param</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * sql_fn_param_ref		parser callback for ParamRefs ($n symbols)
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>sql_fn_param_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParamRef</name> <modifier>*</modifier></type><name>pref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name> <init>= <expr><operator>(</operator><name>SQLFunctionParseInfoPtr</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name> <init>= <expr><name><name>pref</name><operator>-&gt;</operator><name>number</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check parameter number is valid */</comment>
	<if_stmt><if>if <condition>(<expr><name>paramno</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>paramno</name> <operator>&gt;</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* unknown parameter number */</comment>

	<return>return <expr><call><name>sql_fn_make_param</name><argument_list>(<argument><expr><name>pinfo</name></expr></argument>, <argument><expr><name>paramno</name></expr></argument>, <argument><expr><name><name>pref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * sql_fn_make_param		construct a Param node for the given paramno
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>sql_fn_make_param</name><parameter_list>(<parameter><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>paramno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXTERN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name>paramno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>paramno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have a function input collation, allow it to override the
	 * type-derived collation for parameter symbols.  (XXX perhaps this should
	 * not happen if the type collation is not default?)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>collation</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>param</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search for a function parameter of the given name; if there is one,
 * construct and return a Param node for it.  If not, return NULL.
 * Helper function for sql_fn_post_column_ref.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>sql_fn_resolve_param_name</name><parameter_list>(<parameter><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>paramname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pinfo</name><operator>-&gt;</operator><name>argnames</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pinfo</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>paramname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>sql_fn_make_param</name><argument_list>(<argument><expr><name>pinfo</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set up the per-query execution_state records for a SQL function.
 *
 * The input is a List of Lists of parsed and rewritten, but not planned,
 * querytrees.  The sublist structure denotes the original query boundaries.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>init_execution_state</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>queryTree_list</name></decl></parameter>,
					 <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>lazyEvalOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eslist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>lasttages</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>queryTree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qtlist</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>firstes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>preves</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>qtlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>queryTree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>newes</name></decl>;</decl_stmt>

			<comment type="block">/* Plan the query if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Utility commands require no planning. */</comment>
				<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>,
									 <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PlannedStmt</name><operator>*</operator><operator>)</operator><name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>metricsQueryType</name> <operator>=</operator> <name>FUNCTION_INNER_QUERY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Precheck all commands for validity in a function.  This should
			 * generally match the restrictions spi.c applies.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CopyStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name><operator>)</operator><operator>-&gt;</operator><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot COPY to/from client in a SQL function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<comment type="block">/* translator: %s is a SQL statement name */</comment>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed in a SQL function"</literal></expr></argument>,
									<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CommandIsReadOnly</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: %s is a SQL statement name */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed in a non-volatile function"</literal></expr></argument>,
								<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CommandIsReadOnly</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* OK, build the execution_state for this query */</comment>
			<expr_stmt><expr><name>newes</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>execution_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>preves</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>preves</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>firstes</name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_START</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>setsResult</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might change below */</comment>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might change below */</comment>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>qd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lasttages</name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>preves</name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>eslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>eslist</name></expr></argument>, <argument><expr><name>firstes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Mark the last canSetTag query as delivering the function result; then,
	 * if it is a plain SELECT, mark it for lazy evaluation. If it's not a
	 * SELECT we must always run it to completion.
	 *
	 * Note: at some point we might add additional criteria for whether to use
	 * lazy eval.  However, we should prefer to use it whenever the function
	 * doesn't return set, since fetching more than one row is useless in that
	 * case.
	 *
	 * Note: don't set setsResult if the function returns VOID, as evidenced
	 * by not having made a junkfilter.  This ensures we'll throw away any
	 * output from the last statement in such a function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lasttages</name> <operator>&amp;&amp;</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lasttages</name><operator>-&gt;</operator><name>setsResult</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lazyEvalOK</name> <operator>&amp;&amp;</operator>
			<name><name>lasttages</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>lasttages</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name><name>lasttages</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>eslist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the SQLFunctionCache for a SQL function
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_sql_fcache</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lazyEvalOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>foid</name> <init>= <expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procedureTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>queryTree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>flat_query_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create memory context that holds all the SQLFunctionCache data.  It
	 * must be a child of whatever context holds the FmgrInfo.
	 */</comment>
	<expr_stmt><expr><name>fcontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
									 <argument><expr><literal type="string">"SQL function"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>fcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the struct proper, link it to fcontext and fn_extra.  Once this
	 * is done, we'll be able to recover the memory after failure, even if the
	 * FmgrInfo is long-lived.
	 */</comment>
	<expr_stmt><expr><name>fcache</name> <operator>=</operator> <operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SQLFunctionCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>fcontext</name></name> <operator>=</operator> <name>fcontext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>fcache</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * get the procedure tuple corresponding to the given function Oid
	 */</comment>
	<expr_stmt><expr><name>procedureTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * copy function name immediately for use by error reporting callback, and
	 * for use as memory context identifier
	 */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSetIdentifier</name><argument_list>(<argument><expr><name>fcontext</name></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get the result type from the procedure tuple, and check for polymorphic
	 * result type; if so, find out the actual result type.
	 */</comment>
	<expr_stmt><expr><name>rettype</name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rettype</name> <operator>=</operator> <call><name>get_fn_expr_rettype</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* this probably should not happen */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine actual result type for function declared to return type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>

	<comment type="block">/* Fetch the typlen and byval info for the result type */</comment>
	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember whether we're returning setof something */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>

	<comment type="block">/* Remember if function is STABLE/IMMUTABLE */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>=</operator>
		<operator>(</operator><name><name>procedureStruct</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need the actual argument types to pass to the parser.  Also make
	 * sure that parameter symbols are considered to have the function's
	 * resolved input collation.
	 */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name></name> <operator>=</operator> <call><name>prepare_sql_fn_parse_info</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>,
											  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>,
											  <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And of course we need the function body text.
	 */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
						  <argument><expr><name>procedureTuple</name></expr></argument>,
						  <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc for function %u"</literal></expr></argument>, <argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse and rewrite the queries in the function text.  Use sublists to
	 * keep track of the original query boundaries.  But we also build a
	 * "flat" list of the rewritten queries to pass to check_sql_fn_retval.
	 * This is because the last canSetTag query determines the result type
	 * independently of query boundaries --- and it might not be in the last
	 * sublist, for example if the last query rewrites to DO INSTEAD NOTHING.
	 * (It might not be unreasonable to throw an error in such a case, but
	 * this is the historical behavior and it doesn't seem worth changing.)
	 *
	 * Note: since parsing and planning is done in fcontext, we will generate
	 * a lot of cruft that lives as long as the fcache does.  This is annoying
	 * but we'll not worry about it until the module is rewritten to use
	 * plancache.c.
	 */</comment>
	<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>queryTree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>flat_query_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>queryTree_sublist</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>queryTree_sublist</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite_params</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
														  <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>,
														  <argument><expr><operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>sql_fn_parser_setup</name></expr></argument>,
														  <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name></name></expr></argument>,
														  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>queryTree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queryTree_list</name></expr></argument>, <argument><expr><name>queryTree_sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flat_query_list</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>flat_query_list</name></expr></argument>,
									  <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>queryTree_sublist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_sql_fn_statements</name><argument_list>(<argument><expr><name>flat_query_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have only SELECT statements with no FROM clauses, we should
	 * be able to execute them locally, even on the QE.  Most often, this is something 
	 * like   SELECT $1
	 * Functions use that type of SELECT to evaluate expressions, so without those,
	 * no functions would be useful.
	 * 
	 * We also need to execute certain catalog queries locally.  The
	 * Fault-Tolerance system does queries of gp_segment_configuration, and
	 * some DDL and Utility commands do selects from the catalog table, etc.
	 * So, if the FROM clause consists only of catalog tables, we will run the
	 * query locally.
	 * 
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This will error out if there is a problem with the query tree */</comment>
		<expr_stmt><expr><call><name>querytree_safe_for_qe</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>queryTree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that the function returns the type it claims to.  Although in
	 * simple cases this was already done when the function was defined, we
	 * have to recheck because database objects used in the function's queries
	 * might have changed type.  We'd have to do it anyway if the function had
	 * any polymorphic arguments.
	 *
	 * Note: we set fcache-&gt;returnsTuple according to whether we are returning
	 * the whole tuple result or just a single column.  In the latter case we
	 * clear returnsTuple because we need not act different from the scalar
	 * result case, even if it's a rowtype column.  (However, we have to force
	 * lazy eval mode in that case; otherwise we'd need extra code to expand
	 * the rowtype column into multiple columns, since we have no way to
	 * notify the caller that it should do that.)
	 *
	 * check_sql_fn_retval will also construct a JunkFilter we can use to
	 * coerce the returned rowtype to the desired form (unless the result type
	 * is VOID, in which case there's nothing to coerce to).
	 */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsTuple</name></name> <operator>=</operator> <call><name>check_sql_fn_retval</name><argument_list>(<argument><expr><name>foid</name></expr></argument>,
											   <argument><expr><name>rettype</name></expr></argument>,
											   <argument><expr><name>flat_query_list</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsTuple</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make sure output rowtype is properly blessed */</comment>
		<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_resultSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name> <operator>&amp;&amp;</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Returning rowtype as if it were scalar --- materialize won't work.
		 * Right now it's sufficient to override any caller preference for
		 * materialize mode, but to add more smarts in init_execution_state
		 * about this, we'd probably need a three-way flag instead of bool.
		 */</comment>
		<expr_stmt><expr><name>lazyEvalOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Finally, plan the queries */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name> <operator>=</operator> <call><name>init_execution_state</name><argument_list>(<argument><expr><name>queryTree_list</name></expr></argument>,
											  <argument><expr><name>fcache</name></expr></argument>,
											  <argument><expr><name>lazyEvalOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark fcache with time of creation to show it's valid */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>subxid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Start up execution of one execution_state node */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postquel_start</name><parameter_list>(<parameter><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Caller should have ensured a suitable snapshot is active */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this query produces the function result, send its output to the
	 * tuplestore; else discard any output.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>setsResult</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DR_sqlfunction</name> <modifier>*</modifier></type><name>myState</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestSQLFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* pass down the needed info to the dest receiver routines */</comment>
		<expr_stmt><expr><name>myState</name> <operator>=</operator> <operator>(</operator><name>DR_sqlfunction</name> <operator>*</operator><operator>)</operator> <name>dest</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>==</operator> <name>DestSQLFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>filter</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>None_Receiver</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>,
							 <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>,
							 <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
							 <argument><expr><name>InvalidSnapshot</name></expr></argument>,
							 <argument><expr><name>dest</name></expr></argument>,
							 <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr> ?</condition><then> <expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>queryEnv</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* GPDB hook for collecting query info */</comment>
	<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_QUERY_SUBMIT</name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Utility commands don't need Executor. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>operation</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>SPI_IsMemoryReserved</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name> <operator>=</operator> <call><name>SPI_GetMemoryReservation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In lazyEval mode, do not let the executor set up an AfterTrigger
		 * context.  This is necessary not just an optimization, because we
		 * mustn't exit from the function execution with a stacked
		 * AfterTrigger level still active.  We are careful not to select
		 * lazyEval mode for any statement that could possibly queue triggers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>lazyEval</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>eflags</name> <operator>=</operator> <name>EXEC_FLAG_SKIP_TRIGGERS</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>eflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>			<comment type="block">/* default run-to-completion flags */</comment>
		<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_RUN</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Run one execution_state; either to completion or to first result row */</comment>
<comment type="block">/* Returns true if we ran to completion */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>postquel_getnext</name><parameter_list>(<parameter><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>,
					   <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>,
					   <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>,
					   <argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
					   <argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
					   <argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>			<comment type="block">/* never stops early */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Run regular commands to completion unless lazyEval */</comment>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>count</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>es</name><operator>-&gt;</operator><name>lazyEval</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name> <operator>||</operator> <operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>lazyEval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we requested run to completion OR there was no tuple returned,
		 * command must be complete.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Shut down execution of one execution_state node */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postquel_end</name><parameter_list>(<parameter><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* mark status done to ensure we don't do ExecutorEnd twice */</comment>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_DONE</name></expr>;</expr_stmt>

	<comment type="block">/* Utility commands don't need Executor. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>operation</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relationOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt> 	<comment type="block">/* relation that is modified */</comment>
		<decl_stmt><decl><type><name>AutoStatsCmdType</name></type> <name>cmdType</name> <init>= <expr><name>AUTOSTATS_CMDTYPE_SENTINEL</name></expr></init></decl>;</decl_stmt> 	<comment type="block">/* command type */</comment>

		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>autostats_get_cmdtype</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmdType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* MPP-14001: Running auto_stats */</comment>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>auto_stats</name><argument_list>(<argument><expr><name>cmdType</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* inFunction */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Build ParamListInfo array representing current arguments */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postquel_sub_params</name><parameter_list>(<parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>,
					<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>makeParamList</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name> <operator>=</operator> <name>paramLI</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name> <operator>==</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Extract the SQL function's value from a single result row.  This is used
 * both for scalar (non-set) functions and for each row of a lazy-eval set
 * result.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>postquel_get_single_result</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						   <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
						   <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>,
						   <parameter><decl><type><name>MemoryContext</name></type> <name>resultcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set up to return the function value.  For pass-by-reference datatypes,
	 * be sure to allocate the result in resultcontext, not the current memory
	 * context (which has query lifespan).  We can't leave the data in the
	 * TupleTableSlot because we intend to clear the slot before returning.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>resultcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsTuple</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We must return the whole tuple as a Datum. */</comment>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTupleDatum</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Returning a scalar, which we have to extract from the first column
		 * of the SELECT result, and then copy into result context if needed.
		 */</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fmgr_sql: function call manager for SQL functions
 */</comment>
<function><type><name>Datum</name></type>
<name>fmgr_sql</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>sqlerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>randomAccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lazyEvalOK</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pushed_snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eslist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>eslc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>sql_exec_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>sqlerrcontext</name></expr>;</expr_stmt>

	<comment type="block">/* Check call context */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_retset</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For simplicity, we require callers to support both set eval modes.
		 * There are cases where we must use one or must use the other, and
		 * it's not really worthwhile to postpone the check till we know. But
		 * note we do not require caller to provide an expectedDesc.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_ValuePerCall</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>randomAccess</name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lazyEvalOK</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Preferred</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>randomAccess</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lazyEvalOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Initialize fcache (build plans) if first time through; or re-initialize
	 * if the cache is stale.
	 */</comment>
	<expr_stmt><expr><name>fcache</name> <operator>=</operator> <operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fcache</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>lxid</name></name> <operator>!=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>||</operator>
			<operator>!</operator><call><name>SubTransactionIsActive</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>subxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* It's stale; unlink and delete */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fcache</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>init_sql_fcache</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lazyEvalOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fcache</name> <operator>=</operator> <operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Switch to context in which the fcache lives.  This ensures that our
	 * tuplestore etc will have sufficient lifetime.  The sub-executor is
	 * responsible for deleting per-tuple information.  (XXX in the case of a
	 * long-lived FmgrInfo, this policy represents more memory leakage, but
	 * it's not entirely clear where to keep stuff instead.)
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find first unfinished query in function, and note whether it's the
	 * first query.
	 */</comment>
	<expr_stmt><expr><name>eslist</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>es</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>eslc</argument>, <argument>eslist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>eslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>es</name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>F_EXEC_DONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>es</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Convert params to appropriate format if starting a fresh execution. (If
	 * continuing execution, we can re-use prior params.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_first</name> <operator>&amp;&amp;</operator> <name>es</name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>F_EXEC_START</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>postquel_sub_params</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build tuplestore to hold results, if we don't have one already. Note
	 * it's in the query-lifespan context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
	<comment type="block">/*
	 * Execute each command in the function one after another until we either
	 * run out of commands or get a result row from a lazily-evaluated SELECT.
	 *
	 * Notes about snapshot management:
	 *
	 * In a read-only function, we just use the surrounding query's snapshot.
	 *
	 * In a non-read-only function, we rely on the fact that we'll never
	 * suspend execution between queries of the function: the only reason to
	 * suspend execution before completion is if we are returning a row from a
	 * lazily-evaluated SELECT.  So, when first entering this loop, we'll
	 * either start a new query (and push a fresh snapshot) or re-establish
	 * the active snapshot from the existing query descriptor.  If we need to
	 * start a new query in a subsequent execution of the loop, either we need
	 * a fresh snapshot (and pushed_snapshot is false) or the existing
	 * snapshot is on the active stack and we can just bump its command ID.
	 */</comment>
	<expr_stmt><expr><name>pushed_snapshot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>es</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>completed</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>F_EXEC_START</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If not read-only, be sure to advance the command counter for
			 * each command, so that all work to date in this transaction is
			 * visible.  Take a new snapshot if we don't have one yet,
			 * otherwise just bump the command ID in the existing snapshot.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pushed_snapshot</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>pushed_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>postquel_start</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pushed_snapshot</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Re-establish active snapshot when re-entering function */</comment>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pushed_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>completed</name> <operator>=</operator> <call><name>postquel_getnext</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we ran the command to completion, we can shut it down now. Any
		 * row(s) we need to return are safely stashed in the tuplestore, and
		 * we want to be sure that, for example, AFTER triggers get fired
		 * before we return anything.  Also, if the function doesn't return
		 * set, we can shut it down anyway because it must be a SELECT and we
		 * don't care about fetching any more result rows.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>completed</name> <operator>||</operator> <operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>postquel_end</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Break from loop if we didn't shut down (implying we got a
		 * lazily-evaluated row).  Otherwise we'll press on till the whole
		 * function is done, relying on the tuplestore to keep hold of the
		 * data to eventually be returned.  This is necessary since an
		 * INSERT/UPDATE/DELETE RETURNING that sets the result might be
		 * followed by additional rule-inserted commands, and we want to
		 * finish doing all those commands before we return anything.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>F_EXEC_DONE</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Advance to next execution_state, which might be in the next list.
		 */</comment>
		<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>!</operator><name>es</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>eslc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>eslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eslc</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* end of function */</comment>

			<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>eslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Flush the current snapshot so that we will take a new one for
			 * the new query list.  This ensures that new snaps are taken at
			 * original-query boundaries, matching the behavior of interactive
			 * execution.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>pushed_snapshot</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pushed_snapshot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></while>
</block_content>}</block>
<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The tuplestore now contains whatever row(s) we are supposed to return.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>es</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we stopped short of being done, we must have a lazy-eval
			 * row.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>lazyEval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Re-use the junkfilter's output slot to fetch back the tuple */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_resultSlot</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch lazy-eval tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Extract the result as a datum, and copy out from the slot */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>postquel_get_single_result</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>,
												<argument><expr><name>fcache</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Clear the tuplestore, but keep it for next time */</comment>
			<comment type="block">/* NB: this might delete the slot's content, but we don't care */</comment>
			<expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Let caller know we're not finished.
			 */</comment>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>isDone</name></name> <operator>=</operator> <name>ExprMultipleResult</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Ensure we will get shut down cleanly if the exprcontext is not
			 * run to completion.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RegisterExprContextCallback</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>,
											<argument><expr><name>ShutdownSQLFunction</name></expr></argument>,
											<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>lazyEval</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We are done with a lazy evaluation.  Clean up.
			 */</comment>
			<expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Let caller know we're finished.
			 */</comment>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>isDone</name></name> <operator>=</operator> <name>ExprEndResult</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* Deregister shutdown callback, if we made one */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnregisterExprContextCallback</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>,
											  <argument><expr><name>ShutdownSQLFunction</name></expr></argument>,
											  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We are done with a non-lazy evaluation.  Return whatever is in
			 * the tuplestore.  (It is now caller's responsibility to free the
			 * tuplestore when done.)
			 */</comment>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<comment type="block">/* must copy desc because execSRF.c will free it */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_cleanTupType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* Deregister shutdown callback, if we made one */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnregisterExprContextCallback</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>,
											  <argument><expr><name>ShutdownSQLFunction</name></expr></argument>,
											  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Non-set function.  If we got a row, return it; else return NULL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Re-use the junkfilter's output slot to fetch back the tuple */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_resultSlot</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>postquel_get_single_result</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>,
													<argument><expr><name>fcache</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Should only get here for VOID functions and procedures */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>rettype</name></name> <operator>==</operator> <name>VOIDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Clear the tuplestore, but keep it for next time */</comment>
		<expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Pop snapshot if we have pushed one */</comment>
	<if_stmt><if>if <condition>(<expr><name>pushed_snapshot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we've gone through every command in the function, we are done. Reset
	 * the execution states to start over again on next call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>es</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>eslc</argument>, <argument>fcache-&gt;func_state</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>eslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>es</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_START</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * error context callback to let us supply a call-stack traceback
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sql_exec_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>flinfo</name> <init>= <expr><operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name> <init>= <expr><operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>syntaxerrposition</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can do nothing useful if init_sql_fcache() didn't get as far as
	 * saving the function name
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fcache</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there is a syntax error position, convert to internal syntax error
	 */</comment>
	<expr_stmt><expr><name>syntaxerrposition</name> <operator>=</operator> <call><name>geterrposition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>syntaxerrposition</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fcache</name><operator>-&gt;</operator><name>src</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>errposition</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrposition</name><argument_list>(<argument><expr><name>syntaxerrposition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrquery</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Try to determine where in the function we failed.  If there is a query
	 * with non-null QueryDesc, finger it.  (We check this rather than looking
	 * for F_EXEC_RUN state, so that errors during ExecutorStart or
	 * ExecutorEnd are blamed on the appropriate query; see postquel_start and
	 * postquel_end.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>query_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>es</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>query_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fcache-&gt;func_state</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>es</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL function \"%s\" statement %d"</literal></expr></argument>,
							   <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>, <argument><expr><name>query_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name>es</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>query_num</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>es</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * couldn't identify a running query; might be function entry,
			 * function exit, or between queries.
			 */</comment>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL function \"%s\""</literal></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Assume we failed during init_sql_fcache().  (It's possible that the
		 * function actually has an empty body, but in that case we may as
		 * well report all errors as being "during startup".)
		 */</comment>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL function \"%s\" during startup"</literal></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * callback function in case a function-returning-set needs to be shut down
 * before it has been run to completion
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShutdownSQLFunction</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name> <init>= <expr><operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fcache-&gt;func_state</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>es</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Shut down anything still running */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>F_EXEC_RUN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Re-establish active snapshot for any called functions */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>postquel_end</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Reset states to START in case we're called again */</comment>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_START</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block>

	<comment type="block">/* Release tuplestore if we have one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* execUtils will deregister the callback... */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_sql_fn_statements
 *
 * Check statements in an SQL function.  Error out if there is anything that
 * is not acceptable.
 */</comment>
<function><type><name>void</name></type>
<name>check_sql_fn_statements</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>queryTreeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>queryTreeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Disallow procedures with output arguments.  The current
		 * implementation would just throw the output values away, unless the
		 * statement is the last one.  Per SQL standard, we should assign the
		 * output values by name.  By disallowing this here, we preserve an
		 * opportunity for future improvement.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CallStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CallStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CallStmt</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>numargs</name> <operator>=</operator> <call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>argmodes</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_INOUT</name> <operator>||</operator> <name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_OUT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"calling procedures with output arguments is not supported in SQL functions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * check_sql_fn_retval() -- check return value of a list of sql parse trees.
 *
 * The return value of a sql function is the value returned by the last
 * canSetTag query in the function.  We do some ad-hoc type checking here
 * to be sure that the user is returning the type he claims.  There are
 * also a couple of strange-looking features to assist callers in dealing
 * with allowed special cases, such as binary-compatible result types.
 *
 * For a polymorphic function the passed rettype must be the actual resolved
 * output type of the function; we should never see a polymorphic pseudotype
 * such as ANYELEMENT as rettype.  (This means we can't check the type during
 * function definition of a polymorphic function.)
 *
 * This function returns true if the sql function returns the entire tuple
 * result of its final statement, or false if it returns just the first column
 * result of that statement.  It throws an error if the final statement doesn't
 * return the right type at all.
 *
 * Note that because we allow "SELECT rowtype_expression", the result can be
 * false even when the declared function return type is a rowtype.
 *
 * If modifyTargetList isn't NULL, the function will modify the final
 * statement's targetlist in two cases:
 * (1) if the tlist returns values that are binary-coercible to the expected
 * type rather than being exactly the expected type.  RelabelType nodes will
 * be inserted to make the result types match exactly.
 * (2) if there are dropped columns in the declared result rowtype.  NULL
 * output columns will be inserted in the tlist to match them.
 * (Obviously the caller must pass a parsetree that is okay to modify when
 * using this flag.)  Note that this flag does not affect whether the tlist is
 * considered to be a legal match to the result type, only how we react to
 * allowed not-exact-match cases.  *modifyTargetList will be set true iff
 * we had to make any "dangerous" changes that could modify the semantics of
 * the statement.  If it is set true, the caller should not use the modified
 * statement, but for simplicity we apply the changes anyway.
 *
 * If junkFilter isn't NULL, then *junkFilter is set to a JunkFilter defined
 * to convert the function's tuple result to the correct output tuple type.
 * Exception: if the function is defined to return VOID then *junkFilter is
 * set to NULL.
 */</comment>
<function><type><name>bool</name></type>
<name>check_sql_fn_retval</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rettype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>queryTreeList</name></decl></parameter>,
					<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>modifyTargetList</name></decl></parameter>,
					<parameter><decl><type><name>JunkFilter</name> <modifier>*</modifier><modifier>*</modifier></type><name>junkFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>tlist_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tlistlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>fn_typtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>modifyTargetList</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>modifyTargetList</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* initialize for no change */</comment>
	<if_stmt><if>if <condition>(<expr><name>junkFilter</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>junkFilter</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* initialize in case of VOID result */</comment>

	<comment type="block">/*
	 * If it's declared to return VOID, we don't care what's in the function.
	 * (This takes care of the procedure case, as well.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>VOIDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find the last canSetTag query in the list.  This isn't necessarily the
	 * last parsetree, because rule rewriting can insert queries after what
	 * the user wrote.
	 */</comment>
	<expr_stmt><expr><name>parse</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>queryTreeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parse</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If it's a plain SELECT, it returns whatever the targetlist says.
	 * Otherwise, if it's INSERT/UPDATE/DELETE with RETURNING, it returns
	 * that. Otherwise, the function return type must be VOID.
	 *
	 * Note: eventually replace this test with QueryReturnsTuples?	We'd need
	 * a more general method of determining the output type, though.  Also, it
	 * seems too dangerous to consider FETCH or EXECUTE as returning a
	 * determinable rowtype, since they depend on relatively short-lived
	 * entities.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parse</name> <operator>&amp;&amp;</operator>
		<name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tlist_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>parse</name> <operator>&amp;&amp;</operator>
			 <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
			  <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
			  <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tlist_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Empty function body, or last statement is a utility command */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type mismatch in function declared to return %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Function's final statement must be SELECT or INSERT/UPDATE/DELETE RETURNING."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * OK, check that the targetlist returns something matching the declared
	 * type.
	 */</comment>

	<comment type="block">/*
	 * Count the non-junk entries in the result targetlist.
	 */</comment>
	<expr_stmt><expr><name>tlistlen</name> <operator>=</operator> <call><name>ExecCleanTargetListLength</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fn_typtype</name> <operator>=</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fn_typtype</name> <operator>==</operator> <name>TYPTYPE_BASE</name> <operator>||</operator>
		<name>fn_typtype</name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name> <operator>||</operator>
		<name>fn_typtype</name> <operator>==</operator> <name>TYPTYPE_ENUM</name> <operator>||</operator>
		<name>fn_typtype</name> <operator>==</operator> <name>TYPTYPE_RANGE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For scalar-type returns, the target list must have exactly one
		 * non-junk entry, and its type must agree with what the user
		 * declared; except we allow binary-compatible types too.
		 */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>tlistlen</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type mismatch in function declared to return %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Final statement must return exactly one column."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* We assume here that non-junk TLEs must come first in tlists */</comment>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>restype</name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type mismatch in function declared to return %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Actual return type is %s."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>modifyTargetList</name> <operator>&amp;&amp;</operator> <name>restype</name> <operator>!=</operator> <name>rettype</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
												 <argument><expr><name>rettype</name></expr></argument>,
												 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												 <argument><expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Relabel is dangerous if TLE is a sort/group or setop column */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>modifyTargetList</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Set up junk filter if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>junkFilter</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>junkFilter</name> <operator>=</operator> <call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
											 <argument><expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>fn_typtype</name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>||</operator> <name>rettype</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Returns a rowtype.
		 *
		 * Note that we will not consider a domain over composite to be a
		 * "rowtype" return type; it goes through the scalar case above.  This
		 * is because SQL functions don't provide any implicit casting to the
		 * result type, so there is no way to produce a domain-over-composite
		 * result except by computing it as an explicit single-column result.
		 */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tupnatts</name></decl>;</decl_stmt>	<comment type="block">/* physical number of columns in tuple */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>tuplogcols</name></decl>;</decl_stmt> <comment type="block">/* # of nondeleted columns in tuple */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>colindex</name></decl>;</decl_stmt>	<comment type="block">/* physical column index */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newtlist</name></decl>;</decl_stmt>	<comment type="block">/* new non-junk tlist entries */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>junkattrs</name></decl>;</decl_stmt>	<comment type="block">/* new junk tlist entries */</comment>

		<comment type="block">/*
		 * If the target list is of length 1, and the type of the varnode in
		 * the target list matches the declared return type, this is okay.
		 * This can happen, for example, where the body of the function is
		 * 'SELECT func2()', where func2 has the same composite return type as
		 * the function that's calling it.
		 *
		 * XXX Note that if rettype is RECORD, the IsBinaryCoercible check
		 * will succeed for any composite restype.  For the moment we rely on
		 * runtime type checking to catch any discrepancy, but it'd be nice to
		 * do better at parse time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tlistlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>restype</name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>modifyTargetList</name> <operator>&amp;&amp;</operator> <name>restype</name> <operator>!=</operator> <name>rettype</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
														 <argument><expr><name>rettype</name></expr></argument>,
														 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
														 <argument><expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Relabel is dangerous if sort/group or setop column */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>modifyTargetList</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Set up junk filter if needed */</comment>
				<if_stmt><if>if <condition>(<expr><name>junkFilter</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>=
					<expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><operator>*</operator><name>junkFilter</name> <operator>=</operator> <call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* NOT returning whole tuple */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Is the rowtype fixed, or determined only at runtime?  (Note we
		 * cannot see TYPEFUNC_COMPOSITE_DOMAIN here.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_func_result_type</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Assume we are returning the whole tuple. Crosschecking against
			 * what the caller expects will happen at runtime.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>junkFilter</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>junkFilter</name> <operator>=</operator> <call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Verify that the targetlist matches the return tuple type. We scan
		 * the non-deleted attributes to ensure that they match the datatypes
		 * of the non-resjunk columns.  For deleted attributes, insert NULL
		 * result columns if the caller asked for that.
		 */</comment>
		<expr_stmt><expr><name>tupnatts</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuplogcols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* we'll count nondeleted cols as we go */</comment>
		<expr_stmt><expr><name>colindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>			<comment type="block">/* these are only used if modifyTargetList */</comment>
		<expr_stmt><expr><name>junkattrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>tletype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>atttype</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>modifyTargetList</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>junkattrs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>junkattrs</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name>colindex</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>colindex</name> <operator>&gt;</operator> <name>tupnatts</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type mismatch in function declared to return %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Final statement returns too many columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>colindex</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator> <name>modifyTargetList</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>null_expr</name></decl>;</decl_stmt>

					<comment type="block">/* The type of the null we insert isn't important */</comment>
					<expr_stmt><expr><name>null_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
												   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												   <argument><expr><name>InvalidOid</name></expr></argument>,
												   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
												   <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* isnull */</comment>
												   <argument><expr><name>true</name></expr></argument> <comment type="block">/* byval */</comment> )</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>newtlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>,
									   <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>null_expr</name></expr></argument>,
													   <argument><expr><name>colindex</name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* NULL insertion is dangerous in a setop */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>modifyTargetList</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block> while <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>;</do>
			<expr_stmt><expr><name>tuplogcols</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>tletype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>atttype</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>tletype</name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type mismatch in function declared to return %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Final statement returns %s instead of %s at column %d."</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>tletype</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>tuplogcols</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>modifyTargetList</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>tletype</name> <operator>!=</operator> <name>atttype</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
														 <argument><expr><name>atttype</name></expr></argument>,
														 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
														 <argument><expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Relabel is dangerous if sort/group or setop column */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>modifyTargetList</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>colindex</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newtlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* remaining columns in tupdesc had better all be dropped */</comment>
		<for>for <control>(<init><expr><name>colindex</name><operator>++</operator></expr>;</init> <condition><expr><name>colindex</name> <operator>&lt;=</operator> <name>tupnatts</name></expr>;</condition> <incr><expr><name>colindex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>colindex</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type mismatch in function declared to return %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Final statement returns too few columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>modifyTargetList</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>null_expr</name></decl>;</decl_stmt>

				<comment type="block">/* The type of the null we insert isn't important */</comment>
				<expr_stmt><expr><name>null_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
											   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>InvalidOid</name></expr></argument>,
											   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
											   <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
											   <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* isnull */</comment>
											   <argument><expr><name>true</name></expr></argument> <comment type="block">/* byval */</comment> )</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newtlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>,
								   <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>null_expr</name></expr></argument>,
												   <argument><expr><name>colindex</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* NULL insertion is dangerous in a setop */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>modifyTargetList</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>modifyTargetList</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ensure resjunk columns are numbered correctly */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>junkattrs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>colindex</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
			<comment type="block">/* replace the tlist with the modified one */</comment>
			<expr_stmt><expr><operator>*</operator><name>tlist_ptr</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>, <argument><expr><name>junkattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Set up junk filter if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>junkFilter</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>=
			<expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>junkFilter</name> <operator>=</operator> <call><name>ExecInitJunkFilterConversion</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
													   <argument><expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Report that we are returning entire tuple result */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type %s is not supported for SQL functions"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateSQLFunctionDestReceiver -- create a suitable DestReceiver object
 */</comment>
<function><type><name>DestReceiver</name> <modifier>*</modifier></type>
<name>CreateSQLFunctionDestReceiver</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DR_sqlfunction</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>DR_sqlfunction</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DR_sqlfunction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>receiveSlot</name></name> <operator>=</operator> <name>sqlfunction_receive</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rStartup</name></name> <operator>=</operator> <name>sqlfunction_startup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rShutdown</name></name> <operator>=</operator> <name>sqlfunction_shutdown</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rDestroy</name></name> <operator>=</operator> <name>sqlfunction_destroy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>=</operator> <name>DestSQLFunction</name></expr>;</expr_stmt>

	<comment type="block">/* private fields will be set by postquel_start */</comment>

	<return>return <expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * sqlfunction_startup --- executor startup
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sqlfunction_startup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* no-op */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * sqlfunction_receive --- receive one tuple
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sqlfunction_receive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DR_sqlfunction</name> <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_sqlfunction</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Filter tuple as needed */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>filter</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the filtered tuple into the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * sqlfunction_shutdown --- executor end
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sqlfunction_shutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* no-op */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * sqlfunction_destroy --- release DestReceiver object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sqlfunction_destroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
