<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/nodeTableFunction.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeTableFunction.c
 *	 Support routines for scans of enhanced table functions.
 *
 * DESCRIPTION
 *
 *   This code is distinct from ExecFunctionScan due to the nature of
 *   the plans.  A plain table function will be called without an input
 *   subquery, whereas the enhanced table function framework allows 
 *   table functions operating over table input.
 *
 *  Normal Table Function            Enhanced Table Function
 *
 *         (out)                              (out)
 *           |                                  |
 *     (FunctionScan)                  (TableFunctionScan)
 *                                              |
 *                                        (SubqueryScan)
 *
 * INTERFACE ROUTINES
 * 	 ExecTableFunctionScan			sequentially scans a relation.
 *	 ExecTableFunctionNext			retrieve next tuple in sequential order.
 *	 ExecInitTableFunctionScan		creates and initializes a externalscan node.
 *	 ExecEndTableFunctionScan		releases any storage allocated.
 *	 ExecTableFunctionReScan		rescans the relation
 *
 * Portions Copyright (c) 2011, EMC
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/executor/nodeTableFunction.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tablefuncapi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTableFunction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>TableFunctionNext</name><parameter_list>(<parameter><decl><type><name>TableFunctionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Private structure forward declared in tablefuncapi.h */</comment>
<typedef>typedef <type><struct>struct <name>AnyTableData</name>
<block>{
	<decl_stmt><decl><type><name>ExprContext</name>			<modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>			<modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>     <comment type="block">/* subplan node */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type>            <name>subdesc</name></decl>;</decl_stmt>     <comment type="block">/* tuple descriptor of subplan */</comment>
	<decl_stmt><decl><type><name>JunkFilter</name>          <modifier>*</modifier></type><name>junkfilter</name></decl>;</decl_stmt>  <comment type="block">/* for projection of subplan tuple */</comment>
}</block></struct></type> <name>AnyTableData</name>;</typedef>

<comment type="block">/*
 * TableFunctionNext - ExecScan callback function for table function scans
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>TableFunctionNext</name><parameter_list>(<parameter><decl><type><name>TableFunctionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type>        <name>oldcontext</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name>		<modifier>*</modifier></type><name>slot</name>        <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name>			<modifier>*</modifier></type><name>econtext</name>	 <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>                 <name>returns_set</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>flinfo</name><operator>.</operator><name>fn_retset</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>            <name>tuple</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>            <name>resultdesc</name>  <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>resultdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>                <name>user_result</name></decl>;</decl_stmt>

	<comment type="block">/* Clean up any per-tuple memory */</comment>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setup arguments on the first call */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>is_firstcall</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>argstate</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argstate</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The ANYTABLE argument is represented as a NULL in the
				 * arguments list.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>AnyTableGetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>inputscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>argstate</name></expr></argument>,
														   <argument><expr><name>econtext</name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>is_firstcall</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If all results have been returned by the callback function then
	 * we are done. 
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>==</operator> <name>ExprEndResult</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* empty slot */</comment>

	<comment type="block">/* Invoke the user supplied function */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>user_result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fcinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>returnMode</name></name> <operator>!=</operator> <name>SFRM_ValuePerCall</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* FIXME: should support both protocols */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table functions must use SFRM_ValuePerCall protocol"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>==</operator> <name>ExprEndResult</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* empty slot */</comment>

	<comment type="block">/* Mark this the last value if the func doesn't return a set */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>returns_set</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>==</operator> <name>ExprSingleResult</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>=</operator> <name>ExprEndResult</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* This would only error if the user violated the SRF calling convensions */</comment>
	<if_stmt><if>if <condition>(<expr><name>returns_set</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning set of rows cannot return null value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Convert the Datum into tuple and store it into the scan slot */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>is_rowtype</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTupleHeader</name></type>  <name>th</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>returns_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* checked above */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>resultdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;=</operator> <name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>resultdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>

			<comment type="block">/* 
			 * If we get a clean solution to the tuple allocation below we
			 * can use it here as well.  This is less an issue because there
			 * is only a single tuple in this case, so the overhead of a
			 * single palloc is not a big deal.
			 */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>resultdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>

			<comment type="block">/* Convert returned HeapTupleHeader into a HeapTuple */</comment>
			<expr_stmt><expr><name>th</name>	  <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>user_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name>  <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

			<comment type="block">/* Double check that this tuple is of the expected form */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>resultdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>!=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, 
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid tuple returned from table function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Returned tuple does not match output "</literal>
								   <literal type="string">"tuple descriptor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* 
		 * TODO: This will allocate memory for each tuple, we should be able 
		 * to get away with fewer pallocs.
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* &amp;user_result yields a singleton pointer - make sure only one is read */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>==</operator> <name><name>resultdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>resultdesc</name></expr></argument>, 
								<argument><expr><operator>&amp;</operator><name>user_result</name></expr></argument>, 
								<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* 
	 * Store the tuple into the scan slot.
	 *
	 * Note: Tuple should be allocated in the per-row memory context, so they
	 * will be freed automatically when the context is freed, we cannot free
	 * them again here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, 
							  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>, 
							  <argument><expr><name>false</name></expr></argument> <comment type="block">/* shouldFree */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TableFunctionRecheck -- access method routine to recheck a tuple in EvalPlanQual
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TableFunctionRecheck</name><parameter_list>(<parameter><decl><type><name>TableFunctionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* nothing to check */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecTableFunction - wrapper around TableFunctionNext
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecTableFunction</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableFunctionState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>TableFunctionState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ExecScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>ExecScanAccessMtd</name><operator>)</operator> <name>TableFunctionNext</name></expr></argument>,
					<argument><expr><operator>(</operator><name>ExecScanRecheckMtd</name><operator>)</operator> <name>TableFunctionRecheck</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecInitTableFunction - Setup the table function executor 
 */</comment>
<function><type><name>TableFunctionState</name> <modifier>*</modifier></type>
<name>ExecInitTableFunction</name><parameter_list>(<parameter><decl><type><name>TableFunctionScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableFunctionState</name>	<modifier>*</modifier></type><name>scanstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>           <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>					 <name>funcrettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeFuncClass</name></type>		 <name>functypclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>            <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name>         <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>            <name>inputdesc</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>			 <name>resultdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argstates</name></decl>;</decl_stmt>

	<comment type="block">/* Inner plan is not used, outer plan must be present */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Forward scan only */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_MARK</name> <operator>|</operator> <name>EXEC_FLAG_BACKWARD</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create state structure.
	 */</comment>
	<expr_stmt><expr><name>scanstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TableFunctionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name>  <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecTableFunction</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>inputscan</name></name>   <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AnyTableData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>is_firstcall</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Create expression context for the node. */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

	<comment type="block">/* Initialize child nodes */</comment>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>scanstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplan</name>   <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>scanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inputdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * The funcexpr must be a function call.  This check is to verify that
	 * the planner didn't try to perform constant folding or other inlining
	 * on a function invoked as a table function.
	 */</comment>
	<expr_stmt><expr><name>rtfunc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>function</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* should not be possible */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table function expression is not a function expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>func</name> <operator>=</operator> <operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>functypclass</name> <operator>=</operator> <call><name>get_expr_result_type</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator> <name>func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funcrettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<switch>switch <condition>(<expr><name>functypclass</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TYPEFUNC_COMPOSITE</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* Composite data type: copy the typcache entry for safety */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>resultdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>is_rowtype</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>TYPEFUNC_RECORD</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* Record data type: Construct tuple desc based on rangeTable */</comment>
			<expr_stmt><expr><name>resultdesc</name> <operator>=</operator> <call><name>BuildDescFromLists</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name></expr></argument>,
											<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>,
											<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypmods</name></name></expr></argument>,
											<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcollations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>is_rowtype</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>TYPEFUNC_SCALAR</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* Scalar data type: Construct a tuple descriptor manually */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>attname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>resultdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>resultdesc</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>attname</name></expr></argument>,
							   <argument><expr><name>funcrettype</name></expr></argument>,
							   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>resultdesc</name></expr></argument>,
										<argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>is_rowtype</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<comment type="block">/* This should not be possible, it should be caught by parser. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table function has unsupported return type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * For RECORD results, make sure a typmod has been assigned.  (The
	 * function should do this for itself, but let's cover things in case it
	 * doesn't.)
	 */</comment>
	<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>resultdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize scan slot and type */</comment>
	<expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>resultdesc</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>TTSOpsHeapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>resultdesc</name></name> <operator>=</operator> <name>resultdesc</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize result tuple type and projection info */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTypeTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignScanProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize child expressions */</comment>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>scanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Other node-specific setup
	 */</comment>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>type</name></name>		   <operator>=</operator> <name>T_ReturnSetInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>econtext</name></name>	   <operator>=</operator> <name>econtext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>expectedDesc</name></name> <operator>=</operator> <name>resultdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>allowedModes</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>SFRM_ValuePerCall</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>returnMode</name></name>   <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>SFRM_ValuePerCall</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>isDone</name></name>	   <operator>=</operator> <name>ExprSingleResult</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>setResult</name></name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>rsinfo</name><operator>.</operator><name>setDesc</name></name>	   <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>userdata</name></name> <operator>=</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcuserdata</name></name></expr>;</expr_stmt>

	<comment type="block">/* setup the AnyTable input */</comment>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>inputscan</name><operator>-&gt;</operator><name>econtext</name></name> <operator>=</operator> <name>econtext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>inputscan</name><operator>-&gt;</operator><name>subplan</name></name>  <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>inputscan</name><operator>-&gt;</operator><name>subdesc</name></name>  <operator>=</operator> <name>inputdesc</name></expr>;</expr_stmt>

	<comment type="block">/* Determine projection information for subplan */</comment>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>inputscan</name><operator>-&gt;</operator><name>junkfilter</name></name> <operator>=</operator>
		<call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, 
						   <argument><expr><name>NULL</name></expr></argument>  <comment type="block">/* slot */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>scanstate</name><operator>-&gt;</operator><name>inputscan</name><operator>-&gt;</operator><name>junkfilter</name><operator>-&gt;</operator><name>jf_cleanTupType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare for execution of the function.
	 */</comment>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scanstate</name><operator>-&gt;</operator><name>flinfo</name><operator>.</operator><name>fn_nargs</name></name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"number of arguments between TableFunctionScan and Fmgrinfo don't match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>fcinfo</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><name><name>scanstate</name><operator>-&gt;</operator><name>flinfo</name><operator>.</operator><name>fn_nargs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name><name>scanstate</name><operator>-&gt;</operator><name>fcinfo</name></name></expr></argument>,		<comment type="block">/* Fcinfo  */</comment>
							 <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,		<comment type="block">/* Flinfo  */</comment>
							 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* Nargs   */</comment>
							 <argument><expr><name>InvalidOid</name></expr></argument>,					  <comment type="block">/* input_collation */</comment>
							 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scanstate</name></expr></argument>,                   <comment type="block">/* Context */</comment>
							 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>scanstate</name><operator>-&gt;</operator><name>rsinfo</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* ResultInfo */</comment>

	<comment type="block">/*
	 * Initialize ExprStates for all arguments.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>argstates</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>func-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>argstate</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TableValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>argstate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>argstate</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>argstates</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>argstates</name></expr></argument>, <argument><expr><name>argstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Currently we don't allow table functions with more than one table value
	 * expression arguments, and if they don't have at least one they will be
	 * planned as nodeFunctionScan instead of nodeTableFunctionScan.
	 * Therefore we should have found exactly 1 TableValueExpr above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table functions over multiple TABLE value expressions not yet supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>argstates</name></expr>;</expr_stmt>

	<return>return <expr><name>scanstate</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecEndTableFunction</name><parameter_list>(<parameter><decl><type><name>TableFunctionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Free the ExprContext */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* Clean out the tuple table */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* End the subplans */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanTableFunction</name><parameter_list>(<parameter><decl><type><name>TableFunctionState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* TableFunction Planner marks TableFunction nodes as not rescannable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>is_firstcall</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid rescan of TableFunctionScan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Callback functions exposed to the user */</comment>
<function><type><name>TupleDesc</name></type> 
<name>AnyTable_GetTupleDesc</name><parameter_list>(<parameter><decl><type><name>AnyTable</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, 
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid null value for anytable type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>junkfilter</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>junkfilter</name></name></expr></argument>, <argument><expr><name>JunkFilter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return the projected tuple descriptor */</comment>
	<return>return <expr><name><name>t</name><operator>-&gt;</operator><name>junkfilter</name><operator>-&gt;</operator><name>jf_cleanTupType</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>AnyTable_GetNextTuple</name><parameter_list>(<parameter><decl><type><name>AnyTable</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, 
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid null value for anytable type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fetch the next tuple into the tuple slot */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ----------------------------------------
	 * 1) Fetch the tuple from the tuple slot
	 * 2) apply resjunk filtering
	 * 3) copy result into a HeapTuple
	 * ----------------------------------------
	 */</comment>

	<comment type="block">/* GPDB_91_MERGE_FIXME: We used to call  ExecRemoveJunk here, but it
	 * was removed in the upstream. I copied the implementation of
	 * ExecRemoveJunk here, but based on the commit message (2e852e541c),
	 * I don't think we should be doing this either
	 */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>junkfilter</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tf_set_userdata_internal
 * This is the entity of TF_SET_USERDATA() API. Sets bytea datum to
 * RangeTblEntry, which is transported to project function via serialized
 * plan tree.
 */</comment>
<function><type><name>void</name></type>
<name>tf_set_userdata_internal</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>userdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected RangeTblFunction node, found %d"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr> ?</condition><then> <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rtfunc</name> <operator>=</operator> <operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>

	<comment type="block">/* Make sure it gets detoasted, but packed is allowed */</comment>
	<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcuserdata</name></name> <operator>=</operator>
		<ternary><condition><expr><name>userdata</name></expr> ?</condition><then> <expr><call><name>pg_detoast_datum_packed</name><argument_list>(<argument><expr><name>userdata</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tf_get_userdata_internal
 * This is the entity of TF_GET_USERDATA() API. Extracts userdata from
 * its scan node which was transported via serialized plan tree.
 */</comment>
<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>tf_get_userdata_internal</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>userdata</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>TableFunctionState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected TableFunctionState node, found %d"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr> ?</condition><then> <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>userdata</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>TableFunctionState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator><operator>-&gt;</operator><name>userdata</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>userdata</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* unpack, just in case */</comment>
	<return>return <expr><call><name>pg_detoast_datum</name><argument_list>(<argument><expr><name>userdata</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
