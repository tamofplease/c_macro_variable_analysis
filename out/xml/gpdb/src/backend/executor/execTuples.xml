<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/execTuples.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execTuples.c
 *	  Routines dealing with TupleTableSlots.  These are used for resource
 *	  management associated with tuples (eg, releasing buffer pins for
 *	  tuples in disk buffers, or freeing the memory occupied by transient
 *	  tuples).  Slots also provide access abstraction that lets us implement
 *	  "virtual" tuples to reduce data-copying overhead.
 *
 *	  Routines dealing with the type information for tuples. Currently,
 *	  the type information for a tuple is an array of FormData_pg_attribute.
 *	  This information is needed by routines manipulating tuples
 *	  (getattribute, formtuple, etc.).
 *
 *
 *	 EXAMPLE OF HOW TABLE ROUTINES WORK
 *		Suppose we have a query such as SELECT emp.name FROM emp and we have
 *		a single SeqScan node in the query plan.
 *
 *		At ExecutorStart()
 *		----------------

 *		- ExecInitSeqScan() calls ExecInitScanTupleSlot() to construct a
 *		  TupleTableSlots for the tuples returned by the access method, and
 *		  ExecInitResultTypeTL() to define the node's return
 *		  type. ExecAssignScanProjectionInfo() will, if necessary, create
 *		  another TupleTableSlot for the tuples resulting from performing
 *		  target list projections.
 *
 *		During ExecutorRun()
 *		----------------
 *		- SeqNext() calls ExecStoreBufferHeapTuple() to place the tuple
 *		  returned by the access method into the scan tuple slot.
 *
 *		- ExecSeqScan() (via ExecScan), if necessary, calls ExecProject(),
 *		  putting the result of the projection in the result tuple slot. If
 *		  not necessary, it directly returns the slot returned by SeqNext().
 *
 *		- ExecutePlan() calls the output function.
 *
 *		The important thing to watch in the executor code is how pointers
 *		to the slots containing tuples are passed instead of the tuples
 *		themselves.  This facilitates the communication of related information
 *		(such as whether or not a tuple should be pfreed, what buffer contains
 *		this tuple, the tuple's tuple descriptor, etc).  It also allows us
 *		to avoid physically constructing projection tuples in many cases.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/execTuples.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>ExecTypeFromTLInternal</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>skipjunk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pg_attribute_always_inline</name> <name>void</name></type> <name>slot_deform_heap_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>offp</name></decl></parameter>,
															  <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tts_buffer_heap_store_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
											   <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
											   <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>transfer_pin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tts_heap_store_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name></type> <name>TTSOpsVirtual</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name></type> <name>TTSOpsHeapTuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name></type> <name>TTSOpsMinimalTuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name></type> <name>TTSOpsBufferHeapTuple</name></decl>;</decl_stmt>


<comment type="block">/*
 * TupleTableSlotOps implementations.
 */</comment>

<comment type="block">/*
 * TupleTableSlotOps implementation for VirtualTupleTableSlot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_virtual_init</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_virtual_release</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_virtual_clear</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VirtualTupleTableSlot</name> <modifier>*</modifier></type><name>vslot</name> <init>= <expr><operator>(</operator><name>VirtualTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>vslot</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vslot</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attribute values are readily available in tts_values and tts_isnull array
 * in a VirtualTupleTableSlot. So there should be no need to call either of the
 * following two functions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_virtual_getsomeattrs</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"getsomeattrs is not required to be called on a virtual tuple table slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>tts_virtual_getsysattr</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * GPDB: AppendOptimized relations do need to get sysattrs AND use virtual
	 * tuples to pass around data. It is assumed that the caller knows what is
	 * doing, if the attribute is gp_segment_id. Otherwise, error out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>GpSegmentIdAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<return>return <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"virtual tuple table slot does not have system attributes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* silence compiler warnings */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * To materialize a virtual slot all the datums that aren't passed by value
 * have to be copied into the slot's memory context.  To do so, compute the
 * required size, and allocate enough memory to store all attributes.  That's
 * good for cache hit ratio, but more importantly requires only memory
 * allocation/deallocation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_virtual_materialize</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VirtualTupleTableSlot</name> <modifier>*</modifier></type><name>vslot</name> <init>= <expr><operator>(</operator><name>VirtualTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<comment type="block">/* already materialized */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* compute size of memory required */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>natt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>natt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>||</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>natt</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>natt</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We want to flatten the expanded value so that the materialized
			 * slot doesn't depend on it.
			 */</comment>
			<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* all data is byval */</comment>
	<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* allocate memory */</comment>
	<expr_stmt><expr><name><name>vslot</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>

	<comment type="block">/* and copy all attributes into the pre-allocated space */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>natt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>natt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>||</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>natt</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>natt</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>data_length</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We want to flatten the expanded value so that the materialized
			 * slot doesn't depend on it.
			 */</comment>
			<decl_stmt><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eoh</name> <init>= <expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EOH_flatten_into</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>data_length</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>data_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>data_length</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_virtual_copyslot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>dstslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>srcslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>srcdesc</name> <init>= <expr><name><name>srcslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>srcdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;=</operator> <name><name>dstslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tts_virtual_clear</name><argument_list>(<argument><expr><name>dstslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>srcslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>natt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name><name>srcdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator> <name><name>srcslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>natt</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator> <name><name>srcslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>natt</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name><name>srcdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>

	<comment type="block">/* make sure storage doesn't depend on external memory */</comment>
	<expr_stmt><expr><call><name>tts_virtual_materialize</name><argument_list>(<argument><expr><name>dstslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>tts_virtual_copy_heap_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MinimalTuple</name></type>
<name>tts_virtual_copy_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>heap_form_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
								   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
								   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TupleTableSlotOps implementation for HeapTupleTableSlot.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_heap_init</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_heap_release</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_heap_clear</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name> <init>= <expr><operator>(</operator><name>HeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Free the memory for the heap tuple if it's allowed. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hslot</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_heap_getsomeattrs</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name> <init>= <expr><operator>(</operator><name>HeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>slot_deform_heap_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hslot</name><operator>-&gt;</operator><name>off</name></name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>tts_heap_getsysattr</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name> <init>= <expr><operator>(</operator><name>HeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>heap_getsysattr</name><argument_list>(<argument><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_heap_materialize</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name> <init>= <expr><operator>(</operator><name>HeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This slot has it's tuple already materialized. Nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
									   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
									   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The tuple contained in this slot is not allocated in the memory
		 * context of the given slot (else it would have TTS_SHOULDFREE set).
		 * Copy the tuple into the given slot's memory context.
		 */</comment>
		<expr_stmt><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Have to deform from scratch, otherwise tts_values[] entries could point
	 * into the non-materialized tuple (which might be gone when accessed).
	 */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hslot</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_heap_copyslot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>dstslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>srcslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>srcslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>dstslot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>tts_heap_get_heap_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name> <init>= <expr><operator>(</operator><name>HeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tts_heap_materialize</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>tts_heap_copy_heap_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name> <init>= <expr><operator>(</operator><name>HeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tts_heap_materialize</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MinimalTuple</name></type>
<name>tts_heap_copy_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name> <init>= <expr><operator>(</operator><name>HeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tts_heap_materialize</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>minimal_tuple_from_heap_tuple</name><argument_list>(<argument><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_heap_store_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name> <init>= <expr><operator>(</operator><name>HeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>tts_heap_clear</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hslot</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TupleTableSlotOps implementation for MinimalTupleTableSlot.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_minimal_init</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTupleTableSlot</name> <modifier>*</modifier></type><name>mslot</name> <init>= <expr><operator>(</operator><name>MinimalTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize the heap tuple pointer to access attributes of the minimal
	 * tuple contained in the slot as if its a heap tuple.
	 */</comment>
	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>mslot</name><operator>-&gt;</operator><name>minhdr</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_minimal_release</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_minimal_clear</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTupleTableSlot</name> <modifier>*</modifier></type><name>mslot</name> <init>= <expr><operator>(</operator><name>MinimalTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_minimal_getsomeattrs</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTupleTableSlot</name> <modifier>*</modifier></type><name>mslot</name> <init>= <expr><operator>(</operator><name>MinimalTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>slot_deform_heap_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>mslot</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mslot</name><operator>-&gt;</operator><name>off</name></name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>tts_minimal_getsysattr</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"minimal tuple table slot does not have system attributes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* silence compiler warnings */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_minimal_materialize</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTupleTableSlot</name> <modifier>*</modifier></type><name>mslot</name> <init>= <expr><operator>(</operator><name>MinimalTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This slot has it's tuple already materialized. Nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name> <operator>=</operator> <call><name>heap_form_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
												  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
												  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The minimal tuple contained in this slot is not allocated in the
		 * memory context of the given slot (else it would have TTS_SHOULDFREE
		 * set).  Copy the minimal tuple into the given slot's memory context.
		 */</comment>
		<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name> <operator>=</operator> <call><name>heap_copy_minimal_tuple</name><argument_list>(<argument><expr><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mslot</name><operator>-&gt;</operator><name>tuple</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>mslot</name><operator>-&gt;</operator><name>minhdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>minhdr</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>minhdr</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Have to deform from scratch, otherwise tts_values[] entries could point
	 * into the non-materialized tuple (which might be gone when accessed).
	 */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_minimal_copyslot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>dstslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>srcslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>mintuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mintuple</name> <operator>=</operator> <call><name>ExecCopySlotMinimalTuple</name><argument_list>(<argument><expr><name>srcslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>mintuple</name></expr></argument>, <argument><expr><name>dstslot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MinimalTuple</name></type>
<name>tts_minimal_get_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTupleTableSlot</name> <modifier>*</modifier></type><name>mslot</name> <init>= <expr><operator>(</operator><name>MinimalTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tts_minimal_materialize</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>tts_minimal_copy_heap_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTupleTableSlot</name> <modifier>*</modifier></type><name>mslot</name> <init>= <expr><operator>(</operator><name>MinimalTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tts_minimal_materialize</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>heap_tuple_from_minimal_tuple</name><argument_list>(<argument><expr><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MinimalTuple</name></type>
<name>tts_minimal_copy_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTupleTableSlot</name> <modifier>*</modifier></type><name>mslot</name> <init>= <expr><operator>(</operator><name>MinimalTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tts_minimal_materialize</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>heap_copy_minimal_tuple</name><argument_list>(<argument><expr><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_minimal_store_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTupleTableSlot</name> <modifier>*</modifier></type><name>mslot</name> <init>= <expr><operator>(</operator><name>MinimalTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>tts_minimal_clear</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>mintuple</name></name> <operator>=</operator> <name>mtup</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mslot</name><operator>-&gt;</operator><name>tuple</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>mslot</name><operator>-&gt;</operator><name>minhdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>minhdr</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mslot</name><operator>-&gt;</operator><name>minhdr</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* no need to set t_self or t_tableOid since we won't allow access */</comment>

	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TupleTableSlotOps implementation for BufferHeapTupleTableSlot.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_buffer_heap_init</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_buffer_heap_release</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_buffer_heap_clear</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Free the memory for heap tuple if allowed. A tuple coming from buffer
	 * can never be freed. But we may have materialized a tuple from buffer.
	 * Such a tuple can be freed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We should have unpinned the buffer while materializing the tuple. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_buffer_heap_getsomeattrs</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>slot_deform_heap_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>off</name></name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>tts_buffer_heap_getsysattr</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>heap_getsysattr</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_buffer_heap_materialize</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If already materialized nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Normally BufferHeapTupleTableSlot should have a tuple + buffer
		 * associated with it, unless it's materialized (which would've
		 * returned above). But when it's useful to allow storing virtual
		 * tuples in a buffer slot, which then also needs to be
		 * materializable.
		 */</comment>
		<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
											<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
											<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * A heap tuple stored in a BufferHeapTupleTableSlot should have a
		 * buffer associated with it, unless it's materialized or virtual.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Have to deform from scratch, otherwise tts_values[] entries could point
	 * into the non-materialized tuple (which might be gone when accessed).
	 */</comment>
	<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tts_buffer_heap_copyslot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>dstslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>srcslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bsrcslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>srcslot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bdstslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>dstslot</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the source slot is of a different kind, or is a buffer slot that has
	 * been materialized / is virtual, make a new copy of the tuple. Otherwise
	 * make a new reference to the in-buffer tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_ops</name></name> <operator>!=</operator> <name><name>srcslot</name><operator>-&gt;</operator><name>tts_ops</name></name> <operator>||</operator>
		<call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>srcslot</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><name><name>bsrcslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>dstslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdstslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>srcslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>bsrcslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tts_buffer_heap_store_tuple</name><argument_list>(<argument><expr><name>dstslot</name></expr></argument>, <argument><expr><name><name>bsrcslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>,
									<argument><expr><name><name>bsrcslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The HeapTupleData portion of the source tuple might be shorter
		 * lived than the destination slot. Therefore copy the HeapTuple into
		 * our slot's tupdata, which is guaranteed to live long enough (but
		 * will still point into the buffer).
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bdstslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name></name></expr></argument>, <argument><expr><name><name>bdstslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdstslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>bdstslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>tts_buffer_heap_get_heap_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tts_buffer_heap_materialize</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>tts_buffer_heap_copy_heap_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tts_buffer_heap_materialize</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MinimalTuple</name></type>
<name>tts_buffer_heap_copy_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tts_buffer_heap_materialize</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>minimal_tuple_from_heap_tuple</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>tts_buffer_heap_store_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
							<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>transfer_pin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* materialized slot shouldn't have a buffer to release */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If tuple is on a disk page, keep the page pinned as long as we hold a
	 * pointer into it.  We assume the caller already has such a pin.  If
	 * transfer_pin is true, we'll transfer that pin to this slot, if not
	 * we'll pin it again ourselves.
	 *
	 * This is coded to optimize the case where the slot previously held a
	 * tuple on the same disk page: in that case releasing and re-acquiring
	 * the pin is a waste of cycles.  This is a common situation during
	 * seqscans, so it's worth troubling over.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>buffer</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transfer_pin</name> <operator>&amp;&amp;</operator> <call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>transfer_pin</name> <operator>&amp;&amp;</operator> <call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In transfer_pin mode the caller won't know about the same-page
		 * optimization, so we gotta release its pin.
		 */</comment>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * slot_deform_heap_tuple
 *		Given a TupleTableSlot, extract data from the slot's physical tuple
 *		into its Datum/isnull arrays.  Data is extracted up through the
 *		natts'th column (caller must ensure this is a legal column number).
 *
 *		This is essentially an incremental version of heap_deform_tuple:
 *		on each call we extract attributes up to the one needed, without
 *		re-computing information about previously extracted attributes.
 *		slot-&gt;tts_nvalid is the number of attributes already extracted.
 *
 * This is marked as always inline, so the different offp for different types
 * of slots gets optimized away.
 */</comment>
<function><type><specifier>static</specifier> <name>pg_attribute_always_inline</name> <name>void</name></type>
<name>slot_deform_heap_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>offp</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tup</name> <init>= <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnulls</name> <init>= <expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>				<comment type="block">/* ptr to tuple data */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>off</name></decl>;</decl_stmt>			<comment type="block">/* offset in tuple data */</comment>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bp</name> <init>= <expr><name><name>tup</name><operator>-&gt;</operator><name>t_bits</name></name></expr></init></decl>;</decl_stmt>	<comment type="block">/* ptr to null bitmap in tuple */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>slow</name></decl>;</decl_stmt>			<comment type="block">/* can we use/set attcacheoff? */</comment>

	<comment type="block">/* We can only fetch as many attributes as the tuple has. */</comment>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check whether the first call for this tuple, and initialize or restore
	 * loop state.
	 */</comment>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Start from the first attribute */</comment>
		<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Restore state from previous execution */</comment>
		<expr_stmt><expr><name>off</name> <operator>=</operator> <operator>*</operator><name>offp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slow</name> <operator>=</operator> <call><name>TTS_SLOW</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>thisatt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasnulls</name> <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* can't use attcacheoff anymore */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can only cache the offset for a varlena attribute if the
			 * offset is already suitably aligned, so that there would be no
			 * pad bytes in any case: then the offset will be valid for either
			 * an aligned or unaligned value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator>
				<name>off</name> <operator>==</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* not varlena, so safe to use att_align_nominal */</comment>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>fetchatt</name><argument_list>(<argument><expr><name>thisatt</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* can't use attcacheoff anymore */</comment>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Save state for next execution
	 */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>offp</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slow</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SLOW</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_SLOW</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name></type> <name>TTSOpsVirtual</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>base_slot_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VirtualTupleTableSlot</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>tts_virtual_init</name></expr>,
	<expr><operator>.</operator><name>release</name> <operator>=</operator> <name>tts_virtual_release</name></expr>,
	<expr><operator>.</operator><name>clear</name> <operator>=</operator> <name>tts_virtual_clear</name></expr>,
	<expr><operator>.</operator><name>getsomeattrs</name> <operator>=</operator> <name>tts_virtual_getsomeattrs</name></expr>,
	<expr><operator>.</operator><name>getsysattr</name> <operator>=</operator> <name>tts_virtual_getsysattr</name></expr>,
	<expr><operator>.</operator><name>materialize</name> <operator>=</operator> <name>tts_virtual_materialize</name></expr>,
	<expr><operator>.</operator><name>copyslot</name> <operator>=</operator> <name>tts_virtual_copyslot</name></expr>,

	<comment type="block">/*
	 * A virtual tuple table slot can not "own" a heap tuple or a minimal
	 * tuple.
	 */</comment>
	<expr><operator>.</operator><name>get_heap_tuple</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>get_minimal_tuple</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>copy_heap_tuple</name> <operator>=</operator> <name>tts_virtual_copy_heap_tuple</name></expr>,
	<expr><operator>.</operator><name>copy_minimal_tuple</name> <operator>=</operator> <name>tts_virtual_copy_minimal_tuple</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name></type> <name>TTSOpsHeapTuple</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>base_slot_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleTableSlot</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>tts_heap_init</name></expr>,
	<expr><operator>.</operator><name>release</name> <operator>=</operator> <name>tts_heap_release</name></expr>,
	<expr><operator>.</operator><name>clear</name> <operator>=</operator> <name>tts_heap_clear</name></expr>,
	<expr><operator>.</operator><name>getsomeattrs</name> <operator>=</operator> <name>tts_heap_getsomeattrs</name></expr>,
	<expr><operator>.</operator><name>getsysattr</name> <operator>=</operator> <name>tts_heap_getsysattr</name></expr>,
	<expr><operator>.</operator><name>materialize</name> <operator>=</operator> <name>tts_heap_materialize</name></expr>,
	<expr><operator>.</operator><name>copyslot</name> <operator>=</operator> <name>tts_heap_copyslot</name></expr>,
	<expr><operator>.</operator><name>get_heap_tuple</name> <operator>=</operator> <name>tts_heap_get_heap_tuple</name></expr>,

	<comment type="block">/* A heap tuple table slot can not "own" a minimal tuple. */</comment>
	<expr><operator>.</operator><name>get_minimal_tuple</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>copy_heap_tuple</name> <operator>=</operator> <name>tts_heap_copy_heap_tuple</name></expr>,
	<expr><operator>.</operator><name>copy_minimal_tuple</name> <operator>=</operator> <name>tts_heap_copy_minimal_tuple</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name></type> <name>TTSOpsMinimalTuple</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>base_slot_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MinimalTupleTableSlot</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>tts_minimal_init</name></expr>,
	<expr><operator>.</operator><name>release</name> <operator>=</operator> <name>tts_minimal_release</name></expr>,
	<expr><operator>.</operator><name>clear</name> <operator>=</operator> <name>tts_minimal_clear</name></expr>,
	<expr><operator>.</operator><name>getsomeattrs</name> <operator>=</operator> <name>tts_minimal_getsomeattrs</name></expr>,
	<expr><operator>.</operator><name>getsysattr</name> <operator>=</operator> <name>tts_minimal_getsysattr</name></expr>,
	<expr><operator>.</operator><name>materialize</name> <operator>=</operator> <name>tts_minimal_materialize</name></expr>,
	<expr><operator>.</operator><name>copyslot</name> <operator>=</operator> <name>tts_minimal_copyslot</name></expr>,

	<comment type="block">/* A minimal tuple table slot can not "own" a heap tuple. */</comment>
	<expr><operator>.</operator><name>get_heap_tuple</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>get_minimal_tuple</name> <operator>=</operator> <name>tts_minimal_get_minimal_tuple</name></expr>,
	<expr><operator>.</operator><name>copy_heap_tuple</name> <operator>=</operator> <name>tts_minimal_copy_heap_tuple</name></expr>,
	<expr><operator>.</operator><name>copy_minimal_tuple</name> <operator>=</operator> <name>tts_minimal_copy_minimal_tuple</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name></type> <name>TTSOpsBufferHeapTuple</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>base_slot_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufferHeapTupleTableSlot</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>tts_buffer_heap_init</name></expr>,
	<expr><operator>.</operator><name>release</name> <operator>=</operator> <name>tts_buffer_heap_release</name></expr>,
	<expr><operator>.</operator><name>clear</name> <operator>=</operator> <name>tts_buffer_heap_clear</name></expr>,
	<expr><operator>.</operator><name>getsomeattrs</name> <operator>=</operator> <name>tts_buffer_heap_getsomeattrs</name></expr>,
	<expr><operator>.</operator><name>getsysattr</name> <operator>=</operator> <name>tts_buffer_heap_getsysattr</name></expr>,
	<expr><operator>.</operator><name>materialize</name> <operator>=</operator> <name>tts_buffer_heap_materialize</name></expr>,
	<expr><operator>.</operator><name>copyslot</name> <operator>=</operator> <name>tts_buffer_heap_copyslot</name></expr>,
	<expr><operator>.</operator><name>get_heap_tuple</name> <operator>=</operator> <name>tts_buffer_heap_get_heap_tuple</name></expr>,

	<comment type="block">/* A buffer heap tuple table slot can not "own" a minimal tuple. */</comment>
	<expr><operator>.</operator><name>get_minimal_tuple</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>copy_heap_tuple</name> <operator>=</operator> <name>tts_buffer_heap_copy_heap_tuple</name></expr>,
	<expr><operator>.</operator><name>copy_minimal_tuple</name> <operator>=</operator> <name>tts_buffer_heap_copy_minimal_tuple</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ----------------------------------------------------------------
 *				  tuple table create/delete functions
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* --------------------------------
 *		MakeTupleTableSlot
 *
 *		Basic routine to make an empty TupleTableSlot of given
 *		TupleTableSlotType. If tupleDesc is specified the slot's descriptor is
 *		fixed for its lifetime, gaining some efficiency. If that's
 *		undesirable, pass NULL.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>MakeTupleTableSlot</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>basesz</name></decl>,
				<decl><type ref="prev"/><name>allocsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>basesz</name> <operator>=</operator> <name><name>tts_ops</name><operator>-&gt;</operator><name>base_slot_size</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * When a fixed descriptor is specified, we can reduce overhead by
	 * allocating the entire slot in one go.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleDesc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>allocsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>basesz</name></expr></argument>)</argument_list></call> <operator>+</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>allocsz</name> <operator>=</operator> <name>basesz</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>allocsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* const for optimization purposes, OK to modify at allocation time */</comment>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>TupleTableSlotOps</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name></name><operator>)</operator> <operator>=</operator> <name>tts_ops</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_TupleTableSlot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tupleDesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_FIXED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>=</operator> <name>tupleDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tupleDesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
			<operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>slot</name><operator>)</operator>
			 <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>basesz</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
			<operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>slot</name><operator>)</operator>
			 <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>basesz</name></expr></argument>)</argument_list></call>
			 <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PinTupleDesc</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * And allow slot type specific initialization.
	 */</comment>
	<expr_stmt><expr><call><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecAllocTableSlot
 *
 *		Create a tuple table slot within a tuple table (which is just a List).
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecAllocTableSlot</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tupleTable</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tts_ops</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>tupleTable</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tupleTable</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecResetTupleTable
 *
 *		This releases any resources (buffer pins, tupdesc refcounts)
 *		held by the tuple table, and optionally releases the memory
 *		occupied by the tuple table data structure.
 *		It is expected that this routine be called by EndPlan().
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecResetTupleTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tupleTable</name></decl></parameter>,	<comment type="block">/* tuple table */</comment>
					<parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>	<comment type="block">/* true if we should free memory */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tupleTable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TupleTableSlot</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Always release resources and reset the slot to empty */</comment>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>release</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If shouldFree, release memory occupied by the slot itself */</comment>
		<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TTS_FIXED</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* If shouldFree, release the list structure */</comment>
	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>tupleTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		MakeSingleTupleTableSlot
 *
 *		This is a convenience routine for operations that need a standalone
 *		TupleTableSlot not gotten from the main executor tuple table.  It makes
 *		a single slot of given TupleTableSlotType and initializes it to use the
 *		given tuple descriptor.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>MakeSingleTupleTableSlot</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tts_ops</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecDropSingleTupleTableSlot
 *
 *		Release a TupleTableSlot made with MakeSingleTupleTableSlot.
 *		DON'T use this on a slot that's part of a tuple table list!
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecDropSingleTupleTableSlot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This should match ExecResetTupleTable's processing of one slot */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>TupleTableSlot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>release</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TTS_FIXED</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *				  tuple table slot accessor functions
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* --------------------------------
 *		ExecSetSlotDescriptor
 *
 *		This function is used to set the tuple descriptor associated
 *		with the slot's tuple.  The passed descriptor must have lifespan
 *		at least equal to the slot's.  If it is a reference-counted descriptor
 *		then the reference count is incremented for as long as the slot holds
 *		a reference.
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetSlotDescriptor</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <comment type="block">/* slot to change */</comment>
					  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>	<comment type="block">/* new tuple descriptor */</comment>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_FIXED</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For safety, make sure slot is empty before changing it */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release any old descriptor.  Also release old Datum/isnull arrays if
	 * present (we don't bother to check if they could be re-used).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Install the new descriptor; if it's refcounted, bump its refcount.
	 */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PinTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate Datum/isnull arrays of the appropriate size.  These must have
	 * the same lifetime as the slot, so allocate in the slot's own context.
	 */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecStoreHeapTuple
 *
 *		This function is used to store an on-the-fly physical tuple into a specified
 *		slot in the tuple table.
 *
 *		tuple:	tuple to store
 *		slot:	TTSOpsHeapTuple type slot to store it in
 *		shouldFree: true if ExecClearTuple should pfree() the tuple
 *					when done with it
 *
 * shouldFree is normally set 'true' for tuples constructed on-the-fly.  But it
 * can be 'false' when the referenced tuple is held in a tuple table slot
 * belonging to a lower-level executor Proc node.  In this case the lower-level
 * slot retains ownership and responsibility for eventually releasing the
 * tuple.  When this method is used, we must be certain that the upper-level
 * Proc node will lose interest in the tuple sooner than the lower-level one
 * does!  If you're not certain, copy the lower-level tuple with heap_copytuple
 * and let the upper-level table slot assume ownership of the copy!
 *
 * Return value is just the passed-in slot pointer.
 *
 * If the target slot is not guaranteed to be TTSOpsHeapTuple type slot, use
 * the, more expensive, ExecForceStoreHeapTuple().
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreHeapTuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
				   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_IS_HEAPTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trying to store a heap tuple into wrong type of slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>tts_heap_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecStoreBufferHeapTuple
 *
 *		This function is used to store an on-disk physical tuple from a buffer
 *		into a specified slot in the tuple table.
 *
 *		tuple:	tuple to store
 *		slot:	TTSOpsBufferHeapTuple type slot to store it in
 *		buffer: disk buffer if tuple is in a disk page, else InvalidBuffer
 *
 * The tuple table code acquires a pin on the buffer which is held until the
 * slot is cleared, so that the tuple won't go away on us.
 *
 * Return value is just the passed-in slot pointer.
 *
 * If the target slot is not guaranteed to be TTSOpsBufferHeapTuple type slot,
 * use the, more expensive, ExecForceStoreHeapTuple().
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreBufferHeapTuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
						 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						 <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_IS_BUFFERTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trying to store an on-disk heap tuple into wrong type of slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>tts_buffer_heap_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like ExecStoreBufferHeapTuple, but transfer an existing pin from the caller
 * to the slot, i.e. the caller doesn't need to, and may not, release the pin.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStorePinnedBufferHeapTuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
							   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							   <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_IS_BUFFERTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trying to store an on-disk heap tuple into wrong type of slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>tts_buffer_heap_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Store a minimal tuple into TTSOpsMinimalTuple type slot.
 *
 * If the target slot is not guaranteed to be TTSOpsMinimalTuple type slot,
 * use the, more expensive, ExecForceStoreMinimalTuple().
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreMinimalTuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mtup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_IS_MINIMALTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trying to store a minimal tuple into wrong type of slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>tts_minimal_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Store a HeapTuple into any kind of slot, performing conversion if
 * necessary.
 */</comment>
<function><type><name>void</name></type>
<name>ExecForceStoreHeapTuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
						<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TTS_IS_HEAPTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TTS_IS_BUFFERTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
						  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store a MinimalTuple into any kind of slot, performing conversion if
 * necessary.
 */</comment>
<function><type><name>void</name></type>
<name>ExecForceStoreMinimalTuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>,
						   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TTS_IS_MINIMALTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tts_minimal_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>htup</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>htup</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
						  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecStoreVirtualTuple
 *			Mark a slot as containing a virtual tuple.
 *
 * The protocol for loading a slot with virtual tuple data is:
 *		* Call ExecClearTuple to mark the slot empty.
 *		* Store data into the Datum/isnull arrays.
 *		* Call ExecStoreVirtualTuple to mark the slot valid.
 * This is a bit unclean but it avoids one round of data copying.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreVirtualTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TTS_FLAG_EMPTY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecStoreAllNullTuple
 *			Set up the slot to contain a null in every column.
 *
 * At first glance this might sound just like ExecClearTuple, but it's
 * entirely different: the slot ends up full, not empty.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreAllNullTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear any old contents */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill all the columns of the virtual tuple with nulls
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
		   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Store a HeapTuple in datum form, into a slot. That always requires
 * deforming it and storing it in virtual form.
 *
 * Until the slot is materialized, the contents of the slot depend on the
 * datum.
 */</comment>
<function><type><name>void</name></type>
<name>ExecStoreHeapTupleDatum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
					  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 * ExecFetchSlotHeapTuple - fetch HeapTuple representing the slot's content
 *
 * The returned HeapTuple represents the slot's content as closely as
 * possible.
 *
 * If materialize is true, the contents of the slots will be made independent
 * from the underlying storage (i.e. all buffer pins are released, memory is
 * allocated in the slot's context).
 *
 * If shouldFree is not-NULL it'll be set to true if the returned tuple has
 * been allocated in the calling memory context, and must be freed by the
 * caller (via explicit pfree() or a memory context reset).
 *
 * NB: If materialize is true, modifications of the returned tuple are
 * allowed. But it depends on the type of the slot whether such modifications
 * will also affect the slot's contents. While that is not the nicest
 * behaviour, all such modifications are in the process of being removed.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>ExecFetchSlotHeapTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>materialize</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Materialize the tuple so that the slot "owns" it, if requested. */</comment>
	<if_stmt><if>if <condition>(<expr><name>materialize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>materialize</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>get_heap_tuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>shouldFree</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>copy_heap_tuple</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>shouldFree</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>get_heap_tuple</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecFetchSlotMinimalTuple
 *			Fetch the slot's minimal physical tuple.
 *
 *		If the given tuple table slot can hold a minimal tuple, indicated by a
 *		non-NULL get_minimal_tuple callback, the function returns the minimal
 *		tuple returned by that callback. It assumes that the minimal tuple
 *		returned by the callback is "owned" by the slot i.e. the slot is
 *		responsible for freeing the memory consumed by the tuple. Hence it sets
 *		*shouldFree to false, indicating that the caller should not free the
 *		memory consumed by the minimal tuple. In this case the returned minimal
 *		tuple should be considered as read-only.
 *
 *		If that callback is not supported, it calls copy_minimal_tuple callback
 *		which is expected to return a copy of minimal tuple representing the
 *		contents of the slot. In this case *shouldFree is set to true,
 *		indicating the caller that it should free the memory consumed by the
 *		minimal tuple. In this case the returned minimal tuple may be written
 *		up.
 * --------------------------------
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>ExecFetchSlotMinimalTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>get_minimal_tuple</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>shouldFree</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>get_minimal_tuple</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>shouldFree</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>copy_minimal_tuple</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecFetchSlotHeapTupleDatum
 *			Fetch the slot's tuple as a composite-type Datum.
 *
 *		The result is always freshly palloc'd in the caller's memory context.
 * --------------------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>ExecFetchSlotHeapTupleDatum</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ret</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch slot's contents in regular-physical-tuple form */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>

	<comment type="block">/* Convert to Datum form */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>heap_copy_tuple_as_datum</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *				convenience initialization routines
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		ExecInitResultTypeTL
 *
 *		Initialize result type, using the plan node's targetlist.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecInitResultTypeTL</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleDesc</name></name> <operator>=</operator> <name>tupDesc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		ExecInit{Result,Scan,Extra}TupleSlot[TL]
 *
 *		These are convenience routines to initialize the specified slot
 *		in nodes inheriting the appropriate state.  ExecInitExtraTupleSlot
 *		is used for initializing special-purpose slots.
 * --------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		ExecInitResultTupleSlotTL
 *
 *		Initialize result tuple slot, using the tuple descriptor previously
 *		computed with ExecInitResultTypeTL().
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecInitResultSlot</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>,
							  <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleDesc</name></name></expr></argument>, <argument><expr><name>tts_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>resultopsfixed</name></name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleDesc</name></name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>resultops</name></name> <operator>=</operator> <name>tts_ops</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>resultopsset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		ExecInitResultTupleSlotTL
 *
 *		Initialize result tuple slot, using the plan node's targetlist.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecInitResultTupleSlotTL</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecInitResultTypeTL</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecInitResultSlot</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>tts_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		ExecInitScanTupleSlot
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecInitScanTupleSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>,
					  <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name></name> <operator>=</operator> <call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>,
													 <argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>tts_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>scandesc</name></name> <operator>=</operator> <name>tupledesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>scanopsfixed</name></name> <operator>=</operator> <name>tupledesc</name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>scanops</name></name> <operator>=</operator> <name>tts_ops</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>scanopsset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		ExecInitExtraTupleSlot
 *
 * Return a newly created slot. If tupledesc is non-NULL the slot will have
 * that as its fixed tupledesc. Otherwise the caller needs to use
 * ExecSetSlotDescriptor() to set the descriptor before use.
 * ----------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecInitExtraTupleSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					   <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>tts_ops</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		ExecInitNullTupleSlot
 *
 * Build a slot containing an all-nulls tuple of the given type.
 * This is used as a substitute for an input tuple when performing an
 * outer join.
 * ----------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecInitNullTupleSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupType</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tts_ops</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------------------------------
 *      Routines for setting/accessing attributes in a slot.
 * ---------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Fill in missing values for a TupleTableSlot.
 *
 * This is only exposed because it's needed for JIT compiled tuple
 * deforming. That exception aside, there should be no callers outside of this
 * file.
 */</comment>
<function><type><name>void</name></type>
<name>slot_getmissingattrs</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startAttNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lastAttNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>attrmiss</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrmiss</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no missing values array at all, so just fill everything in as NULL */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name> <operator>+</operator> <name>startAttNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>lastAttNum</name> <operator>-</operator> <name>startAttNum</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name> <operator>+</operator> <name>startAttNum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>lastAttNum</name> <operator>-</operator> <name>startAttNum</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>missattnum</name></decl>;</decl_stmt>

		<comment type="block">/* if there is a missing values array we must process them one by one */</comment>
		<for>for <control>(<init><expr><name>missattnum</name> <operator>=</operator> <name>startAttNum</name></expr>;</init>
			 <condition><expr><name>missattnum</name> <operator>&lt;</operator> <name>lastAttNum</name></expr>;</condition>
			 <incr><expr><name>missattnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>missattnum</name></expr>]</index></name> <operator>=</operator> <name><name>attrmiss</name><index>[<expr><name>missattnum</name></expr>]</index></name><operator>.</operator><name>am_value</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>missattnum</name></expr>]</index></name> <operator>=</operator> <operator>!</operator><name><name>attrmiss</name><index>[<expr><name>missattnum</name></expr>]</index></name><operator>.</operator><name>am_present</name></expr>;</expr_stmt>
		</block_content>}</block></for>

	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * slot_getsomeattrs_int - workhorse for slot_getsomeattrs()
 */</comment>
<function><type><name>void</name></type>
<name>slot_getsomeattrs_int</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check for caller errors */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>&lt;</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* checked in slot_getsomeattrs */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute number %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch as many attributes as possible from the underlying tuple. */</comment>
	<expr_stmt><expr><call><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name><operator>-&gt;</operator><name>getsomeattrs</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the underlying tuple doesn't have enough attributes, tuple
	 * descriptor must have the missing attributes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>&lt;</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>slot_getmissingattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecTypeFromTL
 *
 *		Generate a tuple descriptor for the result tuple of a targetlist.
 *		(A parse/plan tlist must be passed, not an ExprState tlist.)
 *		Note that resjunk columns, if any, are included in the result.
 *
 *		Currently there are about 4 different places where we create
 *		TupleDescriptors.  They should all be merged, or perhaps
 *		be rewritten to call BuildDesc().
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ExecTypeFromTL</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExecTypeFromTLInternal</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecCleanTypeFromTL
 *
 *		Same as above, but resjunk columns are omitted from the result.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ExecCleanTypeFromTL</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExecTypeFromTLInternal</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>ExecTypeFromTLInternal</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipjunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>typeInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cur_resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>skipjunk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ExecCleanTargetListLength</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ExecTargetListLength</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>typeInfo</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>skipjunk</name> <operator>&amp;&amp;</operator> <name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
						   <argument><expr><name>cur_resno</name></expr></argument>,
						   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
						   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
									<argument><expr><name>cur_resno</name></expr></argument>,
									<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_resno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>typeInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecTypeFromExprList - build a tuple descriptor from a list of Exprs
 *
 * This is roughly like ExecTypeFromTL, but we work from bare expressions
 * not TargetEntrys.  No names are attached to the tupledesc's columns.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ExecTypeFromExprList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>typeInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cur_resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>typeInfo</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
						   <argument><expr><name>cur_resno</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
									<argument><expr><name>cur_resno</name></expr></argument>,
									<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_resno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>typeInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecTypeSetColNames - set column names in a TupleDesc
 *
 * Column names must be provided as an alias list (list of String nodes).
 *
 * For some callers, the supplied tupdesc has a named rowtype (not RECORD)
 * and it is moderately likely that the alias list matches the column names
 * already present in the tupdesc.  If we do change any column names then
 * we must reset the tupdesc's type to anonymous RECORD; but we avoid doing
 * so if no names change.
 */</comment>
<function><type><name>void</name></type>
<name>ExecTypeSetColNames</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>typeInfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namesList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>modified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>namesList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

		<comment type="block">/* Guard against too-long names list */</comment>
		<if_stmt><if>if <condition>(<expr><name>colno</name> <operator>&gt;=</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colno</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Ignore empty aliases (these must be for dropped columns) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Change tupdesc only if alias is actually different */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* If we modified the tupdesc, it's now a new record type */</comment>
	<if_stmt><if>if <condition>(<expr><name>modified</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BlessTupleDesc - make a completed tuple descriptor useful for SRFs
 *
 * Rowtype Datums returned by a function must contain valid type information.
 * This happens "for free" if the tupdesc came from a relcache entry, but
 * not if we have manufactured a tupdesc for a transient RECORD datatype.
 * In that case we have to notify typcache.c of the existence of the type.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>BlessTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
		<name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>assign_record_type_typmod</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tupdesc</name></expr>;</return>				<comment type="block">/* just for notational convenience */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * TupleDescGetAttInMetadata - Build an AttInMetadata structure based on the
 * supplied TupleDesc. AttInMetadata can be used in conjunction with C strings
 * to produce a properly formed tuple.
 */</comment>
<function><type><name>AttInMetadata</name> <modifier>*</modifier></type>
<name>TupleDescGetAttInMetadata</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>atttypeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>attinfuncid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>attinfuncinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>attioparams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>atttypmods</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <operator>(</operator><name>AttInMetadata</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttInMetadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* "Bless" the tupledesc so that we can make rowtype datums with it */</comment>
	<expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Gather info needed later to call the "in" function for each attribute
	 */</comment>
	<expr_stmt><expr><name>attinfuncinfo</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attioparams</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>atttypmods</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped attributes */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>atttypeid</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>atttypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attinfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>attinfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attinfuncinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>atttypmods</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attinfuncs</name></name> <operator>=</operator> <name>attinfuncinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attioparams</name></name> <operator>=</operator> <name>attioparams</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>atttypmods</name></name> <operator>=</operator> <name>atttypmods</name></expr>;</expr_stmt>

	<return>return <expr><name>attinmeta</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BuildTupleFromCStrings - build a HeapTuple given user data in C string form.
 * values is an array of C strings, one for each attribute of the return tuple.
 * A NULL string pointer indicates we want to create a NULL field.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>BuildTupleFromCStrings</name><parameter_list>(<parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>attinmeta</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call the "in" function for each non-dropped attribute, even for nulls,
	 * to support domains.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Non-dropped attributes */</comment>
			<expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attinmeta</name><operator>-&gt;</operator><name>attinfuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>atttypmods</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Handle dropped attributes by setting to NULL */</comment>
			<expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Form a tuple
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release locally palloc'd space.  XXX would probably be good to pfree
	 * values of pass-by-reference datums, as well.
	 */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * HeapTupleHeaderGetDatum - convert a HeapTupleHeader pointer to a Datum.
 *
 * This must *not* get applied to an on-disk tuple; the tuple should be
 * freshly made by heap_form_tuple or some wrapper routine for it (such as
 * BuildTupleFromCStrings).  Be sure also that the tupledesc used to build
 * the tuple has a properly "blessed" rowtype.
 *
 * Formerly this was a macro equivalent to PointerGetDatum, relying on the
 * fact that heap_form_tuple fills in the appropriate tuple header fields
 * for a composite Datum.  However, we now require that composite Datums not
 * contain any external TOAST pointers.  We do not want heap_form_tuple itself
 * to enforce that; more specifically, the rule applies only to actual Datums
 * and not to HeapTuple structures.  Therefore, HeapTupleHeaderGetDatum is
 * now a function that detects whether there are externally-toasted fields
 * and constructs a new tuple with inlined fields if so.  We still need
 * heap_form_tuple to insert the Datum header fields, because otherwise this
 * code would have no way to obtain a tupledesc for the tuple.
 *
 * Note that if we do build a new tuple, it's palloc'd in the current
 * memory context.  Beware of code that changes context between the initial
 * heap_form_tuple/etc call and calling HeapTuple(Header)GetDatum.
 *
 * For performance-critical callers, it could be worthwhile to take extra
 * steps to ensure that there aren't TOAST pointers in the output of
 * heap_form_tuple to begin with.  It's likely however that the costs of the
 * typcache lookup and tuple disassembly/reassembly are swamped by TOAST
 * dereference costs, so that the benefits of such extra effort would be
 * minimal.
 *
 * XXX it would likely be better to create wrapper functions that produce
 * a composite Datum from the field values in one step.  However, there's
 * enough code using the existing APIs that we couldn't get rid of this
 * hack anytime soon.
 */</comment>
<function><type><name>Datum</name></type>
<name>HeapTupleHeaderGetDatum</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<comment type="block">/* No work if there are no external TOAST pointers in the tuple */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderHasExternal</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Use the type data saved by heap_form_tuple to look up the rowtype */</comment>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And do the flattening */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>toast_flatten_tuple_to_datum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
										  <argument><expr><call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Functions for sending tuples to the frontend (or other specified destination)
 * as though it is a SELECT result. These are used by utility commands that
 * need to project directly to the destination and don't need or want full
 * table function capability. Currently used by EXPLAIN and SHOW ALL.
 */</comment>
<function><type><name>TupOutputState</name> <modifier>*</modifier></type>
<name>begin_tup_output_tupdesc</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
						 <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <operator>(</operator><name>TupOutputState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupOutputState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tstate</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tts_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>tstate</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name><argument_list>(<argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>CMD_SELECT</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write a single tuple
 */</comment>
<function><type><name>void</name></type>
<name>do_tup_output</name><parameter_list>(<parameter><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>tstate</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* make sure the slot is clear */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* insert data */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mark slot as containing a virtual tuple */</comment>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* send the tuple to the receiver */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name><name>tstate</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * write a chunk of text, breaking at newline characters
 *
 * Should only be used with a single-TEXT-attribute tupdesc.
 */</comment>
<function><type><name>void</name></type>
<name>do_text_output_multiline</name><parameter_list>(<parameter><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>txt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>txt</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>eol</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name>eol</name> <operator>-</operator> <name>txt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>eol</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>eol</name> <operator>=</operator> <name>txt</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>txt</name> <operator>=</operator> <name>eol</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>end_tup_output</name><parameter_list>(<parameter><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><name>tstate</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name><argument_list>(<argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* note that destroying the dest is not ours to do */</comment>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
