<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/execAmi.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execAmi.c
 *	  miscellaneous executor access method routines
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *	src/backend/executor/execAmi.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapAnd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeDynamicBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeDynamicBitmapIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapOr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCtescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCustom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeForeignscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeFunctionscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGather.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGatherMerge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexonlyscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLimit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLockRows.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMaterial.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergejoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNamedtuplestorescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNestloop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeProjectSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeRecursiveunion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeResult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSamplescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSeqscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSetOp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubqueryscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTableFuncscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTidscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTupleSplit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeUnique.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeValuesscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWindowAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWorktablescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAssertOp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeDynamicSeqscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeDynamicIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMotion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTableFunction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodePartitionSelector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeShareInputScan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TargetListSupportsBackwardScan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IndexSupportsBackwardScan</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ExecReScan
 *		Reset a plan node so that its output can be re-scanned.
 *
 * Note that if the plan node has parameters that have changed value,
 * the output might be different from last time.
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If collecting timing stats, update them */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* no longer squelched */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>squelched</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have changed parameters, propagate that info.
	 *
	 * Note: ExecReScanSetParamPlan() can add bits to node-&gt;chgParam,
	 * corresponding to the output param(s) that the InitPlan will update.
	 * Since we make only one pass over the list, that means that an InitPlan
	 * can depend on the output param(s) of a sibling InitPlan only if that
	 * sibling appears earlier in the list.  This is workable for now given
	 * the limited ways in which one InitPlan could depend on another, but
	 * eventually we might need to work harder (or else make the planner
	 * enlarge the extParam/allParam sets to include the params of depended-on
	 * InitPlans).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;initPlan</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>splan</name> <init>= <expr><name><name>sstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If 'splan' is NULL, then InitPlan() thought it was "alien".  We
			 * should not get here then, but let's sanity check.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>splan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subplan not initialized in this slice"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* don't care about child
												 * local Params */</comment>
				<expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name>splan</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecReScanSetParamPlan</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;subPlan</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>splan</name> <init>= <expr><name><name>sstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If 'splan' is NULL, then InitPlan() thought it was "alien".  We
			 * should not get here then, but let's sanity check.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>splan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subplan not initialized in this slice"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name>splan</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<comment type="block">/* Well. Now set chgParam for left/right trees. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>righttree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Call expression callbacks */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And do node-type-specific processing */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_ResultState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanResult</name><argument_list>(<argument><expr><operator>(</operator><name>ResultState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ProjectSetState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanProjectSet</name><argument_list>(<argument><expr><operator>(</operator><name>ProjectSetState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTableState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanModifyTable</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanAppend</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppendState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanMergeAppend</name><argument_list>(<argument><expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RecursiveUnionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanRecursiveUnion</name><argument_list>(<argument><expr><operator>(</operator><name>RecursiveUnionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AssertOpState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanAssertOp</name><argument_list>(<argument><expr><operator>(</operator><name>AssertOpState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAndState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOrState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SampleScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanSampleScan</name><argument_list>(<argument><expr><operator>(</operator><name>SampleScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GatherState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanGather</name><argument_list>(<argument><expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GatherMergeState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicSeqScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanDynamicSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicSeqScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicIndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanDynamicIndex</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			
		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanIndexOnlyScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicBitmapIndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanDynamicBitmapIndex</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicBitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DynamicBitmapHeapScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanDynamicBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>DynamicBitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TidScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanTidScan</name><argument_list>(<argument><expr><operator>(</operator><name>TidScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanSubqueryScan</name><argument_list>(<argument><expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SequenceState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanSequence</name><argument_list>(<argument><expr><operator>(</operator><name>SequenceState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanFunctionScan</name><argument_list>(<argument><expr><operator>(</operator><name>FunctionScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFunctionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanTableFunction</name><argument_list>(<argument><expr><operator>(</operator><name>TableFunctionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanTableFuncScan</name><argument_list>(<argument><expr><operator>(</operator><name>TableFuncScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanValuesScan</name><argument_list>(<argument><expr><operator>(</operator><name>ValuesScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CteScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanCteScan</name><argument_list>(<argument><expr><operator>(</operator><name>CteScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedTuplestoreScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanNamedTuplestoreScan</name><argument_list>(<argument><expr><operator>(</operator><name>NamedTuplestoreScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WorkTableScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanWorkTableScan</name><argument_list>(<argument><expr><operator>(</operator><name>WorkTableScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NestLoopState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanNestLoop</name><argument_list>(<argument><expr><operator>(</operator><name>NestLoopState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeJoinState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanMergeJoin</name><argument_list>(<argument><expr><operator>(</operator><name>MergeJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MaterialState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanMaterial</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SortState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanSort</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AggState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanAgg</name><argument_list>(<argument><expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TupleSplit</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanTupleSplit</name><argument_list>(<argument><expr><operator>(</operator><name>TupleSplitState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WindowAggState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanWindowAgg</name><argument_list>(<argument><expr><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UniqueState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanUnique</name><argument_list>(<argument><expr><operator>(</operator><name>UniqueState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SetOpState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanSetOp</name><argument_list>(<argument><expr><operator>(</operator><name>SetOpState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockRowsState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanLockRows</name><argument_list>(<argument><expr><operator>(</operator><name>LockRowsState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LimitState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanLimit</name><argument_list>(<argument><expr><operator>(</operator><name>LimitState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MotionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanMotion</name><argument_list>(<argument><expr><operator>(</operator><name>MotionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanTableFunction</name><argument_list>(<argument><expr><operator>(</operator><name>TableFunctionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ShareInputScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanShareInputScan</name><argument_list>(<argument><expr><operator>(</operator><name>ShareInputScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_PartitionSelectorState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecReScanPartitionSelector</name><argument_list>(<argument><expr><operator>(</operator><name>PartitionSelectorState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecMarkPos
 *
 * Marks the current scan position.
 *
 * NOTE: mark/restore capability is currently needed only for plan nodes
 * that are the immediate inner child of a MergeJoin node.  Since MergeJoin
 * requires sorted input, there is never any need to support mark/restore in
 * node types that cannot produce sorted output.  There are some cases in
 * which a node can pass through sorted data from its child; if we don't
 * implement mark/restore for such a node type, the planner compensates by
 * inserting a Material node above that node.
 */</comment>
<function><type><name>void</name></type>
<name>ExecMarkPos</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecIndexMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecIndexOnlyMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecCustomMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MaterialState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecMaterialMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SortState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSortMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ResultState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecResultMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>ResultState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MotionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator>
				<call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported call to mark position of Motion operator"</literal></expr></argument>)</argument_list></call>
				<operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Marking scan position for foreign relation is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* don't make hard error unless caller asks to restore... */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ExecRestrPos
 *
 * restores the scan position previously saved with ExecMarkPos()
 *
 * NOTE: the semantics of this are that the first ExecProcNode following
 * the restore operation will yield the same tuple as the first one following
 * the mark operation.  It is unspecified what happens to the plan node's
 * result TupleTableSlot.  (In most cases the result slot is unchanged by
 * a restore, but the node may choose to clear it or to load it with the
 * restored-to tuple.)	Hence the caller should discard any previously
 * returned TupleTableSlot after doing a restore.
 */</comment>
<function><type><name>void</name></type>
<name>ExecRestrPos</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecIndexRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecIndexOnlyRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecCustomRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MaterialState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecMaterialRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SortState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSortRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ResultState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecResultRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>ResultState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MotionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator>
				<call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported call to restore position of Motion operator"</literal></expr></argument>)</argument_list></call>
				<operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Restoring scan position is not yet supported for foreign relation scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSupportsMarkRestore - does a Path support mark/restore?
 *
 * This is used during planning and so must accept a Path, not a Plan.
 * We keep it here to be adjacent to the routines above, which also must
 * know which plan types support mark/restore.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecSupportsMarkRestore</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For consistency with the routines above, we do not examine the nodeTag
	 * but rather the pathtype, which is the Plan node type the Path would
	 * produce.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>customPath</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomPath</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>customPath</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CUSTOMPATH_SUPPORT_MARK_RESTORE</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_Result</name></expr>:</case>

			<comment type="block">/*
			 * Result supports mark/restore iff it has a child plan that does.
			 *
			 * We have to be careful here because there is more than one Path
			 * type that can produce a Result plan node.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>ExecSupportsMarkRestore</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ProjectionPath</name> <operator>*</operator><operator>)</operator> <name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MinMaxAggPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>	<comment type="block">/* childless Result */</comment>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>GroupResultPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>	<comment type="block">/* childless Result */</comment>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Simple RTE_RESULT base relation */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* childless Result */</comment>
			</block_content>}</block></else></if_stmt>

		<case>case <expr><name>T_Append</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>appendPath</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AppendPath</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If there's exactly one child, then there will be no Append
				 * in the final plan, so we can handle mark/restore if the
				 * child plan node can.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>appendPath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>ExecSupportsMarkRestore</name><argument_list>(<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>appendPath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* Otherwise, Append can't handle it */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>mapath</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Like the Append case above, single-subpath MergeAppends
				 * won't be in the final plan, so just return the child's
				 * mark/restore ability.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mapath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>ExecSupportsMarkRestore</name><argument_list>(<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>mapath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* Otherwise, MergeAppend can't handle it */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSupportsBackwardScan - does a plan type support backwards scanning?
 *
 * Ideally, all plan types would support backwards scan, but that seems
 * unlikely to happen soon.  In some cases, a plan node passes the backwards
 * scan down to its children, and so supports backwards scan only if its
 * children do.  Therefore, this routine must be passed a complete plan tree.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecSupportsBackwardScan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Parallel-aware nodes return a subset of the tuples in each worker, and
	 * in general we can't expect to have enough bookkeeping state to know
	 * which ones we returned in this worker as opposed to some other worker.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

		<case>case <expr><name>T_Append</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((Append *) node)-&gt;appendplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
				<comment type="block">/* need not check tlist because Append doesn't evaluate it */</comment>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<return>return <expr><call><name>TargetListSupportsBackwardScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<comment type="block">/* Simplify life for tablesample methods by disallowing this */</comment>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>T_Gather</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<return>return <expr><call><name>IndexSupportsBackwardScan</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>indexid</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<return>return <expr><call><name>IndexSupportsBackwardScan</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>indexid</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<return>return <expr><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>flags</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>flags</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_LockRows</name></expr>:</case>
		<case>case <expr><name>T_Limit</name></expr>:</case>
			<return>return <expr><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSquelchNode
 *
 * When a node decides that it will not consume any more input tuples from a
 * subtree that has not yet returned end-of-data, it must call
 * ExecSquelchNode() on the subtree.
 *
 * This is necessary, to avoid deadlock with Motion nodes. There might be a
 * receiving Motion node in the subtree, and it needs to let the sender side
 * of the Motion know that we will not be reading any more tuples. We might
 * have sibling QE processes in other segments that are still waiting for
 * tuples from the sender Motion, but if the sender's send queue is full, it
 * will never send them. By explicitly telling the sender that we will not be
 * reading any more tuples, it knows to not wait for us, and can skip over,
 * and send tuples to the other QEs that might be waiting.
 *
 * This also gives memory-hungry nodes a chance to release memory earlier, so
 * that other nodes higher up in the plan can make use of it. The Squelch
 * function for many node call a separate node-specific ExecEagerFree*()
 * function to do that.
 *
 * After a node has been squelched, you mustn't try to read more tuples from
 * it. However, ReScanning the node will "un-squelch" it, allowing to read
 * again. Squelching a node is roughly equivalent to fetching and discarding
 * all tuples from it.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSquelchNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>squelched</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_MotionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchMotion</name><argument_list>(<argument><expr><operator>(</operator><name>MotionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTableState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchModifyTable</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

			<comment type="block">/*
			 * Node types that need custom code to recurse.
			 */</comment>
		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchAppend</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppendState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchMergeAppend</name><argument_list>(<argument><expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SequenceState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchSequence</name><argument_list>(<argument><expr><operator>(</operator><name>SequenceState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchSubqueryScan</name><argument_list>(<argument><expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Node types that need no special handling, just recurse to
			 * children.
			 */</comment>
		<case>case <expr><name>T_AssertOpState</name></expr>:</case>
		<case>case <expr><name>T_BitmapAndState</name></expr>:</case>
		<case>case <expr><name>T_BitmapOrState</name></expr>:</case>
		<case>case <expr><name>T_DynamicBitmapHeapScanState</name></expr>:</case>
		<case>case <expr><name>T_LimitState</name></expr>:</case>
		<case>case <expr><name>T_LockRowsState</name></expr>:</case>
		<case>case <expr><name>T_NestLoopState</name></expr>:</case>
		<case>case <expr><name>T_MergeJoinState</name></expr>:</case>
		<case>case <expr><name>T_SetOpState</name></expr>:</case>
		<case>case <expr><name>T_UniqueState</name></expr>:</case>
		<case>case <expr><name>T_HashState</name></expr>:</case>
		<case>case <expr><name>T_PartitionSelectorState</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScanState</name></expr>:</case>
		<case>case <expr><name>T_ResultState</name></expr>:</case>
		<case>case <expr><name>T_ProjectSetState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * These node types have nothing to do, and have no children.
			 */</comment>
		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
		<case>case <expr><name>T_DynamicSeqScanState</name></expr>:</case>
		<case>case <expr><name>T_DynamicIndexScanState</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
		<case>case <expr><name>T_DynamicBitmapIndexScanState</name></expr>:</case>
		<case>case <expr><name>T_BitmapIndexScanState</name></expr>:</case>
		<case>case <expr><name>T_TableFuncScanState</name></expr>:</case>
		<case>case <expr><name>T_ValuesScanState</name></expr>:</case>
		<case>case <expr><name>T_TidScanState</name></expr>:</case>
		<case>case <expr><name>T_TableFunctionState</name></expr>:</case>
		<case>case <expr><name>T_SampleScanState</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/*
			 * Node types that consume resources that we want to free eagerly,
			 * as soon as possible.
			 */</comment>
		<case>case <expr><name>T_RecursiveUnionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchRecursiveUnion</name><argument_list>(<argument><expr><operator>(</operator><name>RecursiveUnionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<comment type="block">/*
			 * For ForeignScans, PostgreSQL's shutdown function does exactly
			 * what we want.
			 */</comment>
			<expr_stmt><expr><call><name>ExecShutdownForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchFunctionScan</name><argument_list>(<argument><expr><operator>(</operator><name>FunctionScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MaterialState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchMaterial</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name><operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SortState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchSort</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AggState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchAgg</name><argument_list>(<argument><expr><operator>(</operator><name>AggState</name><operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TupleSplitState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchTupleSplit</name><argument_list>(<argument><expr><operator>(</operator><name>TupleSplitState</name><operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WindowAggState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchWindowAgg</name><argument_list>(<argument><expr><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ShareInputScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSquelchShareInputScan</name><argument_list>(<argument><expr><operator>(</operator><name>ShareInputScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Also recurse into subplans, if any. (InitPlans are handled as a separate step,
	 * at executor startup, and don't need squelching.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;subPlan</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ips</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ips</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subplan has no planstate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><name>ips</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>squelched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If the tlist contains set-returning functions, we can't support backward
 * scan, because the TupFromTlist code is direction-ignorant.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TargetListSupportsBackwardScan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * An IndexScan or IndexOnlyScan node supports backward scan only if the
 * index's AM does.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IndexSupportsBackwardScan</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_idxrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>idxrelrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch the pg_class tuple of the index relation */</comment>
	<expr_stmt><expr><name>ht_idxrel</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>idxrelrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch the index AM's API struct */</comment>
	<expr_stmt><expr><name>amroutine</name> <operator>=</operator> <call><name>GetIndexAmRoutineByAmId</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanbackward</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>amroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecMaterializesOutput - does a plan type materialize its output?
 *
 * Returns true if the plan node type is one that automatically materializes
 * its output (typically by keeping it in a tuplestore).  For such plans,
 * a rescan without any parameter change will have zero startup cost and
 * very low per-tuple cost.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecMaterializesOutput</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>plantype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>plantype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
