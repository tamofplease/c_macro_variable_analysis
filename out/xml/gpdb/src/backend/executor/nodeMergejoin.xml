<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/nodeMergejoin.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeMergejoin.c
 *	  routines supporting merge joins
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeMergejoin.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *		ExecMergeJoin			mergejoin outer and inner relations.
 *		ExecInitMergeJoin		creates and initializes run time states
 *		ExecEndMergeJoin		cleans up the node.
 *
 * NOTES
 *
 *		Merge-join is done by joining the inner and outer tuples satisfying
 *		join clauses of the form ((= outerKey innerKey) ...).
 *		The join clause list is provided by the query planner and may contain
 *		more than one (= outerKey innerKey) clause (for composite sort key).
 *
 *		However, the query executor needs to know whether an outer
 *		tuple is "greater/smaller" than an inner tuple so that it can
 *		"synchronize" the two relations. For example, consider the following
 *		relations:
 *
 *				outer: (0 ^1 1 2 5 5 5 6 6 7)	current tuple: 1
 *				inner: (1 ^3 5 5 5 5 6)			current tuple: 3
 *
 *		To continue the merge-join, the executor needs to scan both inner
 *		and outer relations till the matching tuples 5. It needs to know
 *		that currently inner tuple 3 is "greater" than outer tuple 1 and
 *		therefore it should scan the outer relation first to find a
 *		matching tuple and so on.
 *
 *		Therefore, rather than directly executing the merge join clauses,
 *		we evaluate the left and right key expressions separately and then
 *		compare the columns one at a time (see MJCompare).  The planner
 *		passes us enough information about the sort ordering of the inputs
 *		to allow us to determine how to make the comparison.  We may use the
 *		appropriate btree comparison function, since Postgres' only notion
 *		of ordering is specified by btree opfamilies.
 *
 *
 *		Consider the above relations and suppose that the executor has
 *		just joined the first outer "5" with the last inner "5". The
 *		next step is of course to join the second outer "5" with all
 *		the inner "5's". This requires repositioning the inner "cursor"
 *		to point at the first inner "5". This is done by "marking" the
 *		first inner 5 so we can restore the "cursor" to it before joining
 *		with the second outer 5. The access method interface provides
 *		routines to mark and restore to a tuple.
 *
 *
 *		Essential operation of the merge join algorithm is as follows:
 *
 *		Join {
 *			get initial outer and inner tuples				INITIALIZE
 *			do forever {
 *				while (outer != inner) {					SKIP_TEST
 *					if (outer &lt; inner)
 *						advance outer						SKIPOUTER_ADVANCE
 *					else
 *						advance inner						SKIPINNER_ADVANCE
 *				}
 *				mark inner position							SKIP_TEST
 *				do forever {
 *					while (outer == inner) {
 *						join tuples							JOINTUPLES
 *						advance inner position				NEXTINNER
 *					}
 *					advance outer position					NEXTOUTER
 *					if (outer == mark)						TESTOUTER
 *						restore inner position to mark		TESTOUTER
 *					else
 *						break	// return to top of outer loop
 *				}
 *			}
 *		}
 *
 *		The merge join operation is coded in the fashion
 *		of a state machine.  At each state, we do something and then
 *		proceed to another state.  This state is stored in the node's
 *		execution state information and is preserved across calls to
 *		ExecMergeJoin. -cim 10/31/89
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergejoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * States of the ExecMergeJoin state machine
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_INITIALIZE_OUTER</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_INITIALIZE_INNER</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_JOINTUPLES</name></cpp:macro>				<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_NEXTOUTER</name></cpp:macro>				<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_TESTOUTER</name></cpp:macro>				<cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_NEXTINNER</name></cpp:macro>				<cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_SKIP_TEST</name></cpp:macro>				<cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_SKIPOUTER_ADVANCE</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_SKIPINNER_ADVANCE</name></cpp:macro>		<cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_ENDOUTER</name></cpp:macro>				<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_MJ_ENDINNER</name></cpp:macro>				<cpp:value>11</cpp:value></cpp:define>

<comment type="block">/*
 * Runtime data for each mergejoin clause
 */</comment>
<typedef>typedef <type><struct>struct <name>MergeJoinClauseData</name>
<block>{
	<comment type="block">/* Executable expression trees */</comment>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>lexpr</name></decl>;</decl_stmt>			<comment type="block">/* left-hand (outer) input expression */</comment>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>rexpr</name></decl>;</decl_stmt>			<comment type="block">/* right-hand (inner) input expression */</comment>

	<comment type="block">/*
	 * If we have a current left or right input tuple, the values of the
	 * expressions are loaded into these fields:
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ldatum</name></decl>;</decl_stmt>			<comment type="block">/* current left-hand value */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>rdatum</name></decl>;</decl_stmt>			<comment type="block">/* current right-hand value */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lisnull</name></decl>;</decl_stmt>		<comment type="block">/* and their isnull flags */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>risnull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * CDB: Remember whether the mergejoin operation was actually an "is
	 *      not distinct from" predicate.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>notdistinct</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Everything we need to know to compare the left and right values is
	 * stored here.
	 */</comment>
	<decl_stmt><decl><type><name>SortSupportData</name></type> <name>ssup</name></decl>;</decl_stmt>
}</block></struct></type>			<name>MergeJoinClauseData</name>;</typedef>

<comment type="block">/* Result type for MJEvalOuterValues and MJEvalInnerValues */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>MJEVAL_MATCHABLE</name></decl>,			<comment type="block">/* normal, potentially matchable tuple */</comment>
	<decl><name>MJEVAL_NONMATCHABLE</name></decl>,		<comment type="block">/* tuple cannot join because it has a null */</comment>
	<decl><name>MJEVAL_ENDOFJOIN</name></decl>			<comment type="block">/* end of input (physical or effective) */</comment>
}</block></enum></type> <name>MJEvalResult</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MarkInnerTuple</name><parameter_list>(<parameter><type><name>innerTupleSlot</name></type></parameter>, <parameter><type><name>mergestate</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>ExecCopySlot((mergestate)-&gt;mj_MarkedTupleSlot, (innerTupleSlot))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>Test_print_prefetch_joinqual</name></decl>;</decl_stmt>

<comment type="block">/*
 * MJExamineQuals
 *
 * This deconstructs the list of mergejoinable expressions, which is given
 * to us by the planner in the form of a list of "leftexpr = rightexpr"
 * expression trees in the order matching the sort columns of the inputs.
 * We build an array of MergeJoinClause structs containing the information
 * we will need at runtime.  Each struct essentially tells us how to compare
 * the two expressions from the original clause.
 *
 * In addition to the expressions themselves, the planner passes the btree
 * opfamily OID, collation OID, btree strategy number (BTLessStrategyNumber or
 * BTGreaterStrategyNumber), and nulls-first flag that identify the intended
 * sort ordering for each merge key.  The mergejoinable operator is an
 * equality operator in the opfamily, and the two inputs are guaranteed to be
 * ordered in either increasing or decreasing (respectively) order according
 * to the opfamily and collation, with nulls at the indicated end of the range.
 * This allows us to obtain the needed comparison function from the opfamily.
 *
 * CDB: We also recognize the "is not distinct from" predicate which is
 *      interesting for sequential window plans.  The pseudo-Lisp for this
 *      predicate is (BoolExpr_NOT (DistinctExpr_= leftexpr rightexpr)).
 */</comment>
<function><type><specifier>static</specifier> <name>MergeJoinClause</name></type>
<name>MJExamineQuals</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergefamilies</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergecollations</name></decl></parameter>,
			   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mergestrategies</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>mergenullsfirst</name></decl></parameter>,
			   <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergeJoinClause</name></type> <name>clauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nClauses</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>clauses</name> <operator>=</operator> <operator>(</operator><name>MergeJoinClause</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MergeJoinClauseData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>iClause</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cl</argument>, <argument>mergeclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MergeJoinClause</name></type> <name>clause</name> <init>= <expr><operator>&amp;</operator><name><name>clauses</name><index>[<expr><name>iClause</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><name><name>mergefamilies</name><index>[<expr><name>iClause</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><name><name>mergecollations</name><index>[<expr><name>iClause</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name> <init>= <expr><name><name>mergestrategies</name><index>[<expr><name>iClause</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>nulls_first</name> <init>= <expr><name><name>mergenullsfirst</name><index>[<expr><name>iClause</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>op_strategy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>op_lefttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>op_righttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>sortfunc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>bx</name> <init>= <expr><operator>(</operator><name>BoolExpr</name><operator>*</operator><operator>)</operator><name>qual</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			
			<if_stmt><if>if <condition>( <expr><call><name>IsA</name><argument_list>(<argument><expr><name>bx</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>bx</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>NOT_EXPR</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>bx</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr> )</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>dx</name> <init>= <expr><operator>(</operator><name>DistinctExpr</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>bx</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				
				<if_stmt><if>if <condition>( <expr><call><name>IsA</name><argument_list>(<argument><expr><name>dx</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr> )</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>notdistinct</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>dx</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mergejoin clause is not an OpExpr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Prepare the input expressions for execution.
		 */</comment>
		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>lexpr</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>qual</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>rexpr</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>qual</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up sort support data */</comment>
		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>ssup_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>ssup_collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opstrategy</name> <operator>==</operator> <name>BTLessStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>ssup_reverse</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>opstrategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>ssup_reverse</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>					<comment type="block">/* planner screwed up */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported mergejoin strategy %d"</literal></expr></argument>, <argument><expr><name>opstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <name>nulls_first</name></expr>;</expr_stmt>

		<comment type="block">/* Extract the operator's declared left/right datatypes */</comment>
		<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name><name>qual</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>op_strategy</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>op_lefttype</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>op_strategy</name> <operator>!=</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot merge using non-equality operator %u"</literal></expr></argument>,
				 <argument><expr><name><name>qual</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * sortsupport routine must know if abbreviation optimization is
		 * applicable in principle.  It is never applicable for merge joins
		 * because there is no convenient opportunity to convert to
		 * alternative representation.
		 */</comment>
		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>abbreviate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* And get the matching support or comparison function */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>comparator</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortfunc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
									 <argument><expr><name>op_lefttype</name></expr></argument>,
									 <argument><expr><name>op_righttype</name></expr></argument>,
									 <argument><expr><name>BTSORTSUPPORT_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortfunc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The sort support function can provide a comparator */</comment>
			<expr_stmt><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>sortfunc</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>clause</name><operator>-&gt;</operator><name>ssup</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>comparator</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* support not available, get comparison func */</comment>
			<expr_stmt><expr><name>sortfunc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
										 <argument><expr><name>op_lefttype</name></expr></argument>,
										 <argument><expr><name>op_righttype</name></expr></argument>,
										 <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortfunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) in opfamily %u"</literal></expr></argument>,
					 <argument><expr><name>BTORDER_PROC</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* We'll use a shim to call the old-style btree comparator */</comment>
			<expr_stmt><expr><call><name>PrepareSortSupportComparisonShim</name><argument_list>(<argument><expr><name>sortfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>clause</name><operator>-&gt;</operator><name>ssup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>iClause</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>clauses</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MJEvalOuterValues
 *
 * Compute the values of the mergejoined expressions for the current
 * outer tuple.  We also detect whether it's impossible for the current
 * outer tuple to match anything --- this is true if it yields a NULL
 * input, since we assume mergejoin operators are strict.  If the NULL
 * is in the first join column, and that column sorts nulls last, then
 * we can further conclude that no following tuple can match anything
 * either, since they must all have nulls in the first column.  However,
 * that case is only interesting if we're not in FillOuter mode, else
 * we have to visit all the tuples anyway.
 *
 * For the convenience of callers, we also make this routine responsible
 * for testing for end-of-input (null outer tuple), and returning
 * MJEVAL_ENDOFJOIN when that's seen.  This allows the same code to be used
 * for both real end-of-input and the effective end-of-input represented by
 * a first-column NULL.
 *
 * We evaluate the values in OuterEContext, which can be reset each
 * time we move to a new tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>MJEvalResult</name></type>
<name>MJEvalOuterValues</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>mergestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_OuterEContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MJEvalResult</name></type> <name>result</name> <init>= <expr><name>MJEVAL_MATCHABLE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/* Check for end of outer subplan */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MJEVAL_ENDOFJOIN</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name><name>mergestate</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mergestate</name><operator>-&gt;</operator><name>mj_NumClauses</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MergeJoinClause</name></type> <name>clause</name> <init>= <expr><operator>&amp;</operator><name><name>mergestate</name><operator>-&gt;</operator><name>mj_Clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>ldatum</name></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>clause</name><operator>-&gt;</operator><name>lisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>lisnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>notdistinct</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* match is impossible; can we end the join early? */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>ssup_nulls_first</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillOuter</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>MJEVAL_ENDOFJOIN</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>result</name> <operator>==</operator> <name>MJEVAL_MATCHABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>MJEVAL_NONMATCHABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MJEvalInnerValues
 *
 * Same as above, but for the inner tuple.  Here, we have to be prepared
 * to load data from either the true current inner, or the marked inner,
 * so caller must tell us which slot to load from.
 */</comment>
<function><type><specifier>static</specifier> <name>MJEvalResult</name></type>
<name>MJEvalInnerValues</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>mergestate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>innerslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_InnerEContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MJEvalResult</name></type> <name>result</name> <init>= <expr><name>MJEVAL_MATCHABLE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/* Check for end of inner subplan */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>innerslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MJEVAL_ENDOFJOIN</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>innerslot</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mergestate</name><operator>-&gt;</operator><name>mj_NumClauses</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MergeJoinClause</name></type> <name>clause</name> <init>= <expr><operator>&amp;</operator><name><name>mergestate</name><operator>-&gt;</operator><name>mj_Clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>rdatum</name></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>clause</name><operator>-&gt;</operator><name>risnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>risnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>notdistinct</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* match is impossible; can we end the join early? */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>ssup</name><operator>.</operator><name>ssup_nulls_first</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillInner</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>MJEVAL_ENDOFJOIN</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>result</name> <operator>==</operator> <name>MJEVAL_MATCHABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>MJEVAL_NONMATCHABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MJCompare
 *
 * Compare the mergejoinable values of the current two input tuples
 * and return 0 if they are equal (ie, the mergejoin equalities all
 * succeed), &gt;0 if outer &gt; inner, &lt;0 if outer &lt; inner.
 *
 * MJEvalOuterValues and MJEvalInnerValues must already have been called
 * for the current outer and inner tuples, respectively.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>MJCompare</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>mergestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulleqnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Call the comparison functions in short-lived context, in case they leak
	 * memory.
	 */</comment>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mergestate</name><operator>-&gt;</operator><name>mj_NumClauses</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MergeJoinClause</name></type> <name>clause</name> <init>= <expr><operator>&amp;</operator><name><name>mergestate</name><operator>-&gt;</operator><name>mj_Clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Special case for NULL-vs-NULL, else use standard comparison.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>lisnull</name></name> <operator>&amp;&amp;</operator> <name><name>clause</name><operator>-&gt;</operator><name>risnull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nulleqnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* NULL "=" NULL */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>ldatum</name></name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>lisnull</name></name></expr></argument>,
									 <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>rdatum</name></name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>risnull</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>clause</name><operator>-&gt;</operator><name>ssup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we had any NULL-vs-NULL inputs, we do not want to report that the
	 * tuples are equal.  Instead, if result is still 0, change it to +1. This
	 * will result in advancing the inner side of the join.
	 *
	 * Likewise, if there was a constant-false joinqual, do not report
	 * equality.  We have to check this as part of the mergequals, else the
	 * rescan logic will do the wrong thing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>nulleqnull</name> <operator>||</operator> <name><name>mergestate</name><operator>-&gt;</operator><name>mj_ConstFalseJoin</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Generate a fake join tuple with nulls for the inner tuple,
 * and return it if it passes the non-join quals.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>MJFillOuter</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>otherqual</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_NullInnerTupleSlot</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * qualification succeeded.  now form the desired projection tuple and
		 * return the slot containing it.
		 */</comment>
		<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: returning outer fill tuple\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a fake join tuple with nulls for the outer tuple,
 * and return it if it passes the non-join quals.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>MJFillInner</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>otherqual</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we don't have an inner, return NULL */</comment>
	<if_stmt><if>if<condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_NullOuterTupleSlot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * qualification succeeded.  now form the desired projection tuple and
		 * return the slot containing it.
		 */</comment>
		<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: returning inner fill tuple\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check that a qual condition is constant true or constant false.
 * If it is constant false (or null), set *is_const_false to true.
 *
 * Constant true would normally be represented by a NIL list, but we allow an
 * actual bool Const as well.  We do expect that the planner will have thrown
 * away any non-constant terms that have been ANDed with a constant false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_constant_qual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_const_false</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qual</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>con</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>||</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>is_const_false</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecMergeTupleDump
 *
 *		This function is called through the MJ_dump() macro
 *		when EXEC_MERGEJOINDEBUG is defined
 * ----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_MERGEJOINDEBUG</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecMergeTupleDumpOuter</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>mergestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerSlot</name> <init>= <expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"==== outer tuple ====\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(nil)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MJ_debugtup</name><argument_list>(<argument><expr><name>outerSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecMergeTupleDumpInner</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>mergestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>innerSlot</name> <init>= <expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"==== inner tuple ====\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>innerSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(nil)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MJ_debugtup</name><argument_list>(<argument><expr><name>innerSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecMergeTupleDumpMarked</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>mergestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>markedSlot</name> <init>= <expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_MarkedTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"==== marked tuple ====\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>markedSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(nil)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MJ_debugtup</name><argument_list>(<argument><expr><name>markedSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecMergeTupleDump</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>mergestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"******** ExecMergeTupleDump ********\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecMergeTupleDumpOuter</name><argument_list>(<argument><expr><name>mergestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecMergeTupleDumpInner</name><argument_list>(<argument><expr><name>mergestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecMergeTupleDumpMarked</name><argument_list>(<argument><expr><name>mergestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"********\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecMergeJoin
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecMergeJoin_guts</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>MergeJoinState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>joinqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>otherqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>qualResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compareResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>innerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>innerTupleSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>doFillOuter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>doFillInner</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get information from node
	 */</comment>
	<expr_stmt><expr><name>innerPlan</name> <operator>=</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>joinqual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>joinqual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>otherqual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>doFillOuter</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_FillOuter</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>doFillInner</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_FillInner</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset per-tuple memory context to free any expression evaluation
	 * storage allocated in the previous tuple cycle.
	 */</comment>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * MPP-4165: My fix for MPP-3300 was correct in that we avoided
	 * the *deadlock* but had very unexpected (and painful)
	 * performance characteristics: we basically de-pipeline and
	 * de-parallelize execution of any query which has motion below
	 * us.
	 *
	 * So now prefetch_inner is set (see createplan.c) if we have *any* motion
	 * below us. If we don't have any motion, it doesn't matter.
	 *
	 * See motion_sanity_walker() for details on how a deadlock may occur.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_inner</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name> <operator>=</operator> <name>innerTupleSlot</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prefetch JoinQual or NonJoinQual to prevent motion hazard.
	 *
	 * See ExecPrefetchQual() for details.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_joinqual</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecPrefetchQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>js</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_joinqual</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_qual</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecPrefetchQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>js</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_qual</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * ok, everything is setup.. let's go to work
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MJ_dump</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * get the current state of the join and do things accordingly.
		 */</comment>
		<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/*
				 * EXEC_MJ_INITIALIZE_OUTER means that this is the first time
				 * ExecMergeJoin() has been called and so we have to fetch the
				 * first matchable tuple for both outer and inner subplans. We
				 * do the outer side in INITIALIZE_OUTER state, then advance
				 * to INITIALIZE_INNER state for the inner subplan.
				 */</comment>
			<case>case <expr><name>EXEC_MJ_INITIALIZE_OUTER</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_INITIALIZE_OUTER\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>

				<comment type="block">/* Compute join values and check for unmatchability */</comment>
				<switch>switch <condition>(<expr><call><name>MJEvalOuterValues</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MJEVAL_MATCHABLE</name></expr>:</case>
						<comment type="block">/* OK to go get the first inner tuple */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_INITIALIZE_INNER</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_NONMATCHABLE</name></expr>:</case>
						<comment type="block">/* Stay in same state to fetch next outer tuple */</comment>
						<if_stmt><if>if <condition>(<expr><name>doFillOuter</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Generate a fake join tuple with nulls for the
							 * inner tuple, and return it if it passes the
							 * non-join quals.
							 */</comment>
							<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MJFillOuter</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_ENDOFJOIN</name></expr>:</case>
						<comment type="block">/* No more outer tuples */</comment>
						<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: nothing in outer subplan\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>doFillInner</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Need to emit right-join tuples for remaining
							 * inner tuples. We set MatchedInner = true to
							 * force the ENDOUTER state to advance inner.
							 */</comment>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_ENDOUTER</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* Otherwise we're done. */</comment>
						<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

			<case>case <expr><name>EXEC_MJ_INITIALIZE_INNER</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_INITIALIZE_INNER\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name> <operator>=</operator> <name>innerTupleSlot</name></expr>;</expr_stmt>

				<comment type="block">/* Compute join values and check for unmatchability */</comment>
				<switch>switch <condition>(<expr><call><name>MJEvalInnerValues</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MJEVAL_MATCHABLE</name></expr>:</case>
						<comment type="block">/*
						 * OK, we have the initial tuples.  Begin by skipping
						 * non-matching tuples.
						 */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_SKIP_TEST</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_NONMATCHABLE</name></expr>:</case>
						<comment type="block">/* Mark before advancing, if wanted */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mj_ExtraMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ExecMarkPos</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<comment type="block">/* Stay in same state to fetch next inner tuple */</comment>
						<if_stmt><if>if <condition>(<expr><name>doFillInner</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Generate a fake join tuple with nulls for the
							 * outer tuple, and return it if it passes the
							 * non-join quals.
							 */</comment>
							<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MJFillInner</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_ENDOFJOIN</name></expr>:</case>
						<comment type="block">/* No more inner tuples */</comment>
						<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: nothing in inner subplan\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>doFillOuter</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Need to emit left-join tuples for all outer
							 * tuples, including the one we just fetched.  We
							 * set MatchedOuter = false to force the ENDINNER
							 * state to emit first tuple before advancing
							 * outer.
							 */</comment>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_ENDINNER</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* Otherwise we're done. */</comment>
						<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

				<comment type="block">/*
				 * EXEC_MJ_JOINTUPLES means we have two tuples which satisfied
				 * the merge clause so we join them and then proceed to get
				 * the next inner tuple (EXEC_MJ_NEXTINNER).
				 */</comment>
			<case>case <expr><name>EXEC_MJ_JOINTUPLES</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_JOINTUPLES\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Set the next state machine state.  The right things will
				 * happen whether we return this join tuple or just fall
				 * through to continue the state machine execution.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_NEXTINNER</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Check the extra qual conditions to see if we actually want
				 * to return this join tuple.  If not, can proceed with merge.
				 * We must distinguish the additional joinquals (which must
				 * pass to consider the tuples "matched" for outer-join logic)
				 * from the otherquals (which must pass before we actually
				 * return the tuple).
				 *
				 * We don't bother with a ResetExprContext here, on the
				 * assumption that we just did one while checking the merge
				 * qual.  One per tuple should be sufficient.  We do have to
				 * set up the econtext links to the tuples for ExecQual to
				 * use.
				 */</comment>
				<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>innerTupleSlot</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>qualResult</name> <operator>=</operator> <operator>(</operator><name>joinqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
							  <call><name>ExecQual</name><argument_list>(<argument><expr><name>joinqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MJ_DEBUG_QUAL</name><argument_list>(<argument><expr><name>joinqual</name></expr></argument>, <argument><expr><name>qualResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>qualResult</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/* In an antijoin, we never return a matched tuple */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_NEXTOUTER</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If we only need to join to the first matching inner
					 * tuple, then consider returning this one, but after that
					 * continue with next outer tuple.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>single_match</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_NEXTOUTER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>qualResult</name> <operator>=</operator> <operator>(</operator><name>otherqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
								  <call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MJ_DEBUG_QUAL</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>qualResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>qualResult</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * qualification succeeded.  now form the desired
						 * projection tuple and return the slot containing it.
						 */</comment>
						<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: returning tuple\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * EXEC_MJ_NEXTINNER means advance the inner scan to the next
				 * tuple. If the tuple is not nil, we then proceed to test it
				 * against the join qualification.
				 *
				 * Before advancing, we check to see if we must emit an
				 * outer-join fill tuple for this inner tuple.
				 */</comment>
			<case>case <expr><name>EXEC_MJ_NEXTINNER</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_NEXTINNER\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>doFillInner</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Generate a fake join tuple with nulls for the outer
					 * tuple, and return it if it passes the non-join quals.
					 */</comment>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* do it only once */</comment>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MJFillInner</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * now we get the next inner tuple, if any.  If there's none,
				 * advance to next outer tuple (which may be able to join to
				 * previously marked tuples).
				 *
				 * NB: must NOT do "extraMarks" here, since we may need to
				 * return to previously marked tuples.
				 */</comment>
				<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name> <operator>=</operator> <name>innerTupleSlot</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MJ_DEBUG_PROC_NODE</name><argument_list>(<argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* Compute join values and check for unmatchability */</comment>
				<switch>switch <condition>(<expr><call><name>MJEvalInnerValues</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MJEVAL_MATCHABLE</name></expr>:</case>

						<comment type="block">/*
						 * Test the new inner tuple to see if it matches
						 * outer.
						 *
						 * If they do match, then we join them and move on to
						 * the next inner tuple (EXEC_MJ_JOINTUPLES).
						 *
						 * If they do not match then advance to next outer
						 * tuple.
						 */</comment>
						<expr_stmt><expr><name>compareResult</name> <operator>=</operator> <call><name>MJCompare</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MJ_DEBUG_COMPARE</name><argument_list>(<argument><expr><name>compareResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>compareResult</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_JOINTUPLES</name></expr>;</expr_stmt></block_content></block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compareResult</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_NEXTOUTER</name></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_NONMATCHABLE</name></expr>:</case>

						<comment type="block">/*
						 * It contains a NULL and hence can't match any outer
						 * tuple, so we can skip the comparison and assume the
						 * new tuple is greater than current outer.
						 */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_NEXTOUTER</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_ENDOFJOIN</name></expr>:</case>

						<comment type="block">/*
						 * No more inner tuples.  However, this might be only
						 * effective and not physical end of inner plan, so
						 * force mj_InnerTupleSlot to null to make sure we
						 * don't fetch more inner tuples.  (We need this hack
						 * because we are not transiting to a state where the
						 * inner plan is assumed to be exhausted.)
						 */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_NEXTOUTER</name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>MergeJoin</name><operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>unique_outer</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* we are done */</comment>
							<return>return <expr><name>NULL</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<break>break;</break>

				<comment type="block">/*-------------------------------------------
				 * EXEC_MJ_NEXTOUTER means
				 *
				 *				outer inner
				 * outer tuple -  5		5  - marked tuple
				 *				  5		5
				 *				  6		6  - inner tuple
				 *				  7		7
				 *
				 * we know we just bumped into the
				 * first inner tuple &gt; current outer tuple (or possibly
				 * the end of the inner stream)
				 * so get a new outer tuple and then
				 * proceed to test it against the marked tuple
				 * (EXEC_MJ_TESTOUTER)
				 *
				 * Before advancing, we check to see if we must emit an
				 * outer-join fill tuple for this outer tuple.
				 *------------------------------------------------
				 */</comment>
			<case>case <expr><name>EXEC_MJ_NEXTOUTER</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_NEXTOUTER\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>doFillOuter</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Generate a fake join tuple with nulls for the inner
					 * tuple, and return it if it passes the non-join quals.
					 */</comment>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* do it only once */</comment>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MJFillOuter</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * now we get the next outer tuple, if any
				 */</comment>
				<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MJ_DEBUG_PROC_NODE</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* Compute join values and check for unmatchability */</comment>
				<switch>switch <condition>(<expr><call><name>MJEvalOuterValues</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MJEVAL_MATCHABLE</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>MergeJoin</name><operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>unique_outer</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* The current innerTuple will match with this outerTuple.*/</comment>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_JOINTUPLES</name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* Go test the new tuple against the marked tuple */</comment>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_TESTOUTER</name></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_NONMATCHABLE</name></expr>:</case>
						<comment type="block">/* Can't match, so fetch next outer tuple */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_NEXTOUTER</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_ENDOFJOIN</name></expr>:</case>
						<comment type="block">/* No more outer tuples */</comment>
						<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: end of outer subplan\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>doFillInner</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Need to emit right-join tuples for remaining
							 * inner tuples.
							 */</comment>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_ENDOUTER</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* Otherwise we're done. */</comment>
						<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

				<comment type="block">/*--------------------------------------------------------
				 * EXEC_MJ_TESTOUTER If the new outer tuple and the marked
				 * tuple satisfy the merge clause then we know we have
				 * duplicates in the outer scan so we have to restore the
				 * inner scan to the marked tuple and proceed to join the
				 * new outer tuple with the inner tuples.
				 *
				 * This is the case when
				 *						  outer inner
				 *							4	  5  - marked tuple
				 *			 outer tuple -	5	  5
				 *		 new outer tuple -	5	  5
				 *							6	  8  - inner tuple
				 *							7	 12
				 *
				 *				new outer tuple == marked tuple
				 *
				 * If the outer tuple fails the test, then we are done
				 * with the marked tuples, and we have to look for a
				 * match to the current inner tuple.  So we will
				 * proceed to skip outer tuples until outer &gt;= inner
				 * (EXEC_MJ_SKIP_TEST).
				 *
				 *		This is the case when
				 *
				 *						  outer inner
				 *							5	  5  - marked tuple
				 *			 outer tuple -	5	  5
				 *		 new outer tuple -	6	  8  - inner tuple
				 *							7	 12
				 *
				 *				new outer tuple &gt; marked tuple
				 *
				 *---------------------------------------------------------
				 */</comment>
			<case>case <expr><name>EXEC_MJ_TESTOUTER</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_TESTOUTER\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Here we must compare the outer tuple with the marked inner
				 * tuple.  (We can ignore the result of MJEvalInnerValues,
				 * since the marked inner tuple is certainly matchable.)
				 */</comment>
				<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_MarkedTupleSlot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MJEvalInnerValues</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>compareResult</name> <operator>=</operator> <call><name>MJCompare</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MJ_DEBUG_COMPARE</name><argument_list>(<argument><expr><name>compareResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>compareResult</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * the merge clause matched so now we restore the inner
					 * scan position to the first mark, and go join that tuple
					 * (and any following ones) to the new outer.
					 *
					 * If we were able to determine mark and restore are not
					 * needed, then we don't have to back up; the current
					 * inner is already the first possible match.
					 *
					 * NOTE: we do not need to worry about the MatchedInner
					 * state for the rescanned inner tuples.  We know all of
					 * them will match this new outer tuple and therefore
					 * won't be emitted as fill tuples.  This works *only*
					 * because we require the extra joinquals to be constant
					 * when doing a right or full join --- otherwise some of
					 * the rescanned tuples might fail the extra joinquals.
					 * This obviously won't happen for a constant-true extra
					 * joinqual, while the constant-false case is handled by
					 * forcing the merge clause to never match, so we never
					 * get here.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>mj_SkipMarkRestore</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ExecRestrPos</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * ExecRestrPos probably should give us back a new
						 * Slot, but since it doesn't, use the marked slot.
						 * (The previously returned mj_InnerTupleSlot cannot
						 * be assumed to hold the required tuple.)
						 */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name> <operator>=</operator> <name>innerTupleSlot</name></expr>;</expr_stmt>
						<comment type="block">/* we need not do MJEvalInnerValues again */</comment>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_JOINTUPLES</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* ----------------
					 *	if the new outer tuple didn't match the marked inner
					 *	tuple then we have a case like:
					 *
					 *			 outer inner
					 *			   4	 4	- marked tuple
					 * new outer - 5	 4
					 *			   6	 5	- inner tuple
					 *			   7
					 *
					 *	which means that all subsequent outer tuples will be
					 *	larger than our marked inner tuples.  So we need not
					 *	revisit any of the marked tuples but can proceed to
					 *	look for a match to the current inner.  If there's
					 *	no more inners, no more matches are possible.
					 * ----------------
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>compareResult</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>MergeJoin</name><operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>unique_outer</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Mergejoin: compareResult &gt; 0, bad plan ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name></expr>;</expr_stmt>

					<comment type="block">/* reload comparison data for current inner */</comment>
					<switch>switch <condition>(<expr><call><name>MJEvalInnerValues</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>MJEVAL_MATCHABLE</name></expr>:</case>
							<comment type="block">/* proceed to compare it to the current outer */</comment>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_SKIP_TEST</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>MJEVAL_NONMATCHABLE</name></expr>:</case>

							<comment type="block">/*
							 * current inner can't possibly match any outer;
							 * better to advance the inner scan than the
							 * outer.
							 */</comment>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_SKIPINNER_ADVANCE</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>MJEVAL_ENDOFJOIN</name></expr>:</case>
							<comment type="block">/* No more inner tuples */</comment>
							<if_stmt><if>if <condition>(<expr><name>doFillOuter</name></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/*
								 * Need to emit left-join tuples for remaining
								 * outer tuples.
								 */</comment>
								<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_ENDINNER</name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
							<comment type="block">/* Otherwise we're done. */</comment>
							<return>return <expr><name>NULL</name></expr>;</return>
					</block_content>}</block></switch>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

				<comment type="block">/*----------------------------------------------------------
				 * EXEC_MJ_SKIP means compare tuples and if they do not
				 * match, skip whichever is lesser.
				 *
				 * For example:
				 *
				 *				outer inner
				 *				  5		5
				 *				  5		5
				 * outer tuple -  6		8  - inner tuple
				 *				  7    12
				 *				  8    14
				 *
				 * we have to advance the outer scan
				 * until we find the outer 8.
				 *
				 * On the other hand:
				 *
				 *				outer inner
				 *				  5		5
				 *				  5		5
				 * outer tuple - 12		8  - inner tuple
				 *				 14    10
				 *				 17    12
				 *
				 * we have to advance the inner scan
				 * until we find the inner 12.
				 *----------------------------------------------------------
				 */</comment>
			<case>case <expr><name>EXEC_MJ_SKIP_TEST</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_SKIP_TEST\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * before we advance, make sure the current tuples do not
				 * satisfy the mergeclauses.  If they do, then we update the
				 * marked tuple position and go join them.
				 */</comment>
				<expr_stmt><expr><name>compareResult</name> <operator>=</operator> <call><name>MJCompare</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MJ_DEBUG_COMPARE</name><argument_list>(<argument><expr><name>compareResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>compareResult</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>mj_SkipMarkRestore</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ExecMarkPos</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>MarkInnerTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_JOINTUPLES</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>compareResult</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_SKIPOUTER_ADVANCE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<comment type="block">/* compareResult &gt; 0 */</comment>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_SKIPINNER_ADVANCE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * SKIPOUTER_ADVANCE: advance over an outer tuple that is
				 * known not to join to any inner tuple.
				 *
				 * Before advancing, we check to see if we must emit an
				 * outer-join fill tuple for this outer tuple.
				 */</comment>
			<case>case <expr><name>EXEC_MJ_SKIPOUTER_ADVANCE</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_SKIPOUTER_ADVANCE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>doFillOuter</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Generate a fake join tuple with nulls for the inner
					 * tuple, and return it if it passes the non-join quals.
					 */</comment>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* do it only once */</comment>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MJFillOuter</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * now we get the next outer tuple, if any
				 */</comment>
				<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MJ_DEBUG_PROC_NODE</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* Compute join values and check for unmatchability */</comment>
				<switch>switch <condition>(<expr><call><name>MJEvalOuterValues</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MJEVAL_MATCHABLE</name></expr>:</case>
						<comment type="block">/* Go test the new tuple against the current inner */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_SKIP_TEST</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_NONMATCHABLE</name></expr>:</case>
						<comment type="block">/* Can't match, so fetch next outer tuple */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_SKIPOUTER_ADVANCE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_ENDOFJOIN</name></expr>:</case>
						<comment type="block">/* No more outer tuples */</comment>
						<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: end of outer subplan\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>doFillInner</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Need to emit right-join tuples for remaining
							 * inner tuples.
							 */</comment>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_ENDOUTER</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* Otherwise we're done. */</comment>
						<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

				<comment type="block">/*
				 * SKIPINNER_ADVANCE: advance over an inner tuple that is
				 * known not to join to any outer tuple.
				 *
				 * Before advancing, we check to see if we must emit an
				 * outer-join fill tuple for this inner tuple.
				 */</comment>
			<case>case <expr><name>EXEC_MJ_SKIPINNER_ADVANCE</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_SKIPINNER_ADVANCE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>doFillInner</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Generate a fake join tuple with nulls for the outer
					 * tuple, and return it if it passes the non-join quals.
					 */</comment>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* do it only once */</comment>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MJFillInner</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Mark before advancing, if wanted */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mj_ExtraMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecMarkPos</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * now we get the next inner tuple, if any
				 */</comment>
				<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name> <operator>=</operator> <name>innerTupleSlot</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MJ_DEBUG_PROC_NODE</name><argument_list>(<argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* Compute join values and check for unmatchability */</comment>
				<switch>switch <condition>(<expr><call><name>MJEvalInnerValues</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MJEVAL_MATCHABLE</name></expr>:</case>
						<comment type="block">/* proceed to compare it to the current outer */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_SKIP_TEST</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_NONMATCHABLE</name></expr>:</case>

						<comment type="block">/*
						 * current inner can't possibly match any outer;
						 * better to advance the inner scan than the outer.
						 */</comment>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_SKIPINNER_ADVANCE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>MJEVAL_ENDOFJOIN</name></expr>:</case>
						<comment type="block">/* No more inner tuples */</comment>
						<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: end of inner subplan\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>doFillOuter</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Need to emit left-join tuples for remaining
							 * outer tuples.
							 */</comment>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_ENDINNER</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* Otherwise we're done. */</comment>
						<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

				<comment type="block">/*
				 * EXEC_MJ_ENDOUTER means we have run out of outer tuples, but
				 * are doing a right/full join and therefore must null-fill
				 * any remaining unmatched inner tuples.
				 */</comment>
			<case>case <expr><name>EXEC_MJ_ENDOUTER</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_ENDOUTER\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>doFillInner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Generate a fake join tuple with nulls for the outer
					 * tuple, and return it if it passes the non-join quals.
					 */</comment>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* do it only once */</comment>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MJFillInner</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Mark before advancing, if wanted */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mj_ExtraMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecMarkPos</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * now we get the next inner tuple, if any
				 */</comment>
				<expr_stmt><expr><name>innerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>innerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name> <operator>=</operator> <name>innerTupleSlot</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MJ_DEBUG_PROC_NODE</name><argument_list>(<argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>innerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: end of inner subplan\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Else remain in ENDOUTER state and process next tuple. */</comment>
				<break>break;</break>

				<comment type="block">/*
				 * EXEC_MJ_ENDINNER means we have run out of inner tuples, but
				 * are doing a left/full join and therefore must null- fill
				 * any remaining unmatched outer tuples.
				 */</comment>
			<case>case <expr><name>EXEC_MJ_ENDINNER</name></expr>:</case>
				<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: EXEC_MJ_ENDINNER\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>doFillOuter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Generate a fake join tuple with nulls for the inner
					 * tuple, and return it if it passes the non-join quals.
					 */</comment>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* do it only once */</comment>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MJFillOuter</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * now we get the next outer tuple, if any
				 */</comment>
				<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MJ_DEBUG_PROC_NODE</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>MJ_printf</name><argument_list>(<argument><expr><literal type="string">"ExecMergeJoin: end of outer subplan\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Else remain in ENDINNER state and process next tuple. */</comment>
				<break>break;</break>

				<comment type="block">/*
				 * broken state value?
				 */</comment>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized mergejoin state: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecMergeJoin</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecMergeJoin_guts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * CDB: We'll read no more from inner subtree. To keep our sibling
		 * QEs from being starved, tell source QEs not to clog up the
		 * pipeline with our never-to-be-consumed data.
		 */</comment>
		<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitMergeJoin
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>MergeJoinState</name> <modifier>*</modifier></type>
<name>ExecInitMergeJoin</name><parameter_list>(<parameter><decl><type><name>MergeJoin</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>mergestate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rewindflag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>outerDesc</name></decl>,
				<decl><type ref="prev"/><name>innerDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>innerOps</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MJ1_printf</name><argument_list>(<argument><expr><literal type="string">"ExecInitMergeJoin: %s\n"</literal></expr></argument>,
			   <argument><expr><literal type="string">"initializing node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>mergestate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>MergeJoinState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecMergeJoin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_ConstFalseJoin</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we need two additional econtexts in which we can compute the join
	 * expressions from the left and right input tuples.  The node's regular
	 * econtext won't do because it gets reset too often.
	 */</comment>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_OuterEContext</name></name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_InnerEContext</name></name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>prefetch_inner</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>prefetch_joinqual</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_joinqual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>prefetch_qual</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_qual</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Test_print_prefetch_joinqual</name> <operator>&amp;&amp;</operator> <name><name>mergestate</name><operator>-&gt;</operator><name>prefetch_joinqual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			 <argument><expr><literal type="string">"prefetch join qual in slice %d of plannode %d"</literal></expr></argument>,
			 <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * reuse GUC Test_print_prefetch_joinqual to output debug information for
	 * prefetching non join qual
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Test_print_prefetch_joinqual</name> <operator>&amp;&amp;</operator> <name><name>mergestate</name><operator>-&gt;</operator><name>prefetch_qual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			 <argument><expr><literal type="string">"prefetch non join qual in slice %d of plannode %d"</literal></expr></argument>,
			 <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare inner operators for rewind after the prefetch */</comment>
	<expr_stmt><expr><name>rewindflag</name> <operator>=</operator> <ternary><condition><expr><name><name>mergestate</name><operator>-&gt;</operator><name>prefetch_inner</name></name></expr> ?</condition><then> <expr><name>EXEC_FLAG_REWIND</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize child nodes
     *
     * inner child must support MARK/RESTORE, unless we have detected that we
     * don't need that.  Note that skip_mark_restore must never be set if
     * there are non-mergeclause joinquals, since the logic wouldn't work.
     */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>skip_mark_restore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_SkipMarkRestore</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>skip_mark_restore</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>mergestate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>mergestate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>mergestate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
											  <argument><expr><ternary><condition><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_SkipMarkRestore</name></name></expr> ?</condition><then>
											  <expr><name>eflags</name> <operator>|</operator> <name>rewindflag</name></expr></then><else>:
											  <expr><operator>(</operator><name>eflags</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name> <operator>|</operator> <name>rewindflag</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>mergestate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For certain types of inner child nodes, it is advantageous to issue
	 * MARK every time we advance past an inner tuple we will never return to.
	 * For other types, MARK on a tuple we cannot return to is a waste of
	 * cycles.  Detect which case applies and set mj_ExtraMarks if we want to
	 * issue "unnecessary" MARK calls.
	 *
	 * Currently, only Material wants the extra MARKs, and it will be helpful
	 * only if eflags doesn't specify REWIND.
	 *
	 * Note that for IndexScan and IndexOnlyScan, it is *necessary* that we
	 * not set mj_ExtraMarks; otherwise we might attempt to set a mark before
	 * the first inner tuple, which they do not support.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Material</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_REWIND</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>mergestate</name><operator>-&gt;</operator><name>mj_SkipMarkRestore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_ExtraMarks</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_ExtraMarks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Initialize result slot, type and projection.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * tuple table initialization
	 */</comment>
	<expr_stmt><expr><name>innerOps</name> <operator>=</operator> <call><name>ExecGetResultSlotOps</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>mergestate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_MarkedTupleSlot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>innerDesc</name></expr></argument>,
															<argument><expr><name>innerOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child expressions
	 */</comment>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>mergestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>mergestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* mergeclauses are handled below */</comment>

	<comment type="block">/*
	 * detect whether we need only consider the first matching inner tuple
	 */</comment>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>single_match</name></name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>inner_unique</name></name> <operator>||</operator>
								   <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* set up null tuples for outer joins, if needed */</comment>
	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillInner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillOuter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillInner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_NullInnerTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>innerDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillInner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_NullOuterTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>outerDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Can't handle right or full join with non-constant extra
			 * joinclauses.  This should have been caught by planner.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_constant_qual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>mergestate</name><operator>-&gt;</operator><name>mj_ConstFalseJoin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RIGHT JOIN is only supported with merge-joinable join conditions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillOuter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_FillInner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_NullOuterTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>outerDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_NullInnerTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>innerDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Can't handle right or full join with non-constant extra
			 * joinclauses.  This should have been caught by planner.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_constant_qual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>mergestate</name><operator>-&gt;</operator><name>mj_ConstFalseJoin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FULL JOIN is only supported with merge-joinable join conditions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_LASJ_NOTIN</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"join type not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * preprocess the merge clauses
	 */</comment>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_NumClauses</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_Clauses</name></name> <operator>=</operator> <call><name>MJExamineQuals</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>,
											<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeFamilies</name></name></expr></argument>,
											<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeCollations</name></name></expr></argument>,
											<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeStrategies</name></name></expr></argument>,
											<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeNullsFirst</name></name></expr></argument>,
											<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>mergestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize join state
	 */</comment>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_INITIALIZE_OUTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mergestate</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialization successful
	 */</comment>
	<expr_stmt><expr><call><name>MJ1_printf</name><argument_list>(<argument><expr><literal type="string">"ExecInitMergeJoin: %s\n"</literal></expr></argument>,
			   <argument><expr><literal type="string">"node initialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mergestate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndMergeJoin
 *
 * old comments
 *		frees storage allocated through C routines.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndMergeJoin</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MJ1_printf</name><argument_list>(<argument><expr><literal type="string">"ExecEndMergeJoin: %s\n"</literal></expr></argument>,
			   <argument><expr><literal type="string">"ending node processing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free the exprcontext
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean out the tuple table
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MarkedTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * shut down the subplans
	 */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MJ1_printf</name><argument_list>(<argument><expr><literal type="string">"ExecEndMergeJoin: %s\n"</literal></expr></argument>,
			   <argument><expr><literal type="string">"node processing ended"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanMergeJoin</name><parameter_list>(<parameter><decl><type><name>MergeJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MarkedTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_JoinState</name></name> <operator>=</operator> <name>EXEC_MJ_INITIALIZE_OUTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_MatchedInner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_OuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mj_InnerTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * if chgParam of subnodes is not null then plans will be re-scanned by
	 * first ExecProcNode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>righttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>
</unit>
