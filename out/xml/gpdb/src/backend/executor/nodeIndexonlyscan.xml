<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/executor/nodeIndexonlyscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeIndexonlyscan.c
 *	  Routines to support index-only scans
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeIndexonlyscan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *		ExecIndexOnlyScan			scans an index
 *		IndexOnlyNext				retrieve next tuple
 *		ExecInitIndexOnlyScan		creates and initializes state info.
 *		ExecReScanIndexOnlyScan		rescans the indexed relation.
 *		ExecEndIndexOnlyScan		releases all storage.
 *		ExecIndexOnlyMarkPos		marks scan position.
 *		ExecIndexOnlyRestrPos		restores scan position.
 *		ExecIndexOnlyScanEstimate	estimates DSM space needed for
 *						parallel index-only scan
 *		ExecIndexOnlyScanInitializeDSM	initialize DSM for parallel
 *						index-only scan
 *		ExecIndexOnlyScanReInitializeDSM	reinitialize DSM for fresh scan
 *		ExecIndexOnlyScanInitializeWorker attach to DSM info in parallel worker
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexonlyscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>IndexOnlyNext</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreIndexTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
							<parameter><decl><type><name>TupleDesc</name></type> <name>itupdesc</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *		IndexOnlyNext
 *
 *		Retrieve a tuple from the IndexOnlyScan node's index.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>IndexOnlyNext</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>direction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * extract necessary information from index scan node
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>direction</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr>;</expr_stmt>
	<comment type="block">/* flip direction if this is an overall backward scan */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>indexorderdir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>BackwardScanDirection</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>scandesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>scandesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We reach here if the index only scan is not parallel, or if we're
		 * serially executing an index only scan that was planned to be
		 * parallel.
		 */</comment>
		<expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
								   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name> <operator>=</operator> <name>scandesc</name></expr>;</expr_stmt>


		<comment type="block">/* Set it up for index-only scan */</comment>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If no run-time keys to calculate or they are ready, go ahead and
		 * pass the scankeys to the index AM.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, now that we have what we need, fetch the next tuple.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>tid</name> <operator>=</operator> <call><name>index_getnext_tid</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>tuple_from_heap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can skip the heap fetch if the TID references a heap page on
		 * which all tuples are known visible to everybody.  In any case,
		 * we'll use the index tuple not the heap tuple as the data source.
		 *
		 * Note on Memory Ordering Effects: visibilitymap_get_status does not
		 * lock the visibility map buffer, and therefore the result we read
		 * here could be slightly stale.  However, it can't be stale enough to
		 * matter.
		 *
		 * We need to detect clearing a VM bit due to an insert right away,
		 * because the tuple is present in the index page but not visible. The
		 * reading of the TID by this scan (using a shared lock on the index
		 * buffer) is serialized with the insert of the TID into the index
		 * (using an exclusive lock on the index buffer). Because the VM bit
		 * is cleared before updating the index, and locking/unlocking of the
		 * index page acts as a full memory barrier, we are sure to see the
		 * cleared bit if we see a recently-inserted TID.
		 *
		 * Deletes do not update the index page (only VACUUM will clear out
		 * the TID), so the clearing of the VM bit by a delete is not
		 * serialized with this test below, and we may see a value that is
		 * significantly stale. However, we don't care about the delete right
		 * away, because the tuple is still visible until the deleting
		 * transaction commits or the statement ends (if it's our
		 * transaction). In either case, the lock on the VM buffer will have
		 * been released (acting as a write barrier) after clearing the bit.
		 * And for us to have a snapshot that includes the deleting
		 * transaction (making the tuple invisible), we must have acquired
		 * ProcArrayLock after that time, acting as a read barrier.
		 *
		 * It's worth going through this complexity to avoid needing to lock
		 * the VM buffer, which could cause significant contention.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ALL_VISIBLE</name><argument_list>(<argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>,
							<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Rats, we have to visit the heap to check visibility.
			 */</comment>
			<expr_stmt><expr><call><name>InstrCountTuples2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>index_fetch_heap</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_TableSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no visible tuple, try next index entry */</comment>

			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_TableSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Only MVCC snapshots are supported here, so there should be no
			 * need to keep following the HOT chain once a visible entry has
			 * been found.  If we did want to allow that, we'd need to keep
			 * more state to remember not to call index_getnext_tid next time.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_heap_continue</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"non-MVCC snapshots are not supported in index-only scans"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Note: at this point we are holding a pin on the heap page, as
			 * recorded in scandesc-&gt;xs_cbuf.  We could release that pin now,
			 * but it's not clear whether it's a win to do so.  The next index
			 * entry might require a visit to the same heap page.
			 */</comment>

			<expr_stmt><expr><name>tuple_from_heap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Fill the scan tuple slot with data from the index.  This might be
		 * provided in either HeapTuple or IndexTuple format.  Conceivably an
		 * index AM might fill both fields, in which case we prefer the heap
		 * format, since it's probably a bit cheaper to fill a slot from.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_hitup</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We don't take the trouble to verify that the provided tuple has
			 * exactly the slot's format, but it seems worth doing a quick
			 * check on the number of fields.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator>
				   <name><name>scandesc</name><operator>-&gt;</operator><name>xs_hitupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_hitup</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_itup</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>StoreIndexTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_itup</name></name></expr></argument>, <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_itupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no data returned for index-only scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If the index was lossy, we have to recheck the index quals.
		 * (Currently, this can never happen, but we should support the case
		 * for possible future use, eg with GiST indexes.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQualAndReset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Fails recheck, so drop it and loop back for another */</comment>
				<expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We don't currently support rechecking ORDER BY distances.  (In
		 * principle, if the index can support retrieval of the originally
		 * indexed value, it should be able to produce an exact distance
		 * calculation too.  So it's not clear that adding code here for
		 * recheck/re-sort would be worth the trouble.  But we should at least
		 * throw an error if someone tries it.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>scandesc</name><operator>-&gt;</operator><name>xs_recheckorderby</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lossy distance functions are not supported in index-only scans"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we didn't access the heap, then we'll need to take a predicate
		 * lock explicitly, as if we had.  For now we do that at page level.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuple_from_heap</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PredicateLockPage</name><argument_list>(<argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>,
							  <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>slot</name></expr>;</return>
	</block_content>}</block></while>

	<comment type="block">/*
	 * if we get here it means the index scan failed so we are at the end of
	 * the scan..
	 */</comment>
	<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StoreIndexTuple
 *		Fill the slot with data from the index tuple.
 *
 * At some point this might be generally-useful functionality, but
 * right now we don't need it elsewhere.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreIndexTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>itupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Note: we must use the tupdesc supplied by the AM in index_deform_tuple,
	 * not the slot's tupdesc, in case the latter has different datatypes
	 * (this happens for btree name_ops in particular).  They'd better have
	 * the same number of columns though, as well as being datatype-compatible
	 * which is something we can't so easily check.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name><name>itupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_deform_tuple</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IndexOnlyRecheck -- access method routine to recheck a tuple in EvalPlanQual
 *
 * This can't really happen, since an index can't supply CTID which would
 * be necessary data for any potential EvalPlanQual target relation.  If it
 * did happen, the EPQ code would pass us the wrong data, namely a heap
 * tuple not an index tuple.  So throw an error.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IndexOnlyRecheck</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"EvalPlanQual recheck is not supported in index-only scans"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIndexOnlyScan(node)
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexOnlyScanState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we have runtime keys and they've not already been set up, do it now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ExecScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>ExecScanAccessMtd</name><operator>)</operator> <name>IndexOnlyNext</name></expr></argument>,
					<argument><expr><operator>(</operator><name>ExecScanRecheckMtd</name><operator>)</operator> <name>IndexOnlyRecheck</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecReScanIndexOnlyScan(node)
 *
 *		Recalculates the values of any scan keys whose value depends on
 *		information known at runtime, then rescans the indexed relation.
 *
 *		Updating the scan key was formerly done separately in
 *		ExecUpdateIndexScanKeys. Integrating it into ReScan makes
 *		rescans of indices and relations/general streams more uniform.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we are doing runtime key calculations (ie, any of the index key
	 * values weren't simple Consts), compute the new key values.  But first,
	 * reset the context so we don't leak memory as each outer tuple is
	 * scanned.  Note this assumes that we will recalculate *all* runtime keys
	 * on each call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecIndexEvalRuntimeKeys</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeys</name></name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* reset index scan */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecScanReScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndIndexOnlyScan
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>indexScanDesc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * extract information from the node
	 */</comment>
	<expr_stmt><expr><name>indexRelationDesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexScanDesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* Release VM buffer pin, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Free the exprcontext(s) ... now dead code, see ExecFreeExprContext
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * clear out tuple table slots
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * close the index relation (no-op if we didn't open it)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>indexScanDesc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>indexScanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>indexRelationDesc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelationDesc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIndexOnlyMarkPos
 *
 * Note: we assume that no caller attempts to set a mark before having read
 * at least one tuple.  Otherwise, ioss_ScanDesc might still be NULL.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyMarkPos</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We are inside an EvalPlanQual recheck.  If a test tuple exists for
		 * this relation, then we shouldn't access the index at all.  We would
		 * instead need to save, and later restore, the state of the
		 * es_epqScanDone flag, so that re-fetching the test tuple is
		 * possible.  However, given the assumption that no caller sets a mark
		 * at the start of the scan, we can only get here with es_epqScanDone
		 * already set, and so no state need be saved.
		 */</comment>
		<decl_stmt><decl><type><name>Index</name></type>		<name>scanrelid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scanrelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Verify the claim above */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected ExecIndexOnlyMarkPos call in EPQ recheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>index_markpos</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIndexOnlyRestrPos
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyRestrPos</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* See comments in ExecIndexOnlyMarkPos */</comment>
		<decl_stmt><decl><type><name>Index</name></type>		<name>scanrelid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scanrelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSlot</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Verify the claim above */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected ExecIndexOnlyRestrPos call in EPQ recheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>index_restrpos</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitIndexOnlyScan
 *
 *		Initializes the index scan's state information, creates
 *		scan keys, and opens the base and index relations.
 *
 *		Note: index scans have 2 sets of state information because
 *			  we have to keep track of the base relation and the
 *			  index relation.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type>
<name>ExecInitIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>indexstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>currentRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>indexstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexOnlyScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecIndexOnlyScan</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * open the scan relation
	 */</comment>
	<expr_stmt><expr><name>currentRelation</name> <operator>=</operator> <call><name>ExecOpenScanRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name> <operator>=</operator> <name>currentRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* no heap scan here */</comment>

	<comment type="block">/*
	 * Build the scan tuple type using the indextlist generated by the
	 * planner.  We use this, rather than the index's physical tuple
	 * descriptor, because the latter contains storage column types not the
	 * types of the original datums.  (It's the AM's responsibility to return
	 * suitable data anyway.)
	 */</comment>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need another slot, in a format that's suitable for the table AM, for
	 * when we need to fetch a tuple from the table for rechecking visibility.
	 */</comment>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_TableSlot</name></name> <operator>=</operator>
		<call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>,
						   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>currentRelation</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name>currentRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize result type and projection info.  The node's targetlist will
	 * contain Vars with varno = INDEX_VAR, referencing the scan tuple.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTypeTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignScanProjectionInfoWithVarno</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>INDEX_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child expressions
	 *
	 * Note: we don't initialize all of the indexorderby expression, only the
	 * sub-parts corresponding to runtime keys (see below).
	 */</comment>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are just doing EXPLAIN (ie, aren't going to run the plan), stop
	 * here.  This allows an index-advisor plugin to EXPLAIN a plan containing
	 * references to nonexistent indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>indexstate</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Open the index relation. */</comment>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <call><name>exec_rt_fetch</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rellockmode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize index-specific scan state
	 */</comment>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeKeys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * build the index scan keys from the index qualification
	 */</comment>
	<expr_stmt><expr><call><name>ExecIndexBuildScanKeys</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>,
						   <argument><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
						   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeKeys</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no ArrayKeys */</comment>
						   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * any ORDER BY exprs have to be turned into scankeys in the same way
	 */</comment>
	<expr_stmt><expr><call><name>ExecIndexBuildScanKeys</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>,
						   <argument><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
						   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderby</name></name></expr></argument>,
						   <argument><expr><name>true</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeKeys</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no ArrayKeys */</comment>
						   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have runtime keys, we need an ExprContext to evaluate them. The
	 * node's standard context won't do because we want to reset that context
	 * for every tuple.  So, build another context just like the other one...
	 * -tgl 7/11/00
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>stdecontext</name> <init>= <expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name> <operator>=</operator> <name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>=</operator> <name>stdecontext</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * all done.
	 */</comment>
	<return>return <expr><name>indexstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		Parallel Index-only Scan Support
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIndexOnlyScanEstimate
 *
 *		Compute the amount of space we'll need in the parallel
 *		query DSM, and inform pcxt-&gt;estimator about our needs.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyScanEstimate</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						  <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_PscanLen</name></name> <operator>=</operator> <call><name>index_parallelscan_estimate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
													  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_PscanLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIndexOnlyScanInitializeDSM
 *
 *		Set up a parallel index-only scan descriptor.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyScanInitializeDSM</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelIndexScanDesc</name></type> <name>piscan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>piscan</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_PscanLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_parallelscan_initialize</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
								  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
								  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
								  <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name> <operator>=</operator>
		<call><name>index_beginscan_parallel</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>,
								 <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If no run-time keys to calculate or they are ready, go ahead and pass
	 * the scankeys to the index AM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIndexOnlyScanReInitializeDSM
 *
 *		Reset shared state before beginning a fresh scan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyScanReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								 <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>index_parallelrescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIndexOnlyScanInitializeWorker
 *
 *		Copy relevant information from TOC into planstate.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyScanInitializeWorker</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								  <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelIndexScanDesc</name></type> <name>piscan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>piscan</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name> <operator>=</operator>
		<call><name>index_beginscan_parallel</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>,
								 <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If no run-time keys to calculate or they are ready, go ahead and pass
	 * the scankeys to the index AM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
