<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/parser/parse_partition_gp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_partition_gp.c
 *	  Expand GPDB legacy partition syntax to PostgreSQL commands.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *	src/backend/parser/parse_partition_gp.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_partition_template.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PartitionKeyData</name> <modifier>*</modifier></type><name>partkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>endVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isEndValMaxValue</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ExprState</name>   <modifier>*</modifier></type><name>plusexprstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>plusexpr_params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type>		<name>currStart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>currEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>called</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>endReached</name></decl>;</decl_stmt>

	<comment type="block">/* for context in error messages */</comment>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>end_location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>every_location</name></decl>;</decl_stmt>
}</block></struct></type> <name>PartEveryIterator</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generateRangePartitions</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
									 <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
									 <parameter><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>,
									 <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>subPart</name></decl></parameter>,
									 <parameter><decl><type><name>partname_comp</name> <modifier>*</modifier></type><name>partnamecomp</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasImplicitRangeBounds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generateListPartition</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
								   <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
								   <parameter><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>,
								   <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>subPart</name></decl></parameter>,
								   <parameter><decl><type><name>partname_comp</name> <modifier>*</modifier></type><name>partnamecomp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generateDefaultPartition</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
									  <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
									  <parameter><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>,
									  <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>subPart</name></decl></parameter>,
									  <parameter><decl><type><name>partname_comp</name> <modifier>*</modifier></type><name>partnamecomp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>extract_tablename_from_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * qsort_stmt_cmp
 *
 * Used when sorting CreateStmts across all partitions.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_stmt_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmt</name>	   <modifier>*</modifier></type><name>b1cstmt</name> <init>= <expr><operator>*</operator><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmt</name>	   <modifier>*</modifier></type><name>b2cstmt</name> <init>= <expr><operator>*</operator><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>partKey</name> <init>= <expr><operator>(</operator><name>PartitionKey</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>b1</name> <init>= <expr><name><name>b1cstmt</name><operator>-&gt;</operator><name>partbound</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>b2</name> <init>= <expr><name><name>b2cstmt</name><operator>-&gt;</operator><name>partbound</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>partnatts</name> <init>= <expr><name><name>partKey</name><operator>-&gt;</operator><name>partnatts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name> <init>= <expr><name><name>partKey</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name> <init>= <expr><name><name>partKey</name><operator>-&gt;</operator><name>partcollation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>b1lowerdatums</name> <init>= <expr><name><name>b1</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>b2lowerdatums</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>b1upperdatums</name> <init>= <expr><name><name>b1</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>b2upperdatums</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>b1cstmt</name></expr></argument>, <argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>b2cstmt</name></expr></argument>, <argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort DEFAULT partitions last */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>is_default</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>b2</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>b1lowerdatums</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b2lowerdatums</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>b1lowerdatum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>b2lowerdatum</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>b1lowerdatums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>b1lowerdatum</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>b2lowerdatums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>b2lowerdatum</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name>b1lowerdatum</name></expr></argument>,
													 <argument><expr><name>b2lowerdatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>b1upperdatums</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b2upperdatums</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>b1upperdatum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>b2upperdatum</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>b1upperdatums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>b1upperdatum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call><operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"maxvalue"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>b2upperdatums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>b2upperdatum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call><operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"maxvalue"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name>b1upperdatum</name></expr></argument>,
													 <argument><expr><name>b2upperdatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>b1lowerdatums</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b2upperdatums</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>b1lowerdatum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>b2upperdatum</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>b1lowerdatums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>b1lowerdatum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>b2upperdatums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>b2upperdatum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call><operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"maxvalue"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name>b1lowerdatum</name></expr></argument>,
													 <argument><expr><name>b2upperdatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * if after comparison, b1 lower and b2 upper are same, we should get
		 * b2 before b1 so that its start can be adjusted properly. Hence,
		 * return b1 is greater than b2 to flip the order.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>b1upperdatums</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b2lowerdatums</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>b1upperdatum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>b2lowerdatum</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>b1upperdatums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>b1upperdatum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call><operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"maxvalue"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>b2lowerdatums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>b2lowerdatum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name>b1upperdatum</name></expr></argument>,
													 <argument><expr><name>b2lowerdatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cmpval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an array of partition bound Datums to List of Consts.
 *
 * The array of Datums representation is used e.g. in PartitionBoundInfo,
 * whereas the Const List representation is used e.g. in the raw-parse output
 * of PartitionBoundSpec.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>datums_to_consts</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>partkey</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					  <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					  <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					  <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					  <argument><expr><call><name>datumCopy</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>,
					  <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type>
<name>consts_to_datums</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>partkey</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>consts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>datums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition bounds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>datums</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>consts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected Const in partition bound"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>datums</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort a list of CreateStmts in-place.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>list_qsort_arg</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>qsort_arg_comparator</name></type> <name>cmp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>create_stmts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Empty list is easy */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Flatten list into an array, so we can use qsort */</comment>
	<expr_stmt><expr><name>create_stmts</name> <operator>=</operator> <operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CreateStmt</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
		<expr_stmt><expr><name><name>create_stmts</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>create_stmts</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CreateStmt</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
		<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ptr_value</name></name> <operator>=</operator> <name><name>create_stmts</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>create_stmts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sort the list of GpPartitionBoundSpecs based first on START, if START does
 * not exist, use END. After sort, if any stmt contains an implicit START or
 * END, deduce the value and update the corresponding list of CreateStmts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deduceImplicitRangeBounds</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>addpartition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>desc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>list_qsort_arg</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>qsort_stmt_cmp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This works slightly differently, depending on whether this is a
	 * CREATE TABLE or ALTER TABLE SET SUBPARTITION TEMPLATE command to create
	 * a whole new set of child partitions of a parent table, or an ALTER TABLE
	 * ADD PARTTION to add to an existing set of sibling partitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addpartition</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * CREATE TABLE or ALTER TABLE SET SUBPARTITION TEMPLATE. We deduce the
		 * missing START/END bounds based on the other partitions defined in
		 * the same command.
		 */</comment>
		<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>prevstmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmts</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>prevstmt</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>prevstmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator> <name><name>prevstmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot derive starting value of partition based upon ending of previous partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>minvalue</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>minvalue</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>minvalue</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"minvalue"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>minvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><ternary><condition><expr><name><name>lc</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><call><name>lfirst</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>next</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>nextstmt</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator><name>next</name></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>nextstmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator> <name><name>nextstmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot derive ending value of partition based upon starting of next partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>maxvalue</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>maxvalue</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>maxvalue</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"maxvalue"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>maxvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>prevstmt</name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This is ALTER TABLE ADD PARTITION. We deduce the missing START/END
		 * bound based on the existing partitions. In principle, we should also
		 * take into account any other partitions defined in the same command,
		 * but in practice it is not necessary, because the ALTER TABLE ADD
		 * PARTITION syntax only allows creating one partition in one command.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot add more than one partition to existing partitioned table in one command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>, <argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"must specify partition bounds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* not allowed in syntax */</comment>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>existing_bound_offset</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>upperdatums</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>upperdatums</name> <operator>=</operator> <call><name>consts_to_datums</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Find the highest existing partition that's lower than or equal to the new
				 * upper bound.
				 */</comment>
				<expr_stmt><expr><name>existing_bound_offset</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
																	  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
																	  <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>,
																	  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
																	  <argument><expr><name>upperdatums</name></expr></argument>,
																	  <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * If there is an existing partition with a lower bound that's
				 * equal to the given upper bound, there isn't much we can do.
				 * The operation is doomed to fail. We set the lower bound as
				 * MINVALUE, and let the later stages throw the error about
				 * overlapping partitions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>existing_bound_offset</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>equal</name> <operator>&amp;&amp;</operator>
					<name><name>desc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>existing_bound_offset</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The new partition was defined with no START, and there is an existing
					 * partition before the given END.
					 */</comment>
					<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator> <call><name>datums_to_consts</name><argument_list>(<argument><expr><name>key</name></expr></argument>,
																	<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>existing_bound_offset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>minvalue</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>minvalue</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>minvalue</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"minvalue"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>minvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>existing_bound_offset</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>lowerdatums</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>lowerdatums</name> <operator>=</operator> <call><name>consts_to_datums</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Find the smallest existing partition that's greater than
				 * the new lower bound.
				 */</comment>
				<expr_stmt><expr><name>existing_bound_offset</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
																	  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
																	  <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>,
																	  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
																	  <argument><expr><name>lowerdatums</name></expr></argument>,
																	  <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>existing_bound_offset</name><operator>++</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>existing_bound_offset</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&amp;&amp;</operator>
					<name><name>desc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>existing_bound_offset</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator> <call><name>datums_to_consts</name><argument_list>(<argument><expr><name>key</name></expr></argument>,
																	<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>existing_bound_offset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>maxvalue</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>maxvalue</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>maxvalue</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"maxvalue"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>maxvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Functions for iterating through all the partition bounds based on
 * transformed START/END/EVERY.
 */</comment>
<function><type><specifier>static</specifier> <name>PartEveryIterator</name> <modifier>*</modifier></type>
<name>initPartEveryIterator</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>PartitionKeyData</name> <modifier>*</modifier></type><name>partkey</name></decl></parameter>,
					  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>every</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end_location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartEveryIterator</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>startVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>endVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> 		<modifier>*</modifier></type><name>plusexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isEndValMaxValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>start</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>start</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startVal</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>start</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>end</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>isEndValMaxValue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>endVal</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>end</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartEveryIterator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>partkey</name></name> <operator>=</operator> <name>partkey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>endVal</name></name> <operator>=</operator> <name>endVal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>isEndValMaxValue</name></name> <operator>=</operator> <name>isEndValMaxValue</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>every</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>plusexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>every</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexpr_params</name></name> <operator>=</operator> <call><name>makeParamList</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexpr_params</name><operator>-&gt;</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexpr_params</name><operator>-&gt;</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexpr_params</name><operator>-&gt;</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexpr_params</name><operator>-&gt;</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ptype</name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>plusexpr_params</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexprstate</name></name> <operator>=</operator> <call><name>ExecInitExprWithParams</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>plusexpr</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexpr_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>currEnd</name></name> <operator>=</operator> <name>startVal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>currStart</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>called</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>endReached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>end_location</name></name> <operator>=</operator> <name>end_location</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>every_location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>every</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>iter</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>freePartEveryIterator</name><parameter_list>(<parameter><decl><type><name>PartEveryIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>estate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return next partition bound in START/END/EVERY specification.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>nextPartBound</name><parameter_list>(<parameter><decl><type><name>PartEveryIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>firstcall</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>firstcall</name> <operator>=</operator> <operator>!</operator><name><name>iter</name><operator>-&gt;</operator><name>called</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>called</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>plusexprstate</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Call (previous bound) + EVERY
		 */</comment>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>next</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<comment type="block">/* If the previous partition reached END, we're done */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>endReached</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexpr_params</name><operator>-&gt;</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexpr_params</name><operator>-&gt;</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>currEnd</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>plusexprstate</name></name></expr></argument>,
										 <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * None of the built-in + operators can return NULL, but a user-defined
		 * operator could.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not compute next partition boundary with EVERY, plus-operator returned NULL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>every_location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>currStart</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>currEnd</name></name></expr>;</expr_stmt>

		<comment type="block">/* Is the next bound greater than END? */</comment>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>partkey</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>partkey</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name>next</name></expr></argument>,
												 <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>endVal</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>endReached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>currEnd</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>endVal</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Sanity check that the next bound is &gt; previous bound. This prevents us
			 * from getting into an infinite loop if the + operator is not behaving.
			 */</comment>
			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>partkey</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
													 <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>partkey</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
													 <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>currEnd</name></name></expr></argument>,
													 <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>firstcall</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Second iteration: parameter hasn't increased the
					 * current end from the old end.
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EVERY parameter too small"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>every_location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * We got a smaller value but later than we
					 * thought so it must be an overflow.
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"END parameter not reached before type overflows"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>end_location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>currEnd</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Without EVERY, create just one partition that covers the whole range */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>firstcall</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>called</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>currStart</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>currEnd</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>currEnd</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>endVal</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>endReached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>ChoosePartitionName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parentname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>naemspaceId</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>partname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>partsubstring</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>levelstr</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>levelstr</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>partname</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>partsubstring</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"prt_%s"</literal></expr></argument>, <argument><expr><name>partname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>makeObjectName</name><argument_list>(<argument><expr><name>parentname</name></expr></argument>, <argument><expr><name>levelstr</name></expr></argument>, <argument><expr><name>partsubstring</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>partsubstring</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"prt_%d"</literal></expr></argument>, <argument><expr><name>partnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ChooseRelationName</name><argument_list>(<argument><expr><name>parentname</name></expr></argument>, <argument><expr><name>levelstr</name></expr></argument>, <argument><expr><name>partsubstring</name></expr></argument>, <argument><expr><name>naemspaceId</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>CreateStmt</name> <modifier>*</modifier></type>
<name>makePartitionCreateStmt</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>partname</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>boundspec</name></decl></parameter>,
						<parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>subPart</name></decl></parameter>, <parameter><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>,
						<parameter><decl><type><name>partname_comp</name> <modifier>*</modifier></type><name>partnamecomp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>childstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>parentrv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>childrv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>final_part_name</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>partnamecomp</name><operator>-&gt;</operator><name>tablename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>final_part_name</name> <operator>=</operator> <name><name>partnamecomp</name><operator>-&gt;</operator><name>tablename</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>final_part_name</name> <operator>=</operator> <call><name>ChoosePartitionName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name><name>partnamecomp</name><operator>-&gt;</operator><name>level</name></name></expr></argument>,
											  <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>partname</name></expr></argument>,
											  <argument><expr><operator>++</operator><name><name>partnamecomp</name><operator>-&gt;</operator><name>partnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>schemaname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>parentrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parentrv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parentrv</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>childrv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>final_part_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childrv</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>childstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>childrv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>parentrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>=</operator> <name>boundspec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>=</operator> <name>subPart</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>ofTypename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <ternary><condition><expr><name><name>elem</name><operator>-&gt;</operator><name>options</name></name></expr> ?</condition><then> <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>ONCOMMIT_NOOP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <ternary><condition><expr><name><name>elem</name><operator>-&gt;</operator><name>tablespacename</name></name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>tablespacename</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <ternary><condition><expr><name><name>elem</name><operator>-&gt;</operator><name>accessMethod</name></name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>gp_style_alter_part</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>distributedBy</name></name> <operator>=</operator> <call><name>make_distributedby_for_rel</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>partitionBy</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>relKind</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>ownerid</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childstmt</name><operator>-&gt;</operator><name>attr_encodings</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>colencs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>childstmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate partitions for transformed START (..) END (..) EVERY (..) */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generateRangePartitions</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						<parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
						<parameter><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>,
						<parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>subPart</name></decl></parameter>,
						<parameter><decl><type><name>partname_comp</name> <modifier>*</modifier></type><name>partnamecomp</name></decl></parameter>,
						<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasImplicitRangeBounds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPartitionRangeSpec</name> <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>				 <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type>		 <name>partkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartEveryIterator</name>	 <modifier>*</modifier></type><name>boundIter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>				 <modifier>*</modifier></type><name>start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>				 <modifier>*</modifier></type><name>end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>				 <modifier>*</modifier></type><name>every</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 				 <name>end_location</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					 <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * We should have checked the same in transformGpPartDefElemWithRangeSpec().
	 * However, we need to check again here in case a GpPartDefElem that comes
	 * from a subpartition template with a boundspec that is no longer up to
	 * date with the first child partition's PartitionKey.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name></expr></argument>, <argument><expr><name>GpPartitionRangeSpec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid boundary specification for RANGE partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <operator>(</operator><name>GpPartitionRangeSpec</name> <operator>*</operator><operator>)</operator> <name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Syntax doesn't allow expressions in partition key */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many columns for RANGE partition -- only one column is allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To create multi-column range partitioned table, use PostgreSQL's grammar. For example:\n"</literal>
							<literal type="string">"create table z (a int, b int, c int) partition by range(b, c);\n"</literal>
							<literal type="string">"create table z1 partition of z for values from (10, 10) TO (20, 20);"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>boundspec</name><operator>-&gt;</operator><name>partStart</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partStart</name><operator>-&gt;</operator><name>edge</name></name> <operator>=</operator> <name>PART_EDGE_INCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partStart</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>hasImplicitRangeBounds</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEnd</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>edge</name></name> <operator>=</operator> <name>PART_EDGE_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>end_location</name> <operator>=</operator> <name><name>boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>hasImplicitRangeBounds</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<comment type="block">/*
	 * Tablename is used by legacy dump and restore ONLY. If tablename is
	 * specified expectation is to ignore the EVERY clause even if
	 * specified. Ideally, dump should never dump the partition CREATE stmts
	 * with EVERY clause, but somehow old code didn't remove EVERY clause from
	 * dump instead ignored the same during restores. Hence, we need to carry
	 * the same hack in new code.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partnamecomp</name><operator>-&gt;</operator><name>tablename</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>boundspec</name><operator>-&gt;</operator><name>partEvery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>every</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEvery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>boundIter</name> <operator>=</operator> <call><name>initPartEveryIterator</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>every</name></expr></argument>, <argument><expr><name>end_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>nextPartBound</name><argument_list>(<argument><expr><name>boundIter</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>childstmt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>partname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>partsubstring</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>is_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>start</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator> <call><name>datums_to_consts</name><argument_list>(<argument><expr><name><name>boundIter</name><operator>-&gt;</operator><name>partkey</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>boundIter</name><operator>-&gt;</operator><name>currStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&amp;&amp;</operator> <name><name>boundIter</name><operator>-&gt;</operator><name>endReached</name></name> <operator>&amp;&amp;</operator> <name><name>boundIter</name><operator>-&gt;</operator><name>isEndValMaxValue</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>maxvalue</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>maxvalue</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"maxvalue"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>maxvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator> <call><name>datums_to_consts</name><argument_list>(<argument><expr><name><name>boundIter</name><operator>-&gt;</operator><name>partkey</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>boundIter</name><operator>-&gt;</operator><name>currEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>every</name> <operator>&amp;&amp;</operator> <name><name>elem</name><operator>-&gt;</operator><name>partName</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>partsubstring</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s_%d"</literal></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>partName</name></name></expr></argument>, <argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partname</name> <operator>=</operator> <operator>&amp;</operator><name><name>partsubstring</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>partname</name> <operator>=</operator> <name><name>elem</name><operator>-&gt;</operator><name>partName</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>childstmt</name> <operator>=</operator> <call><name>makePartitionCreateStmt</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>partname</name></expr></argument>, <argument><expr><name>boundspec</name></expr></argument>,
											<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>subPart</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>partnamecomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>childstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>freePartEveryIterator</name><argument_list>(<argument><expr><name>boundIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generateListPartition</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					  <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
					  <parameter><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>subPart</name></decl></parameter>,
					  <parameter><decl><type><name>partname_comp</name> <modifier>*</modifier></type><name>partnamecomp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPartitionListSpec</name> <modifier>*</modifier></type><name>gpvaluesspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name>  <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmt</name>			<modifier>*</modifier></type><name>childstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>			<modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>				<modifier>*</modifier></type><name>listdatums</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * We should have checked the same in transformGpPartDefElemWithListSpec().
	 * However, we need to check again here in case a GpPartDefElem that comes
	 * from a subpartition template with a boundspec that is no longer up to
	 * date with the first child partition's PartitionKey.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name></expr></argument>, <argument><expr><name>GpPartitionListSpec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid boundary specification for LIST partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>gpvaluesspec</name> <operator>=</operator> <operator>(</operator><name>GpPartitionListSpec</name> <operator>*</operator><operator>)</operator> <name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>is_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>listdatums</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>gpvaluesspec-&gt;partValues</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>thisvalue</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>thisvalue</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VALUES specification with more than one column not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>listdatums</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>listdatums</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>thisvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>=</operator> <name>listdatums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>childstmt</name> <operator>=</operator> <call><name>makePartitionCreateStmt</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>partName</name></name></expr></argument>, <argument><expr><name>boundspec</name></expr></argument>, <argument><expr><name>subPart</name></expr></argument>,
										<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>partnamecomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>childstmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generateDefaultPartition</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						 <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
						 <parameter><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>subPart</name></decl></parameter>,
						 <parameter><decl><type><name>partname_comp</name> <modifier>*</modifier></type><name>partnamecomp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>childstmt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>is_default</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* default partition always needs name to be specified */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>partName</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>childstmt</name> <operator>=</operator> <call><name>makePartitionCreateStmt</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>partName</name></name></expr></argument>, <argument><expr><name>boundspec</name></expr></argument>, <argument><expr><name>subPart</name></expr></argument>,
										<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>partnamecomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>childstmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>extract_tablename_from_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>o_lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>prev_lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tablename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>o_lc</argument>, <argument>*options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>pDef</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>o_lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * get the tablename from the WITH, then remove this element
		 * from the list
		 */</comment>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"tablename"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if the string isn't quoted you get a typename ? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid tablename specification"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname_str</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>pDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><name>options</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><operator>*</operator><name>options</name></expr></argument>, <argument><expr><name>o_lc</name></expr></argument>, <argument><expr><name>prev_lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tablename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>relname_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>prev_lc</name> <operator>=</operator> <name>o_lc</name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>tablename</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>split_encoding_clauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>encs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>non_def</name></decl></parameter>,
					   <parameter><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier><modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>encs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>deflt</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>def</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"DEFAULT COLUMN ENCODING clause specified more than "</literal>
					 <literal type="string">"once for partition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>def</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>non_def</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>non_def</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>merge_partition_encoding</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>elem_colencs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>penc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elem_nondefs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>part_nondefs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>elem_def</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>part_def</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>penc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>elem_colencs</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the specific partition has no specific column encoding, just set it
	 * to the partition level default and we're done.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>elem_colencs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>penc</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fixup the actual column encoding clauses for this specific partition
	 * element.
	 *
	 * Rules:
	 *
	 * 1. If an element level clause mentions a specific column, do not
	 * override it.
	 *
	 * 2. Clauses at the partition configuration level which mention a column
	 * not already mentioned at the element level, are applied to the element.
	 *
	 * 3. If an element level default clause exists, we're done.
	 *
	 * 4. If a partition configuration level default clause exists, apply it
	 * to the element level.
	 *
	 * 5. We're done.
	 */</comment>

	<comment type="block">/* Split specific clauses and default clauses from both our lists */</comment>
	<expr_stmt><expr><call><name>split_encoding_clauses</name><argument_list>(<argument><expr><name>elem_colencs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nondefs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>split_encoding_clauses</name><argument_list>(<argument><expr><name>penc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>part_nondefs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>part_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add clauses from part_nondefs if the columns are not already mentioned */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>part_nondefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>pd</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>elem_nondefs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>ed</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>column</name></name></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>column</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elem_colencs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elem_colencs</name></expr></argument>, <argument><expr><name>pd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>elem_def</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>elem_colencs</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>part_def</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elem_colencs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elem_colencs</name></expr></argument>, <argument><expr><name>part_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>elem_colencs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an exclusive start (or inclusive end) value from the legacy
 * START..EXCLUSIVE (END..INCLUSIVE) syntax into an inclusive start (exclusive
 * end) value. This is required because the range bounds that we store in
 * the catalog (i.e. PartitionBoundSpec-&gt;lower/upperdatums) are always in
 * inclusive start and exclusive end format.
 *
 * We only support this for limited data types. For the supported data
 * types, we perform a '+1' operation on the datum, except for the case when
 * the datum is already the maximum value of the data type, in which case we
 * mark constval-&gt;constisnull as true and preserve the original
 * constval-&gt;constvalue. The caller is responsible for checking
 * constval-&gt;constisnull and if that is true constructing an upperdatum of
 * MAXVALUE (or throwing an error if it's START EXCLUSIVE).
 *
 * If 'is_exclusive_start' is true, this is a START EXCLUSIVE value.
 * Otherwise it is an END INCLUSIVE value. That affects the error messages.
 */</comment>
<function><type><name>void</name></type>
<name>convert_exclusive_start_inclusive_end</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>part_col_typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>part_col_typmod</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>is_exclusive_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>part_col_typmod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>part_col_typid</name> <operator>==</operator> <name>TIMEOID</name> <operator>||</operator>
		 <name>part_col_typid</name> <operator>==</operator> <name>TIMETZOID</name> <operator>||</operator>
		 <name>part_col_typid</name> <operator>==</operator> <name>TIMESTAMPOID</name> <operator>||</operator>
		 <name>part_col_typid</name> <operator>==</operator> <name>TIMESTAMPTZOID</name> <operator>||</operator>
		 <name>part_col_typid</name> <operator>==</operator> <name>INTERVALOID</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_exclusive_start</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"START EXCLUSIVE not supported when partition key has precision specification: %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>part_col_typid</name></expr></argument>, <argument><expr><name>part_col_typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify an inclusive START value and remove the EXCLUSIVE keyword"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"END INCLUSIVE not supported when partition key has precision specification: %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>part_col_typid</name></expr></argument>, <argument><expr><name>part_col_typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify an exclusive END value and remove the INCLUSIVE keyword"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>part_col_typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int16</name></type> <name>value</name> <init>= <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>PG_INT16_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type> <name>value</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>PG_INT32_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type> <name>value</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>PG_INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>DATEOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DateADT</name></type> <name>value</name> <init>= <expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DATE_IS_NOEND</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>TIMEOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TimeADT</name></type> <name>value</name> <init>= <expr><call><name>DatumGetTimeADT</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
						<decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>time2tm</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>!=</operator> <name>HOURS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>TIMETZOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TimeTzADT</name> <modifier>*</modifier></type><name>valueptr</name> <init>= <expr><call><name>DatumGetTimeTzADTP</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
						 <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>timetz2tm</name><argument_list>(<argument><expr><name>valueptr</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>!=</operator> <name>HOURS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>valueptr</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Timestamp</name></type> <name>value</name> <init>= <expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TIMESTAMP_IS_NOEND</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TimestampTz</name></type> <name>value</name> <init>= <expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TIMESTAMP_IS_NOEND</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>INTERVALOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>intervalp</name> <init>= <expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>intervalp</name><operator>-&gt;</operator><name>month</name></name> <operator>==</operator> <name>PG_INT32_MAX</name> <operator>&amp;&amp;</operator>
				<name><name>intervalp</name><operator>-&gt;</operator><name>day</name></name> <operator>==</operator> <name>PG_INT32_MAX</name> <operator>&amp;&amp;</operator>
				<name><name>intervalp</name><operator>-&gt;</operator><name>time</name></name> <operator>==</operator> <name>PG_INT64_MAX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>intervalp</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <name>PG_INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>intervalp</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>intervalp</name><operator>-&gt;</operator><name>day</name></name> <operator>&lt;</operator> <name>PG_INT32_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>intervalp</name><operator>-&gt;</operator><name>day</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>intervalp</name><operator>-&gt;</operator><name>month</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><name>is_exclusive_start</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"START EXCLUSIVE not supported for partition key data type: %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>part_col_typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify an inclusive START value and remove the EXCLUSIVE keyword"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"END INCLUSIVE not supported for partition key data type: %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>part_col_typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify an exclusive END value and remove the INCLUSIVE keyword"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Transform the GPDB specific GpPartDefElem with LIST spec (VALUES(..))
 *
 * The input GpPartDefElem is modified in-place. Caller is responsible for
 * passing in the copy of the original GpPartDefElem.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformGpPartDefElemWithListSpec</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>, <parameter><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPartitionListSpec</name> <modifier>*</modifier></type><name>gpvaluesspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPartitionListSpec</name> <modifier>*</modifier></type><name>new_gpvaluesspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name>  <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>			<modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>				<modifier>*</modifier></type><name>listdatums</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing boundary specification in partition \"%s\" of type LIST"</literal></expr></argument>,
						   <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>partName</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name></expr></argument>, <argument><expr><name>GpPartitionListSpec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid boundary specification for LIST partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>gpvaluesspec</name> <operator>=</operator> <operator>(</operator><name>GpPartitionListSpec</name> <operator>*</operator><operator>)</operator> <name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_gpvaluesspec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GpPartitionListSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_gpvaluesspec</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_gpvaluesspec</name><operator>-&gt;</operator><name>partValues</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>is_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>listdatums</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>gpvaluesspec-&gt;partValues</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>thisvalue</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>thisvalue</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VALUES specification with more than one column not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>listdatums</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>listdatums</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>thisvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>=</operator> <name>listdatums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundspec</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <call><name>transformPartitionBound</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>boundspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>boundspec-&gt;listdatums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * GPDB6 and lower used to support multi-column LIST partitioning, for
		 * backward compatibility we keep the partValues list two-dimensional.
		 */</comment>
		<expr_stmt><expr><name><name>new_gpvaluesspec</name><operator>-&gt;</operator><name>partValues</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>new_gpvaluesspec</name><operator>-&gt;</operator><name>partValues</name></name></expr></argument>,
											   <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>new_gpvaluesspec</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transform the GPDB specific GpPartDefElem with RANGE spec (START(..) END(..) EVERY(..))
 *
 * The transforms include:
 * - Transform START and END into Consts
 * - Transform EVERY into a plus Expr
 * - Convert EXCLUSIVE START to INCLUSIVE END
 * - Convert INCLUSIVE END to EXCLUSIVE START
 *
 * The input GpPartDefElem is modified in-place. Caller is responsible for
 * passing in the copy of the original GpPartDefElem.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformGpPartDefElemWithRangeSpec</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>, <parameter><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPartitionRangeSpec</name> <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPartitionRangeSpec</name> <modifier>*</modifier></type><name>new_boundspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type>		 <name>partkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>			 <modifier>*</modifier></type><name>partcolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>				 <modifier>*</modifier></type><name>start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				 <name>startExclusive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>				 <modifier>*</modifier></type><name>end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				 <name>endInclusive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>				 <modifier>*</modifier></type><name>every</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>					 <name>part_col_typid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>				 <name>part_col_typmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>					 <name>part_col_collation</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing boundary specification in partition \"%s\" of type RANGE"</literal></expr></argument>,
						   <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>partName</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name></expr></argument>, <argument><expr><name>GpPartitionRangeSpec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid boundary specification for RANGE partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <operator>(</operator><name>GpPartitionRangeSpec</name> <operator>*</operator><operator>)</operator> <name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB_12_MERGE_FEATURE_NOT_SUPPORTED: We currently disabled support for multi-column
	 * range partitioned tables. If user want to define partition table with multi-column
	 * range, can use PostgreSQL's grammar:
	 *
	 * create table z (a int, b int, c int) partition by range(b, c);
	 * create table z1 partition of z for values from (10, 10) TO (20, 20);
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many columns for RANGE partition -- only one column is allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Syntax doesn't allow expressions in partition key */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partcolname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid scribbling on input */</comment>
	<expr_stmt><expr><name>new_boundspec</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>boundspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>boundspec</name><operator>-&gt;</operator><name>partStart</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partStart</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of START values should cover all partition key columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partStart</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partStart</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startExclusive</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>boundspec</name><operator>-&gt;</operator><name>partStart</name><operator>-&gt;</operator><name>edge</name></name> <operator>==</operator> <name>PART_EDGE_EXCLUSIVE</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEnd</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of END values should cover all partition key columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>endInclusive</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>edge</name></name> <operator>==</operator> <name>PART_EDGE_INCLUSIVE</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEvery</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEvery</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of EVERY values should cover all partition key columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>every</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEvery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>boundspec</name><operator>-&gt;</operator><name>partEvery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>new_boundspec</name><operator>-&gt;</operator><name>partEvery</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>part_col_typid</name> <operator>=</operator> <call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>part_col_typmod</name> <operator>=</operator> <call><name>get_partition_col_typmod</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>part_col_collation</name> <operator>=</operator> <call><name>get_partition_col_collation</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse the START/END/EVERY clauses */</comment>
	<if_stmt><if>if <condition>(<expr><name>start</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>startConst</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>startConst</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												  <argument><expr><name>start</name></expr></argument>,
												  <argument><expr><name>partcolname</name></expr></argument>,
												  <argument><expr><name>part_col_typid</name></expr></argument>,
												  <argument><expr><name>part_col_typmod</name></expr></argument>,
												  <argument><expr><name>part_col_collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>startConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use NULL with range partition specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>startExclusive</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>convert_exclusive_start_inclusive_end</name><argument_list>(<argument><expr><name>startConst</name></expr></argument>,
												  <argument><expr><name>part_col_typid</name></expr></argument>, <argument><expr><name>part_col_typmod</name></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>startConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"START EXCLUSIVE is out of range"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>new_boundspec</name><operator>-&gt;</operator><name>partStart</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>startConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_boundspec</name><operator>-&gt;</operator><name>partStart</name><operator>-&gt;</operator><name>edge</name></name> <operator>=</operator> <name>PART_EDGE_INCLUSIVE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>endConst</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>endConst</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><name>end</name></expr></argument>,
												<argument><expr><name>partcolname</name></expr></argument>,
												<argument><expr><name>part_col_typid</name></expr></argument>,
												<argument><expr><name>part_col_typmod</name></expr></argument>,
												<argument><expr><name>part_col_collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>endConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use NULL with range partition specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>endInclusive</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>convert_exclusive_start_inclusive_end</name><argument_list>(<argument><expr><name>endConst</name></expr></argument>,
												  <argument><expr><name>part_col_typid</name></expr></argument>, <argument><expr><name>part_col_typmod</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>new_boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>endConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_boundspec</name><operator>-&gt;</operator><name>partEnd</name><operator>-&gt;</operator><name>edge</name></name> <operator>=</operator> <name>PART_EDGE_EXCLUSIVE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>every</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>		<modifier>*</modifier></type><name>plusexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Param</name>		<modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>end</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EVERY clause requires START and END"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>every</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * NOTE: We don't use transformPartitionBoundValue() here. We don't want to cast
		 * the EVERY clause to that type; rather, we'll be passing it to the + operator.
		 * For example, if the partition column is a timestamp, the EVERY clause
		 * can be an interval, so don't try to cast it to timestamp.
		 */</comment>

		<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXTERN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name>part_col_typid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <name>part_col_typmod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name>part_col_collation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* Look up + operator */</comment>
		<expr_stmt><expr><name>plusexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>param</name></expr></argument>,
									<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>every</name></expr></argument>, <argument><expr><name>EXPR_KIND_PARTITION_BOUND</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>every</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check that the input expression's collation is compatible with one
		 * specified for the parent's partition key (partcollation).  Don't throw
		 * an error if it's the default collation which we'll replace with the
		 * parent's collation anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plusexpr</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>		<name>exprCollOid</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>plusexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>exprCollOid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>exprCollOid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name> <operator>&amp;&amp;</operator>
				<name>exprCollOid</name> <operator>!=</operator> <name>part_col_collation</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation of partition bound value for column \"%s\" does not match partition key collation \"%s\""</literal></expr></argument>,
								   <argument><expr><name>partcolname</name></expr></argument>, <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>part_col_collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>plusexpr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										 <argument><expr><name>plusexpr</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>plusexpr</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>part_col_typid</name></expr></argument>,
										 <argument><expr><name>part_col_typmod</name></expr></argument>,
										 <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
										 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>plusexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specified value cannot be cast to type %s for column \"%s\""</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>part_col_typid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partcolname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>new_boundspec</name><operator>-&gt;</operator><name>partEvery</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>plusexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>boundSpec</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>new_boundspec</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transform the GPDB specific partition definition.
 *
 * The transforms include:
 * - Split partDefElems and encClauses
 * - Sort partDefElems so that DEFAULT PARTITION always appears first
 * - Transform the partDefElems for RANGE and LIST strategy
 *
 * Returns a transformed GpPartitionDefinition.
 */</comment>
<function><type><name>GpPartitionDefinition</name> <modifier>*</modifier></type>
<name>transformGpPartitionDefinition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
							   <parameter><decl><type><name>GpPartitionDefinition</name> <modifier>*</modifier></type><name>gpPartDef</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPartitionDefinition</name>	<modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> 				<name>parentrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>				<modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name>				<modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>					<modifier>*</modifier></type><name>partDefElems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>					<modifier>*</modifier></type><name>encClauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPartDefElem</name>			<modifier>*</modifier></type><name>defaultPartDefElem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> 			<name>partkey</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GpPartitionDefinition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>gpPartDef</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isTemplate</name></name> <operator>=</operator> <name><name>gpPartDef</name><operator>-&gt;</operator><name>isTemplate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>fromCatalog</name></name> <operator>=</operator> <name><name>gpPartDef</name><operator>-&gt;</operator><name>fromCatalog</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>gpPartDef</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>parentrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>parentrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partkey</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expressions in partition key not supported in legacy GPDB partition syntax"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there is a DEFAULT PARTITION, move it to the front of the list.
	 *
	 * This is to keep the partition naming consistent with historic behavior.
	 * In GPDB 6 and below, the default partition is always numbered 1,
	 * regardless of where in the command it is listed. In other words, it is
	 * always given number 1 in the "partcomp" struct . The default partition
	 * itself always has a name, so the partition number isn't used for it,
	 * but it affects the numbering of all the other partitions.
	 *
	 * The main reason we work so hard to keep the naming the same as in
	 * GPDB 6 is to keep the regression tests that refer to partitions by
	 * name after creating them with the legacy partitioning syntax unchanged.
	 * And conceivably there might be users relying on it on real systems,
	 * too.
	 */</comment>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gpPartDef-&gt;partDefElems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	<modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	<modifier>*</modifier></type><name>newnode</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>GpPartDefElem</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GpPartDefElem</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>GpPartDefElem</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * This was not allowed pre-GPDB7, so keeping the same
			 * restriction. Ideally, we can easily support it now based on how
			 * template is stored. I wish to not open up new cases with legacy
			 * syntax than we supported in past, hence keeping the restriction
			 * in-place.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>gpPartDef</name><operator>-&gt;</operator><name>isTemplate</name></name> <operator>&amp;&amp;</operator> <name><name>elem</name><operator>-&gt;</operator><name>colencs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition specific ENCODING clause not supported in SUBPARTITION TEMPLATE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>isDefault</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>defaultPartDefElem</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple default partitions are not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>defaultPartDefElem</name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>partDefElems</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>partDefElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>partDefElems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>partDefElems</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * GPDB_12_MERGE_FIXME: can we optimize grammar to create separate lists
			 * for elems and encoding in encClauses.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>encClauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>encClauses</name></expr></argument>, <argument><expr><name>newnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>partDefElems</name></name> <operator>=</operator> <name>partDefElems</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>encClauses</name></name> <operator>=</operator> <name>encClauses</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partDefElems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>			<modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpPartDefElem</name>	<modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>GpPartDefElem</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elem</name><operator>-&gt;</operator><name>isDefault</name></name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>partkey</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
					<expr_stmt><expr><call><name>transformGpPartDefElemWithRangeSpec</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
					<expr_stmt><expr><call><name>transformGpPartDefElemWithListSpec</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Not supported partition strategy"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a list of CreateStmts, to create partitions based on transformed
 * 'gpPartDef' specification.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>generatePartitions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentrelid</name></decl></parameter>, <parameter><decl><type><name>GpPartitionDefinition</name> <modifier>*</modifier></type><name>gpPartSpec</name></decl></parameter>,
				   <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>subPartSpec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentoptions</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parentaccessmethod</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentattenc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>addpartition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parentrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ancestors</name> <init>= <expr><call><name>get_partition_ancestors</name><argument_list>(<argument><expr><name>parentrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>partname_comp</name></type> <name>partcomp</name> <init>= <expr><block>{<expr><operator>.</operator><name>tablename</name><operator>=</operator><name>NULL</name></expr>, <expr><operator>.</operator><name>level</name><operator>=</operator><literal type="number">0</literal></expr>, <expr><operator>.</operator><name>partnum</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isSubTemplate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>penc_cls</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>parent_tblenc</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasImplicitRangeBounds</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>partcomp</name><operator>.</operator><name>level</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>parentrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>parentrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove "tablename" cell from parentOptions, if exists */</comment>
	<expr_stmt><expr><call><name>extract_tablename_from_options</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parentoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check subpartition specs */</comment>
	<if_stmt><if>if <condition>(<expr><name>subPartSpec</name> <operator>&amp;&amp;</operator> <name><name>subPartSpec</name><operator>-&gt;</operator><name>gpPartDef</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subPartSpec</name><operator>-&gt;</operator><name>gpPartDef</name><operator>-&gt;</operator><name>isTemplate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isSubTemplate</name> <operator>=</operator> <name><name>subPartSpec</name><operator>-&gt;</operator><name>gpPartDef</name><operator>-&gt;</operator><name>isTemplate</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parentattenc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parent_tblenc</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parent_tblenc</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gpPartSpec-&gt;encClauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>penc_cls</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>penc_cls</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Merge encoding specified for parent table level and partition
	 * configuration level. (Each partition element level encoding will be
	 * merged later to this). For example:
	 *
	 * create table example (i int, j int, DEFAULT COLUMN ENCODING (compresstype=zlib))
	 * with (appendonly = true, orientation=column) distributed by (i)
	 * partition by range(j)
	 * (partition p1 start(1) end(10), partition p2 start(10) end (20),
	 *  COLUMN j ENCODING (compresstype=rle_type));
	 *
	 * merged result will be column i having zlib and column j having
	 * rle_type.
	 */</comment>
	<expr_stmt><expr><name>penc_cls</name> <operator>=</operator> <call><name>merge_partition_encoding</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>penc_cls</name></expr></argument>, <argument><expr><name>parent_tblenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hasImplicitRangeBounds</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gpPartSpec-&gt;partDefElems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>			<modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpPartDefElem</name>	<modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>			<modifier>*</modifier></type><name>new_parts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionSpec</name>	<modifier>*</modifier></type><name>tmpSubPartSpec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>GpPartDefElem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Avoid scribbling on input */</comment>
		<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>GpPartDefElem</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>subPartSpec</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tmpSubPartSpec</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>subPartSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isSubTemplate</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>subSpec</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subpartition configuration conflicts with subpartition template"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>GpPartitionDefinition</name><operator>*</operator><operator>)</operator><name><name>elem</name><operator>-&gt;</operator><name>subSpec</name></name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tmpSubPartSpec</name><operator>-&gt;</operator><name>gpPartDef</name></name> <operator>=</operator> <operator>(</operator><name>GpPartitionDefinition</name><operator>*</operator><operator>)</operator> <name><name>elem</name><operator>-&gt;</operator><name>subSpec</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tmpSubPartSpec</name><operator>-&gt;</operator><name>gpPartDef</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no partitions specified at depth %d"</literal></expr></argument>,
								   <argument><expr><name><name>partcomp</name><operator>.</operator><name>level</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>subPartSpec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>subSpec</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subpartition specification provided but table doesn't have SUBPARTITION BY clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>GpPartitionDefinition</name><operator>*</operator><operator>)</operator><name><name>elem</name><operator>-&gt;</operator><name>subSpec</name></name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* if WITH has "tablename" then it will be used as name for partition */</comment>
		<expr_stmt><expr><name><name>partcomp</name><operator>.</operator><name>tablename</name></name> <operator>=</operator> <call><name>extract_tablename_from_options</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>elem</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>options</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <ternary><condition><expr><name>parentoptions</name></expr> ?</condition><then> <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>parentoptions</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <ternary><condition><expr><name>parentaccessmethod</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>parentaccessmethod</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>, <argument><expr><literal type="string">"ao_column"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>colencs</name></name> <operator>=</operator> <call><name>merge_partition_encoding</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>colencs</name></name></expr></argument>, <argument><expr><name>penc_cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>isDefault</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_parts</name> <operator>=</operator> <call><name>generateDefaultPartition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>tmpSubPartSpec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partcomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>new_parts</name> <operator>=</operator> <call><name>generateRangePartitions</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>,
														<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>tmpSubPartSpec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partcomp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasImplicitRangeBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
					<expr_stmt><expr><name>new_parts</name> <operator>=</operator> <call><name>generateListPartition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>tmpSubPartSpec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partcomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not supported partition strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>new_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * GPDB range partition
	 *
	 * Validate and maybe update range partitions bound here instead of in
	 * check_new_partition_bound(), because we need to modify the lower or upper
	 * bounds for implicit START/END.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasImplicitRangeBounds</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deduceImplicitRangeBounds</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>addpartition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
