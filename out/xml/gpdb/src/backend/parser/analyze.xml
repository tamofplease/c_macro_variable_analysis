<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/parser/analyze.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * analyze.c
 *	  transform the raw parse tree into a query tree
 *
 * For optimizable statements, we are careful to obtain a suitable lock on
 * each referenced table, and other modules of the backend preserve or
 * re-obtain these locks before depending on the results.  It is therefore
 * okay to do significant semantic analysis of these statements.  For
 * utility commands, no locks are obtained here (and if they were, we could
 * not be sure we'd still have them at execution).  Hence the general rule
 * for utility commands is to just dump them into a Query node untransformed.
 * DECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are exceptions because they
 * contain optimizable statements, which we should transform.
 *
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *	src/backend/parser/analyze.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cte.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_param.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbendpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_distribution_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<comment type="block">/* Working state for transformSetOperationTree_internal */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>leafinfos</name></decl>;</decl_stmt>
}</block></struct></type> <name>setop_types_ctx</name>;</typedef>

<typedef>typedef <type><struct>struct <name>QueryNodeSearchContext</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>       <name>found</name></decl>;</decl_stmt>
}</block></struct></type> <name>QueryNodeSearchContext</name>;</typedef>

<comment type="block">/* Hook for plugins to get control at end of parse analysis */</comment>
<decl_stmt><decl><type><name>post_parse_analyze_hook_type</name></type> <name>post_parse_analyze_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformOptionalSelectInto</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformDeleteStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>DeleteStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformInsertStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformInsertRow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmtcols</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>icolumns</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attrnos</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>strip_indirection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type><name>transformOnConflictClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
												 <parameter><decl><type><name>OnConflictClause</name> <modifier>*</modifier></type><name>onConflictClause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>count_rowexpr_columns</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformSelectStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformValuesClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformSetOperationStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformSetOperationTree</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformSetOperationTree_internal</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
												<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>setop_types_ctx</name> <modifier>*</modifier></type><name>setop_types</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>coerceSetOpTypes</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>sop</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>preselected_coltypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>preselected_coltypmods</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>select_setop_types</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>setop_types_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SetOperation</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>selected_types</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>selected_typmods</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>determineRecursiveColTypes</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
									   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>larg</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nrtargetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformUpdateStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>UpdateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformReturningList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformUpdateTargetList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformDeclareCursorStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
										 <parameter><decl><type><name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformExplainStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
								   <parameter><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformCreateTableAsStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
										 <parameter><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformCallStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
								<parameter><decl><type><name>CallStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformLockingClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
								   <parameter><decl><type><name>LockingClause</name> <modifier>*</modifier></type><name>lc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pushedDown</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RAW_EXPRESSION_COVERAGE_TEST</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>test_raw_expression_coverage</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* GPDB definitions follow */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_distkey_by_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setQryDistributionPolicy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>checkCanOptSelectLockingClause</name><parameter_list>(<parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>queryNodeSearch</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sanity_check_on_conflict_update_set_distkey</name><parameter_list>(<parameter><decl><type><name>GpPolicy</name>  <modifier>*</modifier></type><name>policy</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>onconflict_set</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sanity_check_on_conflict_update</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>on_conflict_set</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>on_conflict_where</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * parse_analyze
 *		Analyze a raw parse tree and transform it to Query form.
 *
 * Optionally, information about $n parameter types can be supplied.
 * References to $n indexes not defined by paramTypes[] are disallowed.
 *
 * The result is a Query node.  Optimizable statements require considerable
 * transformation, while utility-type statements are simply hung off
 * a dummy CMD_UTILITY Query node.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>parse_analyze</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
			  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>,
			  <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sourceText</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* required as of 8.4 */</comment>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parse_fixed_parameters</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_queryEnv</name></name> <operator>=</operator> <name>queryEnv</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformTopLevelStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>post_parse_analyze_hook</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parse_analyze_varparams
 *
 * This variant is used when it's okay to deduce information about $n
 * symbol datatypes from context.  The passed-in paramTypes[] array can
 * be modified or enlarged (via repalloc).
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>parse_analyze_varparams</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sourceText</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* required as of 8.4 */</comment>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>parse_variable_parameters</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformTopLevelStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure all is well with parameter types */</comment>
	<expr_stmt><expr><call><name>check_variable_parameters</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>post_parse_analyze_hook</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parse_sub_analyze
 *		Entry point for recursively analyzing a sub-statement.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>parse_sub_analyze</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>,
				  <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>parentCTE</name></decl></parameter>,
				  <parameter><decl><type><name>LockingClause</name> <modifier>*</modifier></type><name>lockclause_from_parent</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>resolve_unknowns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name></name> <operator>=</operator> <name>parentCTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lockclause_from_parent</name></name> <operator>=</operator> <name>lockclause_from_parent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name> <operator>=</operator> <name>resolve_unknowns</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformTopLevelStmt -
 *	  transform a Parse tree into a Query tree.
 *
 * This function is just responsible for transferring statement location data
 * from the RawStmt into the finished Query.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformTopLevelStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* We're at top level, so allow SELECT INTO */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformOptionalSelectInto</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>parseTree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>parseTree</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>parseTree</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformOptionalSelectInto -
 *	  If SELECT has INTO, convert it to CREATE TABLE AS.
 *
 * The only thing we do here that we don't do in transformStmt() is to
 * convert SELECT ... INTO into CREATE TABLE AS.  Since utility statements
 * aren't allowed within larger statements, this is only allowed at the top
 * of the parse tree, and so we only try it before entering the recursive
 * transformStmt() processing.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformOptionalSelectInto</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>am_cursor_retrieve_handler</name> <operator>!=</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>RetrieveStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This is %sa retrieve connection, but the query is %sa RETRIEVE."</literal></expr></argument>,
					   <argument><expr><ternary><condition><expr><name>am_cursor_retrieve_handler</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"not "</literal></expr></else></ternary></expr></argument>,
					   <argument><expr><ternary><condition><expr><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>RetrieveStmt</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"not "</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Greenplum specific behavior:
		 * The implementation of select statement with locking clause
		 * (for update | no key update | share | key share) in postgres
		 * is to hold RowShareLock on tables during parsing stage, and
		 * generate a LockRows plan node for executor to lock the tuples.
		 * It is not easy to lock tuples in Greenplum database, since
		 * tuples may be fetched through motion nodes.
		 *
		 * But when Global Deadlock Detector is enabled, and the select
		 * statement with locking clause contains only one table, we are
		 * sure that there are no motions. For such simple cases, we could
		 * make the behavior just the same as Postgres.
		 *
		 * For extended protocal (like jdbc), we do not try to do such
		 * optimization since these queries will be considered as cursor
		 * and dispatched to reader gangs.
		 */</comment>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_canOptSelectLockingClause</name></name> <operator>=</operator> <call><name>checkCanOptSelectLockingClause</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If it's a set-operation tree, drill down to leftmost SelectStmt */</comment>
		<while>while <condition>(<expr><name>stmt</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>ctas</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ctas</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>parseTree</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctas</name><operator>-&gt;</operator><name>into</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctas</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctas</name><operator>-&gt;</operator><name>is_select_into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remove the intoClause from the SelectStmt.  This makes it safe
			 * for transformSelectStmt to complain if it finds intoClause set
			 * (implying that the INTO appeared in a disallowed place).
			 */</comment>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>parseTree</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ctas</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>canOptSelectLockingClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_canOptSelectLockingClause</name></name></expr>;</expr_stmt>

	<return>return <expr><name>q</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformStmt -
 *	  recursively transform a Parse tree into a Query tree.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We apply RAW_EXPRESSION_COVERAGE_TEST testing to basic DML statements;
	 * we can't just run it on everything because raw_expression_tree_walker()
	 * doesn't claim to handle utility statements.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RAW_EXPRESSION_COVERAGE_TEST</name></cpp:ifdef>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>test_raw_expression_coverage</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* RAW_EXPRESSION_COVERAGE_TEST */</comment>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Optimizable statements
			 */</comment>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformInsertStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>InsertStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformDeleteStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>DeleteStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformUpdateStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>UpdateStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>valuesLists</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformValuesClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformSelectStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformSetOperationStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/*
			 * Special cases
			 */</comment>
		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformDeclareCursorStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformExplainStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformCreateTableAsStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformCallStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>CallStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>

			<comment type="block">/*
			 * other statements don't require any transformation; just return
			 * the original parsetree with a Query node plastered on top.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Mark as original query until we learn differently */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>querySource</name></name> <operator>=</operator> <name>QSRC_ORIGINAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasDynamicFunction</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hasDynamicFunctions</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * analyze_requires_snapshot
 *		Returns true if a snapshot must be set before doing parse analysis
 *		on the given raw parse tree.
 *
 * Classification here should match transformStmt().
 */</comment>
<function><type><name>bool</name></type>
<name>analyze_requires_snapshot</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>parseTree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Optimizable statements
			 */</comment>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Special cases
			 */</comment>
		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<comment type="block">/* yes, because we must analyze the contained statement */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* other utility statements don't have any real parse analysis */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformDeleteStmt -
 *	  transforms a Delete Statement
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformDeleteStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>DeleteStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_DELETE</name></expr>;</expr_stmt>

	<comment type="block">/* process the WITH clause independently of all else */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since GPDB currently only support a single writer gang, only one
		 * writable clause is permitted per CTE. Once we get flexible gangs
		 * with more than one writer gang we can lift this restriction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"writable CTE queries cannot be themselves writable"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Greenplum Database currently only support CTEs with one writable clause, called in a non-writable context."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Rewrite the query to only include one writable clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set up range table with just the result rel */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <call><name>setTargetTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
										 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>ACL_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* grab the namespace item made by setTargetTable */</comment>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* there's no DISTINCT in DELETE */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* subqueries in USING cannot access the result relation */</comment>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The USING clause is non-standard SQL syntax, and is equivalent in
	 * functionality to the FROM list that can be specified for UPDATE. The
	 * USING keyword is used rather than FROM because FROM is already a
	 * keyword in the DELETE syntax.
	 */</comment>
	<expr_stmt><expr><call><name>transformFromClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remaining clauses can reference the result relation normally */</comment>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
								<argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <call><name>transformReturningList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* done building the range table and jointree */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasFuncsWithExecRestrictions</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasFuncsWithExecRestrictions</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasTblValueExpr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckTableFunctions</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this must be done after collations, for reliable comparison of exprs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformInsertStmt -
 *	  transform an Insert Statement
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformInsertStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>selectStmt</name> <init>= <expr><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>selectStmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>exprList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isGeneralSelect</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_rtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_namespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>icolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attrnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>icols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>attnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isOnConflictUpdate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>targetPerms</name></decl>;</decl_stmt>

	<comment type="block">/* There can't be any outer WITH to worry about */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_ctenamespace</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_INSERT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_insert</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_on_conflict_update</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* process the WITH clause independently of all else */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since GPDB currently only support a single writer gang, only one
		 * writable clause is permitted per CTE. Once we get flexible gangs
		 * with more than one writer gang we can lift this restriction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"writable CTE queries cannot be themselves writable"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Greenplum Database currently only support CTEs with one writable clause, called in a non-writable context."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Rewrite the query to only include one writable clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>override</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>override</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>isOnConflictUpdate</name> <operator>=</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name></name> <operator>&amp;&amp;</operator>
						  <name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have three cases to deal with: DEFAULT VALUES (selectStmt == NULL),
	 * VALUES list, or general SELECT input.  We special-case VALUES, both for
	 * efficiency and so we can handle DEFAULT specifications.
	 *
	 * The grammar allows attaching ORDER BY, LIMIT, FOR UPDATE, or WITH to a
	 * VALUES clause.  If we have any of those, treat it as a general SELECT;
	 * so it will work, but you can't use DEFAULT items together with those.
	 */</comment>
	<expr_stmt><expr><name>isGeneralSelect</name> <operator>=</operator> <operator>(</operator><name>selectStmt</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>selectStmt</name><operator>-&gt;</operator><name>valuesLists</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
									  <name><name>selectStmt</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
									  <name><name>selectStmt</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
									  <name><name>selectStmt</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
									  <name><name>selectStmt</name><operator>-&gt;</operator><name>lockingClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
									  <name><name>selectStmt</name><operator>-&gt;</operator><name>withClause</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a non-nil rangetable/namespace was passed in, and we are doing
	 * INSERT/SELECT, arrange to pass the rangetable/namespace down to the
	 * SELECT.  This can only happen if we are inside a CREATE RULE, and in
	 * that case we want the rule's OLD and NEW rtable entries to appear as
	 * part of the SELECT's rtable, not as outer references for it.  (Kluge!)
	 * The SELECT's joinlist is not affected however.  We must do this before
	 * adding the target table to the INSERT's rtable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isGeneralSelect</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sub_rtable</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sub_namespace</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>sub_rtable</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>		<comment type="block">/* not used, but keep compiler quiet */</comment>
		<expr_stmt><expr><name>sub_namespace</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Greenplum specific behavior.
	 * conflict update may lock tuples on segments and behaves like
	 * update. So we might consider if to upgrade lockmode for this
	 * case.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_on_conflict_update</name></name> <operator>=</operator> <name>isOnConflictUpdate</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must get write lock on INSERT target table before scanning SELECT, else
	 * we will grab the wrong kind of initial lock if the target table is also
	 * mentioned in the SELECT part.  Note that the target table is not added
	 * to the joinlist or namespace.
	 */</comment>
	<expr_stmt><expr><name>targetPerms</name> <operator>=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isOnConflictUpdate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>targetPerms</name> <operator>|=</operator> <name>ACL_UPDATE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <call><name>setTargetTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetPerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Validate stmt-&gt;cols list, or build default list if no list given */</comment>
	<expr_stmt><expr><name>icolumns</name> <operator>=</operator> <call><name>checkInsertTargets</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attrnos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine which variant of INSERT we have.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>selectStmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have INSERT ... DEFAULT VALUES.  We can handle this case by
		 * emitting an empty targetlist --- all columns will be defaulted when
		 * the planner expands the targetlist.
		 */</comment>
		<expr_stmt><expr><name>exprList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>isGeneralSelect</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We make the sub-pstate a child of the outer pstate so that it can
		 * see any Param definitions supplied from above.  Since the outer
		 * pstate's rtable and namespace are presently empty, there are no
		 * side-effects of exposing names the sub-SELECT shouldn't be able to
		 * see.
		 */</comment>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>sub_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>selectQuery</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Process the source SELECT.
		 *
		 * It is important that this be handled just like a standalone SELECT;
		 * otherwise the behavior of SELECT within INSERT might be different
		 * from a stand-alone SELECT. (Indeed, Postgres up through 6.5 had
		 * bugs of just that nature...)
		 *
		 * The sole exception is that we prevent resolving unknown-type
		 * outputs as TEXT.  This does not change the semantics since if the
		 * column type matters semantically, it would have been resolved to
		 * something else anyway.  Doing this lets us resolve such outputs as
		 * the target column's type, which we handle below.
		 */</comment>
		<expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <name>sub_rtable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* sub_rtable has no joins */</comment>
		<expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>sub_namespace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>selectQuery</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>selectStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The grammar should have produced a SELECT */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>selectQuery</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>selectQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected non-SELECT command in INSERT ... SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Make the source be a subquery in the INSERT's rangetable, and add
		 * it to the INSERT's joinlist.
		 */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><name>selectQuery</name></expr></argument>,
											<argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"*SELECT*"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* assume new rte is at end */</comment>
		<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>rtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*----------
		 * Generate an expression list for the INSERT that selects all the
		 * non-resjunk columns from the subquery.  (INSERT's tlist must be
		 * separate from the subquery's tlist because we may add columns,
		 * insert datatype coercions, etc.)
		 *
		 * HACK: unknown-type constants and params in the SELECT's targetlist
		 * are copied up as-is rather than being referenced as subquery
		 * outputs.  This is to ensure that when we try to coerce them to
		 * the target column's datatype, the right things happen (see
		 * special cases in coerce_type).  Otherwise, this fails:
		 *		INSERT INTO foo SELECT 'bar', ... FROM baz
		 *----------
		 */</comment>
		<expr_stmt><expr><name>exprList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>selectQuery-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprList</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Prepare row for assignment to target table */</comment>
		<expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>transformInsertRow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprList</name></expr></argument>,
									  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>,
									  <argument><expr><name>icolumns</name></expr></argument>, <argument><expr><name>attrnos</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>selectStmt</name><operator>-&gt;</operator><name>valuesLists</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Process INSERT ... VALUES with multiple VALUES sublists. We
		 * generate a VALUES RTE holding the transformed expression lists, and
		 * build up a targetlist containing Vars that reference the VALUES
		 * RTE.
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>exprsLists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coltypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coltypmods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colcollations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sublist_length</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>lateral</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>selectStmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>selectStmt-&gt;valuesLists</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Do basic expression transformation (same as a ROW() expr, but
			 * allow SetToDefault at top level)
			 */</comment>
			<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>transformExpressionList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>,
											  <argument><expr><name>EXPR_KIND_VALUES</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * All the sublists must be the same length, *after*
			 * transformation (which might expand '*' into multiple items).
			 * The VALUES RTE can't handle anything different.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>sublist_length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Remember post-transformation length of first sublist */</comment>
				<expr_stmt><expr><name>sublist_length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>sublist_length</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VALUES lists must all be the same length"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sublist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Prepare row for assignment to target table.  We process any
			 * indirection on the target column specs normally but then strip
			 * off the resulting field/array assignment nodes, since we don't
			 * want the parsed statement to contain copies of those in each
			 * VALUES row.  (It's annoying to have to transform the
			 * indirection specs over and over like this, but avoiding it
			 * would take some really messy refactoring of
			 * transformAssignmentIndirection.)
			 */</comment>
			<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>transformInsertRow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>,
										 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>,
										 <argument><expr><name>icolumns</name></expr></argument>, <argument><expr><name>attrnos</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We must assign collations now because assign_query_collations
			 * doesn't process rangetable entries.  We just assign all the
			 * collations independently in each row, and don't worry about
			 * whether they are consistent vertically.  The outer INSERT query
			 * isn't going to care about the collations of the VALUES columns,
			 * so it's not worth the effort to identify a common collation for
			 * each one here.  (But note this does have one user-visible
			 * consequence: INSERT ... VALUES won't complain about conflicting
			 * explicit COLLATEs in a column, whereas the same VALUES
			 * construct in another context would complain.)
			 */</comment>
			<expr_stmt><expr><call><name>assign_list_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>exprsLists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprsLists</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Construct column type/typmod/collation lists for the VALUES RTE.
		 * Every expression in each column has been coerced to the type/typmod
		 * of the corresponding target column or subfield, so it's sufficient
		 * to look at the exprType/exprTypmod of the first row.  We don't care
		 * about the collation labeling, so just fill in InvalidOid for that.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) linitial(exprsLists)</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>coltypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>coltypmods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Ordinarily there can't be any current-level Vars in the expression
		 * lists, because the namespace was empty ... but if we're inside
		 * CREATE RULE, then NEW/OLD references might appear.  In that case we
		 * have to mark the VALUES RTE as LATERAL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>exprsLists</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lateral</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Generate the VALUES RTE
		 */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForValues</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprsLists</name></expr></argument>,
										  <argument><expr><name>coltypes</name></expr></argument>, <argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><name>colcollations</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lateral</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* assume new rte is at end */</comment>
		<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>rtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate list of Vars referencing the RTE
		 */</comment>
		<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Re-apply any indirection on the target column specs to the Vars
		 */</comment>
		<expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>transformInsertRow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprList</name></expr></argument>,
									  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>,
									  <argument><expr><name>icolumns</name></expr></argument>, <argument><expr><name>attrnos</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Process INSERT ... VALUES with a single VALUES sublist.  We treat
		 * this case separately for efficiency.  The sublist is just computed
		 * directly as the Query's targetlist, with no VALUES RTE.  So it
		 * works just like a SELECT without any FROM.
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>valuesLists</name> <init>= <expr><name><name>selectStmt</name><operator>-&gt;</operator><name>valuesLists</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>valuesLists</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>selectStmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do basic expression transformation (same as a ROW() expr, but allow
		 * SetToDefault at top level)
		 */</comment>
		<expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>transformExpressionList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>valuesLists</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>EXPR_KIND_VALUES_SINGLE</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare row for assignment to target table */</comment>
		<expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>transformInsertRow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprList</name></expr></argument>,
									  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>,
									  <argument><expr><name>icolumns</name></expr></argument>, <argument><expr><name>attrnos</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Generate query's target list using the computed list of expressions.
	 * Also, mark all the target columns as needing insert permissions.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forthree</name><argument_list>(<argument>lc</argument>, <argument>exprList</argument>, <argument>icols</argument>, <argument>icolumns</argument>, <argument>attnos</argument>, <argument>attrnos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>col</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>, <argument><expr><name>icols</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attr_num</name> <init>= <expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>attnos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
							  <argument><expr><name>attr_num</name></expr></argument>,
							  <argument><expr><name><name>col</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>,
										   <argument><expr><name>attr_num</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Process ON CONFLICT, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>=</operator> <call><name>transformOnConflictClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Greenplum specific behavior.
	 * OnConflictUpdate may modify the distkey of the table,
	 * this can lead to wrong data distribution. Add a check
	 * here and raise error for such case.
	 * This fixes the github issue: https://github.com/greenplum-db/gpdb/issues/9444
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isOnConflictUpdate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sanity_check_on_conflict_update</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
													<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
													<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we have a RETURNING clause, we need to add the target relation to
	 * the query namespace before processing it, so that Var references in
	 * RETURNING will work.  Also, remove any namespace entries added in a
	 * sub-SELECT or VALUES list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <call><name>transformReturningList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* done building the range table and jointree */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasFuncsWithExecRestrictions</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasFuncsWithExecRestrictions</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare an INSERT row for assignment to the target table.
 *
 * exprlist: transformed expressions for source values; these might come from
 * a VALUES row, or be Vars referencing a sub-SELECT or VALUES RTE output.
 * stmtcols: original target-columns spec for INSERT (we just test for NIL)
 * icolumns: effective target-columns spec (list of ResTarget)
 * attrnos: integer column numbers (must be same length as icolumns)
 * strip_indirection: if true, remove any field/array assignment nodes
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformInsertRow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmtcols</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>icolumns</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attrnos</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>strip_indirection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>icols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>attnos</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check length of expr list.  It must not have more expressions than
	 * there are target columns.  We allow fewer, but only if no explicit
	 * columns list was given (the remaining columns are implicitly
	 * defaulted).  Note we must check this *after* transformation because
	 * that could expand '*' into multiple items.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSERT has more expressions than target columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>,
														  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>stmtcols</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can get here for cases like INSERT ... SELECT (a,b,c) FROM ...
		 * where the user accidentally created a RowExpr instead of separate
		 * columns.  Add a suitable hint if that seems to be the problem,
		 * because the main error message is quite misleading for this case.
		 * (If there's no stmtcols, you'll get something about data type
		 * mismatch, which is less misleading so we don't worry about giving a
		 * hint in that case.)
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSERT has more target columns than expressions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				   <call><name>count_rowexpr_columns</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator>
				   <call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
				  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The insertion source is a row expression containing the same number of columns expected by the INSERT. Did you accidentally use extra parentheses?"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>,
														  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prepare columns for assignment to target table.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>forthree</name><argument_list>(<argument>lc</argument>, <argument>exprlist</argument>, <argument>icols</argument>, <argument>icolumns</argument>, <argument>attnos</argument>, <argument>attrnos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>col</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>, <argument><expr><name>icols</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>attnos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformAssignedExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
									 <argument><expr><name>EXPR_KIND_INSERT_TARGET</name></expr></argument>,
									 <argument><expr><name><name>col</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									 <argument><expr><name>attno</name></expr></argument>,
									 <argument><expr><name><name>col</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>,
									 <argument><expr><name><name>col</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>strip_indirection</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><name>expr</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<break>break;</break></block_content></block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformOnConflictClause -
 *	  transforms an OnConflictClause in an INSERT
 */</comment>
<function><type><specifier>static</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type>
<name>transformOnConflictClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						  <parameter><decl><type><name>OnConflictClause</name> <modifier>*</modifier></type><name>onConflictClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arbiterElems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arbiterWhere</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>arbiterConstraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>onConflictSet</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>onConflictWhere</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>exclRte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>exclRelIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>exclRelTlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Process the arbiter clause, ON CONFLICT ON (...) */</comment>
	<expr_stmt><expr><call><name>transformOnConflictArbiter</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>onConflictClause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arbiterElems</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>arbiterWhere</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arbiterConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process DO UPDATE */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onConflictClause</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrel</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * All INSERT expressions have been parsed, get ready for potentially
		 * existing SET statements that need to be processed like an UPDATE.
		 */</comment>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_insert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add range table entry for the EXCLUDED pseudo relation.  relkind is
		 * set to composite to signal that we're not dealing with an actual
		 * relation, and no permission checks are required on it.  (We'll
		 * check the actual target relation, instead.)
		 */</comment>
		<comment type="block">/*
		 * GPDB spec. The lockmode of actual target relation might be upgraded.
		 * The pseudo one should follow it to avoid involving another lockmode
		 * which is not the appropriate.
		 */</comment>
		<expr_stmt><expr><name>exclRte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><name>targetrel</name></expr></argument>,
												<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name></expr></argument>, <comment type="block">/* GPDB */</comment>
												<argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"excluded"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>exclRte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>exclRte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* other permissions fields in exclRte are already empty */</comment>

		<expr_stmt><expr><name>exclRelIndex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create EXCLUDED rel's targetlist for use by EXPLAIN */</comment>
		<expr_stmt><expr><name>exclRelTlist</name> <operator>=</operator> <call><name>BuildOnConflictExcludedTargetlist</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>,
														 <argument><expr><name>exclRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add EXCLUDED and the target RTE to the namespace, so that they can
		 * be used in the UPDATE subexpressions.
		 */</comment>
		<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exclRte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now transform the UPDATE subexpressions.
		 */</comment>
		<expr_stmt><expr><name>onConflictSet</name> <operator>=</operator>
			<call><name>transformUpdateTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>onConflictClause</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>onConflictWhere</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											   <argument><expr><name><name>onConflictClause</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
											   <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Finally, build ON CONFLICT DO [NOTHING | UPDATE] expression */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>OnConflictExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name><name>onConflictClause</name><operator>-&gt;</operator><name>action</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>arbiterElems</name></name> <operator>=</operator> <name>arbiterElems</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>arbiterWhere</name></name> <operator>=</operator> <name>arbiterWhere</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>constraint</name></name> <operator>=</operator> <name>arbiterConstraint</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <name>onConflictSet</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator> <name>onConflictWhere</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>exclRelIndex</name></name> <operator>=</operator> <name>exclRelIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>exclRelTlist</name></name> <operator>=</operator> <name>exclRelTlist</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildOnConflictExcludedTargetlist
 *		Create target list for the EXCLUDED pseudo-relation of ON CONFLICT,
 *		representing the columns of targetrel with varno exclRelIndex.
 *
 * Note: Exported for use in the rewriter.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>BuildOnConflictExcludedTargetlist</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>targetrel</name></decl></parameter>,
								  <parameter><decl><type><name>Index</name></type> <name>exclRelIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note that resnos of the tlist must correspond to attnos of the
	 * underlying relation, hence we need entries for dropped columns too.
	 */</comment>
	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>targetrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * can't use atttypid here, but it doesn't really matter what type
			 * the Const claims to be.
			 */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>exclRelIndex</name></expr></argument>, <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
						  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
							 <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>name</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Add a whole-row-Var entry to support references to "EXCLUDED.*".  Like
	 * the other entries in the EXCLUDED tlist, its resno must match the Var's
	 * varattno, else the wrong things happen while resolving references in
	 * setrefs.c.  This is against normal conventions for targetlists, but
	 * it's okay since we don't use this as a real tlist.
	 */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>exclRelIndex</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
				  <argument><expr><name><name>targetrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * count_rowexpr_columns -
 *	  get number of columns contained in a ROW() expression;
 *	  return -1 if expression isn't a RowExpr or a Var referencing one.
 *
 * This is currently used only for hint purposes, so we aren't terribly
 * tense about recognizing all possible cases.  The Var case is interesting
 * because that's what we'll get in the INSERT ... SELECT (...) case.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_rowexpr_columns</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Subselect-in-FROM: examine sub-select's output expr */</comment>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ste</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformSelectStmt -
 *	  transforms a Select Statement
 *
 * Note: this covers only cases with no set operations and no VALUES lists;
 * see below for the other cases.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformSelectStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<comment type="block">/* process the WITH clause independently of all else */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Complain if we get called from someplace where INTO is not allowed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT ... INTO is not allowed here"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* make FOR UPDATE/FOR SHARE info available to addRangeTableEntry */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_locking_clause</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr>;</expr_stmt>

	<comment type="block">/* make WINDOW info available for window functions, too */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_windowdefs</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>

	<comment type="block">/* process the FROM clause */</comment>
	<expr_stmt><expr><call><name>transformFromClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* transform targetlist */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>transformTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mark column origins */</comment>
	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* transform WHERE */</comment>
	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
								<argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initial processing of HAVING clause is much like WHERE clause */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>havingClause</name></name></expr></argument>,
										   <argument><expr><name>EXPR_KIND_HAVING</name></expr></argument>, <argument><expr><literal type="string">"HAVING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transform sorting/grouping stuff.  Do ORDER BY first because both
	 * transformGroupClause and transformDistinctClause need the results. Note
	 * that these functions can also change the targetList, so it's passed to
	 * them by reference.
	 */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>transformSortClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument> <comment type="block">/* allow SQL92 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>transformGroupClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
											<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
											<argument><expr><name>EXPR_KIND_GROUP_BY</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument> <comment type="block">/* allow SQL92 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SCATTER BY clause on a table function TableValueExpr subquery.
	 *
	 * Note: a given subquery cannot have both a SCATTER clause and an INTO
	 * clause, because both of those control distribution.  This should not
	 * possible due to grammar restrictions on where a SCATTER clause is
	 * allowed.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>scatterClause</name></name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>scatterClause</name></name> <operator>=</operator> <call><name>transformScatterClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>scatterClause</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We had SELECT DISTINCT */</comment>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <call><name>transformDistinctClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													  <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We had SELECT DISTINCT ON */</comment>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <call><name>transformDistinctOnClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
														<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* transform LIMIT */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
											<argument><expr><name>EXPR_KIND_OFFSET</name></expr></argument>, <argument><expr><literal type="string">"OFFSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
										   <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>, <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* transform window clauses after we have seen all window functions */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <call><name>transformWindowDefinitions</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_windowdefs</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* resolve any still-unresolved output columns as being type text */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolveTargetListUnknowns</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasFuncsWithExecRestrictions</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasFuncsWithExecRestrictions</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasTblValueExpr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckTableFunctions</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;lockingClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>transformLockingClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this must be done after collations, for reliable comparison of exprs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformValuesClause -
 *	  transforms a VALUES clause that's being used as a standalone SELECT
 *
 * We build a Query containing a VALUES RTE, rather as if one had written
 *			SELECT * FROM (VALUES ...) AS "*VALUES*"
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformValuesClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>exprsLists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coltypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coltypmods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colcollations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>colexprs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublist_length</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lateral</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<comment type="block">/* Most SELECT stuff doesn't apply in a VALUES clause */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>havingClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>scatterClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* process the WITH clause independently of all else */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For each row of VALUES, transform the raw expressions.
	 *
	 * Note that the intermediate representation we build is column-organized
	 * not row-organized.  That simplifies the type and collation processing
	 * below.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;valuesLists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Do basic expression transformation (same as a ROW() expr, but here
		 * we disallow SetToDefault)
		 */</comment>
		<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>transformExpressionList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_VALUES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * All the sublists must be the same length, *after* transformation
		 * (which might expand '*' into multiple items).  The VALUES RTE can't
		 * handle anything different.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sublist_length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Remember post-transformation length of first sublist */</comment>
			<expr_stmt><expr><name>sublist_length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* and allocate array for per-column lists */</comment>
			<expr_stmt><expr><name>colexprs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>sublist_length</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>sublist_length</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VALUES lists must all be the same length"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sublist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Build per-column expression lists */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>sublist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Release sub-list's cells to save memory */</comment>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now resolve the common types of the columns, and coerce everything to
	 * those types.  Then identify the common typmod and common collation, if
	 * any, of each column.
	 *
	 * We must do collation processing now because (1) assign_query_collations
	 * doesn't process rangetable entries, and (2) we need to label the VALUES
	 * RTE with column collations for use in the outer query.  We don't
	 * consider conflict of implicit collations to be an error here; instead
	 * the column will just show InvalidOid as its collation, and you'll get a
	 * failure later if that results in failure to resolve a collation.
	 *
	 * Note we modify the per-column expression lists in-place.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sublist_length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>coltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>coltypmod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colcoll</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"VALUES"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colexprs[i]</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>, <argument><expr><literal type="string">"VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>col</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* As soon as we see a non-matching typmod, fall back to -1 */</comment>
				<if_stmt><if>if <condition>(<expr><name>coltypmod</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>coltypmod</name> <operator>!=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>colcoll</name> <operator>=</operator> <call><name>select_common_collation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>coltypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coltypmods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>, <argument><expr><name>colcoll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Finally, rearrange the coerced expressions into row-organized lists.
	 */</comment>
	<expr_stmt><expr><name>exprsLists</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colexprs[<literal type="number">0</literal>]</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exprsLists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprsLists</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>colexprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sublist_length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>colexprs[i]</argument>, <argument>lc2</argument>, <argument>exprsLists</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* sublist pointer in exprsLists won't need adjustment */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Ordinarily there can't be any current-level Vars in the expression
	 * lists, because the namespace was empty ... but if we're inside CREATE
	 * RULE, then NEW/OLD references might appear.  In that case we have to
	 * mark the VALUES RTE as LATERAL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>exprsLists</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lateral</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Generate the VALUES RTE
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForValues</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprsLists</name></expr></argument>,
									  <argument><expr><name>coltypes</name></expr></argument>, <argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><name>colcollations</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lateral</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* assume new rte is at end */</comment>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate a targetlist as though expanding "*"
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>expandRelAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The grammar allows attaching ORDER BY, LIMIT, and FOR UPDATE to a
	 * VALUES, so cope.
	 */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>transformSortClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument> <comment type="block">/* allow SQL92 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
											<argument><expr><name>EXPR_KIND_OFFSET</name></expr></argument>, <argument><expr><literal type="string">"OFFSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
										   <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>, <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to VALUES"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator>
									  <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasFuncsWithExecRestrictions</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasFuncsWithExecRestrictions</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformSetOperationStmt -
 *	  transforms a set-operations tree
 *
 * A set-operation tree is just a SELECT, but with UNION/INTERSECT/EXCEPT
 * structure to it.  We must transform each leaf SELECT and build up a top-
 * level Query that contains the leaf SELECTs as subqueries in its rangetable.
 * The tree of set operations is converted into the setOperations field of
 * the top-level Query.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformSetOperationStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>leftmostSelect</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftmostRTI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>leftmostQuery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>sostmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>limitOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>limitCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lockingClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WithClause</name> <modifier>*</modifier></type><name>withClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>left_tlist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lct</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lcm</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lcc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetvars</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>targetnames</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>sv_namespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sv_rtable_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jrte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tllen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find leftmost leaf SelectStmt.  We currently only need to do this in
	 * order to deliver a suitable error message if there's an INTO clause
	 * there, implying the set-op tree is in a context that doesn't allow
	 * INTO.  (transformSetOperationTree would throw error anyway, but it
	 * seems worth the trouble to throw a different error for non-leftmost
	 * INTO, so we produce that error in transformSetOperationTree.)
	 */</comment>
	<expr_stmt><expr><name>leftmostSelect</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>leftmostSelect</name> <operator>&amp;&amp;</operator> <name><name>leftmostSelect</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leftmostSelect</name> <operator>=</operator> <name><name>leftmostSelect</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostSelect</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftmostSelect</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <name><name>leftmostSelect</name><operator>-&gt;</operator><name>larg</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>leftmostSelect</name><operator>-&gt;</operator><name>intoClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT ... INTO is not allowed here"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>leftmostSelect</name><operator>-&gt;</operator><name>intoClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We need to extract ORDER BY and other top-level clauses here and not
	 * let transformSetOperationTree() see them --- else it'll just recurse
	 * right back here!
	 */</comment>
	<expr_stmt><expr><name>sortClause</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>limitOffset</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>limitCount</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockingClause</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>withClause</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* We don't support FOR UPDATE/SHARE with set ops at the moment. */</comment>
	<if_stmt><if>if <condition>(<expr><name>lockingClause</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with UNION/INTERSECT/EXCEPT"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator>
									  <call><name>linitial</name><argument_list>(<argument><expr><name>lockingClause</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Process the WITH clause independently of all else */</comment>
	<if_stmt><if>if <condition>(<expr><name>withClause</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Recursively transform the components of the tree.
	 */</comment>
	<expr_stmt><expr><name>sostmt</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>,
					  <argument><expr><call><name>transformSetOperationTree</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sostmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sostmt</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-find leftmost SELECT (now it's a sub-query in rangetable)
	 */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>sostmt</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>larg</name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostRTI</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostQuery</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>leftmostRTI</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subquery</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostQuery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy transformed distribution policy to query */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>intoPolicy</name></name> <operator>=</operator> <name><name>leftmostQuery</name><operator>-&gt;</operator><name>intoPolicy</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate dummy targetlist for outer query using column names of
	 * leftmost select and common datatypes/collations of topmost set
	 * operation.  Also make lists of the dummy vars and their names for use
	 * in parsing ORDER BY.
	 *
	 * Note: we use leftmostRTI as the varno of the dummy variables. It
	 * shouldn't matter too much which RT index they have, as long as they
	 * have one that corresponds to a real RT entry; else funny things may
	 * happen when the tree is mashed by rule rewriting.
	 */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetvars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>forfour</name><argument_list>(<argument>lct</argument>, <argument>sostmt-&gt;colTypes</argument>,
			<argument>lcm</argument>, <argument>sostmt-&gt;colTypmods</argument>,
			<argument>lcc</argument>, <argument>sostmt-&gt;colCollations</argument>,
			<argument>left_tlist</argument>, <argument>leftmostQuery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colType</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>colTypmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colCollation</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>lefttle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>left_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colName</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lefttle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lefttle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>leftmostRTI</name></expr></argument>,
					  <argument><expr><name><name>lefttle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
					  <argument><expr><name>colType</name></expr></argument>,
					  <argument><expr><name>colTypmod</name></expr></argument>,
					  <argument><expr><name>colCollation</name></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>lefttle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							  <argument><expr><name>colName</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetvars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * As a first step towards supporting sort clauses that are expressions
	 * using the output columns, generate a namespace entry that makes the
	 * output columns visible.  A Join RTE node is handy for this, since we
	 * can easily control the Vars generated upon matches.
	 *
	 * Note: we don't yet do anything useful with such cases, but at least
	 * "ORDER BY upper(foo)" will draw the right error message rather than
	 * "foo not found".
	 */</comment>
	<expr_stmt><expr><name>sv_rtable_length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>jrte</name> <operator>=</operator> <call><name>addRangeTableEntryForJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									 <argument><expr><name>targetnames</name></expr></argument>,
									 <argument><expr><name>JOIN_INNER</name></expr></argument>,
									 <argument><expr><name>targetvars</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sv_namespace</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* add jrte to column namespace only */</comment>
	<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>jrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For now, we don't support resjunk sort clauses on the output of a
	 * setOperation tree --- you can only use the SQL92-spec options of
	 * selecting an output column by name or number.  Enforce by checking that
	 * transformSortClause doesn't add any items to tlist.
	 */</comment>
	<expr_stmt><expr><name>tllen</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>transformSortClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><name>sortClause</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument> <comment type="block">/* allow SQL92 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* restore namespace, remove jrte from rtable */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>sv_namespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>sv_rtable_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tllen</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid UNION/INTERSECT/EXCEPT ORDER BY clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only result column names can be used, not expressions or functions."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Add the expression/function to every SELECT, or move the UNION into a FROM clause."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tllen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>limitOffset</name></expr></argument>,
											<argument><expr><name>EXPR_KIND_OFFSET</name></expr></argument>, <argument><expr><literal type="string">"OFFSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>limitCount</name></expr></argument>,
										   <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>, <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasFuncsWithExecRestrictions</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasFuncsWithExecRestrictions</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasTblValueExpr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckTableFunctions</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>lockingClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>transformLockingClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this must be done after collations, for reliable comparison of exprs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformSetOperationTree
 *		Recursively transform leaves and internal nodes of a set-op tree
 *
 * In addition to returning the transformed node, if targetlist isn't NULL
 * then we return a list of its non-resjunk TargetEntry nodes.  For a leaf
 * set-op node these are the actual targetlist entries; otherwise they are
 * dummy entries created to carry the type, typmod, collation, and location
 * (for error messages) of each output column of the set-op node.  This info
 * is needed only during the internal recursion of this function, so outside
 * callers pass NULL for targetlist.  Note: the reason for passing the
 * actual targetlist entries of a leaf node is so that upper levels can
 * replace UNKNOWN Consts with properly-coerced constants.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformSetOperationTree</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>setop_types_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>top</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>selected_types</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>selected_typmods</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Transform all the subtrees.
	 */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>ncols</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>leafinfos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>transformSetOperationTree_internal</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>ncols</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have now transformed all the subtrees, and collected all the
	 * data types and typmods of the columns from each leaf node.
	 *
	 * In PostgreSQL, we also choose the result type for each subtree as we
	 * recurse, but in GPDB, we do that here as a separate pass. That way, we
	 * have can make the decision globally based on every leaf, rather
	 * separately for each subtree.
	 *
	 * There are also some hacks to more leniently coerce between types, to
	 * make some cases not error out.
	 */</comment>
	<expr_stmt><expr><call><name>select_setop_types</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>selected_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>selected_typmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>coerceSetOpTypes</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>selected_types</name></expr></argument>, <argument><expr><name>selected_typmods</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>top</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>select_setop_types</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>setop_types_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SetOperation</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>selected_types</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>selected_typmods</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>selected_types</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>selected_typmods</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>ncols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>typinfos</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>leafinfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lci2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>ptypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>restypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>allsame</name></decl>, <decl><type ref="prev"/><name>hasnontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>context</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>op</name> <operator>==</operator> <name>SETOP_UNION</name></expr> ?</condition><then> <expr><literal type="string">"UNION"</literal></expr> </then><else>:
				   <expr><ternary><condition><expr><name>op</name> <operator>==</operator> <name>SETOP_INTERSECT</name></expr> ?</condition><then> <expr><literal type="string">"INTERSECT"</literal></expr> </then><else>:
				   <expr><literal type="string">"EXCEPT"</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>allsame</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasnontext</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>typinfos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>typinfos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lci2</argument>, <argument>typinfos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ntype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lci2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>ntypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lci2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * In the first iteration, ntype and ptype is the same element,
			 * but we ignore it as it's not a big problem here.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ntype</name> <operator>==</operator> <name>ptype</name> <operator>&amp;&amp;</operator> <name>ntypmod</name> <operator>==</operator> <name>ptypmod</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if any is different, false */</comment>
				<expr_stmt><expr><name>allsame</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/*
			 * MPP-15619 - backwards compatibility with existing view definitions.
			 *
			 * Historically we would cast UNKNOWN to text for most union queries,
			 * but there are many union cases where this historical behavior
			 * resulted in unacceptable errors (MPP-11377).
			 * To handle this we added additional code to resolve to a
			 * consistent cast for unions, which is generally better and
			 * handles more cases.  However, in order to deal with backwards
			 * compatibility we have to deliberately hamstring this code and
			 * cast UNKNOWN to text if the other columns are STRING_TYPE
			 * even when some other datatype (such as name) might actually
			 * be more natural.  This captures the set of views that
			 * we previously supported prior to the fix for MPP-11377 and
			 * thus is the set of views that we must not treat differently.
			 * This might be removed when we are ready to change view definition.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>!=</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator>
				<name>TYPCATEGORY_STRING</name> <operator>!=</operator> <call><name>TypeCategory</name><argument_list>(<argument><expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>ntype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hasnontext</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Backward compatibility; Unfortunately, we cannot change
		 * the old behavior of the part which was working without ERROR,
		 * mostly for the view definition. See comments above for detail.
		 * Setting InvalidOid for this column, the column type resolution
		 * will be falling back to the old process.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasnontext</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>restype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>restypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Even if the types are all the same, we resolve the type
			 * by select_common_type(), which casts domains to base types.
			 * Ideally, the domain types should be preserved, but to keep
			 * compatibility with older GPDB views, currently we don't change it.
			 * This restriction will be solved once upgrade/view issues get clean.
			 * See MPP-7509 for the issue.
			 */</comment>
			<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>typinfos</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * If there's no common type, the last resort is TEXT.
			 * See also select_common_type().
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>restype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>restype</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>restypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Essentially we preserve typmod only when all elements
				 * are identical, otherwise default (-1).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>allsame</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>restypmod</name> <operator>=</operator> <name>ptypmod</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>restypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>selected_types</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>selected_types</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>selected_typmods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>selected_typmods</name></expr></argument>, <argument><expr><name>restypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformSetOperationTree_internal</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>setop_types_ctx</name> <modifier>*</modifier></type><name>setop_types</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isLeaf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex set-expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Validity-check both leaf and internal SELECTs for disallowed ops.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTO is only allowed on first SELECT of UNION/INTERSECT/EXCEPT"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We don't support FOR UPDATE/SHARE with set ops at the moment. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with UNION/INTERSECT/EXCEPT"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator>
									  <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If an internal node of a set-op tree has ORDER BY, LIMIT, FOR UPDATE,
	 * or WITH clauses attached, we need to treat it like a leaf node to
	 * generate an independent sub-Query tree.  Otherwise, it can be
	 * represented by a SetOperationStmt node underneath the parent Query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>rarg</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isLeaf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>rarg</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>isLeaf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>isLeaf</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isLeaf</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Process leaf SELECT */</comment>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>selectQuery</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>selectName</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><name>rte</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Transform SelectStmt into a Query.
		 *
		 * This works the same as SELECT transformation normally would, except
		 * that we prevent resolving unknown-type outputs as TEXT.  This does
		 * not change the subquery's semantics since if the column type
		 * matters semantically, it would have been resolved to something else
		 * anyway.  Doing this lets us resolve such outputs using
		 * select_common_type(), below.
		 *
		 * Note: previously transformed sub-queries don't affect the parsing
		 * of this sub-query, because they are not in the toplevel pstate's
		 * namespace list.
		 */</comment>
		<expr_stmt><expr><name>selectQuery</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for bogus references to Vars on the current query level (but
		 * upper-level references are okay). Normally this can't happen
		 * because the namespace will be empty, but it could happen if we are
		 * inside a rule.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>selectQuery</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UNION/INTERSECT/EXCEPT member statement cannot refer to other relations of same query level"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>locate_var_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>selectQuery</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Extract a list of the non-junk TLEs for upper-level processing.
		 */</comment>
		<expr_stmt><expr><name>numCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>selectQuery-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>numCols</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Also remember the datatype of each column to the lists in
		 * 'setop_types'.
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>setop_types</name><operator>-&gt;</operator><name>ncols</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>setop_types</name><operator>-&gt;</operator><name>ncols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>setop_types</name><operator>-&gt;</operator><name>leafinfos</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>setop_types</name><operator>-&gt;</operator><name>ncols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * It's possible that this leaf query has a different number
			 * of columns than the previous ones. That's an error, but
			 * we don't throw it here because we don't have the context
			 * needed for a good error message. We don't know which
			 * operation of the setop tree is the one where the number
			 * of columns between the left and right branches differ.
			 * Therefore, just return here as if nothing happened, and
			 * we'll catch that error in the parent instead.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>==</operator> <name><name>setop_types</name><operator>-&gt;</operator><name>ncols</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>selectQuery-&gt;targetList</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>setop_types</name><operator>-&gt;</operator><name>leafinfos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>setop_types</name><operator>-&gt;</operator><name>leafinfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
														<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Make the leaf query be a subquery in the top-level rangetable.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>selectName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>selectName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"*SELECT* %d"</literal></expr></argument>,
				 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><name>selectQuery</name></expr></argument>,
											<argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><name>selectName</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Return a RangeTblRef to replace the SelectStmt in the set-op tree.
		 */</comment>
		<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* assume new rte is at end */</comment>
		<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Process an internal node (set operation node) */</comment>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>context</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name></expr> ?</condition><then> <expr><literal type="string">"UNION"</literal></expr> </then><else>:
				   <expr><operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_INTERSECT</name></expr> ?</condition><then> <expr><literal type="string">"INTERSECT"</literal></expr> </then><else>:
					<expr><literal type="string">"EXCEPT"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>all</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Recursively transform the left child node.
		 */</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>transformSetOperationTree_internal</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>setop_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are processing a recursive union query, now is the time to
		 * examine the non-recursive term's output columns and mark the
		 * containing CTE as having those result columns.  We should do this
		 * only at the topmost setop of the CTE, of course.
		 *
		 * In PostgreSQL, transformSetOperationTree() runs as a single pass,
		 * and we coerce the column types as we go. In GPDB, it's a two-pass
		 * process. This function is part of the first pass, where we just
		 * collect datatype information, and in the second pass we coerce
		 * the targetlist of each branch of the setop tree to have compatible
		 * types. Unfortunately, WITH RECURSIVE puts a fly in the ointment.
		 * In order to make the columns of the WITH RECURSIVE itself visible
		 * to the second branch of the UNION, we must fully process the first
		 * branch before the second branch. So if this is WITH RECURSIVE,
		 * proceed with the type coercion after processing the first branch.
		 * We will do another coercion at the top, after processing the second
		 * branch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isTopLevel</name> <operator>&amp;&amp;</operator>
			<name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name></name> <operator>&amp;&amp;</operator>
			<name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name><operator>-&gt;</operator><name>cterecursive</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ltargetlist</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selected_types</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selected_typmods</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>select_setop_types</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>setop_types</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>selected_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>selected_typmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>coerceSetOpTypes</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>selected_types</name></expr></argument>, <argument><expr><name>selected_typmods</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ltargetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>determineRecursiveColTypes</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>ltargetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Recursively transform the right child node.
		 */</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>transformSetOperationTree_internal</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>setop_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In PostgreSQL, we select the common type for each column here.
		 * In GPDB, we do that as a separate pass, after we have collected
		 * information on the types of each leaf node first.
		 */</comment>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>op</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Label every SetOperationStmt in the tree with the given datatypes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>coerceSetOpTypes</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>sop</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>preselected_coltypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>preselected_coltypmods</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>sop</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>sop</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>selectQuery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Extract a list of the non-junk TLEs for upper-level processing.
		 * This is the same we did in the first pass, in
		 * transformSetOperationTree_internal().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>targetlist</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>selectQuery-&gt;targetList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>sop</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ltargetlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtargetlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rtl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pcm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>context</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name></expr> ?</condition><then> <expr><literal type="string">"UNION"</literal></expr> </then><else>:
				   <expr><ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_INTERSECT</name></expr> ?</condition><then> <expr><literal type="string">"INTERSECT"</literal></expr> </then><else>:
				   <expr><literal type="string">"EXCEPT"</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Recurse to determine the children's types first */</comment>
		<expr_stmt><expr><call><name>coerceSetOpTypes</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
						 <argument><expr><name>preselected_coltypes</name></expr></argument>, <argument><expr><name>preselected_coltypmods</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>ltargetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>coerceSetOpTypes</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
						 <argument><expr><name>preselected_coltypes</name></expr></argument>, <argument><expr><name>preselected_coltypmods</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>rtargetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Verify that the two children have the same number of non-junk
		 * columns, and determine the types of the merged output columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>ltargetlist</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rtargetlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"each %s query must have the same number of columns"</literal></expr></argument>,
							<argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtargetlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>preselected_coltypes</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>preselected_coltypmods</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>targetlist</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<comment type="block">/* don't have a "foreach5", so chase three of the lists by hand */</comment>
		<expr_stmt><expr><name>pct</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>preselected_coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pcm</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>preselected_coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>ltl</argument>, <argument>ltargetlist</argument>, <argument>rtl</argument>, <argument>rtargetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ltle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>rtle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rtl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lcolnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ltle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rcolnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rtle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>lcoltype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>rcoltype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>lcoltypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>rcoltypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>bestexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>bestlocation</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>rescoltype</name> <init>= <expr><ternary><condition><expr><name>pct</name></expr> ?</condition><then> <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>pct</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>rescoltypmod</name> <init>= <expr><ternary><condition><expr><name>pcm</name></expr> ?</condition><then> <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>pcm</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>rescolcoll</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the preprocessed coltype is InvalidOid, we fall back
			 * to the old style type resolution for backward
			 * compatibility. See transformSetOperationStmt for the reason.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rescoltype</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* select common type, same as CASE et al */</comment>
				<expr_stmt><expr><name>rescoltype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>context</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>bestexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>bestlocation</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>bestexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* if same type and same typmod, use typmod; else default */</comment>
				<if_stmt><if>if <condition>(<expr><name>lcoltype</name> <operator>==</operator> <name>rcoltype</name> <operator>&amp;&amp;</operator> <name>lcoltypmod</name> <operator>==</operator> <name>rcoltypmod</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rescoltypmod</name> <operator>=</operator> <name>lcoltypmod</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If we used the preselected type, arbitrarily use the left
				 * query's expression for error reporting purposes.
				 */</comment>
				<expr_stmt><expr><name>bestexpr</name> <operator>=</operator> <name>lcolnode</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>bestlocation</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Verify the coercions are actually possible.  If not, we'd fail
			 * later anyway, but we want to fail now while we have sufficient
			 * context to produce an error cursor position.
			 *
			 * For all non-UNKNOWN-type cases, we verify coercibility but we
			 * don't modify the child's expression, for fear of changing the
			 * child query's semantics.
			 *
			 * If a child expression is an UNKNOWN-type Const or Param, we
			 * want to replace it with the coerced expression.  This can only
			 * happen when the child is a leaf set-op node.  It's safe to
			 * replace the expression because if the child query's semantics
			 * depended on the type of this output column, it'd have already
			 * coerced the UNKNOWN to something else.  We want to do this
			 * because (a) we want to verify that a Const is valid for the
			 * target type, or resolve the actual type of an UNKNOWN Param,
			 * and (b) we want to avoid unnecessary discrepancies between the
			 * output type of the child query and the resolved target type.
			 * Such a discrepancy would disable optimization in the planner.
			 *
			 * If it's some other UNKNOWN-type node, eg a Var, we do nothing
			 * (knowing that coerce_to_common_type would fail).  The planner
			 * is sometimes able to fold an UNKNOWN Var to a constant before
			 * it has to coerce the type, so failing now would just break
			 * cases that might work.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>lcoltype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lcolnode</name></expr></argument>,
												 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
					 <call><name>IsA</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>lcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lcolnode</name></expr></argument>,
												 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ltle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lcolnode</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>rcoltype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>,
												 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
					 <call><name>IsA</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>,
												 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rtle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rcolnode</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Select common collation.  A common collation is required for
			 * all set operators except UNION ALL; see SQL:2008 7.13 &lt;query
			 * expression&gt; Syntax Rule 15c.  (If we fail to identify a common
			 * collation for a UNION ALL column, the colCollations element
			 * will be set to InvalidOid, which may result in a runtime error
			 * if something at a higher query level wants to use the column's
			 * collation.)
			 */</comment>
			<expr_stmt><expr><name>rescolcoll</name> <operator>=</operator> <call><name>select_common_collation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												 <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>all</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* emit results */</comment>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name>rescoltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypmods</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypmods</name></name></expr></argument>, <argument><expr><name>rescoltypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>, <argument><expr><name>rescolcoll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * For all cases except UNION ALL, identify the grouping operators
			 * (and, if available, sorting operators) that will be used to
			 * eliminate duplicates.
			 *
			 * A more logical place for this would be in the first pass, but we
			 * can't do this until we've decided the datatypes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_UNION</name> <operator>||</operator> <operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>sortop</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>eqop</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>hashable</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>,
												  <argument><expr><name>bestlocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* determine the eqop and optional sortop */</comment>
				<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>rescoltype</name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* we don't have a tlist yet, so can't assign sortgrouprefs */</comment>
				<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
				<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Construct a dummy tlist entry to return.  We use a SetToDefault
			 * node for the expression, since it carries exactly the fields
			 * needed, but any other expression node type would do as well.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>targetlist</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SetToDefault</name> <modifier>*</modifier></type><name>rescolnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>restle</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>rescoltype</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <name>rescoltypmod</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>rescolcoll</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>bestlocation</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>restle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rescolnode</name></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* no need to set resno */</comment>
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetlist</name></expr></argument>, <argument><expr><name>restle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>pct</name> <operator>=</operator> <ternary><condition><expr><name>pct</name></expr> ?</condition><then> <expr><call><name>lnext</name><argument_list>(<argument><expr><name>pct</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>pcm</name> <operator>=</operator> <ternary><condition><expr><name>pcm</name></expr> ?</condition><then> <expr><call><name>lnext</name><argument_list>(<argument><expr><name>pcm</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process the outputs of the non-recursive term of a recursive union
 * to set up the parent CTE's columns
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>determineRecursiveColTypes</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>larg</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nrtargetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftmostRTI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>leftmostQuery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>left_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nrtl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_resno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find leftmost leaf SELECT
	 */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <name>larg</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>larg</name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostRTI</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostQuery</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>leftmostRTI</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subquery</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostQuery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate dummy targetlist using column names of leftmost select and
	 * dummy result expressions of the non-recursive term.
	 */</comment>
	<expr_stmt><expr><name>targetList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_resno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>nrtl</argument>, <argument>nrtargetlist</argument>, <argument>left_tlist</argument>, <argument>leftmostQuery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>nrtle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>nrtl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>lefttle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>left_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colName</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lefttle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lefttle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name><name>nrtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
							  <argument><expr><name>next_resno</name><operator>++</operator></expr></argument>,
							  <argument><expr><name>colName</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Now build CTE's output column info using dummy targetlist */</comment>
	<expr_stmt><expr><call><name>analyzeCTETargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * transformUpdateStmt -
 *	  transforms an update statement
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformUpdateStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>UpdateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UPDATE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_insert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_on_conflict_update</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* process the WITH clause independently of all else */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since GPDB currently only support a single writer gang, only one
		 * writable clause is permitted per CTE. Once we get flexible gangs
		 * with more than one writer gang we can lift this restriction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"writable CTE queries cannot be themselves writable"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Greenplum Database currently only support CTEs with one writable clause, called in a non-writable context."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Rewrite the query to only include one writable clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <call><name>setTargetTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
										 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>ACL_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* grab the namespace item made by setTargetTable */</comment>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* subqueries in FROM cannot access the result relation */</comment>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * the FROM clause is non-standard SQL syntax. We used to be able to do
	 * this with REPLACE in POSTQUEL so we keep the feature.
	 */</comment>
	<expr_stmt><expr><call><name>transformFromClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remaining clauses can reference the result relation normally */</comment>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
								<argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <call><name>transformReturningList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we are done with SELECT-like processing, and can get on with
	 * transforming the target list to match the UPDATE target columns.
	 */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>transformUpdateTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasFuncsWithExecRestrictions</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasFuncsWithExecRestrictions</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformUpdateTargetList -
 *	handle SET clause in UPDATE/INSERT ... ON CONFLICT UPDATE
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformUpdateTargetList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>origTlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>target_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>orig_tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>transformTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>origTlist</name></expr></argument>,
								<argument><expr><name>EXPR_KIND_UPDATE_SOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare to assign non-conflicting resnos to resjunk attributes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>&lt;=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare non-junk columns for assignment to target table */</comment>
	<expr_stmt><expr><name>target_rte</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>orig_tl</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>origTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>origTarget</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Resjunk nodes need no additional processing, but be sure they
			 * have resnos that do not match any target columns; else rewriter
			 * or planner might get confused.  They don't need a resname
			 * either.
			 */</comment>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>orig_tl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"UPDATE target count mismatch --- internal error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>origTarget</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>, <argument><expr><name>orig_tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>attrno</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>,
							   <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attrno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>updateTargetListEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
							  <argument><expr><name>attrno</name></expr></argument>,
							  <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>,
							  <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark the target column as requiring update permissions */</comment>
		<expr_stmt><expr><name><name>target_rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>target_rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>,
												 <argument><expr><name>attrno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>orig_tl</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>orig_tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>orig_tl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"UPDATE target count mismatch --- internal error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Record in extraUpdatedCols generated columns referencing updated base
	 * columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
		<name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrDefault</name></type> <name>defval</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>defval</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* skip if not generated column */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>defval</name><operator>.</operator><name>adnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>defval</name><operator>.</operator><name>adbin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>target_rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>target_rte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>target_rte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name></expr></argument>,
															  <argument><expr><name><name>defval</name><operator>.</operator><name>adnum</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformReturningList -
 *	handle a RETURNING clause in INSERT/UPDATE/DELETE
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformReturningList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_next_resno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>returningList</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* nothing to do */</comment>

	<comment type="block">/*
	 * We need to assign resnos starting at one in the RETURNING list. Save
	 * and restore the main tlist's value of p_next_resno, just in case
	 * someone looks at it later (probably won't happen).
	 */</comment>
	<expr_stmt><expr><name>save_next_resno</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* transform RETURNING identically to a SELECT targetlist */</comment>
	<expr_stmt><expr><name>rlist</name> <operator>=</operator> <call><name>transformTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>EXPR_KIND_RETURNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Complain if the nonempty tlist expanded to nothing (which is possible
	 * if it contains only a star-expansion of a zero-column table).  If we
	 * allow this, the parsed Query will look like it didn't have RETURNING,
	 * with results that would probably surprise the user.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURNING must have at least one column"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* mark column origins */</comment>
	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* resolve any still-unresolved output columns as being type text */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolveTargetListUnknowns</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* restore state */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <name>save_next_resno</name></expr>;</expr_stmt>

	<return>return <expr><name>rlist</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformDeclareCursorStmt -
 *	transform a DECLARE CURSOR Statement
 *
 * DECLARE CURSOR is like other utility statements in that we emit it as a
 * CMD_UTILITY Query node; however, we must first transform the contained
 * query.  We used to postpone that until execution, but it's really necessary
 * to do it during the normal parse analysis phase to ensure that side effects
 * of parser hooks happen at the expected time.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformDeclareCursorStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_on_conflict_update</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't allow both SCROLL and NO SCROLL to be specified
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_NO_SCROLL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify both SCROLL and NO SCROLL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Transform contained query, not allowing SELECT INTO */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr>;</expr_stmt>

	<comment type="block">/* Grammar should not have allowed anything but SELECT */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected non-SELECT command in DECLARE CURSOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Can not support holdable or scrollable PARALLEL RETRIEVE CURSOR at present */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_HOLD</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_PARALLEL_RETRIEVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE PARALLEL RETRIEVE CURSOR WITH HOLD ... is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Holdable cursors can not be parallel"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_PARALLEL_RETRIEVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SCROLL is not allowed for the PARALLEL RETRIEVE CURSORs"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Scrollable cursors can not be parallel"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We also disallow data-modifying WITH in a cursor.  (This could be
	 * allowed, but the semantics of when the updates occur might be
	 * surprising.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE CURSOR must not contain data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* FOR UPDATE and WITH HOLD are not compatible */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_HOLD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE CURSOR WITH HOLD ... %s is not supported"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator>
									  <call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Holdable cursors must be READ ONLY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* FOR UPDATE and SCROLL are not compatible */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE SCROLL CURSOR ... %s is not supported"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator>
									  <call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Scrollable cursors must be READ ONLY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* FOR UPDATE and INSENSITIVE are not compatible */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_INSENSITIVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE INSENSITIVE CURSOR ... %s is not supported"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator>
									  <call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Insensitive cursors must be READ ONLY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* represent the command as a utility Query */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformExplainStmt -
 *	transform an EXPLAIN Statement
 *
 * EXPLAIN is like other utility statements in that we emit it as a
 * CMD_UTILITY Query node; however, we must first transform the contained
 * query.  We used to postpone that until execution, but it's really necessary
 * to do it during the normal parse analysis phase to ensure that side effects
 * of parser hooks happen at the expected time.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformExplainStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* transform contained query, allowing SELECT INTO */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>transformOptionalSelectInto</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* represent the command as a utility Query */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformCreateTableAsStmt -
 *	transform a CREATE TABLE AS, SELECT ... INTO, or CREATE MATERIALIZED VIEW
 *	Statement
 *
 * As with DECLARE CURSOR and EXPLAIN, transform the contained statement now.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformCreateTableAsStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

	<comment type="block">/* transform contained query, not allowing SELECT INTO */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr>;</expr_stmt>

	<comment type="block">/* additional work needed for CREATE MATERIALIZED VIEW */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>OBJECT_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Prohibit a data-modifying CTE in the query used to create a
		 * materialized view. It's not sufficiently clear what the user would
		 * want to happen if the MV is refreshed or incrementally maintained.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized views must not use data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check whether any temporary database objects are used in the
		 * creation query. It would be hard to refresh data or incrementally
		 * maintain it if a source disappeared.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>isQueryUsingTempRelation</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized views must not use temporary tables or views"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * A materialized view would either need to save parameters for use in
		 * maintaining/loading the data or prohibit them entirely.  The latter
		 * seems safer and more sane.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>query_contains_extern_params</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized views may not be defined using bound parameters"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For now, we disallow unlogged materialized views, because it seems
		 * like a bad idea for them to just go to empty after a crash. (If we
		 * could mark them as unpopulated, that would be better, but that
		 * requires catalog changes which crash recovery can't presently
		 * handle.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized views cannot be unlogged"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * At runtime, we'll need a copy of the parsed-but-not-rewritten Query
		 * for purposes of creating the view's ON SELECT rule.  We stash that
		 * in the IntoClause because that's where intorel_startup() can
		 * conveniently get it from.
		 */</comment>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* represent the command as a utility Query */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>

	<comment type="block">/* GPDB: Set parentStmtType to PARENTSTMTTYPE_CTAS as we know this query is for CTAS */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Query</name><operator>*</operator><operator>)</operator><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name><operator>)</operator><operator>-&gt;</operator><name>parentStmtType</name> <operator>=</operator> <name>PARENTSTMTTYPE_CTAS</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * In binary upgrade mode, we need to create materialize view in utility mode. So we
	 * should enable the setQryDistributionPolicy function in binary upgrade mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>distributedBy</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>IsBinaryUpgrade</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setQryDistributionPolicy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transform a CallStmt
 *
 * We need to do parse analysis on the procedure call and its arguments.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformCallStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CallStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>targs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;funccall-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>targs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targs</name></expr></argument>, <argument><expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>EXPR_KIND_CALL_ARGUMENT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funccall</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
							 <argument><expr><name>targs</name></expr></argument>,
							 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funccall</name></name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funccall</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcexpr</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Produce a string representation of a LockClauseStrength value.
 * This should only be applied to valid values (not LCS_NONE).
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>LCS_asString</name><parameter_list>(<parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>strength</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>LCS_NONE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
			<return>return <expr><literal type="string">"FOR KEY SHARE"</literal></expr>;</return>
		<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
			<return>return <expr><literal type="string">"FOR SHARE"</literal></expr>;</return>
		<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
			<return>return <expr><literal type="string">"FOR NO KEY UPDATE"</literal></expr>;</return>
		<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
			<return>return <expr><literal type="string">"FOR UPDATE"</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><literal type="string">"FOR some"</literal></expr>;</return>			<comment type="block">/* shouldn't happen */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Check for features that are not supported with FOR [KEY] UPDATE/SHARE.
 *
 * exported so planner can check again after rewriting, query pullup, etc
 */</comment>
<function><type><name>void</name></type>
<name>CheckSelectLocking</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strength</name> <operator>!=</operator> <name>LCS_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else caller error */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with UNION/INTERSECT/EXCEPT"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with DISTINCT clause"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with GROUP BY clause"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with HAVING clause"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with aggregate functions"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with window functions"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/*------
		  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with set-returning functions in the target list"</literal></expr></argument>,
						<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a FOR [KEY] UPDATE/SHARE clause
 *
 * This basically involves replacing names by integer relids.
 *
 * NB: if you need to change this, see also markQueryForLocking()
 * in rewriteHandler.c, and isLockedRefname() in parse_relation.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformLockingClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>LockingClause</name> <modifier>*</modifier></type><name>lc</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>pushedDown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lockedRels</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>lockedRels</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockingClause</name> <modifier>*</modifier></type><name>allrels</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CheckSelectLocking</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make a clause we can pass down to subqueries to select all rels */</comment>
	<expr_stmt><expr><name>allrels</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>LockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>allrels</name><operator>-&gt;</operator><name>lockedRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* indicates all rels */</comment>
	<expr_stmt><expr><name><name>allrels</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>allrels</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockedRels</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* all regular tables used in query */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>qry-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTE_RELATION</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>rel_is_external_table</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT FOR UPDATE/SHARE cannot be applied to external tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>,
									   <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT_FOR_UPDATE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
					<expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>,
									   <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * FOR UPDATE/SHARE of subquery is propagated to all of
					 * subquery's rels, too.  We could do this later (based on
					 * the marking of the subquery RTE) but it is convenient
					 * to have local knowledge in each query level about which
					 * rels need to be opened with RowShareLock.
					 */</comment>
					<expr_stmt><expr><call><name>transformLockingClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
										   <argument><expr><name>allrels</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* ignore JOIN, SPECIAL, FUNCTION, VALUES, CTE RTEs */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* just the named tables */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>lockedRels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>thisrel</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* For simplicity we insist on unqualified alias names here */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>thisrel</name><operator>-&gt;</operator><name>catalogname</name></name> <operator>||</operator> <name><name>thisrel</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/*------
				  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s must specify unqualified relation names"</literal></expr></argument>,
								<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>qry-&gt;rtable</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>RTE_RELATION</name></expr>:</case>
							<if_stmt><if>if <condition>(<expr><call><name>rel_is_external_table</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT FOR UPDATE/SHARE cannot be applied to external tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>,
											   <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>, <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT_FOR_UPDATE</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
							<expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>,
											   <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>, <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<comment type="block">/* see comment above */</comment>
							<expr_stmt><expr><call><name>transformLockingClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
												   <argument><expr><name>allrels</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>RTE_JOIN</name></expr>:</case>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<comment type="block">/*------
							  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a join"</literal></expr></argument>,
											<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<comment type="block">/*------
							  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a function"</literal></expr></argument>,
											<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<comment type="block">/*------
							  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a table function"</literal></expr></argument>,
											<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT FOR UPDATE/SHARE cannot be applied to a table function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>RTE_VALUES</name></expr>:</case>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<comment type="block">/*------
							  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to VALUES"</literal></expr></argument>,
											<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>RTE_CTE</name></expr>:</case>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<comment type="block">/*------
							  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a WITH query"</literal></expr></argument>,
											<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<comment type="block">/*------
							  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a named tuplestore"</literal></expr></argument>,
											<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

							<comment type="block">/* Shouldn't be possible to see RTE_RESULT here */</comment>

						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE type: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
					<break>break;</break>		<comment type="block">/* out of foreach loop */</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>rt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/*------
				  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" in %s clause not found in FROM clause"</literal></expr></argument>,
								<argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
								<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record locking info for a single rangetable item
 */</comment>
<function><type><name>void</name></type>
<name>applyLockingClause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>,
				   <parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>, <parameter><decl><type><name>LockWaitPolicy</name></type> <name>waitPolicy</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>pushedDown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strength</name> <operator>!=</operator> <name>LCS_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else caller error */</comment>

	<comment type="block">/* If it's an explicit clause, make sure hasForUpdate gets set */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pushedDown</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasForUpdate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check for pre-existing entry for same rtindex */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>get_parse_rowmark</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the same RTE is specified with more than one locking strength,
		 * use the strongest.  (Reasonable, since you can't take both a shared
		 * and exclusive lock at the same time; it'll end up being exclusive
		 * anyway.)
		 *
		 * Similarly, if the same RTE is specified with more than one lock
		 * wait policy, consider that NOWAIT wins over SKIP LOCKED, which in
		 * turn wins over waiting for the lock (the default).  This is a bit
		 * more debatable but raising an error doesn't seem helpful. (Consider
		 * for instance SELECT FOR UPDATE NOWAIT from a view that internally
		 * contains a plain FOR UPDATE spec.)  Having NOWAIT win over SKIP
		 * LOCKED is reasonable since the former throws an error in case of
		 * coming across a locked tuple, which may be undesirable in some
		 * cases but it seems better than silently returning inconsistent
		 * results.
		 *
		 * And of course pushedDown becomes false if any clause is explicit.
		 */</comment>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>, <argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>, <argument><expr><name>waitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>pushedDown</name></name> <operator>&amp;=</operator> <name>pushedDown</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make a new RowMarkClause */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowMarkClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name>strength</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name>waitPolicy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>pushedDown</name></name> <operator>=</operator> <name>pushedDown</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Coverage testing for raw_expression_tree_walker().
 *
 * When enabled, we run raw_expression_tree_walker() over every DML statement
 * submitted to parse analysis.  Without this provision, that function is only
 * applied in limited cases involving CTEs, and we don't really want to have
 * to test everything inside as well as outside a CTE.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RAW_EXPRESSION_COVERAGE_TEST</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>test_raw_expression_coverage</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>raw_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
									  <argument><expr><name>test_raw_expression_coverage</name></expr></argument>,
									  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* RAW_EXPRESSION_COVERAGE_TEST */</comment>

<comment type="block">/* GPDB statics follow */</comment>
<comment type="block">/*
 * Get distribute key by name.
 *
 * Find the distribute key in into-&gt;colNames if it is not NULL, otherwise
 * search qry-&gt;targetList.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_distkey_by_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>into</name><operator>-&gt;</operator><name>colNames</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>colindex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>into-&gt;colNames</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>colindex</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>colindex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qry-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set Query-&gt;intoPolicy based on the DISTRIBUTED BY clause, in a
 * CREATE TABLE AS statement.
 *
 * This performs some of the same checks and processing that
 * transformDistributedBy() does for a regular CREATE TABLE. There are some
 * differences, however:
 *
 * 1. We form a GpPolicy to represent the DISTRIBUTED BY clause. In a regular
 * CREATE TABLE, we must delay doing that until DefineRelation, after we have
 * merged inherited columns into the table definition, but with CREATE TABLE
 * AS, it's OK, because there is no inheritance.
 *
 * 2. If no DISTRIBUTED BY was given explicitly, we don't try to deduce a
 * default here. We delay that into the planner because we'll have more
 * information available at that point (see cdbllize_adjust_top_path()).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setQryDistributionPolicy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedBy</name> <modifier>*</modifier></type><name>dist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In binary upgrade mode, we need to create materialize view in utility mode. So we
	 * should enable the setQryDistributionPolicy function in binary upgrade mode.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>into</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>distributedBy</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dist</name> <operator>=</operator> <operator>(</operator><name>DistributedBy</name> <operator>*</operator><operator>)</operator><name><name>into</name><operator>-&gt;</operator><name>distributedBy</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dist</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <call><name>GP_POLICY_DEFAULT_NUMSEGMENTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We have a DISTRIBUTED BY column list specified by the user
	 * Process it now and set the distribution policy.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dist</name><operator>-&gt;</operator><name>keyCols</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MaxPolicyAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of distributed by columns exceeds limit (%d)"</literal></expr></argument>,
						<argument><expr><name>MaxPolicyAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dist</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>intoPolicy</name></name> <operator>=</operator> <call><name>createReplicatedGpPolicy</name><argument_list>(<argument><expr><name><name>dist</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	<modifier>*</modifier></type><name>policykeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	<modifier>*</modifier></type><name>policyopclasses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dist-&gt;keyCols</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKeyElem</name>  <modifier>*</modifier></type><name>dkelem</name> <init>= <expr><operator>(</operator><name>DistributionKeyElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>keyindex</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>keytype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>keyopclass</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>keyindex</name> <operator>=</operator> <call><name>get_distkey_by_name</name><argument_list>(<argument><expr><name><name>dkelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" named in DISTRIBUTED BY clause does not exist"</literal></expr></argument>,
								<argument><expr><name><name>dkelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>dkelem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>keyindex</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>keytype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keyopclass</name> <operator>=</operator> <call><name>cdb_get_opclass_for_column_def</name><argument_list>(<argument><expr><name><name>dkelem</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>,
														<argument><expr><name>keytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>policykeys</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>, <argument><expr><name>keyindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>policyopclasses</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>policyopclasses</name></expr></argument>, <argument><expr><name>keyopclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>intoPolicy</name></name> <operator>=</operator> <call><name>createHashPartitionedPolicy</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>,
													  <argument><expr><name>policyopclasses</name></expr></argument>,
													  <argument><expr><name><name>dist</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * checkCanOptSelectLockingClause is used to test
 * whether a select-statement containing locking clause
 * can behave like Postgres. We have to know it before
 * we acquire any locks on the tables.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkCanOptSelectLockingClause</name><parameter_list>(<parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueryNodeSearchContext</name></type> <name>ctx</name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_enable_global_deadlock_detector</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The disableLockingOptimization field is set true
	 * in exec_parse_message to mark queries that using extended
	 * protocal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>disableLockingOptimization</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * TODO: if future ORCA can emit LockRows plannode,
	 * we should remove such restriction here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>optimizer</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>raw_expression_tree_walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
									  <argument><expr><name>queryNodeSearch</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>ctx</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>found</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>queryNodeSearch</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>QueryNodeSearchContext</name> <operator>*</operator><operator>)</operator><name>context</name><operator>)</operator><operator>-&gt;</operator><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sanity_check_on_conflict_update_set_distkey</name><parameter_list>(<parameter><decl><type><name>GpPolicy</name>  <modifier>*</modifier></type><name>policy</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>onconflict_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>  <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>dist_cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>conflict_update_cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dist_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>dist_cols</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>onconflict_set</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>conflict_update_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>conflict_update_cols</name></expr></argument>,
											  <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>bms_intersect</name><argument_list>(<argument><expr><name>dist_cols</name></expr></argument>, <argument><expr><name>conflict_update_cols</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modification of distribution columns in OnConflictUpdate is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sanity_check_on_conflict_update</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>on_conflict_set</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>on_conflict_where</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicy</name>  <modifier>*</modifier></type><name>policy</name> <init>= <expr><call><name>GpPolicyFetch</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>POLICYTYPE_PARTITIONED</name></expr>:</case>
			<expr_stmt><expr><call><name>sanity_check_on_conflict_update_set_distkey</name><argument_list>(<argument><expr><name>policy</name></expr></argument>, <argument><expr><name>on_conflict_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>POLICYTYPE_REPLICATED</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>on_conflict_set</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>on_conflict_where</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modification of replicated tables containing volatile functions in OnConflictUpdate is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>
</unit>
