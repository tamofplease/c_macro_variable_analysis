<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/interfaces/ecpg/pgtypeslib/interval.c"><comment type="block">/* src/interfaces/ecpg/pgtypeslib/interval.c */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__FAST_MATH__</name></cpp:ifdef>
<cpp:error>#<cpp:directive>error</cpp:directive> -ffast-math is known to break this code</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtypeslib_extern.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtypes_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtypes_interval.h"</cpp:file></cpp:include>

<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c
 * and changesd struct pg_tm to struct tm
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustFractSeconds</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>frac</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <comment type="block">/* pg_ */</comment> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>frac</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>frac</name> <operator>*=</operator> <name>scale</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>frac</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>sec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>frac</name> <operator>-=</operator> <name>sec</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>frac</name> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c
 * and changesd struct pg_tm to struct tm
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustFractDays</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>frac</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <comment type="block">/* pg_ */</comment> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>extra_days</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>frac</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>frac</name> <operator>*=</operator> <name>scale</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>extra_days</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>frac</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>extra_days</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>frac</name> <operator>-=</operator> <name>extra_days</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>frac</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ParseISO8601Number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ipart</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>fpart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* did we not see anything that looks like a double? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <name>str</name> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* watch out for overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>val</name> <argument_list type="generic">&lt; <argument><expr><name>INT_MIN</name> <operator>||</operator> <name>val</name></expr></argument> &gt;</argument_list></name> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* be very sure we truncate towards zero (cf dtrunc()) */</comment>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ipart</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>floor</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ipart</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>-</operator><call><name>floor</name><argument_list>(<argument><expr><operator>-</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>fpart</name> <operator>=</operator> <name>val</name> <operator>-</operator> <operator>*</operator><name>ipart</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ISO8601IntegerWidth</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fieldstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We might have had a leading '-' */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fieldstart</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fieldstart</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>strspn</name><argument_list>(<argument><expr><name>fieldstart</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c
 * and changesd struct pg_tm to struct tm
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ClearPgTm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <comment type="block">/* pg_ */</comment> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c
 *
 * * changesd struct pg_tm to struct tm
 *
 * * Made the function static
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DecodeISO8601Interval</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
					  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <comment type="block">/* pg_ */</comment> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>datepart</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>havefield</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DELTA</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ClearPgTm</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'P'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fieldstart</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>fval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>unit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>		<comment type="block">/* T indicates the beginning of the time part */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>fieldstart</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Note: we could step off the end of the string here.  Code below
		 * *must* exit the loop if unit == '\0'.
		 */</comment>
		<expr_stmt><expr><name>unit</name> <operator>=</operator> <operator>*</operator><name>str</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>datepart</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>unit</name></expr>)</condition>		<comment type="block">/* before T: Y M W D */</comment>
			<block>{<block_content>
				<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <operator>(</operator><name>fval</name> <operator>*</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'M'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>DAYS_PER_MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'W'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">7</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'D'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'T'</literal></expr>:</case>		<comment type="block">/* ISO 8601 4.4.3.3 Alternative Format / Basic */</comment>
				<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>ISO8601IntegerWidth</name><argument_list>(<argument><expr><name>fieldstart</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>havefield</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name> <operator>/</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Else fall through to extended alternative format */</comment>
					<comment type="block">/* FALLTHROUGH */</comment>
				<case>case <expr><literal type="char">'-'</literal></expr>:</case>		<comment type="block">/* ISO 8601 4.4.3.3 Alternative Format,
								 * Extended */</comment>
					<if_stmt><if>if <condition>(<expr><name>havefield</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <operator>(</operator><name>fval</name> <operator>*</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>DAYS_PER_MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
				<default>default:</default>
					<comment type="block">/* not a valid date unit suffix */</comment>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>unit</name></expr>)</condition>		<comment type="block">/* after T: H M S */</comment>
			<block>{<block_content>
				<case>case <expr><literal type="char">'H'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'M'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'S'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\0'</literal></expr>:</case>		<comment type="block">/* ISO 8601 4.4.3.3 Alternative Format */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>ISO8601IntegerWidth</name><argument_list>(<argument><expr><name>fieldstart</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>havefield</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>val</name> <operator>/</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>val</name> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Else fall through to extended alternative format */</comment>
					<comment type="block">/* FALLTHROUGH */</comment>
				<case>case <expr><literal type="char">':'</literal></expr>:</case>		<comment type="block">/* ISO 8601 4.4.3.3 Alternative Format,
								 * Extended */</comment>
					<if_stmt><if>if <condition>(<expr><name>havefield</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>

				<default>default:</default>
					<comment type="block">/* not a valid time unit suffix */</comment>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c
 * with 3 exceptions
 *
 *	* changesd struct pg_tm to struct tm
 *
 *	* ECPG code called this without a 'range' parameter
 *	  removed 'int range' from the argument list and
 *	  places where DecodeTime is called; and added
 *		 int range = INTERVAL_FULL_RANGE;
 *
 *	* ECPG seems not to have a global IntervalStyle
 *	  so added
 *		int IntervalStyle = INTSTYLE_POSTGRES;
 */</comment>
<function><type><name>int</name></type>
<name>DecodeInterval</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ftype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nf</name></decl></parameter>,	<comment type="block">/* int range, */</comment>
			   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <comment type="block">/* pg_ */</comment> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>IntervalStyle</name> <init>= <expr><name>INTSTYLE_POSTGRES_VERBOSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>range</name> <init>= <expr><name>INTERVAL_FULL_RANGE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_before</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>tmask</name></decl>,
				<decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>fval</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DELTA</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>type</name> <operator>=</operator> <name>IGNORE_DTF</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ClearPgTm</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read through list backwards to pick up units before values */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nf</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_TIME</name></expr>:</case>
				<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTime</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,	<comment type="block">/* range, */</comment>
								   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_DAY</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ</name></expr>:</case>

				<comment type="block">/*
				 * Timezone is a token with a leading sign character and at
				 * least one digit; there could be ':', '.', '-' embedded in
				 * it as well.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Try for hh:mm or hh:mm:ss.  If not, fall through to
				 * DTK_NUMBER case, which can handle signed float numbers and
				 * signed year-month values.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<call><name>DecodeTime</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,	<comment type="block">/* INTERVAL_FULL_RANGE, */</comment>
							   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* flip the sign on all fields */</comment>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>*</operator><name>fsec</name><operator>)</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Set the next type to be a day, if units are not
					 * specified. This handles the case of '1 +02:03' since we
					 * are reading right to left.
					 */</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_DAY</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* FALL THROUGH */</comment>

			<case>case <expr><name>DTK_DATE</name></expr>:</case>
			<case>case <expr><name>DTK_NUMBER</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>IGNORE_DTF</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* use typmod to decide what rightmost field is */</comment>
					<switch>switch <condition>(<expr><name>range</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_YEAR</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_MONTH</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_DAY</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_HOUR</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_MINUTE</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_SECOND</name></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_SECOND</name></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* SQL "years-months" syntax */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>val2</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>val2</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name>val2</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>val2</name> <operator>&gt;=</operator> <name>MONTHS_PER_YEAR</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_MONTH</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>val2</name> <operator>=</operator> <operator>-</operator><name>val2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <name>val</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name>val2</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>fval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>fval</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>fval</name> <operator>=</operator> <operator>-</operator><name>fval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>fval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* DTK_M(type); */</comment>

				<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
						<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>val</name> <operator>+</operator> <name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MICROSECOND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
						<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <call><name>rint</name><argument_list>(<argument><expr><operator>(</operator><name>val</name> <operator>+</operator> <name>fval</name><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MILLISECOND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_SECOND</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>fval</name> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * If any subseconds were specified, consider this
						 * microsecond and millisecond input as well.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_ALL_SECS_M</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_HOUR</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_DAY</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_DAY</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_WEEK</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">7</literal></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_MONTH</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>DAYS_PER_MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_YEAR</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_DECADE</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

			<case>case <expr><name>DTK_STRING</name></expr>:</case>
			<case>case <expr><name>DTK_SPECIAL</name></expr>:</case>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>IGNORE_DTF</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* DTK_M(type); */</comment>
				<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>UNITS</name></expr>:</case>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>AGO</name></expr>:</case>
						<expr_stmt><expr><name>is_before</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>RESERV</name></expr>:</case>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <operator>(</operator><name>DTK_DATE_M</name> <operator>|</operator> <name>DTK_TIME_M</name><operator>)</operator></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

			<default>default:</default>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>tmask</name> <operator>&amp;</operator> <name>fmask</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <name>tmask</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* ensure that at least one time field has been found */</comment>
	<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* ensure fractional seconds are fractional */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>sec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>*</operator><name>fsec</name> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>-=</operator> <name>sec</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>sec</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * The SQL standard defines the interval literal
	 *	 '-1 1:00:00'
	 * to mean "negative 1 days and negative 1 hours", while Postgres
	 * traditionally treats this as meaning "negative 1 days and positive
	 * 1 hours".  In SQL_STANDARD intervalstyle, we apply the leading sign
	 * to all fields if there are no other explicit signs.
	 *
	 * We leave the signs alone if there are additional explicit signs.
	 * This protects us against misinterpreting postgres-style dump output,
	 * since the postgres-style output code has always put an explicit sign on
	 * all fields following a negative field.  But note that SQL-spec output
	 * is ambiguous and can be misinterpreted on load!	(So it's best practice
	 * to dump in postgres style, not SQL style.)
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IntervalStyle</name> <operator>==</operator> <name>INTSTYLE_SQL_STANDARD</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>field</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check for additional explicit signs */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>more_signs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nf</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>more_signs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>more_signs</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Rather than re-determining which field was field[0], just force
			 * 'em all negative.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fsec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>*</operator><name>fsec</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally, AGO negates everything */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_before</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>*</operator><name>fsec</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AddVerboseIntPart</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>units</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_before</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cp</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* first nonzero value sets is_before */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_zero</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>is_before</name> <operator>=</operator> <operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>abs</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>is_before</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>-</operator><name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" %d %s%s"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>units</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>value</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"s"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>is_zero</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>cp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AddPostgresIntPart</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>units</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_before</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cp</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%s%s%d %s%s"</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><operator>(</operator><operator>!</operator><operator>*</operator><name>is_zero</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>is_before</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><name>value</name></expr></argument>,
			<argument><expr><name>units</name></expr></argument>,
			<argument><expr><ternary><condition><expr><operator>(</operator><name>value</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each nonzero field sets is_before for (only) the next one.  This is a
	 * tad bizarre but it's how it worked before...
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>is_before</name> <operator>=</operator> <operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>is_zero</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>cp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AddISO8601IntPart</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>units</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cp</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendSeconds</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sec</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fillzeros</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>fsec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fillzeros</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fillzeros</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%02d.%0*d"</literal></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>Abs</name><argument_list>(<argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d.%0*d"</literal></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>Abs</name><argument_list>(<argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>TrimTrailingZeros</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* copy&amp;pasted from .../src/backend/utils/adt/datetime.c
 *
 * Change pg_tm to tm
 */</comment>

<function><type><name>void</name></type>
<name>EncodeInterval</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <comment type="block">/* pg_ */</comment> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>year</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mon</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mday</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hour</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sec</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_before</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_zero</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The sign of year and month are guaranteed to match, since they are
	 * stored internally as "month". But we'll need to check for is_before and
	 * is_zero when determining the signs of day and hour/minute/seconds
	 * fields.
	 */</comment>
	<switch>switch <condition>(<expr><name>style</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* SQL Standard interval format */</comment>
		<case>case <expr><name>INTSTYLE_SQL_STANDARD</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_negative</name> <init>= <expr><name>year</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mon</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>mday</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>hour</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_positive</name> <init>= <expr><name>year</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mon</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>mday</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>hour</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>min</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_year_month</name> <init>= <expr><name>year</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>mon</name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_day_time</name> <init>= <expr><name>mday</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>hour</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>min</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_day</name> <init>= <expr><name>mday</name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>sql_standard_value</name> <init>= <expr><operator>!</operator><operator>(</operator><name>has_negative</name> <operator>&amp;&amp;</operator> <name>has_positive</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>!</operator><operator>(</operator><name>has_year_month</name> <operator>&amp;&amp;</operator> <name>has_day_time</name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * SQL Standard wants only 1 "&lt;sign&gt;" preceding the whole
				 * interval ... but can't do that if mixed signs.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>has_negative</name> <operator>&amp;&amp;</operator> <name>sql_standard_value</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>year</name> <operator>=</operator> <operator>-</operator><name>year</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>mon</name> <operator>=</operator> <operator>-</operator><name>mon</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>mday</name> <operator>=</operator> <operator>-</operator><name>mday</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hour</name> <operator>=</operator> <operator>-</operator><name>hour</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>min</name> <operator>=</operator> <operator>-</operator><name>min</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>-</operator><name>sec</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>fsec</name> <operator>=</operator> <operator>-</operator><name>fsec</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_negative</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_positive</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>sql_standard_value</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * For non sql-standard interval values, force outputting
					 * the signs to avoid ambiguities with intervals with
					 * mixed sign components.
					 */</comment>
					<decl_stmt><decl><type><name>char</name></type>		<name>year_sign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>year</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mon</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'-'</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name>day_sign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>mday</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'-'</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name>sec_sign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>hour</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
											<name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'-'</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%c%d-%d %c%d %c%d:%02d:"</literal></expr></argument>,
							<argument><expr><name>year_sign</name></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>mon</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>day_sign</name></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>mday</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>sec_sign</name></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>hour</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>has_year_month</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d-%d"</literal></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>has_day</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d %d:%02d:"</literal></expr></argument>, <argument><expr><name>mday</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d:%02d:"</literal></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/* ISO 8601 "time-intervals by duration only" */</comment>
		<case>case <expr><name>INTSTYLE_ISO_8601</name></expr>:</case>
			<comment type="block">/* special-case zero to avoid printing nothing */</comment>
			<if_stmt><if>if <condition>(<expr><name>year</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mon</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mday</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name>hour</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>min</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sec</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fsec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"PT0S"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'P'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><literal type="char">'Y'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><literal type="char">'M'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>, <argument><expr><literal type="char">'D'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>hour</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'T'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><literal type="char">'M'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/* Compatible with postgresql &lt; 8.4 when DateStyle = 'iso' */</comment>
		<case>case <expr><name>INTSTYLE_POSTGRES</name></expr>:</case>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddPostgresIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><literal type="string">"year"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddPostgresIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><literal type="string">"mon"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddPostgresIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>, <argument><expr><literal type="string">"day"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>is_zero</name> <operator>||</operator> <name>hour</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>minus</name> <init>= <expr><operator>(</operator><name>hour</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%s%s%02d:%02d:"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><name>is_zero</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name>minus</name></expr> ?</condition><then> <expr><literal type="string">"-"</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>is_before</name></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>,
						<argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>hour</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/* Compatible with postgresql &lt; 8.4 when DateStyle != 'iso' */</comment>
		<case>case <expr><name>INTSTYLE_POSTGRES_VERBOSE</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"@"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><literal type="string">"year"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><literal type="string">"mon"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>, <argument><expr><literal type="string">"day"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><literal type="string">"hour"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>sec</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>is_zero</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>is_before</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_before</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>is_before</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" sec%s"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><operator>(</operator><call><name>abs</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>is_zero</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* identically zero? then put in a unitless zero... */</comment>
			<if_stmt><if>if <condition>(<expr><name>is_zero</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>is_before</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" ago"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/* interval2tm()
 * Convert an interval data type to a tm structure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>interval2tm</name><parameter_list>(<parameter><decl><type><name>interval</name></type> <name>span</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>time</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>span</name><operator>.</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>span</name><operator>.</operator><name>month</name></name> <operator>/</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>span</name><operator>.</operator><name>month</name></name> <operator>%</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>time</name> <operator>=</operator> <name><name>span</name><operator>.</operator><name>time</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>*</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <name>time</name> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* interval2tm() */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>tm2interval</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>interval</name> <modifier>*</modifier></type> <name>span</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator>
		<operator>(</operator><name>double</name><operator>)</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator>
					   <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>)</operator> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator>
					 <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator>
				   <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name><operator>)</operator> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* tm2interval() */</comment>

<function><type><name>interval</name> <modifier>*</modifier></type>
<name>PGTYPESinterval_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>interval</name> <operator>*</operator><operator>)</operator> <call><name>pgtypes_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* result can be NULL if we run out of memory */</comment>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>PGTYPESinterval_free</name><parameter_list>(<parameter><decl><type><name>interval</name> <modifier>*</modifier></type> <name>intvl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>intvl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>interval</name> <modifier>*</modifier></type>
<name>PGTYPESinterval_from_asc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>interval</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type>	<name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>ftype</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>lowstr</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>realptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>endptr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>endptr</name></expr> </then><else>: <expr><operator>&amp;</operator><name>realptr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDATELEN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>PGTYPES_INTVL_BAD_INTERVAL</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ParseDateTime</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>lowstr</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nf</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>(</operator><call><name>DecodeInterval</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		 <call><name>DecodeISO8601Interval</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>PGTYPES_INTVL_BAD_INTERVAL</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>interval</name> <operator>*</operator><operator>)</operator> <call><name>pgtypes_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dtype</name> <operator>!=</operator> <name>DTK_DELTA</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>PGTYPES_INTVL_BAD_INTERVAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>tm2interval</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>PGTYPES_INTVL_BAD_INTERVAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PGTYPESinterval_to_asc</name><parameter_list>(<parameter><decl><type><name>interval</name> <modifier>*</modifier></type> <name>span</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type>	<name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>IntervalStyle</name> <init>= <expr><name>INTSTYLE_POSTGRES_VERBOSE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>interval2tm</name><argument_list>(<argument><expr><operator>*</operator><name>span</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>PGTYPES_INTVL_BAD_INTERVAL</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EncodeInterval</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>IntervalStyle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>pgtypes_strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PGTYPESinterval_copy</name><parameter_list>(<parameter><decl><type><name>interval</name> <modifier>*</modifier></type> <name>intvlsrc</name></decl></parameter>, <parameter><decl><type><name>interval</name> <modifier>*</modifier></type> <name>intvldest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>intvldest</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>intvlsrc</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intvldest</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name><name>intvlsrc</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
