<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/interfaces/libpq/fe-secure-gssapi.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fe-secure-gssapi.c
 *   The front-end (client) encryption support for GSSAPI
 *
 * Portions Copyright (c) 2016-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *  src/interfaces/libpq/fe-secure-gssapi.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * This file is compiled with both frontend and backend codes, symlinked by
 * src/backend/Makefile, and use macro FRONTEND to switch.
 *
 * Include "c.h" to adopt Greenplum C types. Don't include "postgres_fe.h",
 * which only defines FRONTEND besides including "c.h"
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe-gssapi-common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Require encryption support, as well as mutual authentication and
 * tamperproofing measures.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GSS_REQUIRED_FLAGS</name></cpp:macro> <cpp:value>GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG | \
	GSS_C_SEQUENCE_FLAG | GSS_C_CONF_FLAG | GSS_C_INTEG_FLAG</cpp:value></cpp:define>

<comment type="block">/*
 * Handle the encryption/decryption of data using GSSAPI.
 *
 * In the encrypted data stream on the wire, we break up the data
 * into packets where each packet starts with a uint32-size length
 * word (in network byte order), then encrypted data of that length
 * immediately following.  Decryption yields the same data stream
 * that would appear when not using encryption.
 *
 * Encrypted data typically ends up being larger than the same data
 * unencrypted, so we use fixed-size buffers for handling the
 * encryption/decryption which are larger than PQComm's buffer will
 * typically be to minimize the times where we have to make multiple
 * packets (and therefore multiple recv/send calls for a single
 * read/write call to us).
 *
 * NOTE: The client and server have to agree on the max packet size,
 * because we have to pass an entire packet to GSSAPI at a time and we
 * don't want the other side to send arbitrarily huge packets as we
 * would have to allocate memory for them to then pass them to GSSAPI.
 *
 * Therefore, these two #define's are effectively part of the protocol
 * spec and can't ever be changed.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PQ_GSS_SEND_BUFFER_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PQ_GSS_RECV_BUFFER_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>

<comment type="block">/*
 * We need these state variables per-connection.  To allow the functions
 * in this file to look mostly like those in be-secure-gssapi.c, set up
 * these macros.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSSendBuffer</name></cpp:macro> <cpp:value>(conn-&gt;gss_SendBuffer)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSSendLength</name></cpp:macro> <cpp:value>(conn-&gt;gss_SendLength)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSSendNext</name></cpp:macro> <cpp:value>(conn-&gt;gss_SendNext)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSSendConsumed</name></cpp:macro> <cpp:value>(conn-&gt;gss_SendConsumed)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSRecvBuffer</name></cpp:macro> <cpp:value>(conn-&gt;gss_RecvBuffer)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSRecvLength</name></cpp:macro> <cpp:value>(conn-&gt;gss_RecvLength)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSResultBuffer</name></cpp:macro> <cpp:value>(conn-&gt;gss_ResultBuffer)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSResultLength</name></cpp:macro> <cpp:value>(conn-&gt;gss_ResultLength)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSResultNext</name></cpp:macro> <cpp:value>(conn-&gt;gss_ResultNext)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PqGSSMaxPktSize</name></cpp:macro> <cpp:value>(conn-&gt;gss_MaxPktSize)</cpp:value></cpp:define>


<comment type="block">/*
 * Attempt to write len bytes of data from ptr to a GSSAPI-encrypted connection.
 *
 * The connection must be already set up for GSSAPI encryption (i.e., GSSAPI
 * transport negotiation is complete).
 *
 * On success, returns the number of data bytes consumed (possibly less than
 * len).  On failure, returns -1 with errno set appropriately.  If the errno
 * indicates a non-retryable error, a message is put into conn-&gt;errorMessage.
 * For retryable errors, caller should call again (passing the same data)
 * once the socket is ready.
 */</comment>
<function><type><name>ssize_t</name></type>
<name>pg_GSS_write</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>major</name></decl>,
				<decl><type ref="prev"/><name>minor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>input</name></decl>,
				<decl><type ref="prev"/><name>output</name> <init>= <expr><name>GSS_C_EMPTY_BUFFER</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_sent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_to_encrypt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_encrypted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_ctx_id_t</name></type> <name>gctx</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When we get a failure, we must not tell the caller we have successfully
	 * transmitted everything, else it won't retry.  Hence a "success"
	 * (positive) return value must only count source bytes corresponding to
	 * fully-transmitted encrypted packets.  The amount of source data
	 * corresponding to the current partly-transmitted packet is remembered in
	 * PqGSSSendConsumed.  On a retry, the caller *must* be sending that data
	 * again, so if it offers a len less than that, something is wrong.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>PqGSSSendConsumed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><literal type="string">"GSSAPI caller failed to retransmit all data needing to be retried\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Discount whatever source data we already encrypted. */</comment>
	<expr_stmt><expr><name>bytes_to_encrypt</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>PqGSSSendConsumed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytes_encrypted</name> <operator>=</operator> <name>PqGSSSendConsumed</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop through encrypting data and sending it out until it's all done or
	 * pqsecure_raw_write() complains (which would likely mean that the socket
	 * is non-blocking and the requested send() would block, or there was some
	 * kind of actual error).
	 */</comment>
	<while>while <condition>(<expr><name>bytes_to_encrypt</name> <operator>||</operator> <name>PqGSSSendLength</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>conf_state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>netlen</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check if we have data in the encrypted output buffer that needs to
		 * be sent (possibly left over from a previous call), and if so, try
		 * to send it.  If we aren't able to, return that fact back up to the
		 * caller.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSSendLength</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ssize_t</name></type>		<name>amount</name> <init>= <expr><name>PqGSSSendLength</name> <operator>-</operator> <name>PqGSSSendNext</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqsecure_raw_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendNext</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Report any previously-sent data; if there was none, reflect
				 * the pqsecure_raw_write result up to our caller.  When there
				 * was some, we're effectively assuming that any interesting
				 * failure condition will recur on the next try.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>bytes_sent</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>bytes_sent</name></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><name>ret</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check if this was a partial write, and if so, move forward that
			 * far in our buffer and try again.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>amount</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>PqGSSSendNext</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* We've successfully sent whatever data was in that packet. */</comment>
			<expr_stmt><expr><name>bytes_sent</name> <operator>+=</operator> <name>PqGSSSendConsumed</name></expr>;</expr_stmt>

			<comment type="block">/* All encrypted data was sent, our buffer is empty now. */</comment>
			<expr_stmt><expr><name>PqGSSSendLength</name> <operator>=</operator> <name>PqGSSSendNext</name> <operator>=</operator> <name>PqGSSSendConsumed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check if there are any bytes left to encrypt.  If not, we're done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bytes_to_encrypt</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check how much we are being asked to send, if it's too much, then
		 * we will have to loop and possibly be called multiple times to get
		 * through all the data.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>bytes_to_encrypt</name> <operator>&gt;</operator> <name>PqGSSMaxPktSize</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>PqGSSMaxPktSize</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>bytes_to_encrypt</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>bytes_encrypted</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>output</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create the next encrypted packet.  Any failure here is considered a
		 * hard failure, so we return -1 even if bytes_sent &gt; 0.
		 */</comment>
		<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>gss_wrap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>GSS_C_QOP_DEFAULT</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conf_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>major</name> <operator>!=</operator> <name>GSS_S_COMPLETE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_GSS_error</name><argument_list>(<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"GSSAPI wrap error"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt>		<comment type="block">/* for lack of a better idea */</comment>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>conf_state</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"outgoing GSSAPI message would not use confidentiality\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt>		<comment type="block">/* for lack of a better idea */</comment>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>PQ_GSS_SEND_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"client tried to send oversize GSSAPI packet (%zu &gt; %zu)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>,
							  <argument><expr><name>PQ_GSS_SEND_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt>		<comment type="block">/* for lack of a better idea */</comment>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>bytes_encrypted</name> <operator>+=</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytes_to_encrypt</name> <operator>-=</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSSendConsumed</name> <operator>+=</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>

		<comment type="block">/* 4 network-order bytes of length, then payload */</comment>
		<expr_stmt><expr><name>netlen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendLength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>netlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSSendLength</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendLength</name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSSendLength</name> <operator>+=</operator> <name><name>output</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>

		<comment type="block">/* Release buffer storage allocated by GSSAPI */</comment>
		<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* If we get here, our counters should all match up. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bytes_sent</name> <operator>==</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bytes_sent</name> <operator>==</operator> <name>bytes_encrypted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>bytes_sent</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<comment type="block">/* Release GSSAPI buffer storage, if we didn't already */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>output</name><operator>.</operator><name>value</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read up to len bytes of data into ptr from a GSSAPI-encrypted connection.
 *
 * The connection must be already set up for GSSAPI encryption (i.e., GSSAPI
 * transport negotiation is complete).
 *
 * Returns the number of data bytes read, or on failure, returns -1
 * with errno set appropriately.  If the errno indicates a non-retryable
 * error, a message is put into conn-&gt;errorMessage.  For retryable errors,
 * caller should call again once the socket is ready.
 */</comment>
<function><type><name>ssize_t</name></type>
<name>pg_GSS_read</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>major</name></decl>,
				<decl><type ref="prev"/><name>minor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>input</name> <init>= <expr><name>GSS_C_EMPTY_BUFFER</name></expr></init></decl>,
				<decl><type ref="prev"/><name>output</name> <init>= <expr><name>GSS_C_EMPTY_BUFFER</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_returned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_ctx_id_t</name></type> <name>gctx</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The plan here is to read one incoming encrypted packet into
	 * PqGSSRecvBuffer, decrypt it into PqGSSResultBuffer, and then dole out
	 * data from there to the caller.  When we exhaust the current input
	 * packet, read another.
	 */</comment>
	<while>while <condition>(<expr><name>bytes_returned</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>conf_state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Check if we have data in our buffer that we can return immediately */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSResultNext</name> <operator>&lt;</operator> <name>PqGSSResultLength</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_in_buffer</name> <init>= <expr><name>PqGSSResultLength</name> <operator>-</operator> <name>PqGSSResultNext</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_to_copy</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>bytes_in_buffer</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>bytes_returned</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Copy the data from our result buffer into the caller's buffer,
			 * at the point where we last left off filling their buffer.
			 */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>bytes_returned</name></expr></argument>, <argument><expr><name>PqGSSResultBuffer</name> <operator>+</operator> <name>PqGSSResultNext</name></expr></argument>, <argument><expr><name>bytes_to_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>PqGSSResultNext</name> <operator>+=</operator> <name>bytes_to_copy</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bytes_returned</name> <operator>+=</operator> <name>bytes_to_copy</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * At this point, we've either filled the caller's buffer or
			 * emptied our result buffer.  Either way, return to caller.  In
			 * the second case, we could try to read another encrypted packet,
			 * but the odds are good that there isn't one available.  (If this
			 * isn't true, we chose too small a max packet size.)  In any
			 * case, there's no harm letting the caller process the data we've
			 * already returned.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Result buffer is empty, so reset buffer pointers */</comment>
		<expr_stmt><expr><name>PqGSSResultLength</name> <operator>=</operator> <name>PqGSSResultNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Because we chose above to return immediately as soon as we emit
		 * some data, bytes_returned must be zero at this point.  Therefore
		 * the failure exits below can just return -1 without worrying about
		 * whether we already emitted some data.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bytes_returned</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * At this point, our result buffer is empty with more bytes being
		 * requested to be read.  We are now ready to load the next packet and
		 * decrypt it (entirely) into our result buffer.
		 */</comment>

		<comment type="block">/* Collect the length if we haven't already */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSRecvLength</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqsecure_raw_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <name>PqGSSRecvLength</name></expr></argument>,
									<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>PqGSSRecvLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If ret &lt;= 0, pqsecure_raw_read already set the correct errno */</comment>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

			<comment type="block">/* If we still haven't got the length, return to the caller */</comment>
			<if_stmt><if>if <condition>(<expr><name>PqGSSRecvLength</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EWOULDBLOCK</name></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Decode the packet length and check for overlength packet */</comment>
		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>PqGSSRecvBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>PQ_GSS_RECV_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"oversize GSSAPI packet sent by the server (%zu &gt; %zu)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr></argument>,
							  <argument><expr><name>PQ_GSS_RECV_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt>		<comment type="block">/* for lack of a better idea */</comment>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Read as much of the packet as we are able to on this call into
		 * wherever we left off from the last time we were called.
		 */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqsecure_raw_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <name>PqGSSRecvLength</name></expr></argument>,
								<argument><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>-</operator> <operator>(</operator><name>PqGSSRecvLength</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If ret &lt;= 0, pqsecure_raw_read already set the correct errno */</comment>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

		<comment type="block">/* If we don't yet have the whole packet, return to the caller */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSRecvLength</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EWOULDBLOCK</name></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We now have the full packet and we can perform the decryption and
		 * refill our result buffer, then loop back up to pass data back to
		 * the caller.  Note that error exits below here must take care of
		 * releasing the gss output buffer.
		 */</comment>
		<expr_stmt><expr><name><name>output</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>PqGSSRecvBuffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>gss_unwrap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conf_state</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>major</name> <operator>!=</operator> <name>GSS_S_COMPLETE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_GSS_error</name><argument_list>(<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"GSSAPI unwrap error"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
						 <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt>		<comment type="block">/* for lack of a better idea */</comment>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>conf_state</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"incoming GSSAPI message did not use confidentiality\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt>		<comment type="block">/* for lack of a better idea */</comment>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSResultBuffer</name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSResultLength</name> <operator>=</operator> <name><name>output</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>

		<comment type="block">/* Our receive buffer is now empty, reset it */</comment>
		<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Release buffer storage allocated by GSSAPI */</comment>
		<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>bytes_returned</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<comment type="block">/* Release GSSAPI buffer storage, if we didn't already */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>output</name><operator>.</operator><name>value</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Simple wrapper for reading from pqsecure_raw_read.
 *
 * This takes the same arguments as pqsecure_raw_read, plus an output parameter
 * to return the number of bytes read.  This handles if blocking would occur and
 * if we detect EOF on the connection.
 */</comment>
<function><type><specifier>static</specifier> <name>PostgresPollingStatusType</name></type>
<name>gss_read</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recv_buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <call><name>pqsecure_raw_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>recv_buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check for EOF */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><call><name>pqReadReady</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <call><name>pqsecure_raw_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>recv_buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>PGRES_POLLING_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Negotiate GSSAPI transport for a connection.  When complete, returns
 * PGRES_POLLING_OK.  Will return PGRES_POLLING_READING or
 * PGRES_POLLING_WRITING as appropriate whenever it would block, and
 * PGRES_POLLING_FAILED if transport could not be negotiated.
 */</comment>
<function><type><name>PostgresPollingStatusType</name></type>
<name>pqsecure_open_gss</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>major</name></decl>,
				<decl><type ref="prev"/><name>minor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>netlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>input</name> <init>= <expr><name>GSS_C_EMPTY_BUFFER</name></expr></init></decl>,
				<decl><type ref="prev"/><name>output</name> <init>= <expr><name>GSS_C_EMPTY_BUFFER</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If first time through for this connection, allocate buffers and
	 * initialize state variables.  By malloc'ing the buffers separately, we
	 * ensure that they are sufficiently aligned for the length-word accesses
	 * that we do in some places in this file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PqGSSSendBuffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>PqGSSSendBuffer</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>PQ_GSS_SEND_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSRecvBuffer</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>PQ_GSS_RECV_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSResultBuffer</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>PQ_GSS_RECV_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PqGSSSendBuffer</name> <operator>||</operator> <operator>!</operator><name>PqGSSRecvBuffer</name> <operator>||</operator> <operator>!</operator><name>PqGSSResultBuffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>PqGSSSendLength</name> <operator>=</operator> <name>PqGSSSendNext</name> <operator>=</operator> <name>PqGSSSendConsumed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>=</operator> <name>PqGSSResultLength</name> <operator>=</operator> <name>PqGSSResultNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if we have anything to send from a prior call and if so, send it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PqGSSSendLength</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ssize_t</name></type>		<name>amount</name> <init>= <expr><name>PqGSSSendLength</name> <operator>-</operator> <name>PqGSSSendNext</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqsecure_raw_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendNext</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <name>amount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>PqGSSSendNext</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
			<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>PqGSSSendLength</name> <operator>=</operator> <name>PqGSSSendNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Client sends first, and sending creates a context, therefore this will
	 * be false the first time through, and then when we get called again we
	 * will check for incoming data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Process any incoming data we might have */</comment>

		<comment type="block">/* See if we are still trying to get the length */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSRecvLength</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Attempt to get the length first */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>gss_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <name>PqGSSRecvLength</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>PqGSSRecvLength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>PGRES_POLLING_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>PqGSSRecvLength</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check if we got an error packet
		 *
		 * This is safe to do because we shouldn't ever get a packet over 8192
		 * and therefore the actual length bytes, being that they are in
		 * network byte order, for any real packet will start with two zero
		 * bytes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>PqGSSRecvBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For an error packet during startup, we don't get a length, so
			 * simply read as much as we can fit into our buffer (as a string,
			 * so leave a spot at the end for a NULL byte too) and report that
			 * back to the caller.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>gss_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <name>PqGSSRecvLength</name></expr></argument>, <argument><expr><name>PQ_GSS_RECV_BUFFER_SIZE</name> <operator>-</operator> <name>PqGSSRecvLength</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>PGRES_POLLING_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We should have the whole length at this point, so pull it out and
		 * then read whatever we have left of the packet
		 */</comment>

		<comment type="block">/* Get the length and check for over-length packet */</comment>
		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>PqGSSRecvBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>PQ_GSS_RECV_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"oversize GSSAPI packet sent by the server (%zu &gt; %zu)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr></argument>,
							  <argument><expr><name>PQ_GSS_RECV_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Read as much of the packet as we are able to on this call into
		 * wherever we left off from the last time we were called.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>gss_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <name>PqGSSRecvLength</name></expr></argument>,
						  <argument><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>-</operator> <operator>(</operator><name>PqGSSRecvLength</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>PGRES_POLLING_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we got less than the rest of the packet then we need to return
		 * and be called again.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSRecvLength</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>PqGSSRecvBuffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Load the service name (no-op if already done */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_GSS_load_servicename</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Call GSS init context, either with an empty input, or with a complete
	 * packet from the server.
	 */</comment>
	<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>gss_init_sec_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gcred</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr></argument>,
								 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gtarg_nam</name></name></expr></argument>, <argument><expr><name>GSS_C_NO_OID</name></expr></argument>,
								 <argument><expr><name>GSS_REQUIRED_FLAGS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* GSS Init Sec Context uses the whole packet, so clear it */</comment>
	<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GSS_ERROR</name><argument_list>(<argument><expr><name>major</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_GSS_error</name><argument_list>(<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not initiate GSSAPI security context"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're done - hooray!  Kind of gross, but we need to disable SSL
		 * here so that we don't accidentally tunnel one over the other.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Clean up */</comment>
		<expr_stmt><expr><call><name>gss_release_cred</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gcred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>gcred</name></name> <operator>=</operator> <name>GSS_C_NO_CREDENTIAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>gssenc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine the max packet size which will fit in our buffer, after
		 * accounting for the length.  pg_GSS_write will need this.
		 */</comment>
		<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>gss_wrap_size_limit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>GSS_C_QOP_DEFAULT</name></expr></argument>,
									<argument><expr><name>PQ_GSS_SEND_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>PqGSSMaxPktSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GSS_ERROR</name><argument_list>(<argument><expr><name>major</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_GSS_error</name><argument_list>(<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"GSSAPI size check error"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
						 <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>PGRES_POLLING_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Must have output.length &gt; 0 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>PQ_GSS_SEND_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_GSS_error</name><argument_list>(<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"GSSAPI context establishment error"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Queue the token for writing */</comment>
	<expr_stmt><expr><name>netlen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSSendBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>netlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqGSSSendLength</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendLength</name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqGSSSendLength</name> <operator>+=</operator> <name><name>output</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>

	<comment type="block">/* We don't bother with PqGSSSendConsumed here */</comment>

	<comment type="block">/* Release buffer storage allocated by GSSAPI */</comment>
	<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ask to be called again to write data */</comment>
	<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GSSAPI Information functions.
 */</comment>

<comment type="block">/*
 * Return the GSSAPI Context itself.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>PQgetgssctx</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true if GSSAPI encryption is in use.
 */</comment>
<function><type><name>int</name></type>
<name>PQgssEncInUse</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>gssenc</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
