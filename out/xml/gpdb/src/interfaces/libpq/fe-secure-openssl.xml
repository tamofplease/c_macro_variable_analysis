<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/interfaces/libpq/fe-secure-openssl.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fe-secure-openssl.c
 *	  OpenSSL support
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-secure-openssl.c
 *
 * NOTES
 *
 *	  We don't provide informational callbacks here (like
 *	  info_cb() in be-secure.c), since there's no good mechanism to
 *	  display such information to the user.
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * This file is compiled with both frontend and backend codes, symlinked by
 * src/backend/Makefile, and use macro FRONTEND to switch.
 *
 * Include "c.h" to adopt Greenplum C types. Don't include "postgres_fe.h",
 * which only defines FRONTEND besides including "c.h"
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe-auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe-secure-common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETINET_TCP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/tcp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pthread-win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/ssl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/conf.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL_ENGINE</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/engine.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/x509v3.h&gt;</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>verify_cb</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ok</name></decl></parameter>, <parameter><decl><type><name>X509_STORE_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>openssl_verify_peer_name_matches_certificate_name</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
															  <parameter><decl><type><name>ASN1_STRING</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
															  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>store_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>destroy_ssl_system</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>initialize_SSL</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PostgresPollingStatusType</name></type> <name>open_client_SSL</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>SSLerrmessage</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>ecode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SSLerrfree</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>my_sock_read</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>my_sock_write</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BIO_METHOD</name> <modifier>*</modifier></type><name>my_BIO_s_socket</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>my_SSL_set_fd</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pq_init_ssl_lib</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pq_init_crypto_lib</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ssl_lib_initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>ssl_open_connections</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>ssl_config_mutex</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>ssl_config_mutex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>win32_ssl_create_mutex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY */</comment>


<comment type="block">/* ------------------------------------------------------------ */</comment>
<comment type="block">/*			 Procedures common to all secure sessions			*/</comment>
<comment type="block">/* ------------------------------------------------------------ */</comment>

<function><type><name>void</name></type>
<name>pgtls_init_library</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>do_ssl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>do_crypto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>

	<comment type="block">/*
	 * Disallow changing the flags while we have open connections, else we'd
	 * get completely confused.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ssl_open_connections</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>pq_init_ssl_lib</name> <operator>=</operator> <name>do_ssl</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pq_init_crypto_lib</name> <operator>=</operator> <name>do_crypto</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PostgresPollingStatusType</name></type>
<name>pgtls_open_client</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* First time through? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Create a connection-specific SSL object, and load client
		 * certificate, private key, and trusted CA certs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>initialize_SSL</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* initialize_SSL already put a message in conn-&gt;errorMessage */</comment>
			<expr_stmt><expr><call><name>pgtls_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Begin or continue the actual handshake */</comment>
	<return>return <expr><call><name>open_client_SSL</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type>
<name>pgtls_read</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ecode</name></decl>;</decl_stmt>

<label><name>rloop</name>:</label>

	<comment type="block">/*
	 * Prepare to call SSL_get_error() by clearing thread's OpenSSL error
	 * queue.  In general, the current thread's error queue must be empty
	 * before the TLS/SSL I/O operation is attempted, or SSL_get_error() will
	 * not work reliably.  Since the possibility exists that other OpenSSL
	 * clients running in the same thread but not under our control will fail
	 * to call ERR_get_error() themselves (after their own I/O operations),
	 * pro-actively clear the per-thread error queue now.
	 */</comment>
	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SSL_read</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Other clients of OpenSSL may fail to call ERR_get_error(), but we
	 * always do, so as to not cause problems for OpenSSL clients that don't
	 * call ERR_clear_error() defensively.  Be sure that this happens by
	 * calling now.  SSL_get_error() relies on the OpenSSL per-thread error
	 * queue being intact, so this is the earliest possible point
	 * ERR_get_error() may be called.
	 */</comment>
	<expr_stmt><expr><name>ecode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>err</name> <operator>!=</operator> <name>SSL_ERROR_NONE</name> <operator>||</operator> <name>n</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>err</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SSL_ERROR_NONE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Not supposed to happen, so we don't translate the msg */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><literal type="string">"SSL_read failed but did not provide error information\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* assume the connection is broken */</comment>
				<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SSL_ERROR_WANT_READ</name></expr>:</case>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SSL_ERROR_WANT_WRITE</name></expr>:</case>

			<comment type="block">/*
			 * Returning 0 here would cause caller to wait for read-ready,
			 * which is not correct since what SSL wants is wait for
			 * write-ready.  The former could get us stuck in an infinite
			 * wait, so don't risk it; busy-loop instead.
			 */</comment>
			<goto>goto <name>rloop</name>;</goto>
		<case>case <expr><name>SSL_ERROR_SYSCALL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>SOCK_ERRNO</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>result_errno</name> <operator>==</operator> <name>EPIPE</name> <operator>||</operator>
					<name>result_errno</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(
													<argument><expr><literal type="string">"server closed the connection unexpectedly\n"</literal>
													<literal type="string">"\tThis probably means the server terminated abnormally\n"</literal>
													<literal type="string">"\tbefore or while processing the request.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL SYSCALL error: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>result_errno</name></expr></argument>,
													<argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL SYSCALL error: EOF detected\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* assume the connection is broken */</comment>
				<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SSL_ERROR_SSL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errm</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><name>ecode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL error: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>errm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* assume the connection is broken */</comment>
				<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>SSL_ERROR_ZERO_RETURN</name></expr>:</case>

			<comment type="block">/*
			 * Per OpenSSL documentation, this error code is only returned for
			 * a clean connection closure, so we should not report it as a
			 * server crash.
			 */</comment>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL connection has been closed unexpectedly\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unrecognized SSL error code: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* assume the connection is broken */</comment>
			<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* ensure we return the intended errno to caller */</comment>
	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><name>result_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>pgtls_read_pending</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SSL_pending</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type>
<name>pgtls_write</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ecode</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SSL_write</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ecode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>err</name> <operator>!=</operator> <name>SSL_ERROR_NONE</name> <operator>||</operator> <name>n</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>err</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SSL_ERROR_NONE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Not supposed to happen, so we don't translate the msg */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><literal type="string">"SSL_write failed but did not provide error information\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* assume the connection is broken */</comment>
				<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SSL_ERROR_WANT_READ</name></expr>:</case>

			<comment type="block">/*
			 * Returning 0 here causes caller to wait for write-ready, which
			 * is not really the right thing, but it's the best we can do.
			 */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SSL_ERROR_WANT_WRITE</name></expr>:</case>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SSL_ERROR_SYSCALL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>SOCK_ERRNO</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>result_errno</name> <operator>==</operator> <name>EPIPE</name> <operator>||</operator> <name>result_errno</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(
													<argument><expr><literal type="string">"server closed the connection unexpectedly\n"</literal>
													<literal type="string">"\tThis probably means the server terminated abnormally\n"</literal>
													<literal type="string">"\tbefore or while processing the request.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL SYSCALL error: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>result_errno</name></expr></argument>,
													<argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL SYSCALL error: EOF detected\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* assume the connection is broken */</comment>
				<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SSL_ERROR_SSL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errm</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><name>ecode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL error: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>errm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* assume the connection is broken */</comment>
				<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>SSL_ERROR_ZERO_RETURN</name></expr>:</case>

			<comment type="block">/*
			 * Per OpenSSL documentation, this error code is only returned for
			 * a clean connection closure, so we should not report it as a
			 * server crash.
			 */</comment>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL connection has been closed unexpectedly\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unrecognized SSL error code: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* assume the connection is broken */</comment>
			<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* ensure we return the intended errno to caller */</comment>
	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><name>result_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_X509_GET_SIGNATURE_NID</name></cpp:ifdef>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pgtls_get_peer_certificate_hash</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>X509</name>	   <modifier>*</modifier></type><name>peer_cert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>EVP_MD</name> <modifier>*</modifier></type><name>algo_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hash</name><index>[<expr><name>EVP_MAX_MD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* size for SHA-512 */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hash_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>algo_nid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cert_hash</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>peer_cert</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the signature algorithm of the certificate to determine the hash
	 * algorithm to use for the result.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OBJ_find_sigid_algs</name><argument_list>(<argument><expr><call><name>X509_get_signature_nid</name><argument_list>(<argument><expr><name>peer_cert</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>algo_nid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not determine server certificate signature algorithm\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The TLS server's certificate bytes need to be hashed with SHA-256 if
	 * its signature algorithm is MD5 or SHA-1 as per RFC 5929
	 * (https://tools.ietf.org/html/rfc5929#section-4.1).  If something else
	 * is used, the same hash as the signature algorithm is used.
	 */</comment>
	<switch>switch <condition>(<expr><name>algo_nid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>NID_md5</name></expr>:</case>
		<case>case <expr><name>NID_sha1</name></expr>:</case>
			<expr_stmt><expr><name>algo_type</name> <operator>=</operator> <call><name>EVP_sha256</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>algo_type</name> <operator>=</operator> <call><name>EVP_get_digestbynid</name><argument_list>(<argument><expr><name>algo_nid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>algo_type</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not find digest for NID %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>OBJ_nid2sn</name><argument_list>(<argument><expr><name>algo_nid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>X509_digest</name><argument_list>(<argument><expr><name>peer_cert</name></expr></argument>, <argument><expr><name>algo_type</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_size</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not generate peer certificate hash\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* save result */</comment>
	<expr_stmt><expr><name>cert_hash</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>hash_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cert_hash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cert_hash</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hash_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>hash_size</name></expr>;</expr_stmt>

	<return>return <expr><name>cert_hash</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_X509_GET_SIGNATURE_NID */</comment>

<comment type="block">/* ------------------------------------------------------------ */</comment>
<comment type="block">/*						OpenSSL specific code					*/</comment>
<comment type="block">/* ------------------------------------------------------------ */</comment>

<comment type="block">/*
 *	Certificate verification callback
 *
 *	This callback allows us to log intermediate problems during
 *	verification, but there doesn't seem to be a clean way to get
 *	our PGconn * structure.  So we can't log anything!
 *
 *	This callback also allows us to override the default acceptance
 *	criteria (e.g., accepting self-signed or expired certs), but
 *	for now we accept the default checks.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>verify_cb</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ok</name></decl></parameter>, <parameter><decl><type><name>X509_STORE_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OpenSSL-specific wrapper around
 * pq_verify_peer_name_matches_certificate_name(), converting the ASN1_STRING
 * into a plain C string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>openssl_verify_peer_name_matches_certificate_name</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ASN1_STRING</name> <modifier>*</modifier></type><name>name_entry</name></decl></parameter>,
												  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>store_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>namedata</name></decl>;</decl_stmt>

	<comment type="block">/* Should not happen... */</comment>
	<if_stmt><if>if <condition>(<expr><name>name_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL certificate's name entry is missing\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * GEN_DNS can be only IA5String, equivalent to US ASCII.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ASN1_STRING_GET0_DATA</name></cpp:ifdef>
	<expr_stmt><expr><name>namedata</name> <operator>=</operator> <call><name>ASN1_STRING_get0_data</name><argument_list>(<argument><expr><name>name_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>namedata</name> <operator>=</operator> <call><name>ASN1_STRING_data</name><argument_list>(<argument><expr><name>name_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ASN1_STRING_length</name><argument_list>(<argument><expr><name>name_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK to cast from unsigned to plain char, since it's all ASCII. */</comment>
	<return>return <expr><call><name>pq_verify_peer_name_matches_certificate_name</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>namedata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>store_name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Verify that the server certificate matches the hostname we connected to.
 *
 * The certificate's Common Name and Subject Alternative Names are considered.
 */</comment>
<function><type><name>int</name></type>
<name>pgtls_verify_peer_name_matches_certificate_guts</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
												<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>names_examined</name></decl></parameter>,
												<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>first_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>GENERAL_NAME</name></expr></argument>)</argument_list></call> <operator>*</operator><name>peer_san</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, get the Subject Alternative Names (SANs) from the certificate,
	 * and compare them against the originally given hostname.
	 */</comment>
	<expr_stmt><expr><name>peer_san</name> <operator>=</operator> <operator>(</operator><call><name>STACK_OF</name><argument_list>(<argument><expr><name>GENERAL_NAME</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator>
		<call><name>X509_get_ext_d2i</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name>NID_subject_alt_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>peer_san</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>san_len</name> <init>= <expr><call><name>sk_GENERAL_NAME_num</name><argument_list>(<argument><expr><name>peer_san</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>san_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>GENERAL_NAME</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>sk_GENERAL_NAME_value</name><argument_list>(<argument><expr><name>peer_san</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>name</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GEN_DNS</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>alt_name</name></decl>;</decl_stmt>

				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>names_examined</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>openssl_verify_peer_name_matches_certificate_name</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
																	   <argument><expr><name><name>name</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>dNSName</name></name></expr></argument>,
																	   <argument><expr><operator>&amp;</operator><name>alt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>alt_name</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>first_name</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>first_name</name> <operator>=</operator> <name>alt_name</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>alt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>sk_GENERAL_NAME_free</name><argument_list>(<argument><expr><name>peer_san</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there is no subjectAltName extension of type dNSName, check the
	 * Common Name.
	 *
	 * (Per RFC 2818 and RFC 6125, if the subjectAltName extension of type
	 * dNSName is present, the CN must be ignored.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>names_examined</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>X509_NAME</name>  <modifier>*</modifier></type><name>subject_name</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>subject_name</name> <operator>=</operator> <call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subject_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cn_index</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cn_index</name> <operator>=</operator> <call><name>X509_NAME_get_index_by_NID</name><argument_list>(<argument><expr><name>subject_name</name></expr></argument>,
												  <argument><expr><name>NID_commonName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cn_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>names_examined</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>openssl_verify_peer_name_matches_certificate_name</name><argument_list>(
																	   <argument><expr><name>conn</name></expr></argument>,
																	   <argument><expr><call><name>X509_NAME_ENTRY_get_data</name><argument_list>(
																								<argument><expr><call><name>X509_NAME_get_entry</name><argument_list>(<argument><expr><name>subject_name</name></expr></argument>, <argument><expr><name>cn_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
																	   <argument><expr><name>first_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CRYPTO_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 *	Callback functions for OpenSSL internal locking.  (OpenSSL 1.1.0
 *	does its own locking, and doesn't need these anymore.  The
 *	CRYPTO_lock() function was removed in 1.1.0, when the callbacks
 *	were made obsolete, so we assume that if CRYPTO_lock() exists,
 *	the callbacks are still required.)
 */</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>pq_threadidcallback</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This is not standards-compliant.  pthread_self() returns pthread_t, and
	 * shouldn't be cast to unsigned long, but CRYPTO_set_id_callback requires
	 * it, so we have to do it.
	 */</comment>
	<return>return <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name> <modifier>*</modifier></type><name>pq_lockarray</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pq_lockingcallback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&amp;</operator> <name>CRYPTO_LOCK</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pq_lockarray</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PGTHREAD_ERROR</name><argument_list>(<argument><expr><literal type="string">"failed to lock mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pq_lockarray</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PGTHREAD_ERROR</name><argument_list>(<argument><expr><literal type="string">"failed to unlock mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY &amp;&amp; HAVE_CRYPTO_LOCK */</comment>

<comment type="block">/*
 * Initialize SSL library.
 *
 * In threadsafe mode, this includes setting up libcrypto callback functions
 * to do thread locking.
 *
 * If the caller has told us (through PQinitOpenSSL) that he's taking care
 * of libcrypto, we expect that callbacks are already set, and won't try to
 * override it.
 */</comment>
<function><type><name>int</name></type>
<name>pgtls_init</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Also see similar code in fe-connect.c, default_threadlock() */</comment>
	<if_stmt><if>if <condition>(<expr><name>ssl_config_mutex</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><call><name>InterlockedExchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>win32_ssl_create_mutex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			 <comment type="block">/* loop, another thread own the lock */</comment> <empty_stmt>;</empty_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><name>ssl_config_mutex</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssl_config_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>InterlockedExchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>win32_ssl_create_mutex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssl_config_mutex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CRYPTO_LOCK</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>pq_init_crypto_lib</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If necessary, set up an array to hold locks for libcrypto.
		 * libcrypto will tell us how big to make this array.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pq_lockarray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pq_lockarray</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pthread_mutex_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>CRYPTO_num_locks</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pq_lockarray</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssl_config_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>CRYPTO_num_locks</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pq_lockarray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pq_lockarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>pq_lockarray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssl_config_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ssl_open_connections</name><operator>++</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * These are only required for threaded libcrypto applications,
			 * but make sure we don't stomp on them if they're already set.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>CRYPTO_get_id_callback</name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CRYPTO_set_id_callback</name><argument_list>(<argument><expr><name>pq_threadidcallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>CRYPTO_get_locking_callback</name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CRYPTO_set_locking_callback</name><argument_list>(<argument><expr><name>pq_lockingcallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_CRYPTO_LOCK */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ssl_lib_initialized</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pq_init_ssl_lib</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_OPENSSL_INIT_SSL</name></cpp:ifdef>
			<expr_stmt><expr><call><name>OPENSSL_init_ssl</name><argument_list>(<argument><expr><name>OPENSSL_INIT_LOAD_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>OPENSSL_config</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SSL_library_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SSL_load_error_strings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>ssl_lib_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssl_config_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	This function is needed because if the libpq library is unloaded
 *	from the application, the callback functions will no longer exist when
 *	libcrypto is used by other parts of the system.  For this reason,
 *	we unregister the callback functions when the last libpq
 *	connection is closed.  (The same would apply for OpenSSL callbacks
 *	if we had any.)
 *
 *	Callbacks are only set when we're compiled in threadsafe mode, so
 *	we only need to remove them in this case. They are also not needed
 *	with OpenSSL 1.1.0 anymore.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>destroy_ssl_system</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CRYPTO_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* Mutex is created in pgtls_init() */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssl_config_mutex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pq_init_crypto_lib</name> <operator>&amp;&amp;</operator> <name>ssl_open_connections</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>--</operator><name>ssl_open_connections</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pq_init_crypto_lib</name> <operator>&amp;&amp;</operator> <name>ssl_open_connections</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No connections left, unregister libcrypto callbacks, if no one
		 * registered different ones in the meantime.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CRYPTO_get_locking_callback</name><argument_list>()</argument_list></call> <operator>==</operator> <name>pq_lockingcallback</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CRYPTO_set_locking_callback</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>CRYPTO_get_id_callback</name><argument_list>()</argument_list></call> <operator>==</operator> <name>pq_threadidcallback</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CRYPTO_set_id_callback</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We don't free the lock array. If we get another connection in this
		 * process, we will just re-use them with the existing mutexes.
		 *
		 * This means we leak a little memory on repeated load/unload of the
		 * library.
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssl_config_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 *	Create per-connection SSL object, and load the client certificate,
 *	private key, and trusted CA certs.
 *
 *	Returns 0 if OK, -1 on failure (with a message in conn-&gt;errorMessage).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>initialize_SSL</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SSL_CTX</name>    <modifier>*</modifier></type><name>SSL_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>homedir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fnbuf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_homedir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_cert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_rootcert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EVP_PKEY</name>   <modifier>*</modifier></type><name>pkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We'll need the home directory if any of the relevant parameters are
	 * defaulted.  If pqGetHomeDirectory fails, act as though none of the
	 * files could be found.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>sslcert</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslcert</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>sslkey</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslkey</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>sslrootcert</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslrootcert</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>sslcrl</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslcrl</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>have_homedir</name> <operator>=</operator> <call><name>pqGetHomeDirectory</name><argument_list>(<argument><expr><name>homedir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>homedir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* won't need it */</comment>
		<expr_stmt><expr><name>have_homedir</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Create a new SSL_CTX object.
	 *
	 * We used to share a single SSL_CTX between all connections, but it was
	 * complicated if connections used different certificates. So now we
	 * create a separate context for each connection, and accept the overhead.
	 */</comment>
	<expr_stmt><expr><name>SSL_context</name> <operator>=</operator> <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>SSLv23_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>SSL_context</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not create SSL context: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Disable old protocol versions */</comment>
	<expr_stmt><expr><call><name>SSL_CTX_set_options</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>, <argument><expr><name>SSL_OP_NO_SSLv2</name> <operator>|</operator> <name>SSL_OP_NO_SSLv3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Disable OpenSSL's moving-write-buffer sanity check, because it causes
	 * unnecessary failures in nonblocking send cases.
	 */</comment>
	<expr_stmt><expr><call><name>SSL_CTX_set_mode</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>, <argument><expr><name>SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the root cert file exists, load it so we can perform certificate
	 * verification. If sslmode is "verify-full" we will also do further
	 * verification after the connection has been completed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslrootcert</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslrootcert</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslrootcert</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>have_homedir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>homedir</name></expr></argument>, <argument><expr><name>ROOT_CERT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
		<call><name>stat</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>X509_STORE</name> <modifier>*</modifier></type><name>cvstore</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SSL_CTX_load_verify_locations</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>, <argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not read root certificate file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cvstore</name> <operator>=</operator> <call><name>SSL_CTX_get_cert_store</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslcrl</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslcrl</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslcrl</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>have_homedir</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>homedir</name></expr></argument>, <argument><expr><name>ROOT_CRL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Set the flags to check against the complete CRL chain */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
				<call><name>X509_STORE_load_locations</name><argument_list>(<argument><expr><name>cvstore</name></expr></argument>, <argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* OpenSSL 0.96 does not support X509_V_FLAG_CRL_CHECK */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>X509_V_FLAG_CRL_CHECK</name></cpp:ifdef>
				<expr_stmt><expr><call><name>X509_STORE_set_flags</name><argument_list>(<argument><expr><name>cvstore</name></expr></argument>,
									 <argument><expr><name>X509_V_FLAG_CRL_CHECK</name> <operator>|</operator> <name>X509_V_FLAG_CRL_CHECK_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL library does not support CRL certificates (file \"%s\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>fnbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* if not found, silently ignore;  we do not require CRL */</comment>
			<expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>have_rootcert</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * stat() failed; assume root file doesn't exist.  If sslmode is
		 * verify-ca or verify-full, this is an error.  Otherwise, continue
		 * without performing any server cert verification.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition>	<comment type="block">/* "verify-ca" or "verify-full" */</comment>
		<block>{<block_content>
			<comment type="block">/*
			 * The only way to reach here with an empty filename is if
			 * pqGetHomeDirectory failed.  That's a sufficiently unusual case
			 * that it seems worth having a specialized error message for it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not get home directory to locate root certificate file\n"</literal>
												<literal type="string">"Either provide the file or change sslmode to disable server certificate verification.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"root certificate file \"%s\" does not exist\n"</literal>
												<literal type="string">"Either provide the file or change sslmode to disable server certificate verification.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fnbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>have_rootcert</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Read the client certificate file */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslcert</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslcert</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslcert</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>have_homedir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>homedir</name></expr></argument>, <argument><expr><name>USER_CERT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no home directory, proceed without a client cert */</comment>
		<expr_stmt><expr><name>have_cert</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If file is not present, just go on without a client cert; server
		 * might or might not accept the connection.  Any other error,
		 * however, is grounds for complaint.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOTDIR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not open certificate file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>have_cert</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Cert file exists, so load it. Since OpenSSL doesn't provide the
		 * equivalent of "SSL_use_certificate_chain_file", we have to load it
		 * into the SSL context, rather than the SSL object.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SSL_CTX_use_certificate_chain_file</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>, <argument><expr><name>fnbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not read certificate file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* need to load the associated private key, too */</comment>
		<expr_stmt><expr><name>have_cert</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The SSL context is now loaded with the correct root and client
	 * certificates. Create a connection-specific SSL object. The private key
	 * is loaded directly into the SSL object. (We could load the private key
	 * into the context, too, but we have done it this way historically, and
	 * it doesn't really matter.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name> <operator>=</operator> <call><name>SSL_new</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>!</operator><call><name>SSL_set_app_data</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>my_SSL_set_fd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not establish SSL connection: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * SSL contexts are reference counted by OpenSSL. We can free it as soon
	 * as we have created the SSL object, and it will stick around for as long
	 * as it's actually needed.
	 */</comment>
	<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name>SSL_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>SSL_context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the SSL key. If a key is specified, treat it as an engine:key
	 * combination if there is colon present - we don't support files with
	 * colon in the name. The exception is if the second character is a colon,
	 * in which case it can be a Windows filename with drive specification.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_cert</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>sslkey</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslkey</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL_ENGINE</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslkey</name></name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
			<operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>sslkey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<comment type="block">/* Colon, but not in second character, treat as engine:key */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>engine_str</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslkey</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>engine_colon</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>engine_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* cannot return NULL because we already checked before strdup */</comment>
			<expr_stmt><expr><name>engine_colon</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>engine_str</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>engine_colon</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* engine_str now has engine name */</comment>
			<expr_stmt><expr><name>engine_colon</name><operator>++</operator></expr>;</expr_stmt>		<comment type="block">/* engine_colon now has key name */</comment>

			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name> <operator>=</operator> <call><name>ENGINE_by_id</name><argument_list>(<argument><expr><name>engine_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not load SSL engine \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>engine_str</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>engine_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ENGINE_init</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not initialize SSL engine \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>engine_str</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ENGINE_free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>engine_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>pkey</name> <operator>=</operator> <call><name>ENGINE_load_private_key</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr></argument>, <argument><expr><name>engine_colon</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pkey</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not read private SSL key \"%s\" from engine \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>engine_colon</name></expr></argument>, <argument><expr><name>engine_str</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ENGINE_finish</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ENGINE_free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>engine_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>SSL_use_PrivateKey</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not load private SSL key \"%s\" from engine \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>engine_colon</name></expr></argument>, <argument><expr><name>engine_str</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ENGINE_finish</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ENGINE_free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>engine_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>engine_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* indicate we're not going to load from a
								 * file */</comment>
		</block_content>}</block></if>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_SSL_ENGINE */</comment>
		<block>{<block_content>
			<comment type="block">/* PGSSLKEY is not an engine, treat it as a filename */</comment>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslkey</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>have_homedir</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No PGSSLKEY specified, load default file */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>homedir</name></expr></argument>, <argument><expr><name>USER_KEY_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_cert</name> <operator>&amp;&amp;</operator> <name><name>fnbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* read the client key from file */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"certificate present, but not private key file \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>fnbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>buf</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"private key file \"%s\" has group or world access; permissions should be u=rw (0600) or less\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>fnbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><call><name>SSL_use_PrivateKey_file</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name>SSL_FILETYPE_PEM</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not load private key file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* verify that the cert and key go together */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_cert</name> <operator>&amp;&amp;</operator>
		<call><name>SSL_check_private_key</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"certificate does not match private key file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>fnbuf</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If a root cert was loaded, also set our certificate verification
	 * callback.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_rootcert</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SSL_set_verify</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>SSL_VERIFY_PEER</name></expr></argument>, <argument><expr><name>verify_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set compression option if the OpenSSL version used supports it (from
	 * 1.0.0 on).
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SSL_OP_NO_COMPRESSION</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslcompression</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>sslcompression</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SSL_set_options</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>SSL_OP_NO_COMPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * Mainline OpenSSL introduced SSL_clear_options() before
	 * SSL_OP_NO_COMPRESSION, so this following #ifdef should not be
	 * necessary, but some old NetBSD version have a locally modified libssl
	 * that has SSL_OP_NO_COMPRESSION but not SSL_clear_options().
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SSL_CLEAR_OPTIONS</name></cpp:ifdef>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SSL_clear_options</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>SSL_OP_NO_COMPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Attempt to negotiate SSL connection.
 */</comment>
<function><type><specifier>static</specifier> <name>PostgresPollingStatusType</name></type>
<name>open_client_SSL</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>SSL_connect</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ecode</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ecode</name> <operator>=</operator> <call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>err</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SSL_ERROR_WANT_READ</name></expr>:</case>
				<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>

			<case>case <expr><name>SSL_ERROR_WANT_WRITE</name></expr>:</case>
				<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>

			<case>case <expr><name>SSL_ERROR_SYSCALL</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL SYSCALL error: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL SYSCALL error: EOF detected\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>pgtls_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
				</block_content>}</block>
			<case>case <expr><name>SSL_ERROR_SSL</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>SSLerrmessage</name><argument_list>(<argument><expr><name>ecode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL error: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pgtls_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
				</block_content>}</block>

			<default>default:</default>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unrecognized SSL error code: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgtls_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We already checked the server certificate in initialize_SSL() using
	 * SSL_CTX_set_verify(), if root.crt exists.
	 */</comment>

	<comment type="block">/* get server certificate */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name> <operator>=</operator> <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>SSLerrmessage</name><argument_list>(<argument><expr><call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"certificate could not be obtained: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SSLerrfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgtls_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pq_verify_peer_name_matches_certificate</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgtls_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* SSL handshake is complete */</comment>
	<return>return <expr><name>PGRES_POLLING_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgtls_close</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>destroy_needed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can't destroy everything SSL-related here due to the possible
		 * later calls to OpenSSL routines which may need our thread
		 * callbacks, so set a flag here and check at the end.
		 */</comment>
		<expr_stmt><expr><name>destroy_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL_ENGINE</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ENGINE_finish</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ENGINE_free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>engine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * This will remove our SSL locking hooks, if this is the last SSL
	 * connection, which means we must wait to call it until after all SSL
	 * calls have been made, otherwise we can end up with a race condition and
	 * possible deadlocks.
	 *
	 * See comments above destroy_ssl_system().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>destroy_needed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>destroy_ssl_system</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Obtain reason string for passed SSL errcode
 *
 * ERR_get_error() is used by caller to get errcode to pass here.
 *
 * Some caution is needed here since ERR_reason_error_string will
 * return NULL if it doesn't recognize the error code.  We don't
 * want to return NULL ever.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ssl_nomem</name><index>[]</index></name> <init>= <expr><literal type="string">"out of memory allocating error description"</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SSL_ERR_LEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SSLerrmessage</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>ecode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errreason</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errbuf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>SSL_ERR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ssl_nomem</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ecode</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>SSL_ERR_LEN</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no SSL error reported"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>errbuf</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>errreason</name> <operator>=</operator> <call><name>ERR_reason_error_string</name><argument_list>(<argument><expr><name>ecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errreason</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errreason</name></expr></argument>, <argument><expr><name>SSL_ERR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>errbuf</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>SSL_ERR_LEN</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSL error code %lu"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>errbuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SSLerrfree</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>ssl_nomem</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------ */</comment>
<comment type="block">/*					SSL information functions					*/</comment>
<comment type="block">/* ------------------------------------------------------------ */</comment>

<comment type="block">/*
 *	Return pointer to OpenSSL object.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>PQgetssl</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>PQsslStruct</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>struct_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>struct_name</name></expr></argument>, <argument><expr><literal type="string">"OpenSSL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type>
<name>PQsslAttributeNames</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>result</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"library"</literal></expr>,
		<expr><literal type="string">"key_bits"</literal></expr>,
		<expr><literal type="string">"cipher"</literal></expr>,
		<expr><literal type="string">"compression"</literal></expr>,
		<expr><literal type="string">"protocol"</literal></expr>,
		<expr><name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>PQsslAttribute</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attribute_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attribute_name</name></expr></argument>, <argument><expr><literal type="string">"library"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"OpenSSL"</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attribute_name</name></expr></argument>, <argument><expr><literal type="string">"key_bits"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>sslbits_str</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sslbits</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SSL_get_cipher_bits</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sslbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sslbits_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sslbits_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>sslbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>sslbits_str</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attribute_name</name></expr></argument>, <argument><expr><literal type="string">"cipher"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>SSL_get_cipher</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attribute_name</name></expr></argument>, <argument><expr><literal type="string">"compression"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><call><name>SSL_get_current_compression</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attribute_name</name></expr></argument>, <argument><expr><literal type="string">"protocol"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>SSL_get_version</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* unknown attribute */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Private substitute BIO: this does the sending and receiving using
 * pqsecure_raw_write() and pqsecure_raw_read() instead, to allow those
 * functions to disable SIGPIPE and give better error messages on I/O errors.
 *
 * These functions are closely modelled on the standard socket BIO in OpenSSL;
 * see sock_read() and sock_write() in OpenSSL's crypto/bio/bss_sock.c.
 * XXX OpenSSL 1.0.1e considers many more errcodes than just EINTR as reasons
 * to retry; do we need to adopt their logic for that?
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_BIO_GET_DATA</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIO_get_data</name><parameter_list>(<parameter><type><name>bio</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(bio-&gt;ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIO_set_data</name><parameter_list>(<parameter><type><name>bio</name></type></parameter>, <parameter><type><name>data</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(bio-&gt;ptr = data)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>BIO_METHOD</name> <modifier>*</modifier></type><name>my_bio_methods</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>my_sock_read</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pqsecure_raw_read</name><argument_list>(<argument><expr><operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <call><name>BIO_get_data</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BIO_clear_retry_flags</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If we were interrupted, tell caller to retry */</comment>
		<switch>switch <condition>(<expr><name>SOCK_ERRNO</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
			<case>case <expr><name>EAGAIN</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
			<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<case>case <expr><name>EINTR</name></expr>:</case>
				<expr_stmt><expr><call><name>BIO_set_retry_read</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>my_sock_write</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pqsecure_raw_write</name><argument_list>(<argument><expr><operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <call><name>BIO_get_data</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BIO_clear_retry_flags</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If we were interrupted, tell caller to retry */</comment>
		<switch>switch <condition>(<expr><name>SOCK_ERRNO</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
			<case>case <expr><name>EAGAIN</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
			<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<case>case <expr><name>EINTR</name></expr>:</case>
				<expr_stmt><expr><call><name>BIO_set_retry_write</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BIO_METHOD</name> <modifier>*</modifier></type>
<name>my_BIO_s_socket</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>my_bio_methods</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BIO_METHOD</name> <modifier>*</modifier></type><name>biom</name> <init>= <expr><operator>(</operator><name>BIO_METHOD</name> <operator>*</operator><operator>)</operator> <call><name>BIO_s_socket</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BIO_METH_NEW</name></cpp:ifdef>
		<decl_stmt><decl><type><name>int</name></type>			<name>my_bio_index</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>my_bio_index</name> <operator>=</operator> <call><name>BIO_get_new_index</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>my_bio_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>my_bio_methods</name> <operator>=</operator> <call><name>BIO_meth_new</name><argument_list>(<argument><expr><name>my_bio_index</name></expr></argument>, <argument><expr><literal type="string">"libpq socket"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>my_bio_methods</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * As of this writing, these functions never fail. But check anyway,
		 * like OpenSSL's own examples do.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BIO_meth_set_write</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>, <argument><expr><name>my_sock_write</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>BIO_meth_set_read</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>, <argument><expr><name>my_sock_read</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>BIO_meth_set_gets</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>, <argument><expr><call><name>BIO_meth_get_gets</name><argument_list>(<argument><expr><name>biom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>BIO_meth_set_puts</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>, <argument><expr><call><name>BIO_meth_get_puts</name><argument_list>(<argument><expr><name>biom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>BIO_meth_set_ctrl</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>, <argument><expr><call><name>BIO_meth_get_ctrl</name><argument_list>(<argument><expr><name>biom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>BIO_meth_set_create</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>, <argument><expr><call><name>BIO_meth_get_create</name><argument_list>(<argument><expr><name>biom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>BIO_meth_set_destroy</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>, <argument><expr><call><name>BIO_meth_get_destroy</name><argument_list>(<argument><expr><name>biom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>BIO_meth_set_callback_ctrl</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>, <argument><expr><call><name>BIO_meth_get_callback_ctrl</name><argument_list>(<argument><expr><name>biom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BIO_meth_free</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_bio_methods</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>my_bio_methods</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BIO_METHOD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>my_bio_methods</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>my_bio_methods</name></expr></argument>, <argument><expr><name>biom</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BIO_METHOD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_bio_methods</name><operator>-&gt;</operator><name>bread</name></name> <operator>=</operator> <name>my_sock_read</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_bio_methods</name><operator>-&gt;</operator><name>bwrite</name></name> <operator>=</operator> <name>my_sock_write</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>my_bio_methods</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This should exactly match OpenSSL's SSL_set_fd except for using my BIO */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>my_SSL_set_fd</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BIO</name>		   <modifier>*</modifier></type><name>bio</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BIO_METHOD</name> <modifier>*</modifier></type><name>bio_method</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>bio_method</name> <operator>=</operator> <call><name>my_BIO_s_socket</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bio_method</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SSLerr</name><argument_list>(<argument><expr><name>SSL_F_SSL_SET_FD</name></expr></argument>, <argument><expr><name>ERR_R_BUF_LIB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>bio</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><name>bio_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bio</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SSLerr</name><argument_list>(<argument><expr><name>SSL_F_SSL_SET_FD</name></expr></argument>, <argument><expr><name>ERR_R_BUF_LIB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>BIO_set_data</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SSL_set_bio</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>bio</name></expr></argument>, <argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BIO_set_fd</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>BIO_NOCLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<label><name>err</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
</unit>
